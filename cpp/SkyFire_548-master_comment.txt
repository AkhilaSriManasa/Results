/* ACE_LACKS_PRAGMA_ONCE */
// Even though the destructor is pure virtual you must provide an
// implementation.  Most people know this, but sometimes we all
// forget, and we might be tempted to remove this code.
/* ACE_ABSTRACT_TIMER_QUEUE_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_HAS_DUMP */
// Returns ACE_HANDLE of the underlying Acceptor_Strategy.
// Initialize the appropriate strategies for creation, passive
// connection acceptance, and concurrency, and then register <this>
// with the Reactor and listen for connection requests at the
// designated <local_addr>.
// Must supply a valid Reactor to Acceptor::open()...
// Open the underlying PEER_ACCEPTOR.
// Set the peer acceptor's handle into non-blocking mode.  This is a
// safe-guard against the race condition that can otherwise occur
// between the time when <select> indicates that a passive-mode
// socket handle is "ready" and when we call <accept>.  During this
// interval, the client can shutdown the connection, in which case,
// the <accept> call can hang!
// Simple constructor.
// Hook called by the explicit dynamic linking facility.
// Perform termination activities when <this> is removed from the
// <reactor>.
// Guard against multiple closes.
// We must pass the DONT_CALL flag here to avoid infinite
// recursion.
// Shut down the listen socket to recycle the handles.
// Set the Reactor to 0 so that we don't try to close down
// again.
// Bridge method for creating a SVC_HANDLER.  The strategy for
// creating a SVC_HANDLER are configured into the Acceptor via it's
// <creation_strategy_>.  The default is to create a new SVC_HANDLER.
// However, subclasses can override this strategy to perform
// SVC_HANDLER creation in any way that they like (such as creating
// subclass instances of SVC_HANDLER, using a singleton, dynamically
// linking the handler, etc.).
// Set the reactor of the newly created <SVC_HANDLER> to the same
// reactor that this <ACE_Acceptor> is using.
// Bridge method for accepting the new connection into the
// <svc_handler>.  The default behavior delegates to the
// <PEER_ACCEPTOR::accept> in the Acceptor_Strategy.
// Try to find out if the implementation of the reactor that we are
// using requires us to reset the event association for the newly
// created handle. This is because the newly created handle will
// inherit the properties of the listen handle, including its event
// associations.
// Acceptor is closed, so reject this call
// stream
// remote address
// timeout
// restart
// reset new handler
// Ensure that errno is preserved in case the svc_handler
// close() method resets it
// Close down handler to avoid memory leaks.
// Bridge method for activating a <svc_handler> with the appropriate
// concurrency strategy.  The default behavior of this method is to
// activate the SVC_HANDLER by calling its open() method (which allows
// the SVC_HANDLER to define its own concurrency strategy).  However,
// subclasses can override this strategy to do more sophisticated
// concurrency activations (such as creating the SVC_HANDLER as an
// "active object" via multi-threading or multi-processing).
// See if we should enable non-blocking I/O on the <svc_handler>'s
// peer.
// Otherwise, make sure it's disabled by default.
// The connection was already made; so this close is a "normal" close
// operation.
// Template Method that makes a SVC_HANDLER (using the appropriate
// creation strategy), accept the connection into the SVC_HANDLER, and
// then activate the SVC_HANDLER.
// Default is "timeout (0, 0)," which means "poll."
// Accept connections from clients.  Note that a loop is used for two
// reasons:
//
// 1. It allows us to accept all pending connections without an
//    extra trip through the ACE_Reactor and without having to use
//    non-blocking I/O...
//
// 2. It allows the TLI_SAP::ACE_Acceptor class to work correctly (don't
//    ask -- TLI is *horrible*...).
// Ensure that errno is preserved in case the ACE::handle_read_ready()
// method resets it in the loop bellow. We are actually supposed to
// ignore any errors from this loop, hence the return 0 following it.
// @@ What should we do if any of the substrategies fail?  Right
// now, we just print out a diagnostic message if <ACE::debug>
// returns > 0 and return 0 (which means that the Acceptor remains
// registered with the Reactor)...
// Create a service handler, using the appropriate creation
// strategy.
// Accept connection into the Svc_Handler.
// Note that <accept_svc_handler> closes the <svc_handler>
// on failure.
// Ensure that the errno from the above call propegates.
// Activate the <svc_handler> using the designated concurrency
// strategy (note that this method becomes responsible for
// handling errors and freeing up the memory if things go
// awry...).
// Note that <activate_svc_handler> closes the <svc_handler>
// on failure.
// Now, check to see if there is another connection pending and
// break out of the loop if there is none.
// First suspend the SVC_HANDLER's we've created.
// Then suspend ourselves.
// First resume ourselves.
// Then resume the SVC_HANDLER's we've created.
/* ACE_HAS_DUMP */
// Returns ACE_HANDLE of the underlying Acceptor_Strategy.
// Initialize the appropriate strategies for creation, passive
// connection acceptance, and concurrency, and then register <this>
// with the Reactor and listen for connection requests at the
// designated <local_addr>.
/* flags unused */,
// Must supply a valid Reactor to Acceptor::open()...
// Initialize the creation strategy.
// Initialize the accept strategy.
// Set the peer acceptor's handle into non-blocking mode.  This is a
// safe-guard against the race condition that can otherwise occur
// between the time when <select> indicates that a passive-mode
// socket handle is "ready" and when we call <accept>.  During this
// interval, the client can shutdown the connection, in which case,
// the <accept> call can hang!
// Initialize the concurrency strategy.
// Initialize the scheduling strategy.
// Simple constructor.
// Perform termination activities when <this> is removed from the
// <ACE_Reactor>.
// Guard against multiple closes.
// We must use the <handle> obtained *before* we deleted the
// accept_strategy_...
// Set the Reactor to 0 so that we don't try to close down
// again.
// Bridge method for creating a <SVC_HANDLER>.  The strategy for
// creating a <SVC_HANDLER> are configured into the Acceptor via it's
// <creation_strategy_>.  The default is to create a new
// <SVC_HANDLER>.  However, subclasses can override this strategy to
// perform <SVC_HANDLER> creation in any way that they like (such as
// creating subclass instances of <SVC_HANDLER>, using a singleton,
// dynamically linking the handler, etc.).
// Bridge method for accepting the new connection into the
// <svc_handler>.  The default behavior delegates to the
// <Strategy_Acceptor::accept> in the Acceptor_Strategy.
// Bridge method for activating a <svc_handler> with the appropriate
// concurrency strategy.  The default behavior of this method is to
// activate the SVC_HANDLER by calling its open() method (which allows
// the SVC_HANDLER to define its own concurrency strategy).  However,
// subclasses can override this strategy to do more sophisticated
// concurrency activations (such as creating the SVC_HANDLER as an
// "active object" via multi-threading or multi-processing).
// Signal the server to shutdown gracefully.
// @@ Should add the protocol in...
/* ACE_HAS_DUMP */
// Initialize the concurrency strategy.
// Reuse the addr, even if it is already in use...!
// Guard against multiple closes.
// Note that if we aren't actually registered with the
// ACE_Reactor then it's ok for this call to fail...
// Since we aren't necessarily registered with the Reactor, don't
// bother to check the return value here...
// Can't do this if we don't have a Reactor.
// Bridge method for activating a <svc_handler> with the appropriate
// concurrency strategy.  The default behavior of this method is to
// activate the SVC_HANDLER by calling its open() method (which allows
// the SVC_HANDLER to define its own concurrency strategy).  However,
// subclasses can override this strategy to do more sophisticated
// concurrency activations (such as creating the SVC_HANDLER as an
// "active object" via multi-threading or multi-processing).
// Factors out the code shared between the <accept> and <handle_input>
// methods.
// Accept connection into the Svc_Handler.
// stream
// remote address
// timeout
// restart
// reset new handle
// Check whether we just timed out or whether we failed...
// Close down handler to avoid memory leaks.
// Activate the <svc_handler> using the designated concurrency
// strategy (note that this method becomes responsible for handling
// errors and freeing up the memory if things go awry...)
// Make a SVC_HANDLER, accept the connection into the SVC_HANDLER, and
// then activate the SVC_HANDLER.  Note that SVC_HANDLER::open()
// decides what type of concurrency strategy to use.
// Note that if timeout == ACE_Time_Value (x, y) where (x > 0 || y >
// 0) then this->connector_.connect() will block synchronously.  If
// <use_reactor> is set then we don't want this to happen (since we
// want the ACE_Reactor to do the timeout asynchronously).
// Therefore, we'll force this->connector_ to use ACE_Time_Value (0,
// 0) in this case...
// stream
// remote address
// timeout
// restart
// reset new handler
// We couldn't accept right away, so let's wait in the
// <ACE_Reactor>.
// Accepts one pending connection from a client (since we're the
// "oneshot" Acceptor).
// Cancel any timer that might be pending.
// Try to find out if the implementation of the reactor that we are
// using requires us to reset the event association for the newly
// created handle.  This is because the newly created handle will
// inherit the properties of the listen handle, including its event
// associations.
// There is a use-case whereby this object will be gone upon return
// from shared_accept - if the Svc_Handler deletes this Oneshot_Acceptor
// during the shared_accept/activation steps. So, do whatever we need
// to do with this object before calling shared_accept.
// stream
// remote address
// timeout
// restart
// reset new handle
// Hook called by the explicit dynamic linking facility.
// Returns ACE_HANDLE of the underlying peer_acceptor.
/* ACE_ACCEPTOR_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_POLL */
// Open versioned namespace, if enabled by the user.
// private:
//  Used internally so not exported.
// Size of allocation granularity.
// Size of a VM page.
// Are we debugging ACE?
// Keeps track of whether we're in some global debug mode.
// EMFILE is common to all platforms.
// On Win32, we need to check for ENOBUFS also.
// On HPUX, we need to check for EADDRNOTAVAIL also.
// On linux, we need to check for ENOENT also.
// For RedHat5.2, need to check for EINVAL too.
// Without threads check for EOPNOTSUPP
// On sun, we need to check for ENOSR also.
// Without threads check for ENOTSUP
// On FreeBSD we need to check for EOPNOTSUPP (LinuxThreads) or
// ENOSYS (libc_r threads) also.
// OpenBSD appears to return EBADF.
/* ACE_WIN32 */
// Yes, this works for UNICODE
//FUZZ: disable check_for_ace_log_categories
//FUZZ: enable check_for_ace_log_categories
// This isn't needed for Windows... it's a no-op anyway.
/* ACE_WIN32 */
/* ACE_WIN32 */
// Create a handle for the given process id.
// New handle is not inheritable.
// Kill the process associated with process_handle.
// Free up the kernel resources.
/* ACE_HAS_PHARLAP */
// Create a handle for the given process id.
/* !ACE_WIN32 */
// Concatenate the .exe suffix onto the end of the executable.
// end points _after_ the terminating nul.
/* ACE_WIN32 */
// @@ UNICODE: Does this function do the correct thing with wchar's?
/* ACE_HAS_WCHAR */
/*
// When the len is truncated, there are problems!  This should
// not happen in normal circomstances
/* ACE_HAS_TLI */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
/* ACE_HAS_TLI */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// This is basically an interface to ACE_OS::readv, that doesn't use
// the struct iovec explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_LACKS_VA_FUNCTIONS */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// This blind cast is safe because n < iov_len, after above loop.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// This blind cast is safe because n < iov_len, after above loop.
// Our current message block chain.
// Check if this block has any space for incoming data.
// Collect the data in the iovec.
// Increment iovec counter.
// The buffer is full make a OS call.  @@ TODO find a way to
// find ACE_IOV_MAX for platforms that do not define it rather
// than simply setting ACE_IOV_MAX to some arbitrary value such
// as 16.
// Add to total bytes transferred.
// Errors.
// Reset iovec counter.
// Select the next message block in the chain.
// Selection of the next message block chain.
// Check for remaining buffers to be sent.  This will happen when
// ACE_IOV_MAX is not a multiple of the number of message blocks.
// Add to total bytes transferred.
// Errors.
// Return total bytes transferred.
/* ACE_HAS_TLI */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// If enobufs no need to loop
/* ACE_WIN32 */
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
/* ACE_HAS_TLI */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_LACKS_VA_FUNCTIONS */
// Try to transfer as much of the remaining data as possible.
// Check EOF.
// Check for other errors.
// Check for possible blocking.
// Wait for the blocking to subside.
// Did select() succeed?
// Blocking subsided.  Continue data transfer.
// Other data transfer or select() failures.
// This blind cast is safe because n < iov_len, after above loop.
// Try to transfer as much of the remaining data as possible.
// Since the socket is in non-blocking mode, this call will not
// block.
// Check for errors.
// Check for possible blocking.
// Wait upto <timeout> for the blocking to subside.
// Did select() succeed?
// Blocking subsided in <timeout> period.  Continue
// data transfer.
// Wait in select() timed out or other data transfer or
// select() failures.
// This blind cast is safe because n < iov_len, after above loop.
// Our current message block chain.
// Check if this block has any data to be sent.
// Collect the data in the iovec.
// Increment iovec counter.
// The buffer is full make a OS call.  @@ TODO find a way to
// find ACE_IOV_MAX for platforms that do not define it rather
// than simply setting ACE_IOV_MAX to some arbitrary value such
// as 16.
// Add to total bytes transferred.
// Errors.
// Reset iovec counter.
// Select the next message block in the chain.
// Selection of the next message block chain.
// Check for remaining buffers to be sent.  This will happen when
// ACE_IOV_MAX is not a multiple of the number of message blocks.
// Add to total bytes transferred.
// Errors.
// Return total bytes transferred.
// Our current message block chain.
// Check if this block has any data to be sent.
// Collect the data in the iovec.
// Increment iovec counter.
// The buffer is full make a OS call.  @@ TODO find a way to
// find ACE_IOV_MAX for platforms that do not define it rather
// than simply setting ACE_IOV_MAX to some arbitrary value such
// as 16.
// Add to total bytes transferred.
// Errors.
// Reset iovec counter.
// Select the next message block in the chain.
// Selection of the next message block chain.
// Check for remaining buffers to be sent.  This will happen when
// ACE_IOV_MAX is not a multiple of the number of message blocks.
// Add to total bytes transferred.
// Errors.
// Return total bytes transferred.
// This blind cast is safe because n < iov_len, after above loop.
// This blind cast is safe because n < iov_len, after above loop.
// Wait for data or for the timeout to elapse.
/* ACE_WIN64 */
// read_fds.
// write_fds.
// exception_fds.
/* ACE_HAS_POLL */
// Timer expired.
/* FALLTHRU */
// we got here directly - select() returned -1.
// Handle has data.
/* FALLTHRU */
// default is case result > 0; return a
// ACE_ASSERT (result == 1);
// We need to record whether we are already *in* nonblocking mode,
// so that we can correctly reset the state when we're done.
// Set the handle into non-blocking mode if it's not already in
// it.
// Save/restore errno.
// Only disable ACE_NONBLOCK if we weren't in non-blocking mode
// originally.
/// Format buffer into printable format.  This is useful for debugging.
/// Portions taken from mdump by J.P. Knight (J.P.Knight@lut.ac.uk)
/// Modifications by Todd Montgomery.
// We can fit 16 bytes output in text mode per line, 4 chars per byte.
// or, buffer[i*16+j]
/// Returns the current timestamp in the form
/// "hour:minute:second:microsecond."  The month, day, and year are
/// also stored in the beginning of the date_and_time array
/// using ISO-8601 format.
/// Returns the given timestamp in the form
/// "hour:minute:second:microsecond."  The month, day, and year are
/// also stored in the beginning of the date_and_time array
/// using ISO-8601 format.
/// 012345678901234567890123456
/// 2010-12-02 12:56:00.123456<nul>
//ACE_TRACE ("ACE::timestamp");
// This magic number is from the formatting statement
// farther down this routine.
/// This function rounds the request to a multiple of the page size.
/* !ACE_WIN32 && ACE_HAS_POLL */
// Winsock is different - it sets the exception bit for failed connect,
// unlike other platforms, where the write bit is set for both success
// and fail.
/* ACE_WIN32 */
// Ignored on Windows: int (h) + 1,
/* ACE_HAS_POLL */
/* ACE_WIN32 */
// If we failed to connect within the time period allocated by the
// caller, then we fail (e.g., the remote host might have been too
// busy to accept our call).
// On Windows, a ready-for-write handle is successfully connected, and
// ready-for-exception is a failure. On fails, we need to grab the error
// code via getsockopt.
// On BSD sockets using select(), the handle becomes writable on
// completion either success or fail, so if the select() does not time
// out, we need to check for success/fail.
// It is believed that TLI sockets use the readable=fail, writeable=success
// but that hasn't been as well tested.
// On Win32, ex_handle set indicates a failure. We'll do the check
// to try and get an errno value, but the connect failed regardless of
// what getsockopt says about the error.
/* ACE_HAS_POLL */
// The "official" bit for failed connect is POLLIN. However, POLLERR
// is often set and there are occasional cases seen with some kernels
// where only POLLERR is set on a failed connect.
/* ACE_HAS_POLL */
/* ACE_WIN32 */
// The following recv() won't block provided that the
// ACE_NONBLOCK flag has not been turned off .
// If no data was read/peeked at, check to see if it's because
// of a non-connected socket (and therefore an error) or there's
// just no data yet.
// 1. The HANDLE is ready for writing and doesn't need to be checked or
// 2. recv() returned an indication of the state of the socket - if there is
// either data present, or a recv is legit but there's no data yet,
// the connection was successfully established.
/// Wait up to @a timeout amount of time to accept a connection.
// Make sure we don't bomb out on erroneous values.
// Use the select() implementation rather than poll().
/* ACE_HAS_POLL */
// We need a loop here if <restart> is enabled.
/* ACE_WIN32 */
/* ACE_HAS_POLL */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/// Make the current process a UNIX daemon.  This is based on Stevens
/// code from APUE.
// Parent exits.
// 1st child continues.
// Become session leader.
// First child terminates.
// Second child continues.
// change working directory.
// clear our file mode creation mask.
// Close down the I/O handles.
/* ACE_LACKS_FORK */
// This algorithm is adapted from an example in the Stevens book
// "Advanced Programming in the Unix Environment" and an item in
// Andrew Gierth's Unix Programming FAQ.  It creates an orphan
// process that's inherited by the init process; init cleans up
// when the orphan process terminates.
//
// Another way to avoid zombies is to ignore or catch the
// SIGCHLD signal; we don't use that approach here.
// The child process forks again to create a grandchild.
// grandchild returns 0.
// assumes all errnos are < 256
// child terminates, orphaning grandchild
// Parent process waits for child to terminate.
// child terminated by calling exit()?
// child terminated normally?
// child didn't call exit(); perhaps it received a signal?
// If == RLIM_INFINITY, fall through to the ACE_LACKS_RLIMIT sections
/* RLIM_INFINITY */
/* RLIMIT_NOFILE && !ACE_LACKS_RLIMIT */
/* _SC_OPEN_MAX */
// Set the number of currently open handles in the process.
//
// If NEW_LIMIT == -1 set the limit to the maximum allowable.
// Otherwise, set it to be the value of NEW_LIMIT.
/* ACE_LACKS_RLIMIT */
// Increase the limit.
// Must return EINVAL errno.
/* ACE_LACKS_RLIMIT */
// Decrease the limit.
// We give a chance to platforms without RLIMIT to work.
// Instead of ACE_NOTSUP_RETURN (0), just return 0 because
// new_limit is <= cur_limit, so it's a no-op.
/* ACE_LACKS_RLIMIT */
/// Euclid's greatest common divisor algorithm.
/// Calculates the minimum enclosing frame size for the given values.
// if one of the periods is zero, treat it as though it as
// uninitialized and return the other period as the frame size
// if neither is zero, find the greatest common divisor of the two periods
// explicitly consider cases to reduce risk of possible overflow errors
// periods are relative primes: just multiply them together
// the first period divides the second: return the second
// the second period divides the first: return the first
// the current frame size and the entry's effective period
// have a non-trivial greatest common divisor: return the
// product of factors divided by those in their gcd.
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/*
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* NOTREACHED */
/* ACE_WIN32 */
/*
/* ACE_WIN32 */
// Figure out how long this string is (remember, it might not be
// NUL-terminated).
/* ACE_HAS_ALLOC_HOOKS */
// Figure out how long this string is (remember, it might not be
// NUL-terminated).
/* ACE_HAS_WCHAR */
// Figure out how long this string is (remember, it might not be
// NUL-terminated).
/* ACE_HAS_ALLOC_HOOKS */
// Figure out how long this string is (remember, it might not be
// NUL-terminated).
/* ACE_HAS_WCHAR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_WCHAR */
// helper functions for ACE::wild_match()
// precond:  *p == '[' start of char class
// postcond: *p == ']' end of the char class
// ] and - are regular in 1st position
// invalid range
// Since we are in the POSIX locale, only the basic ASCII
// characters are allowed as the range endpoints.  These characters
// are the same values in both signed and unsigned chars so we
// don't have to account for any "pathological cases."
// consume the character 1 past the -
// Close versioned namespace, if enabled by the user.
/*****************************************************************/
/*                                                               */
/* CRC LOOKUP TABLE                                              */
/* ================                                              */
/* The following CRC lookup table was generated automagically    */
/* by the Rocksoft^tm Model CRC Algorithm Table Generation       */
/* Program V1.0 using the following model parameters:            */
/*                                                               */
/*    Width   : 4 bytes.                                         */
/*    Poly    : 0x04C11DB7L                                      */
/*    Reverse : TRUE.                                            */
/*                                                               */
/* For more information on the Rocksoft^tm Model CRC Algorithm,  */
/* see the document titled "A Painless Guide to CRC Error        */
/* Detection Algorithms" by Ross Williams                        */
/* (ross@guest.adelaide.edu.au.). This document is likely to be  */
/* in the FTP archive "ftp.adelaide.edu.au/pub/rocksoft".        */
/*                                                               */
/*****************************************************************/
/*****************************************************************/
/*                   End of CRC Lookup Table                     */
/*****************************************************************/
// Open versioned namespace, if enabled by the user.
// Close versioned namespace, if enabled by the user.
/*****************************************************************/
/*                                                               */
/* CRC LOOKUP TABLE                                              */
/* ================                                              */
/* The following CRC lookup table was generated automagically    */
/* by the Rocksoft^tm Model CRC Algorithm Table Generation       */
/* Program V1.0 using the following model parameters:            */
/*                                                               */
/*    Width   : 2 bytes.                                         */
/*    Poly    : 0x1021                                           */
/*    Reverse : TRUE.                                            */
/*                                                               */
/* For more information on the Rocksoft^tm Model CRC Algorithm,  */
/* see the document titled "A Painless Guide to CRC Error        */
/* Detection Algorithms" by Ross Williams                        */
/* (ross@guest.adelaide.edu.au.). This document is likely to be  */
/* in the FTP archive "ftp.adelaide.edu.au/pub/rocksoft".        */
/*                                                               */
/*****************************************************************/
/*****************************************************************/
/*                   End of CRC Lookup Table                     */
/*****************************************************************/
// Open versioned namespace, if enabled by the user.
// Close versioned namespace, if enabled by the user.
// -*- C++ -*-
/* __ACE_INLINE__ */
//FUZZ: disable check_for_NULL
//FUZZ: enable check_for_NULL
/* ACE_HAS_DUMP */
// Destroy the internal queue if one exist.
// Destroy the current queue.
// Set the flag to false.  NOTE that the delete_queue_ flag is a
// flag used to only indicate whether or not if an internal
// ACE_Message_Queue has been created, therefore, it will not
// affect the user if the user decided to replace the queue with
// their own queue no matter how many time they call on this
// function.
// Dequeue the message.
// Get the next <Method_Request>.
// Delete the message block.
// We pass sizeof (*mr) here so that flow control will work
// correctly.  Since we also pass <mr> note that no unnecessary
// memory is actually allocated -- just the size field is set.
// size
// type
// cont
// data
// allocator
// locking strategy
// priority
// execution time
// absolute time of deadline
// data_block allocator
// message_block allocator
// Enqueue in priority order.
// Free ACE_Message_Block if enqueue_prio failed.
/* __ACE_INLINE__ */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_ACTIVE_MAP_MANAGER_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// Note: this object requires static construction and destruction.
/* static */
// Initializes instance variables.  Note that 0 is an unspecified
// protocol family type...
// Initializes instance variables.
/* ACE_HAS_DUMP */
/* __ACE_INLINE__ */
// Open versioned namespace, if enabled by the user.
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Creates this->argv_ out of this->buf_.  New memory is allocated for
// each element of the array.  This is used by the array-to-string
// style constructor and for creating this->argv_ when in iterative
// mode.
// Make an internal copy of the string.
/* ACE_HAS_ALLOC_HOOKS */
// Create this->argv_.
// convert the first argv to a string
// convert the second argv to a string
// Add the number of arguments in both the argvs.
// Allocate memory to the lenght of the combined argv string.
// copy the first argv string to the buffer
// concatenate the second argv string to the buffer
//   Delete the first and second buffers
/* ACE_HAS_ALLOC_HOOKS */
// Nothing to do yet -- the user puts in arguments via add ()
// Only allow this to work in the "iterative" verion -- the
// ACE_ARGVs created with the one argument constructor.
// Put the new argument at the end of the queue.
// Wipe argv_ and buf_ away so that they will be recreated if the
// user calls argv () or buf ().
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Free up argv_ and buf_
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Create buf_ out of the queue_.  This is only used in the
// "iterative" mode.
// If the are no arguments, don't do anything
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Get an iterator over the queue
// Get next argument from the queue.
// Copy the argument into buf_
// Move the pointer down.
// Copy the argument into buf_
// Move the pointer down.
// Put in an argument separating space.
// Put in the NUL terminator
// Close versioned namespace, if enabled by the user.
/* ACE_ARGV_CPP */
/* __ACE_INLINE__ */
// ACE_USES_WCHAR
// ACE_USES_WCHAR
// selectively delete the 'copy' of argv
// if original type is wchar_t
// if original type is char
// ACE_USES_WCHAR
// Make a copy of argv in 'char'. type Create one more argv entry
// than original argc for the NULL.
// last entry of argv is
// always a NULL
// make a copy of argv in 'wchar_t' type
// if n'th entries of both argv lists are different
// loop through the wchar argv list entries that are after
// wchar_argv_index
// swap the pointers in the char argv list
// if n'th entries of both argv lists are different
// loop through the wchar argv list entries that are after
// wchar_argv_index
// swap the pointers in the char argv list
//  Check whether it's ours to delete.
// ACE_USES_WCHAR
/* ACE_HAS_ALLOC_HOOKS */
// If not provided with one, allocate a temporary array.
/* ACE_HAS_ALLOC_HOOKS */
// Fill the temporary array.
// Allocation failed, prohibit iteration.
// Delete the temporary vector.
/* ACE_HAS_ALLOC_HOOKS */
// the return 0's abound because this method
// would otherwise be a deep if { } else { }
// check to see if any arguments still exist
// check to see if the flag is the argument
// the parameter is in the middle somewhere...
// Check for a current argument
// Check for presence of the flag
// match and lengths are equal
// matches, with more info to boot!
// failure
// Stick knowns at the end of the vector (consumed).
// Keep unknowns at the head of the vector.
/* ACE_ATOMIC_OP_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Dynamically initialize an array.
// The copy constructor (performs initialization).
// Assignment operator (performs assignment).
// Check for "self-assignment".
// Need to reallocate memory.
// Strongly exception-safe assignment.
//
// Note that we're swapping the allocators here, too.
// Should we?  Probably.  "*this" should be a duplicate of
// the "right hand side".
// Underlying array is large enough.  No need to reallocate
// memory.
//
// "*this" still owns the memory for the underlying array.
// Do not swap out the allocator.
//
// @@ Why don't we just drop the explicit destructor and
//    placement operator new() calls with a straight
//    element-by-element assignment?  Is the existing
//    approach more efficient?
//        -Ossama
// Set an item in the array at location slot.
// Get an item in the array at location slot.
// Copies the item.  If you don't want to copy, use operator []
// instead (but then you'll be responsible for range checking).
// Initialize the new portion of the array that exceeds the
// previously allocated section.
// ****************************************************************
// ACE_TRACE ("ACE_Array_Iterator<T>::next");
/* ACE_ARRAY_BASE_CPP */
/* !__ACE_INLINE__ */
// Linear insertion due to linear duplicate key search.
// Add the element to the array.
// Increase size by at least one.
// Preallocate storage.
// Relocate the tail element to the location of the erased
// element to prevent introduction of "holes" in the
// underlying array.
// Explicitly destroy the tail element by assigning a default
// constructed instance to it.  Note that this also works for
// the case of a map of size 1.
// No need to deallocate array nor destroy elements.
// This implementation focuses more on static footprint than
// speed.
// Strongly exception safe.
// Do not swap out the size
// since we bypassed the
// temporary map's element
// counting code.
// ---------------------------------------------------------------
// Do not include Array_Map capacity in comparison.  It isn't useful
// in this case.
/* ACE_ARRAY_MAP_CPP */
// The following ASSERT macro is courtesy of Alexandre Karev
// <akg@na47sun05.cern.ch>.
/* -*- C++ -*- */
/* ACE_LACKS_PRAGMA_ONCE */
// This only works on platforms that support async i/o.
// Close down the listen socket
// Create the listener socket
// Initialize the ACE_Asynch_Accept
// Reuse the address
// If port is not specified, bind to any port.
// Bind to the specified port.
// Start listening.
// For the number of <intial_accepts>.
// Initiate accepts.
// Take ownership of the <listen_handle>
// Reinitialize the ACE_Asynch_Accept
// The space_needed calculation is drive by needs of Windows. POSIX doesn't
// need to extra 16 bytes, but it doesn't hurt.
/* ACE_HAS_IPV6 */
// Create a new message block big enough for the addresses and data
// Initiate asynchronous accepts
// Cleanup on error
// Variable for error tracking
// If the asynchronous accept fails.
// In order to use accept handle with other Window Sockets 1.1
// functions, we call the setsockopt function with the
// SO_UPDATE_ACCEPT_CONTEXT option. This option initializes the
// socket so that other Windows Sockets routines to access the
// socket correctly.
/* ACE_WIN32 */
// Parse address.
// Parse the addresses.
// Validate remote address
// The Template method
// If no errors
// Update the Proactor unless make_handler() or constructed handler
// set up its own.
// Pass the addresses
// Pass the ACT
// Set up the handler's new handle value
// Initiate the handler
// On failure, no choice but to close the socket
// Delete the dynamically allocated message_block
// Start off another asynchronous accept to keep the backlog going,
// unless we closed the listen socket already (from the destructor),
// or this callback is the result of a canceled/aborted accept.
/* result */,
/* remote */,
/* local */)
// Default implementation always validates the remote address.
// All I/O operations that are canceled will complete with the error
// ERROR_OPERATION_ABORTED. All completion notifications for the I/O
// operations will occur normally.
// Supported now
/* defined (ACE_HAS_WIN32_OVERLAPPED_IO) */
// Use an ACE_SOCK to get the addresses - it knows how to deal with
// ACE_INET_Addr objects and get IPv4/v6 addresses.
// This matches setup in accept().
/* ACE_HAS_IPV6 */
// just in case
/* defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) */
// Default behavior
/* ACE_WIN32 || ACE_HAS_AIO_CALLS */
/* ACE_ASYNCH_ACCEPTOR_C */
/* ACE_LACKS_PRAGMA_ONCE */
// This only works on platforms that support async I/O.
//this->asynch_connect_.close ();
// Initialize the ACE_Asynch_Connect
// Initiate asynchronous connect
// Variable for error tracking
// If the asynchronous connect fails.
// set blocking mode
// Parse the addresses.
// Call validate_connection even if there was an error - it's the only
// way the application can learn the connect disposition.
// The Template method
// If no errors
// Update the Proactor.
// Pass the addresses
// Pass the ACT
// Set up the handler's new handle value
// Initiate the handler with empty message block;
// On failure, no choice but to close the socket
/* remote_address */,
/* local_address */)
// Default implementation always validates the remote address.
// Getting the addresses.
// Getting the addresses.
/* ACE_HAS_IPV6 */
// Get the length.
// Get the local address.
// Get the remote address.
// Set the addresses.
// Default behavior
/* ACE_WIN32 || ACE_HAS_AIO_CALLS */
/* ACE_ASYNCH_CONNECTOR_CPP */
// This only works on platforms with Asynchronous IO
// Proactor deletes the implementation when the <complete> finishes.
// *********************************************************************
// Grab the singleton proactor if <handler->proactor> is zero
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// ************************************************************
// Proactor will delete the implementation after <complete> is
// finished.
// ***************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// ************************************************************
// Proactor will delte the implementation when the <complete> call
// finishes.
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
/* (defined (ACE_WIN32) && !defined (ACE_HAS_WINCE)) */
// ************************************************************
// Proactor will delete the implementation when <complete> call
// completes.
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
/* (defined (ACE_WIN32) && !defined (ACE_HAS_WINCE)) */
// ************************************************************
// Proactor will delete the implementation when the <complete> call
// completes.
// *********************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
// ************************************************************
// Proactor will delete the implementation when the <complete> call
// completes.
// *********************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
// ************************************************************
// Proactor will delete the implementation when the <complete> call
// completes.
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
// ****************************************************************************
// ************************************************************
// If both are zero, return zero
// Something is valid
// If header is valid, set the fields
/* ACE_WIN64 || ACE_WIN32 */
// If trailer is valid, set the fields
/* ACE_WIN64 || ACE_WIN32 */
// Return the transmit buffers
// *********************************************************************
/* result */)
/* result */)
/* result */)
/* result */)
/* result */)
/* result */)
/* result */)
/* result */)
/* result */)
/* tv */,
/* act */)
// ************************************************************
/* remote_address */,
/* local_address */ )
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
// ************************************************************
// ************************************************************
// Delete the implementation.
// Get a proactor for/from the user.
// Now let us get the implementation initialized.
// Call the <open> method of the base class.
// ************************************************************
/* ACE_HAS_WIN32_OVERLAPPED_IO || ACE_HAS_AIO_CALLS */
// This only works on Win32 platforms and on Unix platforms supporting
// aio calls.
/* __ACE_INLINE__ */
//***********************************************
/***********************************************
//***********************************************
/***********************************************
/* ACE_HAS_WIN32_OVERLAPPED_IO || ACE_HAS_AIO_CALLS */
// should be initialized before reactor_
// don't delete implementation
// If started, return 0
// already stopped
// Register the handler with the reactor.
// Suspend the handle now. Enable only when the accept is issued
// by the application.
/**/ "linux/atmdev.h"
/* ACE_HAS_LINUX_ATM */
/* __ACE_INLINE__ */
// Open versioned namespace, if enabled by the user.
// Put the actual definitions of the ACE_ATM_Request and
// ACE_ATM_Request_Queue classes here to hide them from clients...
/* ACE_HAS_FORE_ATM_WS2 && ACE_HAS_FORE_ATM_XTI */
/* Create a local endpoint of communication */
// Only leaves can listen.
/* Set up the address information to become a server */
/* Associate address with endpoint */
/* Make endpoint listen for service requests */
//we need to set the qos before binding to the socket
//use remote_sap as local_sap
// Make endpoint listen for service requests
/* ACE_HAS_FORE_ATM_XTI/ACE_HAS_FORE_ATM_WS2/ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI */
// Close versioned namespace, if enabled by the user.
/* ACE_HAS_ATM */
// Defines the Internet domain address family address format.
/**/ "forews2.h"
/* ACE_HAS_FORE_ATM_WS2 */
/* __ACE_INLINE__ */
// This is line rate in cells/s for an OC-3 MM interface.
//pbrandao:for Linux:
//pbrandao:for now stick with current definitions
//pbrandao:see if later need to change
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// Default constructor
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// ACE_TRACE ("ACE_ATM_Addr::ACE_ATM_Addr");
// Copy constructor.
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// Return the address.
// Note: this approach may be FORE implementation-specific.  When we
// bind with tag_addr ABSENT and tag_selector PRESENT, only the
// selector (i.e. address[19]) is used by the TP.  The rest of the
// local address is filled in by the TP and can be obtained via the
// 'ret' parameter or with t_getname ()/t_getprotaddr ().
// Need to know the correspondence.
//atm_addr_.sap.t_atm_sap_appl.SVE_tag = (int8_t) T_ATM_PRESENT;
//atm_addr_.sap.t_atm_sap_appl.ID_type = (u_int8_t) T_ATM_USER_APP_ID;
//ACE_OS::memcpy (atm_addr_.sap.t_atm_sap_appl.ID.user_defined_ID,
//                BHLI_MAGIC,
//                sizeof atm_addr_.sap.t_atm_sap_appl.ID);
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 */
/* ACE_HAS_FORE_ATM_XTI */
// Transform the string into the current addressing format.
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// Yow, someone gave us a NULL ATM address!
//&blob;
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 */
// Transform the current address into string format.
/* ACE_HAS_FORE_ATM_XTI && ACE_HAS_FORE_ATM_WS2 */
// Set a pointer to the address.
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_WS2 */
// Compare two addresses for inequality.
// Compare two addresses for equality.
/*  ACE_HAS_LINUX_ATM */
/* ACE_HAS_DUMP */
/* ACE_HAS_ATM */
// ATM_Connector.cpp
/* __ACE_INLINE__ */
// Open versioned namespace, if enabled by the user.
// Actively connect and produce a new ACE_ATM_Stream if things go well...
// Connect the <new_stream> to the <remote_sap>, waiting up to
// <timeout> amount of time if necessary.
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// Close versioned namespace, if enabled by the user.
/* ACE_HAS_ATM */
/* __ACE_INLINE__ */
/* ACE_HAS_ATM */
/* __ACE_INLINE__ */
// This is line rate in cells/s for an OC-3 MM interface.
//pbrandao:for Linux:
//pbrandao:for now stick with current definitions
//pbrandao:see if later need to change
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_LINUX_ATM */
// Setting up cbr parameters ...
// was 1516;
// was 1516;
// Note: this must be set to zero for CBR.
// This may not be really used
// since we do only simplex data xfer.
//    qos_.SendingFlowspec.TokenRate = 0xffffffff;
//    qos_.SendingFlowspec.TokenBucketSize = 0xffffffff;
//    qos_.SendingFlowspec.PeakBandwidth = 0xffffffff;
//    qos_.SendingFlowspec.Latency = 0xffffffff;
//    qos_.SendingFlowspec.DelayVariation = 0xffffffff;
//    qos_.SendingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;
// This will most probably be ignored by the service provider.
//    qos_.SendingFlowspec.MaxSduSize = 0xffffffff;
//    qos_.SendingFlowspec.MinimumPolicedSize = 0xffffffff;
//    qos_.ReceivingFlowspec.TokenRate = 0xffffffff;
//    qos_.ReceivingFlowspec.TokenBucketSize = 0xffffffff;
//    qos_.ReceivingFlowspec.PeakBandwidth = 0xffffffff;
//    qos_.ReceivingFlowspec.Latency = 0xffffffff;
//    qos_.ReceivingFlowspec.DelayVariation = 0xffffffff;
//    qos_.ReceivingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;
// This will most probably be ignored by the service provider.
//    qos_.ReceivingFlowspec.MaxSduSize = 0xffffffff;
//    qos_.ReceivingFlowspec.MinimumPolicedSize = 0;
// This will most probably ignored by SP.
// This will most probably ignored by SP.
/* ACE_HAS_FORE_ATM_WS2 || ACE_HAS_FORE_ATM_XTI || ACE_HAS_LINUX_ATM */
/*
// Setting up cbr parameters ...
/*
// was 1516;
// was 1516;
// Note: this must be set to zero for CBR.
// This may not be really used
// since we only simplex data xfer.
// Setting the token rate sets the minimum rate. 3 Mbits/sec seems too high.
//  Certainly for Vaudeville audio, we only need about 1000 c/s which is
//  424000 bits/sec which is 53000 bytes/sec.
//qos_.SendingFlowspec.TokenRate = 3*(1024*128);      // 3Mbits/sec
// 1000 cells/sec
// our block size
//ourQos.SendingFlowspec.PeakBandwidth = ourQos.SendingFlowspec.TokenRate;
// Peak bandwidth is in bytes/sec. The rate is specified in cells/sec so
//  we need to convert from cells/sec to bytes/sec (i.e., multiply by 53).
// we don't care too much
// we don't care too much
// no provider-specific data allowed on ATM
// unidirectional P2MP; we don't need to setup the Receiving flowspec
//qos_.SendingFlowspec.TokenRate = 0xffffffff;
//qos_.SendingFlowspec.TokenBucketSize = 0xffffffff;
//qos_.SendingFlowspec.PeakBandwidth = 0xffffffff;
//qos_.SendingFlowspec.Latency = 0xffffffff;
//qos_.SendingFlowspec.DelayVariation = 0xffffffff;
//qos_.SendingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;
// This will most probably be ignored by the service provider.
//qos_.SendingFlowspec.MaxSduSize = 0xffffffff;
//qos_.SendingFlowspec.MinimumPolicedSize = 0xffffffff;
//qos_.ReceivingFlowspec.TokenRate = 0xffffffff;
//qos_.ReceivingFlowspec.TokenBucketSize = 0xffffffff;
//qos_.ReceivingFlowspec.PeakBandwidth = 0xffffffff;
//qos_.ReceivingFlowspec.Latency = 0xffffffff;
//qos_.ReceivingFlowspec.DelayVariation = 0xffffffff;
//qos_.ReceivingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;
// This will most probably be ignored by the service provider.
//qos_.ReceivingFlowspec.MaxSduSize = 0xffffffff;
//qos_.ReceivingFlowspec.MinimumPolicedSize = 0;
/*
// This will most probably ignored by SP.
// This will most probably ignored by SP.
/* ACE_HAS_FORE_ATM_WS2 || ACE_HAS_FORE_ATM_XTI || ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM || ACE_HAS_FORE_ATM_XTI */
// This constructs the T_ATM_ORIG_ADDR option, which is used to
// signal the UNI 3.1 Calling Party ID Information Element.
//if (ACE_OS::t_getprotaddr(fd, &boundaddr, 0) < 0) {
// This constructs all options necessary (bearer cap., QoS, and
// Traffic Descriptor) to signal for a CBR connection with the
// specified QoS in kbit/sec., and/or specify a PMP connection.
// For FORE 200e cards, the adapter shapes traffic to CBR with rate
// equal to PCR CLP=0+1 (traffic.forward.PCR_all_traffic)
// T_ATM_BEARER_CAP: Broadband bearer capability
// UBR
// T_ATM_TRAFFIC: traffic descriptor
// T_ATM_QOS: Quality of Service
// Return actual size of options and option buffer to user.
/* ACE_HAS_FORE_ATM_WS2 */
/* ACE_HAS_ATM */
/* __ACE_INLINE__ */
//   // Use t_getprotaddr for XTI/ATM
//   struct t_bind *localaddr
//     = (struct t_bind *) ACE_OS::t_alloc (get_handle (),
//                                          T_BIND,
//                                          T_ADDR);
//   struct t_bind *peeraddr
//      = (struct t_bind *) ACE_OS::t_alloc (get_handle (),
//                                           T_BIND,
//                                           T_ADDR);
//   ::t_getprotaddr (get_handle (),
//                   localaddr,
//                   peeraddr);
//   char* connected_name = (char*) ACE_OS::malloc (peeraddr->addr.len + 1);
//   ACE_OS::strcpy (connected_name,
//                  peeraddr->addr.buf);
//   ACE_OS::t_free ((char *) localaddr,
//                   T_BIND);
//   ACE_OS::t_free ((char *) peeraddr,
//                   T_BIND);
//   return (connected_name);
//  ACE_OS::ioctl (this->get_handle (),
//               TI_GETPEERNAME,
//               &name);
// Use getpeername for WinSock2.
// Find the host address in the ATM hosts file and return the
//  host name
// Convert the line to lower case to ease comparison
// Grab the second token which is the host name
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
// We are only concerned with SVCs so no other check or values are needed
//  here.
/* atm version>=0.62 */
/* patch for atm version 0.59 */
/* SO_ATMPVC || SO_VCID */
/* ACE_HAS_FORE_ATM_XTI || ACE_HAS_FORE_ATM_WS2 || ACE_HAS_LINUX_ATM */
/* ACE_HAS_ATM */
/* __ACE_INLINE__ */
/* ACE_INCLUDE_ATOMIC_OP_SPARC */
// Disable "no return value" warning, as we will be putting
// the return values directly into the EAX register.
/* _MSC_VER */
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
// Return value is already in EAX register.
// xadd [edx], eax
// Return value is already in EAX register.
/* _MSC_VER */
/* _MSC_VER */
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
// The XCHG instruction automatically follows LOCK semantics
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
// Return value is already in EAX register.
// lock xadd [edx], eax
// Return value is already in EAX register.
/* _MSC_VER */
/* _MSC_VER */
/* ACE_HAS_INTEL_ASSEMBLY*/
/* ACE_HAS_INTEL_ASSEMBLY*/
/* _MSC_VER */
// end namespace
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_BUILTIN_ATOMIC_OP */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_GCC_ATOMIC_BUILTINS */
/* ACE_HAS_DUMP */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// *************************************************
// ACE_TRACE ("ACE_Atomic_Op_Ex<ACE_LOCK, TYPE>::mutex");
// ACE_TRACE ("ACE_Atomic_Op_Ex<ACE_LOCK, TYPE>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Atomic_Op_Ex<ACE_LOCK, TYPE>::ACE_Atomic_Op_Ex");
// ACE_TRACE ("ACE_Atomic_Op_Ex<ACE_LOCK, TYPE>::ACE_Atomic_Op_Ex");
// ****************************************************************
// ACE_TRACE ("ACE_Atomic_Op<ACE_LOCK, TYPE>::ACE_Atomic_Op");
// ACE_TRACE ("ACE_Atomic_Op<ACE_LOCK, TYPE>::ACE_Atomic_Op");
/* ACE_ATOMIC_OP_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_WCHAR */
/* ACE_HAS_DUMP */
/* __ACE_INLINE__ */
/*ACE_AUTO_FUNCTOR_CPP*/
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Auto_IncDec<ACE_SAFELY_INCREMENTABLE_DECREMENTABLE>::dump");
/* ACE_HAS_DUMP */
/* ACE_AUTO_INCDEC_T_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_AUTO_PTR_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Sub_Barrier::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Sub_Barrier::ACE_Sub_Barrier");
// ACE_TRACE ("ACE_Barrier::dump");
/* ACE_HAS_DUMP */
// Check for shutdown...
// We're the last running thread, so swap generations and tell
// all the threads waiting on the barrier to continue on their
// way.
// Swap generations.
// Block until all the other threads wait().
// We're awake and the count has completed. See if it completed
// because all threads hit the barrier, or because the barrier
// was shut down.
// Check for shutdown...
// Flag the shutdown
// Tell all the threads waiting on the barrier to continue on their way.
// ACE_TRACE ("ACE_Thread_Barrier::ACE_Thread_Barrier");
// ACE_TRACE ("ACE_Thread_Barrier::dump");
/* ACE_HAS_DUMP */
/* ACE_HAS_THREADS */
/* ACE_HAS_ALLOC_HOOKS */
/**
// Useful typedefs.
/// Keeps track of the mapping between addresses and their associated
/// values.
/// Synchronize concurrent access to the map.
// Search for appropriate base address in repository
// Check to see if <addr> is within any of the regions.
// Assign the base address.
// Assume base address 0 (e.g., if new'ed).
// Bind a new entry to the repository or update the size of an
// existing entry.
// Unbind a base from the repository.
// Search for service handlers that requested notification.
// Check to see if <addr> is within any of the regions and if
// so, unbind the key from the map.
// Unbind base address.
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Find the base address associated with our <this> pointer.  Note
// that it's ok for <find> to return 0, which simply indicates that
// the address is not in memory-mapped virtual address space.
// Store a value of <target_> that indicate "NULL" pointer.
// Find the base address associated with the <addr> pointer.
// Note that it's ok for <find> to return 0, which simply
// indicates that the address is not in memory-mapped virtual
// address space.
// not implemented.
// not implemented.
/* ACE_BASED_POINTER_T_CPP */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// ACE_USES_GPROF
// Initialize the proper configuration context for the new thread
// Placed here since inherit_log_msg() gets called from any of our
// descendants (before self-destructing)
// Run the thread entry point for the <ACE_Thread_Adapter>.  This must
// be an extern "C" to make certain compilers happy...
// As early as we can in the execution of the new thread, allocate
// its local TS storage.  Allocate it on the stack, to save dynamic
// allocation/dealloction.
/* ACE_HAS_TSS_EMULATION */
// ACE_USES_GPROF
// Invoke the user-supplied function with the args.
/* __ACE_INLINE__ */
/* ACE_NLOGGING */
/* -*- C++ -*- */
/* __ACE_INLINE__ */
/* ACE_BOUND_PTR_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Get the recycling act for the svc_handler
// Check to see if the hint svc_handler has been closed down
// If close, decrement refcount
// If refcount goes to zero, close down the svc_handler
// Hint not successful
// Reset hint
// If hint is not closed, see if it is connected to the correct
// address and is recyclable
// Hint successful
// Tell the <svc_handler> that it should prepare itself for
// being recycled.
//
// Update the caching attributes directly since we don't do a
// find() on the cache map.
//
// Indicates successful find.
// This hint will not be used.
// Hint not successful
// If <sh> is not connected to the correct address or is busy,
// we will not use it.
// Try to find the address in the cache.  Only if we don't find it
// do we create a new <SVC_HANDLER> and connect it with the server.
// We found a cached svc_handler.
// Get the cached <svc_handler>
// Is the connection clean?
// read ready
// write ready
// exception ready
// Cycle it once again..
// Found!!!
// Set the flag
// Tell the <svc_handler> that it should prepare itself for
// being recycled.
// Not found...
// Set the flag
// We need to use a temporary variable here since we are not
// allowed to change <sh> because other threads may use this
// when we let go of the lock during the OS level connect.
//
// Note that making a new svc_handler, connecting remotely,
// binding to the map, and assigning of the hint and recycler
// should be atomic to the outside world.
// Create a new svc_handler
// Connect using the svc_handler.
// Close the svc handler.
// Insert the new SVC_HANDLER instance into the cache.
// Close the svc handler and reset <sh>.
// Everything succeeded as planned. Assign <sh> to
// <potential_handler>.
// Set the recycler and the recycling act
// Actively establish the connection.  This is a timed blocking
// connect.
// If connect() failed because of timeouts, we have to reject
// the connection entirely. This is necessary since currently
// there is no way for the non-blocking connects to complete and
// for the <Connector> to notify the cache of the completion of
// connect().
// If the connect failed due to the process running out of
// file descriptors then, auto_purging of some connections
// are done from the CONNECTION_CACHE. This frees the
// descriptors which get used in the connect process and
// hence the same method is called again!
// Try connecting again.
// Check if the user passed a hint svc_handler
// If not found
// Increment the refcount
// For all successful cases: mark the <svc_handler> in the cache
// as being <in_use>.  Therefore recyclable is BUSY.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// The wonders and perils of ACT
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as CLOSED.
// Reset the <*act_holder> in the confines and protection of the
// lock.
// The wonders and perils of ACT
// Decrement the refcount on the <svc_handler>.
// If the svc_handler state is closed and the refcount == 0, call
// close() on svc_handler.
//
// Update the caching attributes directly since we don't do a
// find() on the cache map.
//
// Indicates successful find.
// Excluded other threads from changing the cache while we cleanup
// Close down all cached service handlers.
// save entry for future use
// close handler
// remember next iter
// purge the item from the hash
// assign next iter
/////////////////////////////////////////////////////////////////////////
// Try to find the address in the cache.  Only if we don't find it
// do we create a new <SVC_HANDLER> and connect it with the server.
// We found a cached svc_handler.
// Get the cached <svc_handler>
// Is the connection clean?
// read ready
// write ready
// exception ready
// The connection was disconnected during idle.
// close the svc_handler down.
// and rotate once more...
// Found!!!
// Set the flag
// Tell the <svc_handler> that it should prepare itself for
// being recycled.
// some other return value or error...
// just to see it coming
// Not found...
// Set the flag
// Check the limit of handlers...
// Try to purge idle connections
// Check limit again.
// still too much!
// OK, we have room now...
// We need to use a temporary variable here since we are not
// allowed to change <sh> because other threads may use this
// when we let go of the lock during the OS level connect.
//
// Note that making a new svc_handler, connecting remotely,
// binding to the map, and assigning of the hint and recycler
// should be atomic to the outside world.
// Create a new svc_handler
// Connect using the svc_handler.
// Close the svc handler.
// Insert the new SVC_HANDLER instance into the cache.
// Close the svc handler and reset <sh>.
// Everything succeeded as planned. Assign <sh> to
// <potential_handler>.
// Set the recycler and the recycling act
/* ACE_CACHED_CONNECT_STRATEGY_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Insert an entry which has the <key> and the <cache_value> which
// is the combination of the <value> and the attributes of the
// caching strategy.
// Unless the notification goes thru the bind operation is
// not complete.
// Make sure the unbind operation is done only when the
// notification fails after a bind which is denoted by
// rebind_result = 0
// Unless the notification goes thru the rebind operation is
// not complete.
// Make sure the unbind operation is done only when the
// notification fails after a bind which is denoted by
// rebind_result = 0
// Unless the notification goes thru the rebind operation is
// not complete.
// Make sure the unbind operation is done only when the
// notification fails after a bind which is denoted by
// rebind_result = 0
// Unless the notification goes thru the rebind operation is
// not complete.
// If the entry has got inserted into the map, it is removed
// due to failure.
// If an attempt is made to bind an existing entry the value
// is overwritten with the value from the map.
// Lookup the key and populate the <value>.
// Unless the find and notification operations go thru, this
// method is not successful.
// Since the <cache_value> has now changed after the
// notification, we need to bind to the map again.
// Lookup the key and populate the <value>.
// Unless the find and notification operations go thru, this
// method is not successful.
// Since the <cache_value> has now changed after the
// notification, we need to bind to the map again.
// Remove the entry from the cache.
// Remove the entry from the cache.
/* ACE_HAS_DUMP */
/* ACE_CACHE_MAP_MANAGER_T_CPP */
/* __ACE_INLINE__ */
/* ACE_LACKS_PRAGMA_ONCE */
//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
/* ACE_CACHING_STRATEGIES_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
//////////////////////////////////////////////////////////////////////////////
// Check that the purge_percent is non-zero.
// Get the number of entries in the container.
// Also whether the number of entries in the cache!
// Oops! then there is no way out but exiting. So return an error.
// Calculate the no of entries to remove from the cache depending
// upon the <purge_percent>.
// Simply verifying that the key is non-zero.
// This is important for strategies where the minimum
// entry cant be found due to constraints on the type of entry
// to remove.
// Starting values.
// The iterator moves thru the container searching for the entry
// with the lowest ATTRIBUTES.
// Ah! an item with lower ATTTRIBUTES...
////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check that the purge_percent is non-zero.
// Get the number of entries in the container.
// Also whether the number of entries in the cache is just one!
// Oops! then there is no way out but exiting. So return an error.
//  if (current_map_size <= 1)
// Calculate the no of entries to remove from the cache depending
// upon the <purge_percent>.
// Simply verifying that the key is non-zero.
// This is important for strategies where the minimum
// entry cant be found due to constraints on the type of entry
// to remove.
// Starting values.
// Found the minimum entry to be purged?
// The iterator moves thru the container searching for the entry
// with the lowest ATTRIBUTES.
// If the <min> entry isnt IDLE_AND_PURGABLE continue until you reach
// the first entry which can be purged. This is the minimum with
// which you will compare the rest of the purgable entries.
// Ah! an entry with lower ATTTRIBUTES...
////////////////////////////////////////////////////////////////////////////////
// Check that the purge_percent is non-zero.
// Get the number of entries in the container which can be considered for purging.
// Also whether the number of entries in the cache zero.
// Oops! then there is no way out but exiting.
// Calculate the no of entries to remove from the cache depending
// upon the <purge_percent>.
// Simply verifying that the key is non-zero.
// This is important for strategies where the minimum
// entry cant be found due to constraints on the type of entry
// to remove.
// Starting values.
// Found the minimum entry to be purged?
// The iterator moves thru the container searching for the entry
// with the lowest ATTRIBUTES.
// If the <min> entry isnt IDLE_AND_PURGABLE continue until you reach
// the first entry which can be purged. This is the minimum with
// which you will compare the rest of the purgable entries.
// Ah! an entry with lower ATTTRIBUTES...
////////////////////////////////////////////////////////////////////////////////
// Check that the purge_percent is non-zero.
// Get the number of entries in the container.
// Also whether the number of entries in the cache is just one!
// Oops! then there is no way out but exiting. So return an error.
// Calculate the no of entries to remove from the cache depending
// upon the <purge_percent>.
// Starting values.
// The iterator moves thru the container searching for the entry
// with the lowest ATTRIBUTES.
// Ah! an item with lower ATTTRIBUTES...
////////////////////////////////////////////////////////////////////////////////////////////////////////
/* ACE_CACHING_UTILITY_T_CPP */
/* !__ACE_INLINE__ */
// @@ UNICODE Does this work with unicode?
// Skip blanks
// If we get end of line return
// If name is null.
// String property
// Integer property
// Boolean
// Skip blanks or irrelevant characters
// End of line reached
// Build the entry name
// We have found the required entry?
// Skip puntuaction char if neccesary.
/* ! __ACE_INLINE__ */
/* NONNATIVE_LONGDOUBLE */
//
// See comments in CDR_Base.inl about optimization cases for swap_XX_array.
//
// ACE_ASSERT(n > 0); The caller checks that n > 0
// We pretend that AMD64/GNU G++ systems have a Pentium CPU to
// take advantage of the inline assembly implementation.
// Later, we try to read in 32 or 64 bit chunks,
// so make sure we don't do that for unaligned addresses.
// this is an _if_, not a _while_. The mismatch can only be by 2.
//
// Loop unrolling. Here be dragons.
//
// (n & (~3)) is the greatest multiple of 4 not bigger than n.
// In the while loop ahead, orig will move over the array by 8 byte
// increments (4 elements of 2 bytes).
// end marks our barrier for not falling outside.
// See if we're aligned for writing in 64 or 32 bit chunks...
// 64 bit architecture.
// We're out of luck. We have to write in 2 byte chunks.
// We're little endian.
// We're little endian.
// 64 bit architecture.
// (n & 3) == (n % 4).
// fallthrough
// fallthrough
// ACE_ASSERT (n > 0); The caller checks that n > 0
// Later, we read from *orig in 64 bit chunks,
// so make sure we don't generate unaligned readings.
// The mismatch can only be by 4.
/* ACE_SIZEOF_LONG == 8 */
//
// Loop unrolling. Here be dragons.
//
// (n & (~3)) is the greatest multiple of 4 not bigger than n.
// In the while loop, orig will move over the array by 16 byte
// increments (4 elements of 4 bytes).
// ends marks our barrier for not falling outside.
// 64 bits architecture.
// See if we can write in 8 byte chunks.
// We are out of luck, we have to write in 4 byte chunks.
/* ACE_SIZEOF_LONG != 8 */
// Expect the optimizer reordering this A LOT.
// We leave it this way for clarity.
/* ACE_SIZEOF_LONG == 8 */
// (n & 3) == (n % 4).
// fallthrough
// fallthrough
//
// We don't benefit from unrolling in swap_8_array and swap_16_array
// (swap_8 and swap_16 are big enough).
//
// ACE_ASSERT(n > 0); The caller checks that n > 0
// ACE_ASSERT(n > 0); The caller checks that n > 0
/* ACE_CDR_IGNORE_ALIGNMENT */
// Do the equivalent of ACE_CDR::mb_align() here to avoid having
// to allocate an ACE_Message_Block on the stack thereby avoiding
// the manipulation of the data blocks reference count
// Setting the data block on the mb resets the read and write
// pointers back to the beginning.  We must set the rd_ptr to the
// aligned start and adjust the write pointer to the end
// Remove the DONT_DELETE flags from mb
// Compute the total size.
// We must copy the contents of src into the new buffer, but
// respecting the alignment.
/* ACE_CDR_IGNORE_ALIGNMENT */
// If the destination and source are the same, do not
// attempt to copy the data.  Just update the write pointer.
/* NONNATIVE_LONGLONG */
// Infinity and NaN have an exponent of 0x7ff in 64-bit IEEE
// exponent 0 stays 0 in 128-bit
// Store the sign bit and exponent
// Store the mantissa.  In an 8 byte double, it is split by
// 4 bits (because of the 12 bits for sign and exponent), so
// we have to shift and or the rhs to get the right bytes.
// Infinity and NaN have an exponent of 0x7fff in 128-bit IEEE
// exponent 0 stays 0 in 64-bit
// Store the sign and exponent
// Store the mantissa.  In an 8 byte double, it is split by
// 4 bits (because of the 12 bits for sign and exponent), so
// we have to shift and or the rhs to get the right bytes.
// This bit of code is unnecessary.  However, this code is
// necessary to work around a bug in the gcc 4.1.1 optimizer.
/* NONNATIVE_LONGDOUBLE */
// ACE_CDR::Fixed
// How many digits are to the left of the decimal point?
// Insert the integer part from least to most significant
// Insert the fractional part from most to least significant
// scale set after here so that ++ applies to the fractional part
// Calculate the number of nibbles that can be moved.
// Move and clear the nibbles.
// skip '.'
// Most sig digit of rhs must be >= 5
// split with bot having dig digits
// decrement and check if result is nonzero
// signs of lhs and rhs are the same so lhs < rhs reduces to:
// if positive, |lhs| < |rhs|
// if negative, |rhs| < |lhs|
// 'a' will refer to the value left of < and 'b' to the value to the right
// a's offset (more scale than b)
// b's offset (more scale than a)
// digits in more that are missing in fewer must be 0
// digits in common must match
// extra (more significant) digits in more must be 0
// extra (more significant) digits in fewer must be 0
/* ! __ACE_INLINE__ */
// Note: translator framework is not supported.
//
// wchar is not allowed with GIOP 1.0.
// Note: translator framework is not supported.
//
// Be nice to programmers: treat nulls as empty strings not
// errors. (OMG-IDL supports languages that don't use the C/C++
// notion of null v. empty strings; nulls aren't part of the OMG-IDL
// string model.)
// @@ Leave this method in here, not the `.i' file so that we don't
//    have to unnecessarily pull in the `ace/SString.h' header.
// Note: translator framework is not supported.
//
//In GIOP 1.2 the length field contains the number of bytes
//the wstring occupies rather than number of wchars
//Taking sizeof might not be a good way! This is a temporary fix.
//In GIOP 1.2 zero length wstrings are legal
/* ACE_LACKS_CDR_ALIGNMENT */
/* ! __ACE_INLINE__ */
// ****************************************************************
/* ACE_LACKS_CDR_ALIGNMENT */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_LACKS_CDR_ALIGNMENT */
// We cannot trust the buffer to be properly aligned
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_LACKS_CDR_ALIGNMENT */
// We cannot trust the buffer to be properly aligned
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_LACKS_CDR_ALIGNMENT */
// We cannot trust the buffer to be properly aligned
/* ACE_HAS_MONITOR_POINTS==1 */
/*static*/ void
/*static*/ size_t
// Calculate the new buffer's length; if growing for encode, we
// don't grow in "small" chunks because of the cost.
/* ACE_LACKS_CDR_ALIGNMENT */
// Make sure that there is enough room for <minsize> bytes, but
// also make it bigger than whatever our current size is.
// Message block initialization may fail while the construction
// succeds.  Since as a matter of policy, ACE may throw no
// exceptions, we have to do a separate check like this.
// The new block must start with the same alignment as the
// previous block finished.
/* ACE_LACKS_CDR_ALIGNMENT */
// grow the chain and set the current block.
// wchar is not allowed with GIOP 1.0.
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// Be nice to programmers: treat nulls as empty strings not
// errors. (OMG-IDL supports languages that don't use the C/C++
// notion of null v. empty strings; nulls aren't part of the OMG-IDL
// string model.)
// @@ Leave this method in here, not the `.i' file so that we don't
//    have to unnecessarily pull in the `ace/SString.h' header.
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// What do we do for GIOP 1.2???
//In GIOP 1.2 the length field contains the number of bytes
//the wstring occupies rather than number of wchars
//Taking sizeof might not be a good way! This is a temporary fix.
//In GIOP 1.2 zero length wstrings are legal
// If the buffer is small and it fits in the current message
// block it is be cheaper just to copy the buffer.
// If the mb does not own its data we are forced to make a copy.
/* ACE_LACKS_CDR_ALIGNMENT */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
// TODO: print something?
/* ACE_ENABLE_SWAP_ON_WRITE */
// It is hard to optimize this, the spec requires that on the wire
// booleans be represented as a byte with value 0 or 1, but in
// memory it is possible (though very unlikely) that a boolean has
// a non-zero value (different from 1).
// We resort to a simple loop.
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
/* ACE_ENABLE_SWAP_ON_WRITE */
// Optimize by only doing something if we need to
// Set the number of bytes in the top-level block, reallocating
// if necessary.  The rd_ptr and wr_ptr remain at the original offsets
// into the buffer, even if it is reallocated.
// Return an error if the allocation failed.
// Consolidate the chain into the first block.  NOTE that
// ACE_CDR::consolidate can not be used since we don't want to
// overwrite what is already in the first block. We just append it since
// the read and write pointers weren't affected by the resizing above.
// We also don't have to worry about alignment since the start block is
// already aligned.
// NOTE also we know there is a continuation since we checked for it
// above.  There is therefore no reason to check for a 0 continuation
// field here.
// Release the old blocks that were consolidated and reset the
// current_ and current_is_writable_ to reflect the single used block.
/* ACE_HAS_MONITOR_POINTS==1 */
// ****************************************************************
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
// Set the read pointer
// Set the write pointer after doing a sanity check.
/* ACE_HAS_MONITOR_POINTS==1 */
// Align the base pointer assuming that the incoming stream is also
// aligned the way we are aligned
/* ACE_LACKS_CDR_ALIGNMENT */
/* ACE_HAS_MONITOR_POINTS==1 */
// Align the base pointer assuming that the incoming stream is also
// aligned the way we are aligned
/* ACE_LACKS_CDR_ALIGNMENT */
// Notice that ACE_Message_Block::duplicate may leave the
// wr_ptr() with a higher value than what we actually want.
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_LACKS_CDR_ALIGNMENT */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// A check for the length being too great is done later in the
// call to read_char_array but we want to have it done before
// the memory is allocated.
/* ACE_HAS_ALLOC_HOOKS */
// Convert any null strings to empty strings since empty
// strings can cause crashes. (See bug 58.)
/* ACE_HAS_ALLOC_HOOKS */
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// A check for the length being too great is done later in the
// call to read_char_array but we want to have it done before
// the memory is allocated.
//allocating one extra for the null character needed by applications
/* ACE_HAS_ALLOC_HOOKS */
//Null character used by applications to find the end of
//the wstring
//Is this okay with the GIOP 1.2 spec??
/* ACE_HAS_ALLOC_HOOKS */
// Convert any null strings to empty strings since empty
// strings can cause crashes. (See bug 58.)
/* ACE_HAS_ALLOC_HOOKS */
// As of C++11 std::string guarantees contiguous memory storage.
// That provides the opportunity to optimize CDR streaming.
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// A check for the length being too great is done later in the
// call to read_char_array but we want to have it done before
// the memory is allocated.
// no need to include the terminating '\0' here
// skip the terminating '\0'
// @@ This is a slight violation of "Optimize for the common case",
// i.e. normally the translator will be 0, but OTOH the code is
// smaller and should be better for the cache ;-) ;-)
// A check for the length being too great is done later in the
// call to read_char_array but we want to have it done before
// the memory is allocated.
// no need to include the terminating '\0' here
// skip the terminating '\0'
// TODO: print something?
/* ACE_DISABLE_SWAP_ON_READ */
/* ACE_DISABLE_SWAP_ON_READ */
// Make sure the length of the array isn't greater than the length of
// the stream.
// It is hard to optimize this, the spec requires that on the wire
// booleans be represented as a byte with value 0 or 1, but in
// memory it is possible (though very unlikely) that a boolean has
// a non-zero value (different from 1).
// We resort to a simple loop.
/* ACE_DISABLE_SWAP_ON_READ */
/* ACE_DISABLE_SWAP_ON_READ */
/* ACE_DISABLE_SWAP_ON_READ */
/* ACE_DISABLE_SWAP_ON_READ */
// Indirection, next Long in stream is signed offset to actual
// string location (backwards in same stream from here).
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
// If the message block had a DONT_DELETE flags, just clear it off..
/* ACE_HAS_MONITOR_POINTS==1 */
// Exchange byte orders
// Get the destination read and write pointers
// Get the source read & write pointers
// Exchange data_blocks. Dont release any of the data blocks.
// Exchange the flags information..
// Reset the <cdr> pointers to zero before it is set again.
// Set the read and write pointers.
// Exchange the GIOP version info
/* ACE_HAS_MONITOR_POINTS==1 */
// Get the read & write pointer positions in the incoming CDR
// streams
// Now reset the incoming CDR stream
// As we have reset the stream, try to align the underlying message
// block in the incoming stream
// Get the read & write pointer positions again
// Actual length of the stream is..
// @todo: This will look idiotic, but we dont seem to have much of a
// choice. How do we calculate the length of the incoming stream?
// Calling the method before calling reset () would give us the
// wrong length of the stream that needs copying.  So we do the
// calulation like this
// (1) We get the <rd_ptr> and <wr_ptr> positions of the incoming
// stream.
// (2) Then we reset the <incoming> stream and then align it.
// (3) We get the <rd_ptr> and <wr_ptr> positions again. (Points #1
// thru #3 has been done already)
// (4) The difference in the <rd_ptr> and <wr_ptr> positions gives
// us the following, the actual bytes traversed by the <rd_ptr> and
// <wr_ptr>.
// (5) The bytes traversed by the <wr_ptr> is the actual length of
// the stream.
// Actual bytes traversed
// If the size of the data that needs to be copied are higher than
// what is available, then do a reallocation.
// @@NOTE: We need to probably add another method to the message
// block interface to simplify this
// Replace our data block by using the incoming CDR stream.
// Align the start_ message block.
// Clear the DONT_DELETE flag if it has been set
// Now do the copy
// Set the read pointer position to the same point as that was in
// <incoming> cdr.
// We have changed the read & write pointers for the incoming
// stream. Set them back to the positions that they were before..
// Copy the char/wchar translators
/* ACE_HAS_MONITOR_POINTS==1 */
// If at all our message had a DONT_DELETE flag set, just clear it
// off.
/* ACE_HAS_MONITOR_POINTS==1 */
// Reset the flags...
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
// --------------------------------------------------------------
// --------------------------------------------------------------
// --------------------------------------------------------------
// Same format (hex) and no risk of overflow.
/* GEN_OSTREAM_OPS */
// host name
// verbose flag
// CE does not like '\n' by itself.
// ACE_HAS_WINCE
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_ALLOC_HOOKS */
/*****************************************************************************/
/*****************************************************************************/
/* ACE_HAS_ALLOC_HOOKS */
/*****************************************************************************/
// Return -1 and sets errno if unable to allocate storage.  Enqueue
// at the head and dequeue from the head to get LIFO ordering.
// The object has already been registered.
// Call all registered cleanup hooks, in reverse order of
// registration.
// The object is an ACE_Cleanup.
// The hook is an ACE_EXIT_HOOK.
/* ACE_LACKS_PRAGMA_ONCE */
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// Remove the item from cache only if the handler isnt in use.
////////////////////////////////////////////////////////////////////////////
/* ACE_CLEANUP_STRATEGIES_T_CPP */
/* ACE_HAS_ALLOC_HOOKS */
// Just in case ...
// Symbols which form the Base64 alphabet (Defined as per RFC 2045)
// The padding character used in the encoding
// Number of columns per line of encoded output (Can have a maximum
// value of 76).
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
//=============================================================================
/**
//=============================================================================
// 00-0F
// 10-1F
// 20-2F
// 30-3F
// 40-4F
// 50-5F
// 60-6F
// 70-7F
// 80-8F
// 90-9F
// A0-AF
// B0-BF
// C0-CF
// D0-DF
// E0-EF
// F0-FF
// 00-0F
// 10-1F
// 20-2F
// 30-3F
// 40-4F
// 50-5F
// 60-6F
// 70-7F
// 80-8F
// 90-9F
// A0-AF
// B0-BF
// C0-CF
// D0-DF
// E0-EF
// F0-FF
// drop terminating '\0' read from stream
// ****************************************************************
// drop terminating '\0' read from stream
/* ACE_HAS_EBCDIC */
//=============================================================================
/**
//=============================================================================
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/*
/* -*- C++ -*- */
/**
/* __ACE_INLINE__ */
// -*- C++ -*-
/**
// ACE_TRACE ("ACE_Condition<MUTEX>::dump");
// No dump method for ACE_cond_t even in emulated mode.
// cond_.dump ();
/* ACE_HAS_DUMP */
// We wait on the condition, specifying the nesting mutex. For platforms
// with ACE_HAS_RECURSIVE_MUTEXES, this is the recursive mutex itself,
// and is the same as recursive_mutex, above. The caller should have been
// holding the lock on entry to this method, and it is still held.
// For other platforms, this is the nesting mutex that guards the
// ACE_recursive_mutex_t internals, and recursive_mutex_cond_unlock()
// returned with the lock held, but waiters primed and waiting to be
// released. At cond_wait below, the mutex will be released.
// On return, it will be reacquired.
// We are holding the mutex, whether the wait succeeded or failed.
// Stash errno (in case it failed) and then we need to reset the
// recursive mutex state to what it was on entry to this method.
// Resetting it may require a wait for another thread to release
// the ACE_recursive_thread_mutex_t if this is a platform without
// ACE_HAS_RECURSIVE_MUTEXES, and recursive_mutex_cond_relock() takes
// care of that.
/* ACE_HAS_THREADS */
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Condition<MUTEX>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Thread_Condition<MUTEX>::ACE_Thread_Condition");
// ACE_TRACE ("ACE_Thread_Condition<MUTEX>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Condition<MUTEX>::ACE_Condition");
// ACE_TRACE ("ACE_Condition<MUTEX>::ACE_Condition<MUTEX>");
// ACE_TRACE ("ACE_Condition<MUTEX>::~ACE_Condition");
// ACE_TRACE ("ACE_Condition<MUTEX>::wait");
// ACE_TRACE ("ACE_Condition<MUTEX>::wait");
// Peform an "alertable" timed wait.  If the argument ABSTIME == 0
// then we do a regular cond_wait(), else we do a timed wait for up to
// ABSTIME using the Solaris cond_timedwait() function.
// ACE_TRACE ("ACE_Condition<MUTEX>::wait");
/* ACE_HAS_THREADS */
/* ACE_CONDITION_T_CPP */
/* -*- C++ -*- */
/**
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::dump");
/* ACE_WIN32 */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::ACE_Condition<ACE_Thread_Mutex>");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::ACE_Condition<ACE_Thread_Mutex>");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::~ACE_Condition<ACE_Thread_Mutex>");
// Peform an "alertable" timed wait.  If the argument <abstime> == 0
// then we do a regular <cond_wait>, else we do a timed wait for up to
// <abstime> using the <cond_timedwait> function.
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::wait");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::wait");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::wait");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::signal");
// ACE_TRACE ("ACE_Condition<ACE_Thread_Mutex>::broadcast");
/* ACE_HAS_THREADS */
/* ACE_LACKS_ACCESS */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
//////////////////////////////////////////////////////////////////////////////
// Make a copy of key
// Open the section
// Invalid character set
// Position of the first invalid character or terminating null.
// Check if it is an invalid character.
// The first character can never be a path separator.
// Validate length.
/**
// loop through each section in this object
// find that section in the rhs object
// If the rhs object does not contain the section then we are
// not equal.
// if there is some error opening the section in this object
// Well the sections match
// Enumerate each value in this section
// look for the same value in the rhs section
// We're not equal if the same value cannot
// be found in the rhs object.
// we're not equal if the types do not match.
// finally compare values.
// we're not equal if we cannot get this string
// we're not equal if we cannot get rhs string
// we're not equal if we cannot get this int
// we're not equal if we cannot get rhs int
// we're not equal if we cannot get this data
// we're not equal if we cannot get this data
// are the length's the same?
// yes, then check each element
/* ACE_HAS_ALLOC_HOOKS */
// end if the length's match
// We should never have valueTypes of INVALID, therefore
// we're not comparing them.  How would we since we have
// no get operation for invalid types.
// So, if we have them, we guess they are equal.
// end else if values match.
// end value while loop
// look in the rhs for values not in this
// look for the same value in this section
// We're not equal if the same value cannot
// be found in the rhs object.
// end while for rhs values not in this.
// end else if sections match.
// end section while loop
// Finally, make sure that there are no sections in rhs that do not
// exist in this
// find the section in this
// if there is some error opening the section in this object
// If the rhs object does not contain the section then we
// are not equal.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Note we don't increment the index because the
// enumeration becomes invalid if we change the
// subkey, which we do when we delete it.  By leaving
// it 0, we always delete the top entry
// Get the size of the binary data from windows
// Get the size of the binary data from windows
// unknown type
// Make a copy of hKey
// ACE_HAS_WINCE
// recurse through the path
// Open the key
// ACE_HAS_WINCE
// try creating it
// error
// release our open key handle
/* ACE_WIN32 && !ACE_LACKS_WIN32_REGISTRY */
///////////////////////////////////////////////////////////////
// Do nothing in other cases...
///////////////////////////////////////////////////////////////////////
/* ACE_HAS_ALLOC_HOOKS */
//////////////////////////////////////////////////////////////////////////////
// Create the allocator with the appropriate options.
// The name used for  the lock is the same as one used
// for the file.
// Make sure that the file name is of the legal length.
// Create the allocator with the appropriate options.  The name used
// for  the lock is the same as one used for the file.
// Now check if the backing store has been created successfully.
/* ACE_LACKS_ACCESS */
// This is the easy case since if we find hash table in the
// memory-mapped file we know it's already initialized.
// Create a new <index_> (because we've just created a new
// memory-mapped file).
// Attempt to clean up.
// Add the root section
// Find the base section
// See if this section already exists
// already exists!
// Create the new section name
// only prepend a separater if were not at the root
// Add it to the base section
// Create a new section and add it to the global list
// Allocate memory for items to be stored in the table.
// Populate memory with data.
// If allocation failed ...
// Initialize allocated hash map through placement new.
// create the section map
// If allocation failed
// initialize allocated hash map through placement new
// Do a normal bind.  This will fail if there's already an
// entry with the same name.
/* Entry already existed so bind failed. */
/* Unable to bind for other reasons. */)
// Free our dynamically allocated memory.
// If bind () succeed, it will automatically sync
// up the map manager entry.  However, we must sync up our
// name/value memory.
// set the result
// 1 == allow_path
// Only add the \\ if were not at the root
// resolve the section
// Find this key
// no parent key
// Find this subkey
// Now make sure we dont have any subkeys
// Now remove subkey from parent key
// Remember the pointers so we can free them after we unbind
// iterate over all values and free memory
// remove it
// Free the memory
// resolve the section
// Handle iterator resets
// Get the next entry
// Return the value of the iterator and advance it
// cast to a heap section key
// not a heap key!
// resolve the section
// unknown section
// Handle iterator resets
// Get the next entry
// Return the value of the iterator and advance it
// Get the entry for this item (if it exists)
// found item, replace it
// Free the old value
// Allocate the new value in this heap
// it doesn't exist, bind it
// Get the section name from the key
// Find this section
// section does not exist
// Get the entry for this item (if it exists)
// found item, replace it
// it doesn't exist, bind it
// Get the section name from the key
// Find this section
// section does not exist
// Get the entry for this item (if it exists)
// found item, replace it
// Free the old value
// Allocate the new value in this heap
// it doesn't exist, bind it
// Get the section name from the key
// Find this section
// section does not exist
// See if it exists first
// unknown value
// Check type
// everythings ok, return the data
// Get the section name from the key
// Find this section
// section does not exist
// See if it exists first
// unknown value
// Check type
// Everythings ok, return the data
// Get the section name from the key
// Find this section
// section does not exist
// See if it exists first
// unknown value
// Check type
// Make a copy
/* ACE_HAS_ALLOC_HOOKS */
// Get the section name from the key
// Find this section
// section does not exist
// Find it
// value does not exist
// Get the section name from the key
// Find this section
// section does not exist
// Find it
// free it
// Unbind it
// Imports the configuration database from filename.
// No existing data is removed.
/* ACE_HAS_ALLOC_HOOKS */
// Check if we got all the line.
// look for end of line
// we havn't reach the end of the line yet
// allocate a new buffer - double size the previous one
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// copy the beginnning of the line
/* ACE_HAS_ALLOC_HOOKS */
// Check for a comment
// We have a new section here, strip out the section name
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// end if firs char is a [
// we have a value
// no closing quote, not a value so just skip it
// null terminate the name
// determine the type
// string type
// truncate trailing "
/* ACE_HAS_ALLOC_HOOKS */
// number type
/* ACE_HAS_ALLOC_HOOKS */
// binary type
// divide by 3 to get the actual buffer length
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// invalid type, ignore
// end if first char is a "
// if the first character is not a ", [, ;, or # we may be
// processing a file in the old format.
// Try and process the line as such and if it fails,
// return an error
/* ACE_HAS_ALLOC_HOOKS */
// end if maybe old format
// end while fgets
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// This method exports the entire configuration database to <filename>.
// Once the file is opened this method calls 'export_section' passing
// the root section.
// The data may have been buffered and will be flush on close,
// so we need to check that the close succeeds.
// Method provided by derived classes in order to write one section
// to the file specified.  Called by export_config when exporting
// the entire configuration object.
// don't export the root
// Write out the section header
// Write out each value
// not supported yet - maybe use BASE64 codeing?
/* ACE_HAS_ALLOC_HOOKS */
// Export all sub sections
//
// This method read the line format origionally used in ACE 5.1
//
// Chop any cr/lf at the end of the line.
// assume this is a value, read in the value name
// no =, not a value so just skip it
// null terminate the name
// determine the type
// string type
// number type
// end read_previous_line_format
// Method to read file and populate object.
// @@ Make this a dynamic size!
// Check for a comment and blank line
// We have a new section here, strip out the section name
// We have a line; name ends at equal sign.
// No '='
// No name; just an '='
// Now find the start of the value
// ACE 5.2 (and maybe earlier) exported strings may be enclosed
// in quotes. If string is quote-delimited, strip the quotes.
// Newer exported files don't have quote delimiters.
// Strip quotes off both ends.
// end while fgets
// This method exports the entire configuration database to <filename>.
// Once the file is opened this method calls 'export_section' passing
// the root section.
// The data may have been buffered and will be flush on close,
// so we need to check that the close succeeds.
// Method provided by derived classes in order to write one section to the
// file specified.  Called by export_config when exporting the entire
// configuration objet
// don't export the root
// Write out the section header
// Write out each value
// JDO added break.  Otherwise INVALID is processed
// like BINARY. If that's correct, please remove the
// break and these comments
// not supported yet - maybe use BASE64 codeing?
/* ACE_HAS_ALLOC_HOOKS */
// end switch on type
// end while enumerating values
// Export all sub sections
// Method to squish leading and trailing whitespaces from a string.
// Whitespace is defined as: spaces (' '), tabs ('\t') or end-of-line
// (cr/lf).  The terminating nul is moved up to expunge trailing
// whitespace and the returned pointer points at the first
// non-whitespace character in the string, which may be the nul
// terminator if the string is all whitespace.
// Start at the end and work backwards over all whitespace.
// Chop trailing whitespace
// Now start at the beginning and move over all whitespace.
/* Has ACE_NONBLOCK */
/* ACE_LACKS_PRAGMA_ONCE */
// If SVC_HANDLER is reference counted then NBCH holds a reference
// in cleanup_svc_handle_ which is both a pointer to SVC_HANDLER
// and a flag that triggers remove_reference in NBCH destructor.
/* ACE_HAS_DUMP */
// Make sure that we haven't already initialized the Svc_Handler.
// Exclusive access to the Reactor.
// Double check.
// Remember the Svc_Handler.
// Remove this handle from the set of non-blocking handles
// in the Connector.
// Cancel timer.
// Remove from Reactor.
// This method is called if a connection times out before completing.
// Forward to the SVC_HANDLER the <arg> that was passed in as a
// magic cookie during ACE_Connector::connect().  This gives the
// SVC_HANDLER an opportunity to take corrective action (e.g., wait
// a few milliseconds and try to reconnect again.
// Called when a failure occurs during asynchronous connection
// establishment.
// Close Svc_Handler.
// epoll on Linux will, at least sometimes, return EPOLLERR when a connect
// fails, triggering a total removal from the reactor. This is different from
// select()-based systems which select the fd for read on a connect failure.
// So just call handle_input() to rejoin common handling for a failed
// connect.
// Called when a connection is establishment asynchronous.
// Grab the connector ref before smashing ourselves in close().
// On Win32, the except mask must also be set for asynchronous
// connects.
/* ACE_HAS_DUMP */
// Set the reactor of the newly created <SVC_HANDLER> to the same
// reactor that this <Connector> is using.
// No errors initially
// See if we should enable non-blocking I/O on the <svc_handler>'s
// peer.
// Otherwise, make sure it's disabled by default.
// We are connected now, so try to open things up.
// Make sure to close down the <svc_handler> to avoid descriptor
// leaks.
// The connection was already made; so this close is a "normal"
// close operation.
// Initiate connection to peer.
// Initiate connection to peer.
// If the user hasn't supplied us with a <SVC_HANDLER> we'll use the
// factory method to create one.  Otherwise, things will remain as
// they are...
// Activate immediately if we are connected.
// Delegate to connection strategy.
// If the connection hasn't completed and we are using
// non-blocking semantics then register
// ACE_NonBlocking_Connect_Handler with the ACE_Reactor so that
// it will call us back when the connection is complete or we
// timeout, whichever comes first...
// If for some reason the <nonblocking_connect> call failed, then <errno>
// will be set to the new error.  If the call succeeds, however,
// we need to make sure that <errno> remains set to
// <EWOULDBLOCK>.
// Save/restore errno.
// Make sure to close down the service handler to avoid handle
// leaks.
// Mark this entry as having failed.
// Mark this entry as having succeeded.
// Cancel a <svc_handler> that was started asynchronously.
// find_handler() increments handler's refcount; ensure we decrement it.
// Must have a valid Reactor for non-blocking connects to work.
// Register the pending SVC_HANDLER so that it can be activated
// later on when the connection completes.
// Exclusive access to the Reactor.
// Register handle with the reactor for connection events.
// Add handle to non-blocking handle set.
// If we're starting connection under timer control then we need to
// schedule a timeout with the ACE_Reactor.
// Remember timer id.
// Undo previous actions using the ol' "goto label and fallthru"
// trick...
// Remove from Reactor.
// Remove handle from the set of non-blocking handles.
/* FALLTHRU */
// Close the svc_handler
// Try to find out if the reactor uses event associations for the
// handles it waits on. If so we need to reset it.
// Transfer ownership of the ACE_HANDLE to the SVC_HANDLER.
// Check to see if we're connected.
// Somethings gone wrong, so close down...
// Win32 (at least prior to Windows 2000) has a timing problem.
// If you check to see if the connection has completed too fast,
// it will fail - so wait 35 milliseconds to let it catch up.
// do the svc handler close below...
/* ACE_WIN32 */
// If there are no non-blocking handle pending, return immediately.
// Exclusive access to the Reactor.
// Go through all the non-blocking handles.  It is necessary to
// create a new iterator each time because we remove from the handle
// set when we cancel the Svc_Handler.
// Remove handle from the set of non-blocking handles.
// find_handler() incremented handler's refcount; ensure it's decremented
// Remove handle from the set of non-blocking handles.
// Cancel the non-blocking connection.
// Close the associated Svc_Handler.
// Hook called by the explicit dynamic linking facility.
// @@ Not implemented yet.
// this->flags_ = flags;
// Initialize the creation strategy.
// First we decide if we need to clean up.
// Initialize the accept strategy.
// Initialize the concurrency strategy.
// Close down
/* ACE_CONNECTOR_C */
/* __ACE_INLINE__ */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ----------------------------------------
/* ACE_HAS_DUMP */
//----------------------------------------
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::dump");
/* ACE_HAS_DUMP */
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::ACE_Unbounded_Stack");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::delete_all_nodes");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::copy_all_nodes");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::ACE_Unbounded_Stack");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::operator=");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::~ACE_Unbounded_Stack");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::push");
//  ACE_TRACE ("ACE_Unbounded_Stack<T>::pop");
// ACE_TRACE ("ACE_Unbounded_Stack<T>::find");
// Set <item> into the dummy node.
// Keep looping until we find the item.
// If we found the dummy node then it's not really there, otherwise,
// it is there.
// ACE_TRACE ("ACE_Unbounded_Stack<T>::insert");
// ACE_TRACE ("ACE_Unbounded_Stack<T>::remove");
// Insert the item to be founded into the dummy node.
// Item was not found.
// Skip over the node that we're deleting.
//--------------------------------------------------
// Do nothing
// Do nothing
// @@ Is this a valid retasking? Make sure to check with Purify and
// whatnot that we're not leaking memory or doing any other screwing things.
//--------------------------------------------------
// Advance current_ out of the null area and onto the first item in
// the list
// Advance current_ out of the null area and onto the first item in
// the list
// It seems dangerous to remove nodes in an iterator, but so it goes...
/* ACE_HAS_DUMP */
// Prefix advance.
// Postfix advance.
// Prefix reverse.
// Postfix reverse.
//--------------------------------------------------
// Advance current_ out of the null area and onto the last item in
// the list
// Advance current_ out of the null area and onto the last item in
// the list
// It seems dangerous to remove nodes in an iterator, but so it goes...
/* ACE_HAS_DUMP */
// Prefix advance.
// Postfix advance.
// Prefix reverse.
// Postfix reverse.
// We have no bound.
// Insert it before <head_>, i.e., at tail.
// Insert it after <head_>, i.e., at head.
// Detach it from the list.
// Detach it from the list.
// Dump the state of an object.
/* ACE_HAS_DUMP */
// Well, what will cause errors here?
// Notice that you have to ensure that item is an element of this
// list.  We can't do much checking here.
// Can't remove head
// reset pointers to prevent double removal.
//--------------------------------------------------
/* ACE_HAS_DUMP */
// Keep track of first free slot.
// First, make sure we don't allow duplicates.
// If we found a free spot let's reuse it.
/* No more room! */
// Mark this entry as being free.
//--------------------------------------------------
/* ACE_HAS_DUMP */
//--------------------------------------------------
/* ACE_HAS_DUMP */
//--------------------------------------------------
/* ACE_HAS_DUMP */
//--------------------------------------------------
/* ACE_HAS_DUMP */
// Keep track of first free slot.
// First, make sure we don't allow duplicates.
// If we found a free spot let's reuse it.
// Insert at the end of the active portion.
/* No more room! */
// Mark this entry as being free.
// If we just unbound the highest entry, then we need to
// figure out where the next highest active entry is.
/* ACE_HAS_DUMP */
// ****************************************************************
// ACE_TRACE ("ACE_Unbounded_Stack_Iterator<T>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Unbounded_Stack_Iterator<T>::ACE_Unbounded_Stack_Iterator");
// ACE_TRACE ("ACE_Unbounded_Stack_Iterator<T>::advance");
// ACE_TRACE ("ACE_Unbounded_Stack_Iterator<T>::first");
// ACE_TRACE ("ACE_Unbounded_Stack_Iterator<T>::next");
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::ACE_Ordered_MultiSet");
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::~ACE_Ordered_MultiSet");
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::insert");
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::insert using iterator");
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::remove");
// if we found the node, remove from list and free it
// search an occurrence of item, using iterator's current position as a hint
// if we found the node, update the iterator and indicate success
//  ACE_TRACE ("ACE_Ordered_MultiSet<T>::dump");
//
//  ACELIB_DEBUG ((LM_DEBUG, ACE_BEGIN_DUMP, this));
//  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\nhead_ = %u"), this->head_));
//  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\nhead_->next_ = %u"), this->head_->next_));
//  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\ncur_size_ = %d\n"), this->cur_size_));
//
//  T *item = 0;
//  size_t count = 1;
//
//  for (ACE_Ordered_MultiSet_Iterator<T> iter (*(ACE_Ordered_MultiSet<T> *) this);
//       iter.next (item) != 0;
//       iter.advance ())
//    ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("count = %d\n"), count++));
//
//  ACELIB_DEBUG ((LM_DEBUG, ACE_END_DUMP));
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Ordered_MultiSet<T>::insert_from");
// create a new node
// obtain approximate location of the node
// if there are nodes in the multiset
// insert after the approximate position
// if there is a following node
// link up with the following node
// appending to the end of the set
// link up with the preceeding node
// insert before the position
// if there is a preceeding node
// link up with the preceeding node
// prepending to the start of the set
// link up with the preceeding node
// point the head and tail to the new node.
// If starting before the item, move forward until at or just before
// item.
// If starting after the item, move back until at or just after item
// Save the (approximate) location in the passed pointer.
// Show the location is after (1), before (-1) , or at (0) the item
// Looks for first occurrence of <item> in the ordered set, using the
// passed starting position as a hint: if there is such an instance,
// it updates the new_position pointer to point to one such node and
// returns 0; if there is no such node, then if there is a node before
// where the item would have been, it updates the new_position pointer
// to point to this node and returns -1; if there is no such node,
// then if there is a node after where the item would have been, it
// updates the new_position pointer to point to this node (or 0 if
// there is no such node) and returns 1;
// iterate through list, deleting nodes
// ACE_TRACE ("ACE_Ordered_MultiSet_Iterator<T>::ACE_Ordered_MultiSet_Iterator");
// ACE_TRACE ("ACE_Ordered_MultiSet_Iterator<T>::next");
//ACE_TRACE ("ACE_Ordered_MultiSet_Iterator<T>::operator*");
// ****************************************************************
// Compare this array with <s> for equality.
// ****************************************************************
/* ACE_CONTAINERS_T_CPP */
/**
/* __ACE_INLINE__ */
// Used all of timeout.
// errno = ETIME;
/* ACE_COUNTDOWN_TIME_T_CPP */
// Date_Time.cpp
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// This is the do-nothing constructor.
// Close the device
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// Transform the current address into string format.
// Return a pointer to the address.
/* ACE_HAS_DUMP */
// Do nothing constructor.
// Copy constructor.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// class copy.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// Return the local endpoint address.
// Return the address of the remotely connected peer (if there is
// one).
/* ACE_HAS_DUMP */
// Simple-minded do nothing constructor.
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
// This is basically an interface to ACE_OS::readv, that doesn't use the
// struct iovec explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
/**/ <linux/devpoll.h>
/**/ <devpoll.h>
/**/ <sys/devpoll.h>
/* ACE_LINUX */
/* ACE_HAS_DEV_POLL */
/* __ACE_INLINE__ */
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
/* timer_queue */,
// close-on-exec
/* F_SETFD */
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// Set the read handle into non-blocking mode since we need to
// perform a "speculative" read when determining if there are
// notifications to dispatch.
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// Just consider this method a "no-op" if there's no
// ACE_Dev_Poll_Reactor configured.
// When using the queue, always try to write to the notify pipe. If it
// fills up, ignore it safely because the already-written bytes will
// eventually cause the notify handler to be dispatched.
// Also decrement eh's reference count
// The notification has been queued, so it will be delivered at some
// point (and may have been already); release the refcnt guard.
// Now pop the pipe to force the callback for dispatching when ready. If
// the send fails due to a full pipe, don't fail - assume the already-sent
// pipe bytes will cause the entire notification queue to be processed.
// Note that we don't need a timeout since the pipe is already in
// nonblocking mode and all we want is one attempt.
// Only need one byte to pop the pipe
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
/* number_of_active_handles */,
/* rd_mask */)
// This method is unimplemented in the ACE_Dev_Poll_Reactor.
// Instead, the notification handler is invoked as part of the IO
// event set.  Doing so alters the some documented semantics that
// state that the notifications are handled before IO events.
// Enforcing such semantics does not appear to be beneficial, and
// also serves to slow down event dispatching particularly with this
// ACE_Dev_Poll_Reactor.
// This is a (non-blocking) "speculative" read, i.e., we attempt to
// read even if no event was polled on the read handle.  A
// speculative read is necessary since notifications must be
// dispatched before IO events.  We can avoid the speculative read
// by "walking" the array of pollfd structures returned from
// `/dev/poll' or `/dev/epoll' but that is potentially much more
// expensive than simply checking for an EWOULDBLOCK.
// The idea in the queued case is to be sure we never end up with a notify
// queued but no byte in the pipe. If that happens, the notify won't be
// dispatched. So always try to empty the pipe, read the queue, then put
// a byte in if needed. The notify() method is enqueueing then writing the
// pipe, so be sure to do it in the reverse order here to avoid a race
// between removing the last notification from the queue and the notify
// side writing its byte.
// Nothing dequeued or error
// If it's just a wake-up, toss it and see if there's anything else.
// If there are more messages, ensure there's a byte in the pipe
// in case the notification limit stops dequeuing notifies before
// emptying the queue.
/* one byte is enough */
// Check to see if we've got a short read.
// If so, try to recover by reading the remainder.  If this
// doesn't work we're in big trouble since the input stream
// won't be aligned correctly.  I'm not sure quite what to
// do at this point.  It's probably best just to return -1.
// Return -1 if things have gone seriously wrong.
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
/*handle*/)
// If eh == 0 then another thread is unblocking the
// ACE_Dev_Poll_Reactor to update the ACE_Dev_Poll_Reactor's
// internal structures.  Otherwise, we need to dispatch the
// appropriate handle_* method on the ACE_Event_Handler
// pointer we've been passed.
// Guard the handler's refcount. Recall that when the notify
// was queued, the refcount was incremented, so it need not be
// now. The guard insures that it is decremented properly.
// Should we bail out if we get an invalid mask?
// Must always be > 0 or < 0 to optimize the loop exit condition.
/* defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE) */
/* defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE) */
/* ACE_HAS_DUMP */
// -----------------------------------------------------------------
// Try to allocate the memory.
// Try to increase the number of handles if <size> is greater than
// the current limit.
// Unbind all of the event handlers; similar to remove_handler() on all.
// Check for ref counting now - handle_close () may delete eh.
// Only bother to search for the <handle> if it's in range.
// -----------------------------------------------------------------
// , ready_set_ ()
/* ACE_HAS_DEV_POLL */
// , ready_set_ ()
/* ACE_HAS_DEV_POLL */
// Can't initialize ourselves more than once.
/* ACE_HAS_EVENT_POLL */
// Allows the signal handler to be overridden.
// Allows the timer queue to be overridden.
// Allows the Notify_Handler to be overridden.
// Initialize epoll:
// Allocate the array before opening the device to avoid a potential
// resource leak if allocation fails.
// Open the `/dev/poll' character device.
/* ACE_HAS_EVENT_POLL */
// Registration of the notification handler must be done after the
// /dev/poll device has been fully initialized.
// We're all set to go.
// This will close down all the allocated resources properly.
/* size */)
/* ACE_HAS_EVENT_POLL */
// Stash the current time
//
// The destructor of this object will automatically compute how much
// time elapsed since this method was called.
// If the guard is NOT the owner just return the retval
// Update the countdown to reflect time waiting for the mutex.
/* ACE_HAS_EVENT_POLL */
// We still have work_pending (). Do not poll for
// additional events.
// Check if we have timers to fire.
/* Infinity */
// Wait for an event.
// Milliseconds
// Poll for events
// Retrieve the results from the pollfd array.
// If nfds == 0 then end_pfds_ == start_pfds_ meaning that there is
// no work pending.  If nfds > 0 then there is work pending.
// Otherwise an error occurred.
/* ACE_HAS_EVENT_POLL */
// If timers are pending, override any timeout from the poll.
// Stash the current time
//
// The destructor of this object will automatically compute how much
// time elapsed since this method was called.
// If the guard is NOT the owner just return the retval
// Update the countdown to reflect time waiting for the mutex.
// Poll for events
//
// If the underlying event wait call was interrupted via the interrupt
// signal (i.e. returned -1 with errno == EINTR) then the loop will
// be restarted if so desired.
// Bail out -- we got here since the poll was interrupted.
// If it was due to a signal registered through our ACE_Sig_Handler,
// then it was dispatched, so we count it in the number of events
// handled rather than cause an error return.
// Dispatch an event.
// Dispatch an event. On entry, the token is held by the caller. If an
// event is found to dispatch, the token is released before dispatching it.
// Perform the Template Method for dispatching the first located event.
// We dispatch only one to effectively dispatch events concurrently.
// As soon as an event is located, the token is released, allowing the
// next waiter to begin getting an event while we dispatch one here.
// Handle timers early since they may have higher latency
// constraints than I/O handlers.  Ideally, the order of
// dispatching should be a strategy...
// If no timer dispatched, check for an I/O event.
// Check to see if the ACE_HANDLE associated with the
// Dev_Poll_Reactor's notify hook is enabled.  If so, it means that
// one or more other threads are trying to update the
// ACE_Dev_Poll_Reactor's internal tables or the notify pipe is
// enabled.  We'll handle all these threads and notifications, and
// then break out to continue the event loop.
/* this->state_changed_ ? -1 : */ 0;
/* 0 */
// Dispatch a ready event.
// Define bits to check for while dispatching.
// No known bits for this
/* ACE_HAS_EVENT_POLL */
// epoll_wait() pulls one event which is stored in event_. If the handle
// is invalid, there's no event there. Else process it. In any event, we
// have the event, so clear event_ for the next thread.
// Since the underlying event demultiplexing mechansim (`/dev/poll'
// or '/dev/epoll') is stateful, and since only one result buffer is
// used, all pending events (i.e. those retrieved from a previous
// poll) must be dispatched before any additional event can be
// polled.  As such, the Dev_Poll_Reactor keeps track of the
// progress of events that have been dispatched.
// Select the first available handle with event (s) pending. Check for
// event type in defined order of dispatch: output, exception, input.
// When an event is located, clear its bit in the dispatch set. If there
// are no more events for the handle, also increment the pfds pointer
// to move to the next handle ready.
//
// Notice that pfds only contains file descriptors that have
// received events.
/* ACE_HAS_EVENT_POLL */
/* When using sys_epoll, we can attach arbitrary user
// Going to access handler repo, so lock it. If the lock is
// unobtainable, something is very wrong so bail out.
// No registered handler any longer
// It is possible another thread has changed (and possibly re-armed)
// this handle mask before current thread obtained the repo lock.
// If that did happen and this handler is still suspended, don't
// dispatch on top of another callback. See Bugzilla 4129.
// Figure out what to do first in order to make it easier to manage
// the bit twiddling and possible pfds increment before releasing
// the token for dispatch.
// Note that if there's an error (such as the handle was closed
// without being removed from the event set) the EPOLLHUP and/or
// EPOLLERR bits will be set in revents.
/* ACE_HAS_DEV_POLL */
// Increment the pointer to the next element before we
// release the token.  Otherwise event handlers end up being
// dispatched multiple times for the same poll.
// With epoll, events are registered with oneshot, so the handle is
// effectively suspended; future calls to epoll_wait() will select
// the next event, so they're not managed here.
// The hitch to this is that the notify handler is always registered
// WITHOUT oneshot and is never suspended/resumed. This avoids endless
// notify loops caused by the notify handler requiring a resumption
// which requires the token, which requires a notify, etc. described
// in Bugzilla 3714. So, never suspend the notify handler.
/* ACE_HAS_DEV_POLL */
// End scope for ACE_GUARD holding repo lock
// gets callback status, below.
// Dispatch notifies directly. The notify dispatcher locates a
// notification then releases the token prior to dispatching it.
// NOTE: If notify_handler_->dispatch_one() returns a fail condition
// it has not releases the guard. Else, it has.
// Modify the reference count in an exception-safe way.
// Note that eh could be the notify handler. It's not strictly
// necessary to manage its refcount, but since we don't enable
// the counting policy, it won't do much. Management of the
// notified handlers themselves is done in the notify handler.
// Release the reactor token before upcall.
// Dispatch the detected event; will do the repeated upcalls
// if callback returns > 0, unless it's the notify handler (which
// returns the number of notfies dispatched, not an indication of
// re-callback requested). If anything other than the notify, come
// back with either 0 or < 0.
// If the callback returned 0, epoll-based needs to resume the
// suspended handler but dev/poll doesn't.
// In both epoll and dev/poll cases, if the callback returns <0,
// the token needs to be acquired and the handler checked and
// removed if it hasn't already been.
// epoll-based effectively suspends handlers around the upcall.
// If the handler must be resumed, check to be sure it's the
// same handle/handler combination still.
/* ACE_HAS_EVENT_POLL */
// All state in the handler repository may have changed during the
// upcall. Thus, reacquire the repo lock and evaluate what's needed.
// If the upcalled handler is still the handler of record for handle,
// continue with checking whether or not to remove or resume the
// handler.
// epoll-based effectively suspends handlers around the upcall.
// If the handler must be resumed, check to be sure it's the
// same handle/handler combination still.
/* ACE_HAS_EVENT_POLL */
// Scope close handles eh ref count decrement, if needed.
// Handler not present in the repository.  Bind it.
// All but the notify handler get registered with oneshot to facilitate
// auto suspend before the upcall. See dispatch_io_event for more
// information.
/* ACE_HAS_EVENT_POLL */
// Handler is already present in the repository, so register it
// again, possibly for different event.  Add new mask to the
// current one.
// Add file descriptor to the "interest set."
/*ACE_HAS_DEV_POLL*/
// Note the fact that we've changed the state of the wait_set_,
// which is used by the dispatching loop to determine whether it can
// keep going or if it needs to reconsult select ().
// this->state_changed_ = 1;
/* event_handle */,
/* io_handle */,
/* event_handler */,
/* mask */)
// @@ It might be more efficient to construct a pollfd array and
//    pass it to the write () call in register_handler_i () only once,
//    instead of calling write () (a system call) once for each file
//    descriptor.
/* ACE_NSIG <= 0 */
/* ACE_NSIG <= 0  */
// FUZZ: disable check_for_ACE_Guard
// FUZZ: enable check_for_ACE_Guard
// If registered event handler not the same as eh, don't mess with
// the mask, but do the proper callback and refcount when needed.
// Nothing to work with
// Check for ref counting now - handle_close () may delete eh.
// It would be great if ACE_Reverse_Lock worked with the Guard.
// If there are no longer any outstanding events on the given handle
// then remove it from the handler repository.
/* ACE_NSIG <= 0 */
/* ACE_NSIG <= 0 */
// Already suspended.  @@ Should this be an error?
// Remove the handle from the "interest set."
//
// Note that the associated event handler is still in the handler
// repository, but no events will be polled on the given handle thus
// no event will be dispatched to the event handler.
/* ACE_HAS_EVENT_POLL */
// Place the handle back in to the "interest set."
//
// Events for the given handle will once again be polled.
/* ACE_HAS_EVENT_POLL */
// @@ Is this correct?
// Since the Dev_Poll_Reactor does not do any event associations,
// this method always return false.
// Don't bother waking the poll - the worse that will happen is it will
// wake up for a timer that doesn't exist then go back to waiting.
// Don't bother waking the poll - the worse that will happen is it will
// wake up for a timer that doesn't exist then go back to waiting.
// Pass over both the Event_Handler *and* the mask to allow the
// caller to dictate which Event_Handler method the receiver
// invokes.  Note that this call can timeout.
// Compare all bits in the mask
// Send a notification, but don't block if there's no one to receive
// it.
/* new_owner */,
/* old_owner */)
// There is no need to set the owner of the event loop.  Multiple
// threads may invoke the event loop simulataneously.
/* owner */)
// There is no need to set the owner of the event loop.  Multiple
// threads may invoke the event loop simulataneously.
// Block out all signals until method returns.
// Perform GET, CLR, SET, and ADD operations on the interest/wait
// set and the suspend set (if necessary).
//
// GET = 1, Retrieve current value
// SET = 2, Set value of bits to new mask (changes the entire mask)
// ADD = 3, Bitwise "or" the value into the mask (only changes
//          enabled bits)
// CLR = 4  Bitwise "and" the negation of the value out of the mask
// (only changes enabled bits)
//
// Returns the original mask.
// The work for this operation is done in all cases at the
// beginning of the function.
/// Reset the mask for the given handle.
// Only attempt to alter events for the handle from the
// "interest set" if it hasn't been suspended. If it has been
// suspended, the revised mask will take affect when the
// handle is resumed. The exception is if all the mask bits are
// cleared, we can un-control the fd now.
// Apparently events cannot be updated on-the-fly on Solaris so
// remove the existing events, and then add the new ones.
// Change the events associated with the given file descriptor.
// ACE_Event_Handler::NULL_MASK ???
// If a handle is closed, epoll removes it from the poll set
// automatically - we may not know about it yet. If that's the
// case, a mod operation will fail with ENOENT. Retry it as
// an add. If it's any other failure, just fail outright.
// Change the events associated with the given file descriptor.
/*ACE_HAS_EVENT_POLL  */
/* event_handler */,
/* mask */,
/* ops */)
// Since the Dev_Poll_Reactor uses the poll result buffer, the
// ready_set cannot be directly manipulated outside of the event
// loop.
/* handle */,
/* mask */,
/* ops */)
// Since the Dev_Poll_Reactor uses the poll result buffer, the
// ready_set cannot be directly manipulated outside of the event
// loop.
/* ACE_HAS_DUMP */
// No event.  Remove from interest set.
/* ACE_HAS_EVENT_POLL */
// READ, ACCEPT, and CONNECT flag will place the handle in the
// read set.
/*ACE_HAS_EVENT_POLL*/
// WRITE and CONNECT flag will place the handle in the write set.
/*ACE_HAS_EVENT_POLL*/
// EXCEPT flag will place the handle in the except set.
/*ACE_HAS_EVENT_POLL*/
// Acquire the token but don't ping any waiters; just queue up politely.
// Check for timeouts and errors.
// We got the token and so let us mark ourselves as owner
// Try to grab the token.  If someone if already there, don't wake
// them up, just queue up in the thread pool.
// Check for timeouts and errors.
// We got the token and so let us mark ourseleves as owner
/* ACE_HAS_EVENT_POLL || ACE_HAS_DEV_POLL */
/* __ACE_INLINE__ */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// Construction/Destruction
// Free up any allocated resources.
// Only the lacking-struct-dir emulation allocates this. Native
// scandir includes d_name in the dirent struct itself.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Default constructor. Also, by default, the object will be closed
// before it is destroyed.
// This will automatically up the refcount.
// Assignment operator
// If the library name and the opening mode are specified than on
// object creation the library is implicitly opened.
// The library is closed before the class gets destroyed depending on
// the close_handle_on_destruction value specified which is stored in
// close_handle_on_destruction_.
// Normally delete()d in ACE_DLL::close().  However, that may not
// occur if full ACE_DLL initialization is interrupted due to errors
// (e.g. attempting to open a DSO/DLL that does not exist).  Make
// sure this->dll_name_ is deallocated.
/* ACE_HAS_ALLOC_HOOKS */
// This method opens the library based on the mode specified using the
// ACE_SHLIB_HANDLE which is obtained on making the ACE_OS::dlopen call.
// The default mode is:
// RTLD_LAZY     Only references to data symbols are relocate when the
//               object is first loaded.
// The other modes include:
//  RTLD_NOW     All necessary relocations are performed when the
//               object is first loaded.
//  RTLD_GLOBAL  The object symbols are made available for the
//               relocation processing of any other object.
// If we have a good handle and its the same name, just return.
// The symbol refernce of the name specified is obtained.
// The library is closed using the ACE_SHLIB_HANDLE object, i.e., the
// shared object is now disassociated form the current process.
// Even if close_dll() failed, go ahead and cleanup.
/* ACE_HAS_ALLOC_HOOKS */
// This method is used return the last error of a library operation.
// Return the handle to the user either temporarily or forever, thus
// orphaning it. If 0 means the user wants the handle forever and if 1
// means the user temporarily wants to take the handle.
// Set the handle for the DLL. By default, the object will be closed
// before it is destroyed.
// Create a unique name.  Note that this name is only quaranteed
// to be unique for the life of this object.
/* ACE_HAS_ALLOC_HOOKS */
// Once dll_name_ has been set, it can't be changed..
// If it hasn't been loaded yet, go ahead and do that now.
/*
// Decent guess to avoid realloc later
// Find out where the library is
// Transform the pathname into the appropriate dynamic link library
// by searching the ACE_LD_SEARCH_PATH.
// The ACE_SHLIB_HANDLE object is obtained.
// Good one?
// If errno is ENOENT we just skip over this one,
// anything else - like an undefined symbol, for
// instance must be flagged here or the next error will
// mask it.
// @TODO: If we've found our DLL _and_ it's
// broken, should we continue at all?
// AIX often puts the shared library file (most often named
// shr.o) inside an archive library. If this is an archive
// library name, then try appending [shr.o] and retry.
// If errno is ENOENT we just skip over this one, anything
// else - like an undefined symbol, for instance
// must be flagged here or the next error will mask it.
//
// @TODO: If we've found our DLL _and_ it's broken,
// should we continue at all?
/* AIX */
// Only hold the lock until it comes time to dlclose() the DLL. Closing
// the DLL can cause further shutdowns as DLLs and their dependents are
// unloaded.
// Since we don't actually unload the dll as soon as the refcount
// reaches zero, we need to make sure we don't decrement it below
// zero.
// First remove any associated Framework Components.
// Release lock_ here
// handle_ can be invalid especially when ACE_DLL_Handle resigned ownership
// BTW. Handle lifecycle management is a little crazy in ACE
// Linux says that the symbol could be null and that it isn't an
// error.  So you should check the error message also, but since
// null symbols won't do us much good anyway, let's still report
// an error.
// This method is used return the last error of a library operation.
// Build the array of DLL names to try on this platform by applying the
// proper prefixes and/or suffixes to the specified dll_name.
// 1. Separate the dll_name into the dir part and the file part. We
// only decorate the file part to determine the names to try loading.
// 2. Locate the file suffix, if there is one. Move the '.' and the
// suffix to base_suffix.
// 3. Build the combinations to try for this platform.
// Try these combinations:
//   - name with platform's dll prefix (if it has one) and suffix
//   - name with platform's dll prefix, decorator, and suffix.
//   - name with decorator and platform's suffix appended (if not supplied)
//   - name with platform's suffix appended (if not supplied)
//   - name as originally given
// We first try to find the file using the decorator so that when a
// filename with and without decorator is used, we get the file with
// the same decorator as the ACE dll has and then as last resort
// the one without. For example with msvc, the debug build has a "d"
// decorator, but the release build has none and we really want to get
// the debug version of the library in a debug application instead
// of the release one.
// So we need room for 5 entries in try_names.
// Prefix + name + decorator + suffix
// Prefix + name + suffix
// Name + decorator + suffix
// Name + suffix
// No decorator desired; skip
/******************************************************************/
// Pointer to the Singleton instance.
// Perform Double-Checked Locking Optimization.
// Error while opening dll. Free temp handle
// Add the handle to the vector only if the dll is successfully
// opened.
// If going from LAZY to EAGER or from PER_DLL to PER_PROCESS|EAGER,
// call close(1) on all the ACE_DLL_Handle objects with refcount == 0
// which will force those that are still loaded to be unloaded.
/* ACE_HAS_ALLOC_HOOKS */
// Delete components in reverse order.
/* ACE_HAS_ALLOC_HOOKS */
// apply strategy
// Declare the type of the symbol:
/* ACE_HAS_ALLOC_HOOKS */
// Implementations (very simple for now...)
// Let the Tuple default constructor initialize object_table_
// Dump the state of the object.
// This method registers a new <dumper>.  It detects
// duplicates and simply overwrites them.
// Dump_T.cpp
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_HAS_DUMP */
/* ACE_DUMP_T_CPP */
/* __ACE_INLINE__ */
/* static */ ACE_Dynamic *
/* __ACE_INLINE__ */
// ctor
// dtor
// default the message to have pending priority status
// start with the passed absolute time as the message's priority, then
// call the polymorphic hook method to (at least partially) convert
// the absolute time and message attributes into the message's priority
// if the priority is negative, the message is pending
// priority for pending messages must be shifted
// upward above the late priority range
// otherwise, if the priority is greater than the maximum late
// priority value that can be represented, it is beyond late
// all messages that are beyond late are assigned lowest priority (zero)
// otherwise, the message is late, but its priority is correct
// use (fast) bitwise operators to isolate and replace
// the dynamic portion of the message's priority
// returns the priority status of the message
// Dump the state of the strategy.
/* ACE_HAS_DUMP */
// Convert absolute time passed in tv to negative time
// to deadline of mb with respect to that absolute time.
// dynamic priority conversion function based on time to deadline
/* ACE_HAS_DUMP */
// Convert absolute time passed in tv to negative
// laxity of mb with respect to that absolute time.
// dynamic priority conversion function based on laxity
/* ACE_HAS_DUMP */
// Dump the state of the strategy.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_DYNAMIC_SERVICE_CPP */
/* ACE_HAS_DUMP */
// Get the instance using <name> for the current global
// service configuration repository.
// Find a service registration
// Check the static repo, too if different
// Get the instance using <name> for specific configuration repository.
/* ACE_USES_WCHAR */
/* ACE_BIG_ENDIAN */
// First check for ASCII since much of ASCII text will appear to
// convert from UTF-16 to UTF-8.
// Check for UTF-32
// Check for UTF-16
/* ACE_USES_WCHAR */
/* __ACE_INLINE__ */
/* ACE_ENV_VALUE_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// Event_Handler.cpp
/* Need to see if ACE_HAS_BUILTIN_ATOMIC_OP defined */
/* __ACE_INLINE__ */
// Implement conceptually abstract virtual functions in the base class
// so derived classes don't have to implement unused ones.
// ACE_TRACE ("ACE_Event_Handler::ACE_Event_Handler");
// ACE_TRACE ("ACE_Event_Handler::~ACE_Event_Handler");
// Gets the file descriptor associated with this I/O device.
// Sets the file descriptor associated with this I/O device.
// Gets the priority of this handler.
// Sets the priority
// Called when the object is about to be removed from the Dispatcher
// tables.
// Called when input becomes available on fd.
// Called when output is possible on fd.
// Called when urgent data is available on fd.
// Called when timer expires, TV stores the current time.
// Called when a monitored Process exits
// Called when a registered signal occurs.
// Return a default value and allow the reactor to take care of
// resuming the handler
// It's possible for handle_close() to "delete this" so we need to
// cache the reactor pointer and use it here.
// Keep compilers happy.
/* ACE_WIN32 */
/* thr_mgr */)
// What should we do here?
/* ACE_WIN32 */
// ---------------------------------------------------------------------
/* ACE_HAS_CPP11 */
// ---------------------------------------------------------------------
/* __ACE_INLINE__ */
// Upcall to the <handler>s handle_timeout method.
// 0 means "call handle_close()".
// Upcall to the <handler>s handle_close method
// Event_Handler_T.cpp
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_EVENT_HANDLER_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
//  ACE_TRACE ("ACE_FIFO::ACE_FIFO");
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Note that persistent means "open fifo for writing, as well as
// reading."  This ensures that the fifo never gets EOF, even if there
// aren't any writers at the moment!
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Note that persistent means "open FIFO for writing, as well as
// reading."  This ensures that the FIFO never gets EOF, even if there
// aren't any writers at the moment!
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
//  ACE_TRACE ("ACE_FIFO_Send::ACE_FIFO_Send");
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_FIFO_Send_Msg::send");
// Don't count the length we added.
/* ACE_HAS_STREAM_PIPES */
//  ACE_TRACE ("ACE_FIFO_Send_Msg::ACE_FIFO_Send_Msg");
/* Defines the member functions for the base class of the ACE_IO_SAP
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// This is the do-nothing constructor.
// Close the file
// Return the local endpoint address.
// Perform the downcast since <addr> had better be an
// <ACE_FILE_Addr>.
// Return the same result as <get_local_addr>.
// Specifies no sharing flags.
/* ACE_WIN32 */
// See if you can get rid of some of these.
// static const int RCOPY_FLAGS = (FILE_FLAG_SEQUENTIAL_SCAN |
//                                 O_RDONLY);
// static const int WCOPY_FLAGS = (FILE_FLAG_SEQUENTIAL_SCAN |
//                                 O_RDWR | O_CREAT | O_TRUNC);
// static const int RCOPY_FLAGS = O_RDONLY;
// static const int WCOPY_FLAGS = O_RDWR | O_CREAT | O_TRUNC;
/* ACE_WIN32 */
// static data members
// Fetch the file from the Virtual_Filesystem let the
// Virtual_Filesystem do the work of cache coherency.
// Filecache will also do the acquire, since it holds the lock at
// that time.
// Since this is being opened for a write, simply create a new
// ACE_Filecache_Object now, and let the destructor add it into CVF
// later
// Filecache will also do the acquire, since it holds the lock at
// that time.
// this was dup ()'d
// ------------------
// ACE_Filecache_Hash
// ------------------
/* ACE_HAS_ALLOC_HOOKS */
// We need these template specializations since KEY is defined as a
// ACE_TCHAR*, which doesn't have a hash() or equal() method defined on it.
// -------------
// ACE_Filecache
// -------------
// Double check locking pattern.
// @@ James, please check each of the ACE_NEW_RETURN calls to
// make sure that it is safe to return if allocation fails.
//      ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("   (%t) CVF: creating %s\n"), filename));
// Disassociate file from the cache.
// Try a lock.  If it succeeds, we can delete it now.
// Otherwise, it will clean itself up later.
// ACE_SYNCH_RW_MUTEX &filelock = this->file_lock_[loc];
// Second check in the method call
// Double check locking pattern
// Second check in the method call
//      ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("   (%t) CVF: found %s\n"), filename));
// Last one using a stale file is resposible for deleting it.
// Try a lock.  If it succeds, we can delete it now.
// Otherwise, it will clean itself up later.
// Last one using a stale file is resposible for deleting it.
// Try a lock.  If it succeds, we can delete it now.
// Otherwise, it will clean itself up later.
// stat_ (),
// sa_ (),
// stat_ (),
// ASSERT strlen(filename) < sizeof (this->filename_)
// place ourselves into the READING state
// Can we access the file?
// Can we stat the file?
// Can we open the file?
// Can we map the file?
// Ok, finished!
// Can we access the file?
// Does it exist?
// File exists, but we cannot access it.
// Can we open the file?
// Can we write?
// Can we map?
// Ok, done!
// We are safe since only one thread has a writable Filecache_Object
// Leave the file in an acquirable state.
// The existence of the object means a read lock is being held.
// The existence of the object means a read lock is being held.
// The existence of the object means a read lock is being held.
// The existence of the object means a read lock is being held.
// The existence of the object means a read lock is being held.
// The existence of the object means a read lock is being held.
/* __ACE_INLINE__ */
// Built without mktemp support; punt back to caller.
// Create a temporary file.
/* ACE_DEFAULT_TEMP_FILE */
// -15 for ace-file-XXXXXX
// Add the filename to the end
/* ACE_DEFAULT_TEMP_FILE */
/* ACE_DISABLE_MKTEMP */
// Copy constructor.
// Create a ACE_Addr from a ACE_FILE pathname.
// Return the address.
/* ACE_HAS_DUMP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Check to see if caller has requested that we create the filename.
// Create a new temporary file.
// Use ACE_OS::mkstemp() if it is available since it avoids a
// race condition, and subsequently a security hole due to that
// race condition (specifically, a denial-of-service attack).
//
// However, using mkstemp() prevents us from doing a timed open
// since it opens the file for us.  Better to avoid the race
// condition.
// mkstemp() replaces "XXXXXX"
// class copy.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Simple-minded do nothing constructor.
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
// This is basically an interface to ACE_OS::readv, that doesn't use
// the struct iovec explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
// Allows a client to read from a file without having to provide a
// buffer to read.  This method determines how much data is in the
// file, allocates a buffer of this size, reads in the data, and
// returns the number of bytes read.
// Restrict to max size we can record in iov_len.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_File_Lock::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_File_Lock::ACE_File_Lock");
// ACE_TRACE ("ACE_File_Lock::ACE_File_Lock");
// ACE_TRACE ("ACE_File_Lock::open");
// ACE_TRACE ("ACE_File_Lock::~ACE_File_Lock");
/* ACE_LACKS_FCNTL */
/* __ACE_INLINE__ */
/* CYGWIN32 */
// Flags are file status flags to turn on.
// nonblocking argument (1)
// blocking:            (0)
// Turn on flags.
/* ACE_LACKS_FCNTL */
// Flags are the file status flags to turn off.
// nonblocking argument (1)
// blocking:            (0)
// Turn flags off.
/* ACE_LACKS_FCNTL */
/* __ACE_INLINE__ */
/***************************************************************/
// Pointer to the Singleton instance.
/* ACE_HAS_ALLOC_HOOKS */
// Delete components in reverse order.
/* ACE_HAS_ALLOC_HOOKS */
// Perform Double-Checked Locking Optimization.
// Check to see if it's already registered
// Find hole
// move the contents and reset current_size_
// Since start_hole is now one past the last
// active slot.
/* ACE_HAS_DUMP */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_FRAMEWORK_COMPONENT_T_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_PRAGMA_ONCE */
// Default constructor that takes in a preallocation number
// (<prealloc>), a low and high water mark (<lwm> and <hwm>) and an
// increment value (<inc>)
// Destructor - removes all the elements from the free_list
// Inserts an element onto the free list (if we are allowed to manage
// elements withing and it pasts the high water mark, delete the
// element)
// Check to see that we not at the high water mark.
// Takes a element off the freelist and returns it.  It creates <inc>
// new elements if we are allowed to do it and the size is at the low
// water mark.
// If we are at the low water mark, add some nodes
// Remove a node
// Returns the current size of the free list
// Resizes the free list to <newsize>
// Check if we are allowed to resize
// Check to see if we grow or shrink
// Allocates <n> extra nodes for the freelist
// Removes and frees <n> nodes from the freelist.
/* ACE_FREE_LIST_CPP */
//=============================================================================
/**
//=============================================================================
/* __ACE_INLINE__ */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
///////////////////////////////////
// GOF Command Pattern Templates //
///////////////////////////////////
// Constructor.
// Invokes an operation.
/* ACE_FUNCTOR_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Dump the state of an object.
//FUZZ: disable check_for_NULL
//FUZZ: enable check_for_NULL
/* ACE_HAS_DUMP */
// Yes set ref count to zero.
/* ACE_NEW_THROWS_EXCEPTIONS */
// Use value_ready_mutex_ for both condition and ref count management
// Use value_ready_mutex_ for both condition and ref count management
// We do not need the lock when deleting the representation.
// There should be no side effects from deleting rep and we don
// not want to release a deleted mutex.
// Use value_ready_mutex_ for both condition and ref count management
// detached old last for exception safety
// We do not need the lock when deleting the representation.
// There should be no side effects from deleting rep and we don
// not want to release a deleted mutex.
// If the value is already produced, ignore it...
// Otherwise, create a new result value.  Note the use of the
// Double-checked locking pattern to avoid multiple allocations.
// Still no value, so proceed
// Remove and notify all subscribed observers.
// Signal all the waiting threads.
// Destructor releases the lock.
// If the value is already produced, return it.
// If the value is not yet defined we must block until the
// producer writes to it.
// Perform a timed wait.
// Destructor releases the lock.
// Otherwise, create a new result value.  Note the use of the
// Double-checked locking pattern to avoid corrupting the list.
// If the value is already produced, then notify observer
// Remove all occurrences of the specified observer from this
// objects hash map.
// If the value is already produced, return it.
// Constructor of ace_mon acquires the mutex.
// If the value is not yet defined we must block until the
// producer writes to it.
// Wait ``forever.''
// What to do in this case since we've got to indicate
// failure somehow?  Exceptions would be nice, but they're
// not portable...
// Destructor releases the mutex
// If this ACE_Future is already attached to a ACE_Future_Rep,
// detach it (maybe delete the ACE_Future_Rep).
// Give the pointer to the result to the ACE_Future_Rep.
// We're ready if the ACE_Future_rep is ready...
// We return the ACE_Future_rep.
// note that this will fail (and COREDUMP!)
// if future_rep_ == 0 !
//
// but...
// this is impossible unless somebody is so stupid to
// try something like this:
//
// Future<T> futT;
// T t;
// t = futT;
// perform type conversion on Future_Rep.
// assignment:
//
//  bind <this> to the same <ACE_Future_Rep> as <r>.
// This will work if &r == this, by first increasing the ref count
/* ACE_HAS_DUMP */
/* ACE_HAS_THREADS */
/* ACE_FUTURE_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Detach ourselves from all remaining futures, if any, in our map.
// If a new map entry was created, then attach to the future,
// otherwise we were already attached to the future or some error
// occurred so just delete the future holder.
// Attach ourself to the ACE_Futures list of observer
// Enqueue in priority order.
// Wait for a "readable future" signal from the message queue.
// Extract future rep from the message block.
// Delete the message block.
// Remove the hash map entry with the specified future rep from our map.
/* ACE_HAS_THREADS */
/* ACE_FUTURE_SET_CPP */
/* __ACE_INLINE__ */
/*
/*-
// First check to see if POSIXLY_CORRECT was set.
// Win32 is the only platform capable of wide-char env var.
// Now, check to see if any or the following were passed at
// the beginning of optstring: '+' same as POSIXLY_CORRECT;
// '-' turns off POSIXLY_CORRECT; or ':' which signifies we
// should return ':' if a parameter is missing for an option.
// We use a loop here, since a combination of "{+|-}:" in any
// order should be legal.
// Quit as soon as we see something else...
// Should never happen.
// Update scanning pointer.
// We're done...
// We didn't get an option.
// If we permuted or require the options to be in order, we're done.
// It must be RETURN_IN_ORDER...
// Found "--" so we're done...
// If it's a long option, and we allow long options advance nextchar_.
// Advance to the end of the long option name so we can use
// it to get the length for a string compare.
// set last_option_ to nextchar_, up to the '='.
// Got at least a partial match.
// And in fact, it's an exact match, so let's use it.
// Great, we found a match, but unfortunately we found more than
// one and it wasn't exact.
// Okay, we found a good one (either a single hit or an exact match).
// s must point to '=' which means there's an argument (well
// close enough).
// Good, we want an argument and here it is.
// Whoops, we've got what looks like an argument, but we
// don't want one.
// The spec doesn't cover this, so we keep going and the program
// doesn't know we ignored an argument if opt_err is off!!!
// s didn't help us, but we need an argument. Note that
// optional arguments for long options must use the "=" syntax,
// so we won't get here in that case.
// We still have some elements left, so use the next one.
// All out of elements, so we have to punt...
// Remember matching short equiv
// Since val_ has to be either a valid short option or 0, this works
// great.  If the user really wants to know if a long option was passed.
// Okay, we couldn't find a long option.  If it isn't long_only (which
// means try the long first, and if not found try the short) or a long
// signature was passed, e.g. "--", or it's not a short (not sure when
// this could happen) it's an error.
/* Look at and handle the next option-character.  */
// Set last_option_ to opt
/* Increment `optind' when we start to process its last character.  */
// Remember the option that matched
// Takes an optional argument, and since short option args must
// must follow directly in the same argument, a NULL nextchar_
// means we didn't get one.
// Takes a required argument.
// Found argument in same argv-element.
// Ran out of arguments before finding required argument.
// Use the next argv-element as the argument.
// First of all, make sure we reinitialize any pointers..
// It can happen, e.g., on VxWorks.
// We check this because we can string short options together if the
// preceding one doesn't take an argument.
// We only allow valid alpha-numeric characters as short options.
// If short_options is not a valid alpha-numeric, we can still return it
// when the long option is found, but won't allow the caller to pass it on
// the command line (how could they?).  The special case is 0, but since
// we always return it, we let the caller worry about that.
// If the short_option already exists, make sure it matches, otherwise
// add it.
// Short option exists, so verify the argument options
// Didn't find short option, so add it...
// Add to array
// now loop through the
/* ACE_HAS_DUMP */
// Skip over args untill we find the next option.
// Got an option, so mark this as the end of the non options.
// We found the marker for the end of the options.
/* ACE_HAS_ALLOC_HOOKS */
// FUZZ: disable check_for_ACE_Guard
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ****************************************************************
// ACE_ALLOC_HOOK_DEFINE(ACE_Guard)
// ACE_TRACE ("ACE_Guard<ACE_LOCK>::dump");
/* ACE_HAS_DUMP */
// ACE_ALLOC_HOOK_DEFINE(ACE_Write_Guard)
// ACE_TRACE ("ACE_Write_Guard<ACE_LOCK>::dump");
/* ACE_HAS_DUMP */
// ACE_ALLOC_HOOK_DEFINE(ACE_Read_Guard)
// ACE_TRACE ("ACE_Read_Guard<ACE_LOCK>::dump");
/* ACE_GUARD_T_CPP */
// On Win32, ACE_NONBLOCK gets recognized as O_WRONLY so we
// don't use it there
/* ACE_WIN32 */
// Open the named pipe or file using non-blocking mode...
// This expression checks if we were polling.
// Handle_Set.cpp
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_MSB_MASK is only used here.
// This needs to go here to avoid overflow problems on some compilers.
//  Does ACE_WIN32 have an fd_mask?
/* ! ACE_WIN32 */
/* ! ACE_WIN32 */
// XPG4.2 requires the fds_bits member name, so it is not enabled by
// default on Linux/glibc-2.1.x systems.  Instead use "__fds_bits."
// Ugly, but "what are you going to do?" 8-)
/* ACE_LINUX && __GLIBC__ > 1 && __GLIBC_MINOR__ >= 1 && !_XOPEN_SOURCE */
/* !ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_HAS_DUMP */
// Table that maps bytes to counts of the enabled bits in each value
// from 0 to 255,
//
// nbits_[0] == 0
//
// because there are no bits enabled for the value 0.
//
// nbits_[5] == 2
//
// because there are 2 bits enabled in the value 5, i.e., it's
// 101 in binary.
// Constructor, initializes the bitmask to all 0s.
/* ACE_HAS_BIG_FD_SET */
/* !ACE_WIN32 */
// Counts the number of bits enabled in N.  Uses a table lookup to
// speed up the count.
// Count the number of enabled bits in <n>.  This algorithm is very
// fast, i.e., O(enabled bits in n).
/* ACE_HAS_HANDLE_SET_OPTIMIZED_FOR_SELECT */
// Find the bit position counting from right to left worst case
// (1<<31) is 8.
// This is a fast count method when have the most significative bit.
// Is greater than 15?
// Count number remaining bits.
/* ACE_HAS_BIG_FD_SET */
// Synchronize the underlying FD_SET with the MAX_FD and the SIZE.
// These don't work because shifting right 3 bits is not the same as
// dividing by 3, e.g., dividing by 8 requires shifting right 3 bits.
// In order to do the shift, we need to calculate the number of bits
// at some point.
/* ACE_USE_SHIFT_FOR_EFFICIENCY */
/* !ACE_WIN32 */
// Resets the MAX_FD after a clear of the original MAX_FD.
// This obscure code is needed since "bit 0" is in location 1...
// Do some sanity checking...
/* !ACE_WIN32 */
/* ACE_HAS_DUMP */
// Return the handle and advance the iterator.
/* !ACE_WIN32 */
// No sense searching further than the max_handle_ + 1;
// HP-UX 11 plays some games with the fd_mask type - fd_mask is
// defined as an int_32t, but the fds_bits is an array of longs.
// This makes plainly indexing through the array by hand tricky,
// since the FD_* macros treat the array as int32_t.  So the bits
// are in the right place for int32_t, even though the array is
// long.  This, they say, is to preserve the same in-memory layout
// for 32-bit and 64-bit processes.  So, we play the same game as
// the FD_* macros to get the bits right.  On all other systems,
// this amounts to practically a NOP, since this is what would have
// been done anyway, without all this type jazz.
// We've seen all the handles we're interested in seeing for this
// iterator.
// Increment the iterator and advance to the next bit in this
// word.
// If we've examined all the bits in this word, we'll go onto
// the next word.
// Start the handle_index_ at the beginning of the next word
// and then loop until we've found the first non-zero bit or
// we run past the <maxhandlep1> of the bitset.
// If the bit index becomes >= the maxhandlep1 that means
// there weren't any more bits set that we want to consider.
// Therefore, we'll just store the maxhandlep1, which will
// cause <operator()> to return <ACE_INVALID_HANDLE>
// immediately next time it's called.
// Load the bits of the next word.
// Loop until we get <word_val_> to have its least significant
// bit enabled, keeping track of which <handle_index> this
// represents (this information is used by subsequent calls to
// <operator()>).
/* !ACE_HAS_BIG_FD_SET */
// Find the first word in fds_bits with bit on
// We have exceeded the word count in Handle_Set?
// Set index to word boundary.
// Put new word_val.
// Find the least significative bit.
// Remove least significative bit.
// Save to calculate bit distance.
// Move index to least significative bit.
// Find the least significative bit.
// Remove least significative bit.
// Move index to bit distance between new lsb and old lsb.
/* ACE_WIN32 */
/* ACE_HAS_BIG_FD_SET */
// No sense searching further than the max_handle_ + 1;
// Loop until we've found the first non-zero bit or we run past the
// <maxhandlep1> of the bitset.
// If the bit index becomes >= the maxhandlep1 that means there
// weren't any bits set.  Therefore, we'll just store the
// maxhandlep1, which will cause <operator()> to return
// <ACE_INVALID_HANDLE> immediately.
// Loop until we get <word_val_> to have its least significant bit
// enabled, keeping track of which <handle_index> this represents
// (this information is used by <operator()>).
/* !ACE_WIN32 && !ACE_HAS_BIG_FD_SET */
/* ACE_HAS_BIG_FD_SET */
// No sense searching further than the max_handle_ + 1;
// Loop until we've found the first non-zero bit or we run past the
// <maxhandlep1> of the bitset.
// If the bit index becomes >= the maxhandlep1 that means there
// weren't any bits set.  Therefore, we'll just store the
// maxhandlep1, which will cause <operator()> to return
// <ACE_INVALID_HANDLE> immediately.
// Loop until we get <word_val_> to have its least significant bit
// enabled, keeping track of which <handle_index> this represents
// (this information is used by <operator()>).
/* !ACE_WIN32 && !ACE_HAS_BIG_FD_SET */
/* __ACE_INLINE __ */
// In doing the check below, we take chance of paying a performance
// price when the hash value is zero.  But, that will (hopefully)
// happen far less often than a non-zero value, so this caching
// strategy should pay off, esp. if hash computation is expensive
// relative to the simple comparison.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Insert a entry which has the <key> and the <cache_value> which is
// the combination of the <value> and the attributes of the caching
// strategy.
// Unless the notification goes thru the bind operation is
// not complete.
// Make sure the unbind operation is done only when the
// notification fails after a bind which is denoted by
// rebind_result = 0
// Unless the notification goes thru the rebind operation is
// not complete.
// If the entry has got inserted into the map, it is removed
// due to failure.
// If an attempt is made to bind an existing entry the value
// is overwritten with the value from the map.
// Lookup the key and populate the <value>.
// Unless the find and notification operations go thru, this
// method is not successful.
// Remove the entry from the cache.
/* ACE_HASH_CACHE_MAP_MANAGER_T_CPP */
//=============================================================================
/**
//=============================================================================
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Initialize each entry in the hash table to be a circular linked
// list with the dummy node in the front serving as the anchor of
// the list.
// Calling this->close_i () to ensure we release previous allocated
// memory before allocating new one.
// This assertion is here to help track a situation that shouldn't
// happen, but did with Sun C++ 4.1 (before a change to this class
// was made: it used to have an enum that was supposed to be defined
// to be ACE_DEFAULT_MAP_SIZE, but instead was defined to be 0).
// Protect against "double-deletion" in case the destructor also
// gets called.
// Remove all the entries.
// Iterate through the buckets cleaning up the sentinels.
// Destroy the dummy entry.
// The second argument results in a no-op instead of
// deallocation.
// Reset size.
// Free table memory.
// Should be done last...
// Iterate through the entire map calling the destuctor of each
// <ACE_Hash_Map_Entry>.
// Explicitly call the destructor.
// Restore the sentinel.
// Not found.
// Not found.
// Explicitly call the destructor.
// ------------------------------------------------------------
// Handle initial case specially.
// ------------------------------------------------------------
// Handle initial case specially.
/* ACE_HASH_MAP_MANAGER_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HASH_MAP_WITH_ALLOCATOR_T_CPP */
//=============================================================================
/**
//=============================================================================
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Initialize each entry in the hash table to be a circular linked
// list with the dummy node in the front serving as the anchor of
// the list.
// Calling this->close_i () to ensure we release previous allocated
// memory before allocating new one.
// This assertion is here to help track a situation that shouldn't
// happen, but did with Sun C++ 4.1 (before a change to this class
// was made: it used to have an enum that was supposed to be defined
// to be ACE_DEFAULT_MAP_SIZE, but instead was defined to be 0).
// Protect against "double-deletion" in case the destructor also
// gets called.
// Remove all the entries.
// Iterate through the buckets cleaning up the sentinels.
// Destroy the dummy entry.
// The second argument results in a no-op instead of
// deallocation.
// Reset size.
// Free table memory.
// Should be done last...
// Iterate through the entire map calling the destuctor of each
// <ACE_Hash_Multi_Map_Entry>.
// Explicitly call the destructor.
// Restore the sentinel.
// Not found.
// Not found.
// Not found.
// Explicitly call the destructor.
// ------------------------------------------------------------
// Handle initial case specially.
// ------------------------------------------------------------
// Handle initial case specially.
/* ACE_Hash_Multi_Map_Manager_T_CPP */
// Be very carefull before changing the calculations inside
// ACE_High_Res_Timer.  The precision matters and we are using integer
// calculations not floating point.  Also look good at the emulated 64
// bit int class (inside Basic_Types{h,i,cpp} before changing
// anything.  It's operator/ only returns 32 bits not 64 bits, among
// other things.
/* __ACE_INLINE__ */
// For Intel platforms, a scale factor is required for
// ACE_OS::gethrtime.  We'll still set this to one to prevent division
// by zero errors.
/// Initialize the global_scale_factor_ to 1.  The first
/// ACE_High_Res_Timer instance construction will override this
/// value.
/* static */
/* ! (ACE_WIN32 || ACE_HAS_POWERPC_TIMER || \
// A scale_factor of 1000 converts nanosecond ticks to microseconds.
// That is, on these platforms, 1 tick == 1 nanosecond.
/* static */
/* ! (ACE_WIN32 || ACE_HAS_POWERPC_TIMER || \
/// This is used to tell if the global_scale_factor_ has been
/// set, and if high resolution timers are supported.
/* static */
// Determine the apparent CPU clock speed from /proc/cpuinfo
// Get the BogoMIPS from /proc/cpuinfo.  It works fine on Alpha and
// Pentium Pro.  For other CPUs, it will be necessary to interpret
// the BogoMips, as described in the BogoMips mini-HOWTO.  Note that
// this code assumes an order to the /proc/cpuinfo contents.  The
// BogoMips rating had better come after CPU type and model info.
/* __alpha__ */
// ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT ("\nReading /proc/cpuinfo...")));
// CPU type?
// If this is an Alpha chip, then the BogoMips rating is
// usable...
// Pentium CPU model?
// But if we don't have the right kind of Intel chip,
// just quit.
// If the line "cpu MHz : xxx" is present, then it's a
// reliable measure of the CPU speed - according to the
// kernel-source. It's possible to see a 0 value reported.
// ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT (" setting the clock scale factor to %u"), scale_factor));
/* 0 */
/* __alpha__ */
// ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT (" (done)\n")));
/* ACE_LINUX && !ACE_LACKS_SSCANF*/
// Check if the global scale factor needs to be set, and do if so.
// Grab ACE's static object lock.  This doesn't have anything to
// do with static objects; it's just a convenient lock to use.
// Double check
// This a higher-precision version, specific for Windows systems
// Succeeded in setting the global scale factor
// High-Res timers not supported
/* ACE_LACKS_SSCANF */
/* ! ACE_WIN32 && ! (ACE_LINUX && __alpha__) */
// Failed to retrieve CPU speed from system, so calculate it.
// We have set the global scale factor so set out status
// to 1, this way we only set the global_scale_factor_ once.
// Must be in the !ACE_WIN32 block to make sure that we
// not change a value of -1 (only done for ACE_WINC32) by accident
// to 1
// (ACE_WIN32)
/* (ACE_WIN32 || ACE_HAS_POWERPC_TIMER || \
// Make sure that the global scale factor is set.
// In units of 100 usec, to avoid overflow.
// Store the sample.
// Calculate the mean value of the samples, with no fractional
// precision.  Use it for the global scale factor.
// The addition of 5 below rounds instead of truncates.
/* usec/100 usec */;
/* ACE_HAS_DUMP */
// Note... Win32 does not have ACE_HAS_POSIX_TIME, so the scale factor
// does not need to take into account the different units on Win32.
// This implementation should be cleaned up.
// Just grab the nanoseconds.  That is, leave off all values above
// microsecond.  This equation is right!  Don't mess with me!  (It
// first strips off everything but the portion less than 1 usec.
// Then it converts that to nanoseconds by dividing by the scale
// factor to convert to usec, and multiplying by 1000.)  The cast
// avoids a MSVC 4.1 compiler warning about narrowing.
// Get just the microseconds (dropping any left over nanoseconds).
// Transforms one second in microseconds into nanoseconds.
/* ACE_HAS_POSIX_TIME */
// Please do _not_ rearrange this equation.  It is carefully
// designed and tested to avoid overflow on machines that don't have
// native 64-bit ints. In particular, division can be a problem.
// For more background on this, please see bugzilla #1024.
// Caution - Borland has a problem with >>=, so resist the temptation.
// Right shift is implemented for non native 64-bit ints
// operator/ only for a 32 bit result !
// This a higher-precision version, specific for Windows systems
// Same as above.
// Caution - Borland has a problem with >>=, so resist the temptation.
// This a higher-precision version, specific for Windows systems
// Get the total number of nanoseconds elapsed.
// Separate to seconds and nanoseconds.
// Get the total number of nanoseconds elapsed.
// Separate to seconds and nanoseconds.
/* ACE_HAS_ALLOC_HOOKS */
// Check if icmp protocol is supported on this host
// add back carry outs from top 16 bits to low 16 bits
// add hi 16 to low 16
// add carry
// truncate to 16 bits
/* ACE_HAS_ICMP_SUPPORT == 1 */
// Defines the Internet domain address family address format.
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// Transform the current address into string format.
// XXX Can we (should we) include the scope id for IPv6 addresses?
// ACE_OS::strlen ("65535"), Assuming the max port number.
// sizeof (':'), addr/port sep
// sizeof ('\0'), terminating NUL
/* !ACE_WIN32 && ACE_USES_WCHAR */
// ACE_OS::strlen ("[]") IPv6 addr frames
/* !ACE_WIN32 && ACE_USES_WCHAR */
// ACE_HAS_IPV6
/* ACE_HAS_DUMP */
// Compare two addresses for inequality.
// Compare two addresses for equality.
/* ACE_HAS_IPV6 */
/* ACE_HAS_IPV6 */
// ACE_TRACE ("ACE_INET_Addr::ACE_INET_Addr");
// Ugh, this is really a base class, so don't copy it.
// It's ok to make the copy.
// Transform the string into the current addressing format.
// Need to make a duplicate since we'll be overwriting the string.
// We use strrchr because of IPv6 addresses.
// Check for extended IPv6 format : '[' <ipv6 address> ']' ':' <port>
// find closing bracket
// check for port separator after closing bracket
// if not found leave it, error will come later
// blank out ']'
// skip over '['
// leads to error on missing port
/* ACE_HAS_IPV6 */
// Assume it's a port number.
// strtol scanned the entire string - all digits
// port name
// skip over ':'
// strtol scanned the entire string - all digits
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_WCHAR */
// Copy constructor.
// Initializes a ACE_INET_Addr from a PORT_NUMBER and a 32 bit Internet
// address.
// Initializes a ACE_INET_Addr from a PORT_NUMBER and the remote
// HOST_NAME.
// Yow, someone gave us a NULL host_name!
/* ACE_HAS_IPV6 && ACE_USES_IPV4_IPV6_MIGRATION */
/* ACE_HAS_IPV6 */
// The ai_flags used to contain AI_ADDRCONFIG as well but that prevented
// lookups from completing if there is no, or only a loopback, IPv6
// interface configured. See Bugzilla 4211 for more info.
// Without AI_ALL, Windows machines exhibit inconsistent behaviors on
// difference machines we have tested.
// Note - specify the socktype here to avoid getting multiple entries
// returned with the same address for different socket types or
// protocols. If this causes a problem for some reason (an address that's
// available for TCP but not UDP, or vice-versa) this will need to change
// back to unrestricted hints and weed out the duplicate addresses by
// searching this->inet_addrs_ which would slow things down.
// Helper function to get a port number from a port name.
// Maybe port_name is directly a port number?
// port_name was really a number, and nothing else.
// Check for overflow.
// Return the port number.  NOTE: this number must
// be returned in network byte order!
// We try to resolve port number from its name.
/* ACE_LACKS_GETSERVBYNAME */
// Initializes a ACE_INET_Addr from a <port_name> and the remote
// <host_name>.
/* ACE_HAS_IPV6 */
// Initializes a ACE_INET_Addr from a <port_name> and a 32 bit
// Internet address.
// Creates a ACE_INET_Addr from a PORT_NUMBER and the remote
// HOST_NAME.
/* ACE_HAS_WCHAR */
// Creates a ACE_INET_Addr from a sockaddr_in structure.
/* ACE_HAS_IPV6 */
// Return the address.
// Set a pointer to the address.
/* len */, int map)
/* ACE_HAS_IPV6 */
// ACE_HAS_IPV6
// Creates a ACE_INET_Addr from a sockaddr_in structure.
// Creates a ACE_INET_Addr from a PORT_NUMBER and an Internet address.
// Creates a ACE_INET_Addr from a PORT_NAME and the remote
// HOST_NAME.
/* ACE_HAS_WCHAR */
// Creates a ACE_INET_Addr from a PORT_NAME and an Internet address.
/* ACE_HAS_WCHAR */
// We know that hostname is nul-terminated
//result == -1;
// This could be worse than hostname[len -1] = '\0'?
// We have a build in limitation of MAXHOSTNAMELEN
// Call the char version
// And copy it over, if successful
/* ACE_HAS_WCHAR */
// Return the character representation of the hostname.
/* ACE_HAS_IPV6 */
/* ACE_HAS_IPV6 */
// returns -2 when the hostname is truncated
/* ACE_HAS_IPV6 */
/* = 1 */,
/* = 0 */)
// This is really intended for IPv4. If the object is IPv4, or the type
// hasn't been set but it's a 4-byte address, go ahead. If this is an
// IPv6 object and <encode> is requested, refuse.
// this->set_type (AF_INET);
// If given an IPv4 address to copy to an IPv6 object, map it to
// an IPv4-mapped IPv6 address.
// Build up a 128 bit address.  An IPv4-mapped IPv6 address
// is defined as 0:0:0:0:0:ffff:IPv4_address.  This is defined
// in RFC 1884 */
/* ACE_HAS_IPV6 */
/* end if (len == 4) */
// We protect ourselves up above so IPv6 must be possible here.
/* end len == 16 */
/* ACE_HAS_IPV6 */
// Here with an unrecognized length.
// check to see if the interface lookup succeeded
/* ACE_LINUX && ACE_HAS_IPV6 */
// mcorino@remedy.nl - Aug-26, 2005
// I don't think this should be done because it results in a decimal address
// representation which is not distinguishable from the IPv4 form which makes
// it impossible to resolve back to an IPv6 INET_Addr without prior knowledge
// that this was such an address to begin with.
//if (IN6_IS_ADDR_V4MAPPED (&this->inet_addr_.in6_.sin6_addr))
//{
//  ACE_UINT32 addr;
//  addr = this->get_ip_address();
//  addr = ACE_HTONL (addr);
//  return ACE_OS::inet_ntop (AF_INET, &addr, dst, size);
//}
// Don't want service name
/* ACE_WIN32 */
/* ACE_HAS_IPV6 */
// Return the dotted Internet address.
/* ACE_HAS_IPV6 */
/* !ACE_HAS_IPV6 */
// Return the 4-byte IP address, converting it into host byte order.
// Return the last 32 bits of the address
/* ACE_HAS_IPV6 */
// Don't use ACE_TRACE, because Object_Manager might not have been
// instantiated yet.
// ACE_TRACE ("ACE::init");
// Wait for remaining fini () calls.
// More ACE::fini () calls than ACE::init () calls.  Bad
// application!
/* __ACE_INLINE __ */
/* !ACE_INTRUSIVE_AUTO_PTR_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_INTRUSIVE_LIST_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_INTRUSIVE_LIST_NODE_CPP */
///////////////////////////////////////////////////////////////////////////
/* Here's a simple example of how iostream's non-virtual operators can
// OK
// invokes myiostream::operator>> (String&) returning myiostream&
// OK
// invokes iostream::operator>> (int&) returning iostream&
// BAD
// invokes iostream::operator>> (int&) then iostream::operator>> (String&)
//
// What has happened is that the first >> is invoked on the base class and returns
// a reference to iostream.  The second >> has no idea of the ACE_IOStream and
// gets invoked on iostream.  Probably NOT what you wanted!
// In order to make all of this work the way you want, you have to do this:
// OK
// invokes myiostream::operator>> (String&) returning myiostream&
// OK
// invokes myiostream::operator>> (int&) returning myiostream&
// OK
// Because you provided operator>> (int&) in class myiostream, that
// function will be invoked by the first >>.  Since it returns
// a myiostream&, the second >> will be invoked as desired.  */
// If input mode is not set, any attempt to read from the stream is
// a failure.
// If base () is empty then this is the first time any get/put
// operation has been attempted on the stream.
// Set base () to use our private read buffer.  The arguments are:
//        beginning of the buffer (base ())
//        one-beyond the end of the buffer (ebase ())
//        should base () be deleted on destruction
//
// We have to say "no" to the third parameter because we want to
// explicitly handle deletion of the TWO buffers at destruction.
// Remember that we are now in getMode.  This will help us if
// we're called prior to a mode change as well as helping us
// when the mode does change.
// Using the new values for base (), initialize the get area.
// This simply sets eback (), gptr () and egptr () described
// earlier.
// Set the put buffer such that puts will be disabled.  Any
// attempt to put data will now cause overflow to be invoked.
// base () has been initialized already...
// If we are in put_mode_ now, then it is time to switch to get_mode_
//
// 1. get rid of any pending output
// 2. rearrange base () to use our half of the buffer
// 3. reset the mode
//
// Dump any pending output to the peer.  This is not really
// necessary because of the dual-buffer arrangement we've
// set up but intuitively it makes sense to send the pending
// data before we request data since the peer will probably
// need what we're sending before it can respond.
// We're about to disable put mode but before we do
// that, we want to preserve it's state.
// Disable put mode as described in the constructor.
// Like the case where base () is false, we now point base
// () to use our private get buffer.
// And restore the previous state of the get pointers.
// Finally, set our mode so that we don't get back into this
// if () and so that overflow can operate correctly.
// There could be data in the input buffer if we switched to put
// mode before reading everything.  In that case, we take this
// opportunity to feed it back to the iostream.
// Remember that we return an int so that we can give back
// EOF.  The explicit cast prevents us from returning a signed
// char when we're not returning EOF.
// We really shouldn't be here unless there is a lack of data in the
// read buffer.  So... go get some more data from the peer.
// Fillbuf will give us EOF if there was an error with the peer.  In
// that case, we can do no more input.
// Disable ourselves and return failure to the iostream.  That
// should result in a call to have oursleves closed.
// Return the next available character in the input buffer.  Again,
// we protect against sign extension.
// Much of this is similar to underflow.  I'll just hit the highlights
// rather than repeating a lot of what you've already seen.
// Check to see if output is allowed at all.
// Set base () to use put's private buffer.
//
// Set the mode for optimization.
// Set the put area using the new base () values.
// Disable the get area.
// We're already reading or writing
// If we're coming out of get mode...
// --> JCEJ 6/6/98
/* Something has happened to cause the streambuf
// Save the current get mode values
// <-- JCEJ 6/6/98
// then disable the get buffer
// Reconfigure base () and restore the put pointers.
// Save the new mode.
// If there is output to be flushed, do so now.  We shouldn't
// get here unless this is the case...
// If we're not putting EOF, then we have to deal with the character
// that is being put.  Perhaps we should do something special with EOF???
// We've already written any data that may have been in the
// buffer, so we're guaranteed to have room in the buffer for
// this new information.  So... we add it to the buffer and
// adjust our 'next' pointer acordingly.
// syncin
// As discussed, there really isn't any way to sync input from a
// socket-like device.  We specifially override this base-class
// function so that it won't do anything evil to us.
// syncout
// Unlike syncin, syncout is a doable thing.  All we have to do is
// write whatever is in the output buffer to the peer.  flushbuf ()
// is how we do it.
// sync () is fairly traditional in that it syncs both input and
// output.  We could have omitted the call to syncin () but someday,
// we may want it to do something.
// Don't bother syncing the output unless there is data to be
// sent...
// flushbuf
// pptr () is one character beyond the last character put into the
// buffer.  pbase () points to the beginning of the put buffer.
// Unless pptr () is greater than pbase () there is nothing to be
// sent to the peer.
// 4/12/97 -- JCEJ
// Kludge!!!
// If the remote side shuts down the connection, an attempt to send
// () to the remote will result in the message 'Broken Pipe' I think
// this is an OS message, I've tracked it down to the ACE_OS::write
// () function.  That's the last one to be called before the
// message.  I can only test this on Linux though, so I don't know
// how other systems will react.
//
// To get around this gracefully, I do a PEEK recv () with an
// immediate (nearly) timeout.  recv () is much more graceful on
// it's failure.  If we get -1 from recv () not due to timeout then
// we know we're SOL.
//
// Q:  Is 'errno' threadsafe?  Should the section below be a
//     critical section?
//
// char tbuf[1];
// ACE_Time_Value to (0,1);
// if (this->recv (tbuf, 1, MSG_PEEK, &to) == -1)
// {
//    if (errno != ETIME)
//    {
//            perror ("OOPS preparing to send to peer");
//            return EOF;
//    }
// }
//
// The correct way to handle this is for the application to trap
// (and ignore?) SIGPIPE.  Thanks to Amos Shapira for reminding me
// of this.
// Starting at the beginning of the buffer, send as much data as
// there is waiting.  send guarantees that all of the data will be
// sent or an error will be returned.
// Now that we've sent everything in the output buffer, we reset the
// buffer pointers to appear empty.
// The recv function will return immediately if there is no data
// waiting.  So, we use recv_n to wait for exactly one byte to come
// from the peer.  Later, we can use recv to see if there is
// anything else in the buffer. (Ok, we could use flags to tell it
// to block but I like this better.)
// This will be called when the read (get) buffer has been exhausted
// (ie -- gptr == egptr).
// Invoke recv_n to get exactly one byte from the remote.  This will
// block until something shows up.
// Now, get whatever else may be in the buffer.  This will return if
// there is nothing in the buffer.
// recv will give us -1 if there was a problem.  If there was
// nothing waiting to be read, it will give us 0.  That isn't an
// error.
// Move the get pointer to reflect the number of bytes we just read.
// Return the byte-read-count including the one from <get_one_byte>.
// to avoid Purify UMR
// to avoid Purify UMR
// Return the number of bytes not yet gotten. eback + get_waiting =
// gptr.
// Return the number of bytes in the get area (includes some already
// gotten); eback + get_avail = egptr.
// Return the number of bytes to be 'put' onto the stream media.
// pbase + put_avail = pptr.
// Typical usage:
//
//      u_int  newGptr  = otherStream->get_waiting ();
//      u_int  newEgptr = otherStream->get_avail ();
//      char * newBuf   = otherStream->reset_get_buffer ();
//      char * oldgetbuf = myStream->reset_get_buffer (newBuf, otherStream->streambuf_size (), newGptr, newEgptr);
//
//      'myStream' now has the get buffer of 'otherStream' and can use it in any way.
//      'otherStream' now has a new, empty get buffer.
// The get area is where the iostream will get data from.  This is
// our read buffer.  There are three pointers which describe the
// read buffer:
//
//    eback () - The beginning of the buffer.  Also the furthest
//              point at which putbacks can be done.  Hence the name.
//
//    gptr ()  - Where the next character is to be got from.
//
//    egptr () - One position beyond the last get-able character.
//
// So that we can switch quicky from read to write mode without
// any data copying, we keep copies of these three pointers in
// the variables below.  Initially, they all point to the beginning
// of our read-dedicated buffer.
//
// Disable the get area initially.  This will cause underflow to be
// invoked on the first get operation.
// Typical usage:
//
//      u_int  newPptr = otherStream->put_avail ();
//      char * newBuf  = otherStream->reset_put_buffer ();
//      char * oldputbuf = otherStream->reset_put_buffer (newBuf, otherStream->streambuf_size (), newPptr);
// The put area is where the iostream will put data that needs to be
// sent to the peer.  This becomes our write buffer.  The three
// pointers which maintain this area are:
//
//    pbase () - The beginning of the put area.
//
//    pptr ()  - Where the next character is to be put.
//
//    epptr () - One beyond the last valid position for putting.
//
// Again to switch quickly between modes, we keep copies of
// these three pointers.
//
// Disable the put area.  Overflow will be called by the first call
// to any put operator.
// Until we experience the first get or put operation, we do not
// know what our current IO mode is.
// The common area used for reading and writting is called "base".
// We initialize it this way so that the first get/put operation
// will have to "allocate" base.  This allocation will set base to
// the appropriate specific buffer and set the mode to the correct
// value.
// If the default allocation strategey were used the common buffer
// would be deleted when the object destructs.  Since we are providing
// separate read/write buffers, it is up to us to manage their memory.
/* !ACE_LACKS_ACE_IOSTREAM */
/* ACE_IOSTREAM_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* !__ACE_INLINE__ */
// We will be given a STREAM by the iostream object which creates us.
// See the ACE_IOStream template for how that works.  Like other
// streambuf objects, we can be input-only, output-only or both.
// A streambuf allows for unbuffered IO where every character is
// read as requested and written as provided.  To me, this seems
// terribly inefficient for socket-type operations, so I've disabled
// it.  All of the work would be done by the underflow/overflow
// functions anyway and I haven't implemented anything there to
// support unbuffered IO.
/* ! ACE_LACKS_UNBUFFERED_STREAMBUF */
// Linebuffered is similar to unbuffered.  Again, I don't have any
// need for this and I don't see the advantage.  I believe this
// would have to be supported by underflow/overflow to be effective.
/* ! ACE_LACKS_LINEBUFFERED_STREAMBUF */
// The typical constructor.  This will initiailze your STREAM and then
// setup the iostream baseclass to use a custom streambuf based on
// STREAM.
// We have to get rid of the streambuf_ ourselves since we gave it to
// iostream ()
// The only ambituity in the multiple inheritance is the close ()
// function.
// A simple string operator.  The base iostream has 'em for char* but
// that isn't always the best thing for a String.  If we don't provide
// our own here, we may not get what we want.
/* ACE_WIN32 && defined (_MSC_VER) */
// A more clever put operator for strings that knows how to deal with
// quoted strings containing back-quoted quotes.
// eat space up to the first char
// stream.set (ios::eofbit|ios::failbit);
// Initialize the string
// if we don't have a quote, append until we see space
/* ACE_HAS_STRING_CLASS */
/* ACE_LACKS_ACE_IOSTREAM */
/* ACE_IOSTREAM_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// This is the do-nothing constructor.  It does not perform a
// ACE_OS::open system call.
/* ACE_HAS_DUMP */
/* F_SETOWN */
/* SIGURG */
/* F_SETOWN && FASYNC */
// <==
/* SIGIO <== */
/* F_SETOWN */
/* SIGURG */
/* F_SETOWN && FASYNC */
// <==
/* SIGIO <== */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// This is the do-nothing constructor.  It does not perform a
// ACE_OS::socket system call.
// ACE_TRACE ("ACE_IPC_SAP::ACE_IPC_SAP");
// nonblocking argument (1)
// blocking:            (0)
/* ! ACE_WIN32 && ! ACE_VXWORKS */
/* F_SETOWN */
/* SIGURG */
/* F_SETOWN && FASYNC */
/* SIGIO <== */
// Enables the close-on-exec flag.
/* F_SETFD */
/* ! ACE_WIN32 && ! ACE_VXWORKS */
/* NOTREACHED */
// nonblocking argument (1)
// blocking:            (0)
/* ! ACE_WIN32 && ! ACE_VXWORKS */
/* F_SETOWN */
/* SIGURG */
/* F_SETOWN && FASYNC */
/* SIGIO <== */
// Disables the close-on-exec flag.
/* F_SETFD */
/* ! ACE_WIN32 && ! ACE_VXWORKS */
/* NOTREACHED */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_WIN32 */
/**/ "descrip.h"
/**/ "chfdef.h"
/**/ "stsdef.h"
/**/ "libdef.h"
/**
/// Declare a process wide singleton
/* ACE_OPENVMS */
/* ACE_WIN32 && !ACE_HAS_WINCE && !ACE_HAS_PHARLAP */
/* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */
// Create a copy of filename to work with.
// Insert canonical directory separators.
// Make all the directory separators "canonical" to simplify
// subsequent code.
/* ACE_DIRECTORY_SEPARATOR_CHAR */
// Separate filename from pathname.
// This is a relative path.
// This is an absolute path.
// Check to see if this has an appropriate DLL suffix for the OS
// platform.
// If we have a dot, we have a suffix
// Check whether this matches the appropriate platform-specific
// suffix.
// Use <ACE_OS::strcasecmp> on any platform with
// case-insensitive filenames.
/* ACE_WIN32 */
// Make sure we've got enough space in searchfilename.
/* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */
// Use absolute pathname if there is one.
// Revert to native path name separators.
/* ACE_DIRECTORY_SEPARATOR_CHAR */
// First, try matching the filename *without* adding a
// prefix.
// Second, try matching the filename *with* adding a prefix.
// Use relative filenames via LD_LIBRARY_PATH or PATH (depending on
// OS platform).
// In case not found we should try again with the ACE_DLL_PREFIX
// prefixed
// Wide-char, non-Windows only offers char * getenv. So capture
// it, translate to wide-char, and continue.
/* ACE_WIN32 || !ACE_USES_WCHAR */
/* ACE_DEFAULT_LD_SEARCH_PATH */
/* ACE_HAS_WINCE */
// strtok has the strange behavior of not separating the
// string ":/foo:/bar" into THREE tokens.  One would expect
// that the first iteration the token would be an empty
// string, the second iteration would be "/foo", and the
// third iteration would be "/bar".  However, this is not
// the case; one only gets two iterations: "/foo" followed
// by "/bar".
// This is especially a problem in parsing Unix paths
// because it is permissible to specify 'the current
// directory' as an empty entry.  So, we introduce the
// following special code to cope with this:
// Look at each dynamic lib directory in the search path.
// Check if at end of search path.
// This works around the issue where a path might have
// an empty component indicating 'current directory'.
// We need to do it here rather than anywhere else so
// that the loop condition will still work.
// First, try matching the filename *without* adding a
// prefix.
// Second, try matching the filename *with* adding a
// prefix.
// Fetch the next item in the path
/* ACE_HAS_WINCE */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */
/* ACE_WIN32 && !ACE_HAS_WINCE */
/* ACE_LD_DECORATOR_STR && !ACE_DISABLE_DEBUG_DLL_CHECK */
// leading '_'
/* ACE_NEEDS_DL_UNDERSCORE */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_NEEDS_DL_UNDERSCORE */
// if not found through dlsym() try registry
// Make sure to return -1 if there is an error
/* ACE_WIN32 */
// NOTE! Non-Windows platforms don't deal with wide chars for env.
// variables, so do this narrow-char and convert to wide for the
// caller if necessary.
// On non-win32 platforms, check to see what the TMPDIR environment
// variable is defined to be.  If it doesn't exist, just use /tmp
// Check to see if the buffer is large enough for the string,
// another /, and its null character (hence the + 2)
// Add a trailing slash because we cannot assume there is already one
// at the end.  And having an extra one should not cause problems.
/* ACE_WIN32 */
// Open it.
/* ACE_WIN32 */
// Unlink it so that the file will be removed automatically when the
// process goes away.
// Return the handle.
// Split a string up into 'token'-delimited pieces, ala Perl's
// "split".
// Return the beginning of the string.
// Insure it's terminated.
// Return the beginning of the string.
// Insure it's terminated.
/* ACE_HAS_WCHAR */
// Local_Memory_Pool.cpp
/* ACE_HAS_DUMP */
// Free up all memory allocated by this pool.
// Ask system for initial chunk of local memory.
// Note that we assume that when ACE_Local_Memory_Pool is used,
// ACE_Malloc's constructor will only get called once.  If this
// assumption doesn't hold, we are in deep trouble!
/* ACE_HAS_ALLOC_HOOKS */
// Zap the memory we allocated.
/* ACE_HAS_ALLOC_HOOKS */
// Continue propagate the structural exception up.
/* ACE_WIN32 */
// Not much can be done.
// Let the underlying new operator figure out the alignment...
/* ACE_HAS_ALLOC_HOOKS */
// If they're larger than we are they can't be a substring of us!
// Check if we're equal.
// They're smaller than we are...
// Found a match!  Return the index.
/* ACE_LACKS_PRAGMA_ONCE */
// The following requires Memory Pool to have ::remap()
// defined. Thus currently this will only work for
// ACE_MMap_Memory_Pool.
// Kick it upstairs...
// This is 80x86-specific.
/* __X86__ */
// Resume execution at the original point of "failure."
/* ACE_WIN32 */
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that the value_rep *must* come first to make sure we can
// retrieve this pointer later on in unbind().
// Do a normal bind.  This will fail if there's already an
// <new_internal> with the same name.
// Entry already existed so bind failed. Free our
// dynamically allocated memory.
// Do a rebind.  If there's already any entry, this will
// return the existing <new_name> and <new_internal> and
// overwrite the existing name binding.
// Free up the memory we allocated in shared_bind().
// Note that this assumes that the "value" pointer comes
// first and that the value, name, and type are
// contiguously allocated (see above for details)
// Free our dynamically allocated memory.
// If bind() or rebind() succeed, they will automatically sync
// up the map manager entry.  However, we must sync up our
// name/value memory.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Free up the memory we allocated in shared_bind().  Note that this
// assumes that the "value" pointer comes first and that the value,
// name and type are contiguously allocated (see shared_bind() for
// details)
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note the classy variable name! :)
// Calls conversion operator and then calls the ACE_NS_WString
// assignment operator to get a fresh copy.  (*#*(@#&!*@!!*@&( HP
// compiler causes us to add an extra copy explicitly !! :)
// Gets type and then the actual reprsentation which is a
// ACE_WCHAR_T
// Makes a copy here. Caller needs to call delete to free up
// memory.
/* ACE_HAS_ALLOC_HOOKS */
// Remove the map.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Get directory name
// Use process name as the file name.
// Create the allocator with the appropriate options.
// Now check if the backing store has been created successfully
/* ACE_LACKS_ACCESS */
// This is the easy case since if we find the Name Server Map
// Manager we know it's already initialized.
// This is the hard part since we have to avoid potential race
// conditions...  We will use the double check here
// This is the easy case since if we find the Name Server Map
// Manager we know it's already initialized.
// Initialize the map into its memory location (e.g., shared memory).
// Note that char_rep() allocates memory so we need to delete it
// Check for wildcard case first.
// Compile the regular expression (the 0's cause ACE_OS::compile
// to allocate space).
// If we don't have regular expressions just use the pattern
// directly.
/* ACE_HAS_REGEX */
// Get the type
// Everything matches the wildcard.
// If we don't have regular expressions just use strstr() for
// substring matching.
/* ACE_HAS_REGEX */
/* ACE_HAS_REGEX */
// delete pattern_rep;
/* ACE_HAS_ALLOC_HOOKS */
// Note that char_rep() allocates memory so we need to delete it
// Check for wildcard case first.
// Compile the regular expression (the 0's cause ACE_OS::compile
// to allocate space).
/* If we don't have regular expressions just the pattern
/* ACE_HAS_REGEX */
// Get the type.
// Everything matches
// the wildcard.
/* If we don't have regular expressions just use strstr() for
/* ACE_HAS_REGEX */
/* ACE_HAS_REGEX */
// delete pattern_rep;
/* ACE_HAS_ALLOC_HOOKS */
/* ! ACE_NLOGGING */
// We need to delete key and value since char_rep allocates
// memory for them
/* ACE_HAS_ALLOC_HOOKS */
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// Note that we *must* use structured exception handling here
// because (1) we may need to commit virtual memory pages and (2)
// C++ exception handling doesn't support resumption.
// This should really be a const cast
/* ACE_HAS_DUMP */
/* ACE_LOCAL_NAME_SPACE_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_LACKS_INLINE_FUNCTIONS */
/* ACE_HAS_DUMP */
// This const typecast is safe.
// Just make sure we have enough space.
// The cast is an attempt to get this to compile (and run,
// hopefully) regardless of the type of ACE_thread_t.
/* ACE_HAS_DUMP */
// Not sure this is the right thing to do, but it seems to work.
// The base class ALSO has a proxy_ and client_id_ members (weird?)
// which don't get initialised.  The following two lines make this
// the same as the subclass, so that the slicing works .
/* !ACE_NO_TSS_TOKENS */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// make tpq the entire list
// make head of list
// stick at back of list
// walk through list to insertion point
// end of queue?
// advance pointer
// insert new tpq after temp
/*
// We found it!
// We didn't find it :-(
// sanity
// is it the head?
// pointer comparison.
// is it in the middle or tail?
// previous should never be null since the first if
// conditional should always be false
// is it the tail?
// it wasn't in the list.
/* ACE_HAS_DUMP */
// We need to acquire two locks. This one to ensure that only one
// thread uses this token at a time.
// This one to ensure an atomic transaction across all tokens.  Note
// that this order is crucial too.  It's resource coloring for other
// threads which may be calling this same token.
// Does _anyone_ own the token?
// there are no waiters, so queue as the first waiter (the owner.)
// success
// Does the caller already own it?
// Recursive acquisition.
// success
// Check for deadlock.
// Someone owns it. Sorry, you're getting queued up at the end of
// the waiter queue.
// We need to acquire two locks. This one to ensure that only one
// thread uses this token at a time.
// This one to ensure an atomic transaction across all tokens.  Note
// that this order is crucial too.  It's resource coloring for other
// threads which may be calling this same token.
// Does _anyone_ own the token?
// success
// Does the caller already own it?
// recursive acquisition
// success
// Someone owns it.  Fail.
// Verify that the caller is the owner.
// The caller is the owner, so check to see if there are any
// waiters.  If not, we just keep the token.  == 1 means that there
// is only the owner.
// Requeue the caller.
// Notify new owner.
// Tell the caller that the operation would block.
// Release the current holder of the token (which had
// better be the caller's thread!).
// Does anyone own the token?
// Is the caller the owner.
// Check the nesting level.
// Notify new owner.
// If an <id> is specified, return whether it is the owner being
// returned.
// If there is no owner, or <id> is the owner, return false.
// Step through each waiter looking for <id>.
// If there is an owner, return whether it is <id>.
// ************************************************************
/* ACE_HAS_DUMP */
// We need to acquire two locks. This one to ensure that only one
// thread uses this token at a time.
// This one to ensure an atomic transaction across all tokens.  Note
// that this order is crucial too.  It's resource coloring for other
// threads which may be calling this same token.
// Does _anyone_ own the token?
// There are no waiters, so queue as the first waiter (the owner).
// Check for recursive acquisition.
// Success.
// Reader.
// Are there any writers?
// Queue the caller at the end of the queue.
// Else failure.
// Failure code.
// Check for deadlock.
// Queue the caller at the end of the queue.
// If it's a writer, just notify it.
// Call back all reader owners.
// We need to acquire two locks. This one to ensure that only one
// thread uses this token at a time.
// This one to ensure an atomic transaction across all tokens.  Note
// that this order is crucial too.  It's resource coloring for other
// threads which may be calling this same token.
// Does _anyone_ own the token?
// There are no waiters, so queue as the first waiter (the owner).
// Check for recursive acquisition.
// Success.
// Reader.
// Are there any writers?
// queue the caller at the end of the queue.
// Else, fail.
// Writer.
// We're going to fail, so decrement the num_writers.
// Werify that the caller is the owner
// The caller is the owner, so check to see if there are any
// waiters.  If not, we just keep the token.
// There are waiters, so remove the caller.
// Requeue the caller.
// If the caller got queued before any writers, the caller is
// still the owner.
// success
// else fallthrough and return would block.
// Writers will always have to block since waiters_.size () == 1 or
// requeue_position == 0.
// Get a new owner.
// Tell the caller that the operation would block.
// Check for errors.
// Recursive release.
// Remove the caller and notify the new owner(s).
// the owners already know that they're owners
// The current owner is a reader and the previous owner was a
// writer, so notify all waiting readers up to the first writer.
// call back all reader owners.
// We've gone through all the readers.
// writer
// The first waiter is a writer, so there is only one owner.
// If an <id> is specified, return whether it is the owner being
// returned.
// The first waiter is a reader, so there can be multiple owning
// readers.
// We've gone through all the readers.
// If there is no owner, or <id> is the owner, return false.
// Step through each waiter looking for <id>.
// If there is no owner, return false.
// A writer owns us.
// Readers own us.
// Step through each owning reader looking for <id>.
/* ACE_HAS_DUMP */
// Thread-specific.
/* Use of 'this' in initializer list */
// Notice the token_ (0).  Do *not* copy the token pointer.  This must
// be obtained through the token manager.  Also, we don't copy any
// waiter info.  A copied Proxy does *not* inherit client_id.
// @@ should I do a mutex_->release ()?
// notify token manager that we are done with it so it can
// free it if necessary
// Store some parameters.
// Used in case a name was not specified.
// We must have a name.
// Get or create the underlying token.  The Token Manager will call
// us back to set token_.
// Check for failed get or failed new.
// Make sure no one calls our token_acquired until we have a chance
// to sleep first!  If after we call an EWOULDBLOCK
// mutex_->acquire() below, but before we enter handle_options to
// wait on the cond_var, a thread tries to give take us off the
// waiter queue and signal us, IT WILL FIRST HAVE TO ACQUIRE THIS
// cond_var.mutex ().  _This_ is why we acquire it.
// acquire failed
// Else, fallthrough and block!
// no error, but would block, if error, return error (-1),
// otherwise, return whether we called the holder or not.
// we have the token
// Make sure no one calls our token_acquired until we have a chance
// to sleep first!
// check for error
// no error, but would block, so block or return
// we have the token
// Some operation failed with EWOULDBLOCK.
// Asynchronous.
// Save/restore errno.
// Synchronous.
// Block on condition variable.
// Note, this should obey whatever thread-specific
// interrupt policy is currently in place...
// We come here if a timeout occurs or some serious
// ACE_Condition object error.
// operation succeeded
// Release failed.
// Somebody wants our token!  (Let'em wait...)
// We've been taken off the waiters list and given the token!
// This implementation signals the internal condition
// variable. Thus, if asynchronous acquires are used, this must be
// overriden to do something more useful!
/* ACE_HAS_DUMP */
// ************************************************************
// ************************************************************
// ************************************************************
/* ACE_HAS_TOKENS_LIBRARY */
/* __ACE_INLINE__ */
//  return this->lock_->dump ();
/* ACE_HAS_DUMP */
// for ACE_NEW
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Explicitly destroy the lock.
// Block the thread until the lock is acquired.
// Conditionally acquire the lock (i.e., won't block).
// Release the lock.
// Block until the thread acquires a read lock.  If the locking
// mechanism doesn't support read locks then this just calls
// <acquire>.
// Block until the thread acquires a write lock.  If the locking
// mechanism doesn't support read locks then this just calls
// <acquire>.
// Conditionally acquire a read lock.  If the locking mechanism
// doesn't support read locks then this just calls <acquire>.
// Conditionally acquire a write lock.  If the locking mechanism
// doesn't support write locks then this just calls <acquire>.
// Conditionally try to upgrade a lock held for read to a write lock.
// If the locking mechanism doesn't support read locks then this just
// calls <acquire>. Returns 0 on success, -1 on failure.
/* ACE_LOCK_ADAPTER_T_CPP */
/* ACE_LOCK_SOCK_ACCEPTOR_CPP */
// FUZZ: disable check_for_streams_include
// Parse the string containing (thread) priorities and set them
// accordingly.
// Choose priority mask to change.
// Parse string and alternate priority mask.
// Affect right priority mask.
// Parse the string containing all the flags and set the flags
// accordingly.
// Perform data member initializations.  BTW, do *not* initialize
// <thread_priority_mask_> or <process_priority_mask_> here to avoid
// unduing the behavior in <init>, where these are set by
// <ACE_Log_Msg::instance>.
// Now tokenize the string to get all the flags
// If LOGGER was specified, set up the default logger key.
// The key can be changed by the -k option also, so if it's
// been set already, don't set it.
// Interval (in secs) at which logfile size is sampled.
// Ensure that the LOGGER flag is set
/* ACE_HAS_ALLOC_HOOKS */
// Maximum logfile size (in KB).  Must be a non-zero value.
// convert from KB to bytes.
/* ACE_HAS_ALLOC_HOOKS */
// The max number for the log_file being created
// Log_files generation order
// Now tokenize the string to setup process log priority
// Ensure that the OSTREAM flag is set
/* ACE_HAS_ALLOC_HOOKS */
// Now tokenize the string to setup thread log priority
// Cause the logfile to be wiped out, both on startup and on
// reconfigure.
// 2 files by default (max file number + 1)
/* ACE_DEFAULT_LOGFILE */
/* ACE_HAS_ALLOC_HOOKS */
// Get the temporary directory
// 7 for "logfile"
// Add the filename to the end
/* ACE_DEFAULT_LOGFILE */
// This is allocated in constructor, so it must be deallocated in
// the destructor!
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Avoid double deletions.
/* ACE_HAS_ALLOC_HOOKS */
// Store current priority masks for changes in <parse_args>.
// Use the options hook to parse the command line arguments.
// Setup priorities (to original if not specified on command line)
// Check if any flags were specified. If none were specified, let
// the default behavior take effect.
// Clear all flags
// Check if OSTREAM bit is set
// close and re-open a stream if such exits
// open a stream only if such doesn't exists
// Create a new ofstream to direct output to the file.
/* ACE_LACKS_IOSTREAM_TOTALLY */
// Set the <output_file> that'll be used by the rest of the
// code.
// Setup a timeout handler to perform the maximum file size
// check (if required).
// Use singleton.
// Now set the flags for Log_Msg
/* ACE_LACKS_IOSTREAM_TOTALLY */
// Lock out any other logging.
// Close the current ostream.
// We'll call msg_ostream() modifier later.
/* ACE_LACKS_IOSTREAM_TOTALLY */
// Save current logfile to logfile.old analyze if it was set any
// fixed number for the log_files.
//we only want one file
// Just unlink the file.
// Open a new log file with the same name.
/* ACE_LACKS_IOSTREAM_TOTALLY */
// Release the lock previously acquired.
// Set the number of digits of the log_files labels.
// analyse if it was chosen the mode which will order the
// log_files
// reorder the logs starting at the oldest (the biggest
// number) watch if we reached max_file_number_.
// count_ will always be bigger than max_file_number_,
// so do nothing so to always reorder files from
// max_file_number_.
// Remove any existing old file; ignore error as
// file may not exist.
// Rename the current log file to the name of the
// backup log file.
// start over from 1
// Remove any existing old file; ignore error as file may
// not exist.
// Rename the current log file to the name of the backup log
// file.
// Open a new log file by the same name
/* ACE_LACKS_IOSTREAM_TOTALLY */
// Release the lock previously acquired.
// This will reset reactor member and cancel timer events.
// The following is a "Factory" used by the ACE_Service_Config and
// svc.conf file to dynamically initialize the state of the
// Logging_Strategy.
// _get_dll_unload_policy() prevents ACE from being unloaded and having its
// framework components run down if/when the Logging Strategy is unloaded.
/* __ACE_INLINE__ */
// defined (ACE_HAS_THREADS)
/// Default per-process priority mask
/// By default, all priorities are enabled.
// This should not happen!
// Ensure that we are serialized!
// make sure we only create the key once!
// for atomic integers, post increment is more efficient
// Major problems, this should *never* happen!
// This should not happen!
// defined (ACE_HAS_THREADS)
// defined (ACE_HAS_THREADS)
// We need this to get the status of ACE_NTRACE...
// Turn off tracing for the duration of this file.
/* ACE_NTRACE */
/* ! ACE_MT_SAFE */
// FUZZ: disable check_for_streams_include
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
/* ACE_HAS_TRACE */
/* __ACE_INLINE__ */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
/* ACE_MT_SAFE */
/* ! ACE_WIN32 */
// When doing ACE_OS::s[n]printf() calls in log(), we need to update
// the space remaining in the output buffer based on what's returned from
// the output function. If we could rely on more modern compilers, this
// would be in an unnamed namespace, but it's a macro instead.
// count is a size_t, len is an int and assumed to be non-negative.
/// Instance count for Log_Msg - used to know when dynamically
/// allocated storage (program name and host name) can be safely
/// deleted.
/**
//FUZZ: disable check_for_lack_ACE_OS
//FUZZ: enable check_for_lack_ACE_OS
/* ! ACE_MT_SAFE */
// If flags have been supplied, and they are different from the flags
// we had last time, then we may have to re-create the backend as a
// different type.
// Sanity check for custom backend.
// Allocate the ACE_Log_Msg_Backend instance.
/* defined (WIN32) && !defined (ACE_HAS_WINCE) && !defined (ACE_HAS_PHARLAP) */
// This function is called by the first thread to create an ACE_Log_Msg
// instance.  It makes the call while holding a mutex, so we don't have
// to grab another one here.
// Delete the (main thread's) Log_Msg instance.  I think that this
// is only "necessary" if exception handling is not enabled.
// Without exception handling, main thread TSS destructors don't
// seem to be called.  It's not really necessary anyways, because
// this one leak is harmless on Solaris.
/* ACE_HAS_STHREADS && ! TSS_EMULATION && ! ACE_HAS_EXCEPTIONS */
// Ugly, ugly, but don't know a better way.
// we are never responsible for custom backend
/* static */
/* ACE_HAS_THR_C_DEST */
// Delegate to thr_desc if this not has terminated
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
/* ! ACE_MT_SAFE */
/* static */
// The actual type is ACE_Log_Msg*, but we need this
// void to keep G++ from complaining.
// Get the tss_log_msg from thread-specific storage.
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
/* ! ACE_MT_SAFE */
/* ! ACE_MT_SAFE */
// TSS Singleton implementation.
//This function is called before ACE_OS_Object_Manager is
//initialized.  So the lock might not be valid.  Assume it's
//single threaded and so don't need the lock.
// Allocate the Singleton lock.
//This function is called before ACE_OS_Object_Manager is
//initialized.  So the lock might not be valid.  Assume it's
//single threaded and so don't need the lock.
// Major problems, this should *never* happen!
//This function is called before ACE_OS_Object_Manager is
//initialized.  So the lock might not be valid.  Assume it's
//single threaded and so don't need the lock.
// Get the tss_log_msg from thread-specific storage.
// This should not happen!
// Check to see if this is the first time in for this thread.
// Allocate memory off the heap and store it in a pointer in
// thread-specific storage (on the stack...).  Stop heap
// checking, the memory will always be freed by the thread
// rundown because of the TSS callback set up when the key was
// created. This prevents from getting these blocks reported as
// memory leaks.
// Store the dynamically allocated pointer in thread-specific
// storage.  It gets deleted via the ACE_TSS_cleanup function
// when the thread terminates.
// Major problems, this should *never* happen!
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
/* ! ACE_MT_SAFE */
// We don't have threads, we cannot call
// ACE_Log_Msg_Manager::get_lock () to initialize the logger
// callback, so instead we do it here.
// Singleton implementation.
// Register the instance for destruction at program termination.
/* ! ACE_MT_SAFE */
// Not inlined to help prevent having to include OS.h just to
// get ACELIB_DEBUG, et al, macros.
// Sets the flag in the default priority mask used to initialize
// ACE_Log_Msg instances, as well as the current per-thread instance.
// Clears the flag in the default priority mask used to initialize
// ACE_Log_Msg instances, as well as the current per-thread instance.
/// Name of the local host.
/// Records the program name.
/// Default is to use stderr.
/// Current offset of msg_[].
/// Default per-thread priority mask
/// By default, no priorities are enabled.
/// Default per-process priority mask
/// By default, all priorities are enabled.
// This call needs to go here to avoid memory leaks.
// Please note that this will be called by a statement that is
// harded coded into the ACE_Object_Manager's shutdown sequence, in
// its destructor.
// Clean up this ACE_Log_Msg instance and reset the TSS to
// prevent any future cleanup attempts via TSS mechanisms at
// thread exit. Otherwise in the event of a dynamic library
// unload of libACE, by a program not linked with libACE,
// ACE_TSS_cleanup will be invoked after libACE has been unloaded.
// See Bugzilla 2980 for lots of details.
// Get the tss_log_msg from thread-specific storage.
// we haven't been cleaned up
// The key is not needed any longer; ACE_Log_Msg is closing
// and will need to be reopened if this process wishes to use
// logging again. So delete the key.
/* (ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION) && ACE_MT_SAFE */
// Call after a fork to resynchronize the PID and PROGRAM_NAME
// variables.
// Must free if already allocated!!!
/* ACE_HAS_ALLOC_HOOKS */
// Stop heap checking, block will be freed by the destructor when
// the last ACE_Log_Msg instance is deleted.
// Heap checking state will be restored when the block is left.
/* ! ACE_MT_SAFE */
/* ! ACE_MT_SAFE */
/* ! ACE_MT_SAFE */
/* ! ACE_MT_SAFE */
// Restart by default...
// On by default?
// ACE_TRACE ("ACE_Log_Msg::ACE_Log_Msg");
// If variable is set or is set to date tag so we print date and time.
/* ACE_HAS_ALLOC_HOOKS */
// Only hold the guard while updating the instance_count_.
// If ACE_Log_Msg_Manager::close () is called, the lock will
// be deleted.
// Release the guard.
/* ! ACE_MT_SAFE */
/* ! ACE_MT_SAFE */
// If this is the last instance then cleanup.  Only the last
// thread to destroy its ACE_Log_Msg instance should execute
// this block.
// Destroy the message queue instance.
// Close down custom backend
/* ACE_HAS_TSS_EMULATION */
/* ACE_MT_SAFE */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Open the sender-side of the message queue.
/* ACE_HAS_ALLOC_HOOKS */
// Stop heap checking, block will be freed by the destructor.
// Stop heap checking, block will be freed by the destructor.
// Be sure that there is a message_queue_, with multiple threads.
// Always close the current handle before doing anything else.
// Note that if we fail to open the message queue the default action
// is to use stderr (set via static initialization in the
// Log_Msg.cpp file).
// The SYSLOG backends (both NT and UNIX) can get along fine
// without the logger_key - they will default to prog_name if
// logger key is 0.
// If we are closing down logger, redirect logging to stderr.
// Remember, ACE_Log_Msg::STDERR bit is on by default...
// VERBOSE takes precedence over VERBOSE_LITE...
// Only set this to cerr if it hasn't already been set.
/**
// Start of variable args section.
/**
// Start of variable args section.
/* ACE_HAS_WCHAR */
/* ACE_LACKS_VA_FUNCTIONS */
// External decls.
// Check if there were any conditional values set.
// Reset conditional values.
// Only print the message if <priority_mask_> hasn't been reset to
// exclude this logging priority.
// If conditional values were set and the log priority is correct,
// then the values are actually set.
// Logging is supposed to be a benign activity (i.e., not interfer
// with normal application operations), so don't inadvertently smash
// errno!
// bp is pointer to where to put next part of logged message.
// bspace is the number of characters remaining in msg_.
// Leave room for Nul term.
// If this platform has snprintf() capability to prevent overrunning the
// output buffer, use it. To avoid adding a maintenance-hassle compile-
// time couple between here and OS.cpp, don't try to figure this out at
// compile time. Instead, do a quick check now; if we get a -1 return,
// the platform doesn't support the length-limiting capability.
// Retrieve the flags in a local variable on the stack, it is
// accessed by multiple threads and within this operation we
// check it several times, so this way we only lock once
// Prepend the program name onto this message
// Print just the time
// Print time and date
// Copy input to output until we encounter a %, however a
// % followed by another % is not a format specification.
// An "escaped" '%' (just print one '%').
// Store first %
// but skip second %
// This is most likely a format specification that ends with
// one of the valid options described previously. To enable full
// use of all sprintf capabilities, save the format specifier
// from the '%' up to the format letter in a new char array.
// This allows the full sprintf capability for padding, field
// widths, alignment, etc.  Any width/precision requiring a
// caller-supplied argument is extracted and placed as text
// into the format array. Lastly, we convert the caller-supplied
// format specifier from the ACE_Log_Msg-supported list to the
// equivalent sprintf specifier, and run the new format spec
// through sprintf, adding it to the bp string.
// Converted format string
// Set this string to known values.
// Current format pointer
// Width/precision extracted from args
// How many chars s[n]printf wrote
// always narrow chars
// Copy in the %
// Initialization to satisfy VC6
// Work through the format string to copy in the format
// from the caller. While it's going across, extract ints
// for '*' width/precision values from the argument list.
// When the real format specifier is located, change it to
// one recognized by sprintf, if needed, and do the sprintf
// call.
// Unless a conversion spec changes it
// The initial set of cases are the conversion
// specifiers. Copy them in to the format array.
// Note we don't use 'l', a normal conversion spec,
// as a conversion because it is a ACE_Log_Msg format
// specifier.
// ACE_timer_t
// Abort program after handling all of format string.
// Source file line number
// Source file name
// Program name
/* ACE_WIN32 && ACE_USES_WCHAR */
// Process ID
// Print the process id in hex on OpenVMS.
// <errno> string, ala perror()
// Windows can try to translate the errnum using
// system calls if strerror() doesn't get anything useful.
// PharLap can't do FormatMessage, so try for socket
// error.
// Default language
/* ACE_HAS_PHARLAP */
// If we don't get a valid response from
// <FormatMessage>, we'll assume this is a
// WinSock error and so we'll try to convert
// it into a string.  If this doesn't work it
// returns "unknown error" which is fine for
// our purposes.
// Free the buffer.
/* ACE_WIN32 */
// Print the name of the priority of the message.
// Look at the format precision specifier. .1 is interpreted
// as a single character printout, otherwise we print the name of
// the priority.
// So, did we find a .1 specifier? Do we need to override it?
// Yup.
// Print a single character signifying the severity of the message
// Windows uses 'c' for a wide character
// Other platforms behave differently
// HP-Unix compatible
// Other
/* HPUX */
/* ACE_USES_WCHAR */
// Non-unicode builds simply use a standard character format specifier
/* ACE_USES_WCHAR */
// Below is an optimized (binary search based)
// version of the following simple piece of code:
//
// log_priority == LM_SHUTDOWN  ? 'S' :   // Shutdown
// log_priority == LM_TRACE     ? 'T' :   // Trace
// log_priority == LM_DEBUG     ? 'D' :   // Debug
// log_priority == LM_INFO      ? 'I' :   // Info
// log_priority == LM_NOTICE    ? 'N' :   // Notice
// log_priority == LM_WARNING   ? 'W' :   // Warning
// log_priority == LM_STARTUP   ? 'U' :   // Startup
// log_priority == LM_ERROR     ? 'E' :   // Error
// log_priority == LM_CRITICAL  ? 'C' :   // Critical
// log_priority == LM_ALERT     ? 'A' :   // Alert
// log_priority == LM_EMERGENCY ? '!' :   // Emergency
//                                '?'      // Unknown
// Nope, print out standard priority_name() string
// Format the string assocated with the errno value.
// Windows can try to translate the errnum using
// system calls if strerror() doesn't get anything useful.
/* ACE_WIN32 && ACE_USES_WCHAR */
// PharLap can't do FormatMessage, so try for socket
// error.
// Default language
/* ACE_HAS_PHARLAP */
// If we don't get a valid response from
// <FormatMessage>, we'll assume this is a
// WinSock error and so we'll try to convert
// it into a string.  If this doesn't work it
// returns "unknown error" which is fine for
// our purposes.
// Free the buffer.
/* ACE_WIN32 */
// Format the return status of the operation.
// Increment the trace_depth, then indent
// indent, then decrement trace_depth
// insert a newline, then indent the next line
// according to %I
/* fallthrough */
// Indent with nesting_depth*width spaces
// Caller can do %*I to override nesting indent, and
// if %*I was done, wp has the extracted width.
/* ACE_HAS_TRACE */
// Run (invoke) this subroutine.
// format the string for with this signal number.
// Format the timestamp in format:
// yyyy-mm-dd hour:minute:sec.usec
// This is a maximum of 27 characters
// including terminator.
// Did we find the flag indicating a time value argument
// Format the timestamp in
// hour:minute:sec.usec format.
// Did we find the flag indicating a time value argument
// Format thread id.
/* ACE_WIN32 */
// String
/* ACE_WIN32 && ACE_USES_WCHAR */
/* ACE_WIN32 && ACE_USES_WCHAR */
// Narrow-char string
/* ACE_WIN32 && ACE_USES_WCHAR */
/* ACE_WIN32 && ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* HPUX */
/* ACE_HAS_WCHAR */
// Wide character
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* HPUX */
/* ACE_WIN32 */
/* ACE_WIN32 */
// ACE_OS::WChar character
// On some platforms sizeof (wchar_t) can be 2
// on the others 4 ...
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* HPUX */
/* ACE_WIN32 */
/* ACE_WIN32 */
// ACE_OS::WChar character string
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* HPUX */
/* ACE_WIN32 / ACE_HAS_WCHAR */
/* ACE_WIN32 && ACE_USES_WCHAR */
// Skip leading %
// Skip leading %
// Skip leading %
// Skip leading %
// Assume a 32 bit time_t and change if needed.
// Skip leading %
// Stack trace up to this point
// skip the frame that we're currently in
/* ACE_WIN32 && ACE_USES_WCHAR */
/* ACE_WIN32 && ACE_USES_WCHAR */
// So, it's not a legit format specifier after all...
// Copy from the original % to where we are now, then
// continue with whatever comes next.
// Bump to the next char in the caller's format_str
// Locate end of bp.
// Terminate bp, but don't auto-increment this!
// Check that memory was not corrupted, if it corrupted we can't log anything
// anymore because all our members could be corrupted.
// Copy the message from thread-specific storage into the transfer
// buffer (this can be optimized away by changing other code...).
// Write the <log_record> to the appropriate location.
// Since we are now calling abort instead of exit, this value is
// not used.
// *Always* print a message to stderr if we're aborting.  We
// don't use verbose, however, to avoid recursive aborts if
// something is hosed.
/* ACE_LACKS_VA_FUNCTIONS */
// continuation of the '%p' format after the user's message
// always narrow chars
// when copying to fmt_out_, convert L (used by ACE) to l (used by std)
// the following formatters (here through '?') take no argument
// from the "varags" list so they will end up returning true (keep parsing)
// fall-through
// always narrow chars
// special case for %.1M: unique 1-char abbreviation for log priority
// %D and %T with # in the conversion spec do take an arg (ACE_Time_Value*)
// 3 stack frames between here and user code
// * requires an argument from the "varags" but doesn't complete
// the current conversion specification (for example, %*s):
// these require an argument from the "varags" list:
// ACE_timer_t is a typedef for double on all platforms
// skip %
// skip %
// the remaining parts of case 'p' are handled in prepare_format
// skip %
// skip %
// skip %
// <- ints
// <- doubles
// <- char / const char*
// not actually a format specifier: copy verbatim to output
/* start at % */, n + 2);
// arg is ignored
/* ACE_LACKS_VA_FUNCTIONS */
/**
/// Original signal mask.
/* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
/* ACE_LACKS_UNIX_SIGNALS */
/* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
/* ! ACE_LACKS_UNIX_SIGNALS */
/* ! ACE_WIN32 */
// Retrieve the flags in a local variable on the stack, it is
// accessed by multiple threads and within this operation we
// check it several times, so this way we only lock once
// Format the message and print it to stderr and/or ship it off to
// the log_client daemon, and/or print it to the ostream.  Of
// course, only print the message if "SILENT" mode is disabled.
// Make this block signal-safe.
/* !ACE_WIN32 */
// Do the callback, if needed, before acquiring the lock
// to avoid holding the lock during the callback so we don't
// have deadlock if the callback uses the logger.
// Make sure that the lock is held during all this.
// This is taken care of by our caller.
// Be sure that there is a message_queue_, with multiple threads.
// This must come last, after the other two print operations
// (see the <ACE_Log_Record::print> method for details).
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
// Calls log to do the actual print, but formats first.
// Only print the message if <priority_mask_> hasn't been reset to
// exclude this logging priority.
// in case size = 0
// estimate how many bytes can be output
// We can fit 16 bytes output in text mode per line, 4 chars per byte;
// i.e. we need 68 bytes of buffer per line.
// Now print out the formatted buffer.
// Be sure that there is a message_queue_, with multiple threads.
// Synchronize output operations.
/* ACE_HAS_DUMP */
// Same stream, allow user to change the delete_ostream "flag"
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// The other two cases are no-ops, the user has requested the same
// state that's already present.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_USES_WCHAR */
/* ACE_LACKS_VA_FUNCTIONS */
// ****************************************************************
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Inherit the logging features if the parent thread has an
// <ACE_Log_Msg>.  Note that all of the following operations occur
// within thread-specific storage.
// Note that we do not inherit the callback because this might have
// been allocated off of the stack of the original thread, in which
// case all hell would break loose...
// @@ Now the TSS Log_Msg has been created, cache my thread
// descriptor in.
// This downcast is safe.  We do it to avoid having to #include
// ace/Thread_Manager.h.
// Block the thread from proceeding until
// thread manager has thread descriptor ready.
/* ! ACE_THREADS_DONT_INHERIT_LOG_MSG  &&  ! ACE_HAS_MINIMAL_ACE_OS */
// If we don't do this, handles aren't reused on Win32 and the
// server eventually crashes!
// Serialize the log record using a CDR stream, allocate enough
// space for the complete <ACE_Log_Record>.
// type
// pid
// timestamp
// process id
// data length
// message
// message
// padding;
// Insert contents of <log_record> into payload stream.
// Get the number of bytes used by the CDR stream. If it becomes desireable
// to support payloads more than 4GB, this field will need to be changed
// to a 64-bit value.
// Send a header so the receiver can determine the byte order and
// size of the incoming CDR stream.
// Store the size of the payload that follows
// Use an iovec to send both buffer and payload simultaneously.
// Use the <putpmsg> API if supported to ensure correct message
// queueing according to priority.
// We're running over sockets, so send header and payload
// efficiently using "gather-write".
/* ACE_HAS_STREAM_LOG_MSG_IPC */
// ACE's "resource module" contains the message resource required
// for event logging.
// If a logger_key has been supplied then we use that as the event
// source name, otherwise we default to the program name.
// Information is stored in the registry at a location based on the
// program name.
// Add the event source to the registry. Note that if this fails it
// is not fatal. The application will still be able to write entries
// to the event log, they just won't be formatted correctly.
// Obtain a handle to the event source.
// Make a copy of the log text and replace any newlines with
// CR-LF. Newline characters on their own do not appear correctly in
// the event viewer. We allow for a doubling in the size of the msg
// data for the worst case of all newlines.
// Map the ACE log record type to an event log type.
// Send the log message to the system event log.
/* ACE_HAS_LOG_MSG_NT_EVENT_LOG */
// NOTE:
//   The ACE_Log_Msg_UNIX_Syslog class can use the openlog(),
//   setlogmask(), syslog() and closelog() routines in a thread safe
//   manner (versus using openlog_r(), et. al.), as the ACE_Log_Msg
//   class uses the lock provided by its local ACE_Log_Msg_Manager
//   class when calling the methods of the backend classes.  As a
//   result, logging semantics with respect to the UNIX syslog
//   facility, will be the same for all threads in a process.  This
//   should not be too limiting, as the ACE_Log_Msg class itself can
//   be used to control thread specific logging behavior.
// Initialize the UNIX syslog facility.  Default the syslog log
// options LOG_CONS and LOG_PID to be set.  There really should be a
// logging strategy option to control the syslog log options,
// however, we'll take the easy way out for now.
/* ACE_USES_WCHAR */
/* ACE_LACKS_OPENLOG */
// Enable logging of all syslog priorities.  If logging of all
// priorities is not desired, use the ACE_Log_Msg::priority_mask()
// method to control the log output sent to the syslog daemon via
// the log() method, or use the system's syslog.conf file to select
// desired level of information.
/* ACE_LACKS_SETLOGMASK */
// The UNIX syslog() facility does not support multi-line messages.
// Break up the message data into separate lines and send each line
// to the syslog daemon.
// Format the message line.  Note that the processing for
// VERBOSE is the same as for VERBOSE_LITE, since syslog()
// already provides us with the hostname and PID.  However, the
// timestamp is duplicated (albeit a shortened version) to
// provide a timestamp with greater precision than that provided
// by syslog().
// No formatting required.
/* !ACE_LACKS_UNIX_SYSLOG */
/* __ACE_INLINE__ */
// FUZZ: disable check_for_streams_include
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
// Symbolic names for the <ACE_Log_Priority> enumerators.
// Name must be a statically allocated string
// Get the priority of the <Log_Record> <type_>.  This is computed
// as the base 2 logarithm of <type_> (which must be a power of 2,
// as defined by the enums in <ACE_Log_Priority>).
// Set the priority of the <Log_Record> <type_> (which must be a
// power of 2, as defined by the enums in <ACE_Log_Priority>).
// ACE_TRACE ("ACE_Log_Record::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Log_Record::msg_data");
// Will need room for '\0'
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Log_Record::ACE_Log_Record");
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Log_Record::ACE_Log_Record");
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Log_Record::round_up");
// Determine the length of the payload.
// Round up to the alignment.
// ACE_TRACE ("ACE_Log_Record::ACE_Log_Record");
/* ACE_HAS_ALLOC_HOOKS */
/* 012345678901234567890123456     */
/* yyyy-mm-dd hh:mm:ss.mmmmmm<nul> */
// Only used by VERBOSE and VERBOSE_LITE.
// The sprintf format needs to be different for Windows and POSIX
// in the wide-char case.
// Historical timestamp in VERBOSE[_LITE] used 3 places for partial sec.
// 012345678901234567890123456
// 1989-10-18 14:25:36.123<nul>
/* ACE_HAS_ALLOC_HOOKS */
// We should have written everything
/* ACE_HAS_ALLOC_HOOKS */
// The written message length can't be more than 32 bits (ACE_CDR::ULong)
// so reduce it here if needed.
// Insert each field from <log_record> into the output CDR stream.
/* ACE_USES_WCHAR */
// Extract each field from input CDR stream into <log_record>.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_USES_WCHAR */
// Since ostream expects only chars, we cannot pass wchar_t's
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// This routine sends an open file descriptor to <this->handle_>.
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_LACKS_SENDMSG */
// This file receives an open file descriptor from <this->handle_>.
// Note, this routine returns -1 if problems occur, 0 if we recv a
// message that does not have file descriptor in it, and 1 otherwise.
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_LACKS_SENDMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
// Close down the socket that was returned by the MSG_PEEK.
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_LACKS_SENDMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_STREAMS */
/* ACE_HAS_MSG */
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* ACE_HAS_ALLOC_HOOKS */
// Return the local endpoint address.
/* ACE_HAS_DUMP */
// Do nothing routine for constructor.
// This is a gross hack...
// General purpose routine for performing server ACE_SOCK creation.
// General purpose routine for accepting new connections.
// Reset the size of the addr, which is only necessary for UNIX
// domain sockets.
// Close down the UNIX domain stream and remove the rendezvous point
// from the file system.
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* Here's the general-purpose open routine. */
/* Create a local ACE_SOCK datagram. */
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Establish a connection.
// This is necessary due to the weird inheritance relationships of
// ACE_LSOCK_Stream.
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// The "do nothing" constructor.
// Here's the general-purpose open routine.
// Create a local ACE_SOCK datagram.
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// Perform the downcast since <addr> had better be an
// <ACE_UNIX_Addr>.
// Send a readv-style vector of buffers, along with an open I/O
// handle.
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_LACKS_SENDMSG */
// Read a readv-style vector of buffers, along with an open I/O
// handle.
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */ /* ACE_LACKS_SENDMSG */
/* ACE_HAS_MSG */
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* __ACE_INLINE__ */
// Process-wide ACE_Allocator.
// Controls whether the Allocator is deleted when we shut down (we can
// only delete it safely if we created it!)  This is no longer used;
// see ACE_Allocator::instance (void).
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/*ACE_HAS_MALLOC_STATS*/
/* __ACE_INLINE__ */
// for ACE_ASSERT
//  ACE_TRACE ("ACE_Allocator::instance");
// Perform Double-Checked Locking Optimization.
// Have a seat.  We want to avoid ever having to delete the
// ACE_Allocator instance, to avoid shutdown order
// dependencies.  ACE_New_Allocator never needs to be
// destroyed:  its destructor is empty and its instance
// doesn't have any state.  Therefore, sizeof
// ACE_New_Allocator is equal to sizeof void *.  It's
// instance just contains a pointer to its virtual function
// table.
//
// So, we allocate space for the ACE_New_Allocator instance
// in the data segment.  Because its size is the same as
// that of a pointer, we allocate it as a pointer so that it
// doesn't get constructed statically.  We never bother to
// destroy it.
// Check this critical assumption.  We put it in a variable
// first to avoid stupid compiler warnings that the
// condition may always be true/false.
/* !ACE_NDEBUG */
// Initialize the allocator_instance by using a placement
// new.
// We can't safely delete it since we don't know who created it!
// This should never be executed....  See the
// ACE_Allocator::instance (void) method for an explanation.
/******************************************************************************/
/* ACE_HAS_MALLOC_STATS */
/* ACE_HAS_DUMP */
/******************************************************************************/
// Record the current offset, increment the offset by the number
// of bytes requested, and return the original offset.
// Check to see if ptr is within our pool?!
/* ACE_HAS_MALLOC_STATS */
/* ACE_HAS_DUMP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// To maintain alignment requirements, make sure that each element
// inserted into the free list is aligned properly for the platform.
// Since the memory is allocated as a char[], the compiler won't help.
// To make sure enough room is allocated, round up the size so that
// each element starts aligned.
//
// NOTE - this would probably be easier by defining pool_ as a pointer
// to T and allocating an array of them (the compiler would probably
// take care of the alignment for us), but then the ACE_NEW below would
// require a default constructor on T - a requirement that is not in
// previous versions of ACE
/* ACE_HAS_ALLOC_HOOKS */
// Put into free list using placement constructor, no real memory
// allocation in the above <new>.
/* ACE_HAS_ALLOC_HOOKS */
// Check if size requested fits within pre-determined size.
// addr() call is really not absolutely necessary because of the way
// ACE_Cached_Mem_Pool_Node's internal structure arranged.
// Check if size requested fits within pre-determined size.
// addr() call is really not absolutely necessary because of the way
// ACE_Cached_Mem_Pool_Node's internal structure arranged.
// Put into free list using placement constructor, no real memory
// allocation in the above <new>.
// Check if size requested fits within pre-determined size.
// addr() call is really not absolutely necessary because of the way
// ACE_Cached_Mem_Pool_Node's internal structure arranged.
// Check if size requested fits within pre-determined size.
// addr() call is really not absolutely necessary because of the way
// ACE_Cached_Mem_Pool_Node's internal structure arranged.
/* ACE_HAS_WCHAR */
/* ACE_HAS_MALLOC_STATS */
/* ACE_HAS_DUMP */
/* ACE_HAS_MALLOC_STATS */
/* ACE_HAS_DUMP */
/* ACE_HAS_MALLOC_STATS */
// Put <ptr> in the free list (locked version).
// This function is called by the ACE_Malloc_T constructor to initialize
// the memory pool.  The first time in it allocates room for the
// control block (as well as a chunk of memory, depending on
// rounding...).  Depending on the type of <MEM_POOL> (i.e., shared
// vs. local) subsequent calls from other processes will only
// initialize the control block pointer.
// ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT ("(%P|%t) first time in, control block = %@\n"), this->cb_ptr_));
// If we've got any extra space at the end of the control
// block, then skip past the dummy <MALLOC_HEADER> to
// point at the first free block.
// Why aC++ in 64-bit mode can't grok this, I have no
// idea... but it ends up with an extra bit set which makes
// size_ really big without this hack.
/* (__hpux) && defined (__LP64__) */
// Insert the newly allocated chunk of memory into the free
// list.  Add "1" to skip over the <MALLOC_HEADER> when
// freeing the pointer.
// Use pool_name for lock_name if lock_name not passed.
// Clean up the resources allocated by ACE_Malloc_T.
// ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT ("(%P|%t) destroying ACE_Malloc_T\n")));
/* ACE_HAS_MALLOC_STATS */
// Remove the ACE_LOCK.
// Give the memory pool a chance to release its resources.
// Reset this->cb_ptr_ as it is no longer valid.
// There's also no need to keep the reference counter as the
// underlying memory pool has been destroyed.
// Also notice that we are leaving the decision of removing
// the pool to users so they can map to the same mmap file
// again.
// General-purpose memory allocator.  Assumes caller holds the locks.
/* !ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Round up request to a multiple of the MALLOC_HEADER size.
// Add one for the <MALLOC_HEADER> itself.
// Begin the search starting at the place in the freelist where the
// last block was found.
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Search the freelist to locate a block of the appropriate size.
// *Warning* Do not use "continue" within this while-loop.
// Big enough
// Exact size, just update the pointers.
// Remaining chunk is larger than requested block, so
// allocate at tail end.
// Skip over the MALLOC_HEADER when returning pointer.
// We've wrapped around freelist without finding a
// block.  Therefore, we need to ask the memory pool for
// a new chunk of bytes.
// Compute the chunk size in MALLOC_HEADER units.
// Insert the newly allocated chunk of memory into the
// free list.  Add "1" to skip over the
// <MALLOC_HEADER> when freeing the pointer since
// the first thing <free> does is decrement by this
// amount.
// Shouldn't do this here because of errors with the wchar ver
// This is because ACELIB_ERROR_RETURN converts the __FILE__ to
// wchar before printing out.  The compiler will complain
// about this since a destructor would present in a SEH block
//ACELIB_ERROR_RETURN ((LM_ERROR,
//                   ACE_TEXT ("(%P|%t) %p\n"),
//                   ACE_TEXT ("malloc")),
//                  0);
// General-purpose memory allocator.
// General-purpose memory allocator.
// Put block AP in the free list (must be called with locks held!)
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Adjust AP to point to the block MALLOC_HEADER
// Search until we find the location where the blocks belongs.  Note
// that addresses are kept in sorted order.
// Freed block at the start or the end of the memory pool.
// Join to upper neighbor.
// Join to lower neighbor.
// No locks held here, caller must acquire/release lock.
/* !ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Combine the two allocations into one to avoid overhead...
// Use operator placement new to insert <new_node> at the head of
// the linked list of <NAME_NODE>s.
// Didn't find it, so insert it.
// Found it, so return a copy of the current entry.
// If we're not allowing duplicates, then if the name is already
// present, return 1.
// If we get this far, either we're allowing duplicates or we didn't
// find the name yet.
// Returns a count of the number of available chunks that can hold
// <size> byte allocations.  Function can be used to determine if you
// have reached a water mark. This implies a fixed amount of allocated
// memory.
//
// @param size - the chunk size of that you would like a count of
// @return function returns the number of chunks of the given size
//          that would fit in the currently allocated memory
// Avoid dividing by 0...
// Calculate how many will fit in this block.
// This will free up both the node and the name due to our
// clever trick in <bind>!
// Didn't find it, so fail.
/*****************************************************************************/
/*****************************************************************************/
/* ACE_HAS_DUMP */
// Cheap trick to make code simple.
// @@ Doug, this looks like trouble...
/* ACE_HAS_DUMP */
// Cheap trick to make code simple.
// @@ Doug, this looks like trouble...
// Go to the first element that was inserted.
// Locate the element that was inserted first.
// @@ We could optimize this by making the list a circular list or
// storing an extra pointer.
/* ACE_MALLOC_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_MANAGED_OBJECT_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_WCHAR */
/* ACE_HAS_DUMP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Close old map (if any).
// Use the user specified allocator or the default singleton one.
// This assertion is here to help track a situation that shouldn't
// happen.
// Active_Map_Manager depends on the <slot_index_> being of fixed
// size. It cannot be size_t because size_t is 64-bits on 64-bit
// platform and 32-bits on 32-bit platforms. Size of the <slot_index_>
// has to be consistent across platforms. ACE_UIN32 is chosen as
// ACE_UIN32_MAX is big enough. The assert is to ensure that the user
// doesn't open the ACE_Map_Manager with a bigger size than we can
// handle.
// Resize from 0 to <size>.  Note that this will also set up the
// circular free list.
// Free entries.
// Reset sizes.
// Reset circular free list.
// Reset circular occupied list.
// Try to find the key.
// We found the key. Nothing to change.
// We didn't find the key.
// Look in the free list for an empty slot.
// If we do find a free slot, return successfully.
// Move any free slots from occupied list to free list.
// Try again in case we found any free slots in the occupied list.
// If we do find a free slot, return successfully.
/* ACE_HAS_LAZY_MAP_MANAGER */
// Resize the map.
// Check for errors.
// New free slot.
//
// In the case of lazy map managers, the movement of free slots from
// the occupied list to the free list is delayed until we run out of
// free slots in the free list.
//
// Go through the entire occupied list, moving free slots to the
// free list. Note that all free slots in the occupied list are
// moved in this loop.
//
// Note the trick used here: Information about the current slot
// is first noted; <i> then moves to the next occupied slot;
// only after this is the slot (potentially) moved from the
// occupied list to the free list.  This order of things, i.e.,
// moving <i> before moving the free slot is necessary,
// otherwise we'll forget which our next occupied slot is.
//
// Note information about current slot.
// Move <i> to next occupied slot.
// If current slot is free
// Reset free flag to zero before moving to free list.
// Move from occupied list to free list.
/* ACE_HAS_LAZY_MAP_MANAGER */
// Grab the entry.
// Remove from current list.
// Fix the entry before us.
// Fix the entry after us.
// Add to new list.
// Fix us.
// Fix entry before us.
// Fix entry after us.
// This function assumes that the find() has already been done, and
// therefore, simply adds to the map.
// Find an empty slot.
// Copy key and value.
// Move from free list to occupied list
// Update the current size.
// First try to find the key.
// We found it, so make copies of the old entries and rebind
// current entries.
// Sync changed entry.
// We didn't find it, so let's add it.
// First try to find the key.
// We found it, so make copies of the old entries and rebind
// current entries.
// Sync changed entry.
// We didn't find it, so let's add it.
// First try to find the key.
// We found it, so rebind current entries.
// Sync changed entry.
// We didn't find it, so let's add it.
// Try to find the key.
// Key was found.  Make a copy of value, but *don't* update
// anything in the map!
// We didn't find it, so let's bind it!
// Go through the entire occupied list looking for the key.
/* ACE_HAS_LAZY_MAP_MANAGER */
// If found, return slot.
// Key was not found.
// Go through the entire occupied list.
//
// Note the trick used here: Information about the current slot
// is first noted; <i> then moves to the next occupied slot;
// only after this is the slot (potentially) moved from the
// occupied list to the free list.  This order of things, i.e.,
// moving <i> before moving the free slot is necessary,
// otherwise we'll forget which our next occupied slot is.
//
// Note information about current slot.
// Move <i> to next occupied slot.
/* ACE_HAS_LAZY_MAP_MANAGER */
// Try to find the key.
// Key was found.  Make a copy of value.
// Try to find the key.
//
// In the case of lazy map managers, the movement of free slots
// from the occupied list to the free list is delayed until we
// run out of free slots in the free list.
//
// Move from occupied list to free list.
/* ACE_HAS_LAZY_MAP_MANAGER */
// Update the current size.
// Unbind the entry.
// If found, copy the value.
// Allocate new memory.
// Copy over the occupied entires.
// Call the copy constructor using operator placement new.
// Copy over the free entires.
// Call the copy constructor using operator placement new.
// Construct the new elements.
// Call the constructor for each element in the array using
// operator placement new.  Note that this requires a default
// constructor for <EXT_ID> and <INT_ID>.
// Even though this slot is initially free, we need the <free_>
// flag to be zero so that we don't have to set it when the slot
// is moved to the occupied list.  In addition, this flag has no
// meaning while this slot is in the free list.
/* ACE_HAS_LAZY_MAP_MANAGER */
// Add new entries to the free list.
// Remove/free old elements, update the new totoal size.
// Start using new elements.
// Calculate the new size.
// Exponentially increase if we haven't reached MAX_EXPONENTIAL.
// Linear increase if we have reached MAX_EXPONENTIAL.
// This should be the new size.
// Free up the structure.
// Explicitly call the destructor.
// The "if" second argument results in a no-op instead of
// deallocation.
// Actually free the memory.
/* ACE_HAS_LAZY_MAP_MANAGER */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_MAP_MANAGER_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// Reserve a slot and create an active key.
// Encode the active key and the existing user key into key part
// of <expanded_value>.
// Copy user value into <expanded_value>.
// Copy new, modified key back to the user key.
// In case of errors, unbind from map.
// Reserve a slot and create an active key.
// Encode the active key into key part of <expanded_value>.
// Copy user value into <expanded_value>.
// Copy new, modified key to the user key.
// In case of errors, unbind from map.
// Reserve a slot and create an active key.
// Encode the active key into key part of <expanded_value>.
// Copy user value into <expanded_value>.
// In case of errors, unbind from map.
// Ask the <key_adapter_> to help out with recovering the original
// user key, since it was the one that encode it in the first place.
// Ask the <key_adapter_> to recover the active key.
// Find recovered active key in map.
// Copy value.
// Reset value.
// Copy old value.
// Reset to new value.
// Copy old key and value.
// Reset to new value.
// Ask the <key_adapter_> to recover the active key.
// Unbind recovered active key from map.
// Copy value.
/* ACE_HAS_DUMP */
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// Invoke the user specified key generation functor.
// Invoke the user specified key generation functor.
// Try to add.
/* ACE_HAS_DUMP */
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// The following syntax is necessary to work around certain broken compilers.
// In particular, please do not prefix implementation_ with this->
// Invoke the user specified key generation functor.
// Invoke the user specified key generation functor.
// Try to add.
/* ACE_HAS_DUMP */
/* ACE_MAP_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Do nothing routine for constructor.
/* ACE_HAS_ALLOC_HOOKS */
// General purpose routine for performing server ACE_SOCK creation.
// General purpose routine for accepting new connections.
// On Win32 the third parameter to <accept> must be a NULL
// pointer if to ignore the client's address.
// Allocate 2 * MAXPATHLEN so we can accomodate the unique
// name that gets appended later
// - 24 is so we can append name to the end.
// Make sure we have a fresh start.
// Protocol negociation:
//   Tell the client side what level of signaling strategy
//   we support.
// We don't support MT.
/* ACE_WIN32 || !_ACE_USE_SV_SEM */
//   Now we get the signaling strategy the client support.
// Ensure minimum buffer size
// Client will decide what signaling strategy to use.
// Now set up the shared memory malloc pool.
// @@ Need to handle timeout here.
// No need to worry about byte-order because both parties should always
// be on the same machine.
// Now send the pathname of the mmap file.
// Check to see if we were originally in blocking mode, and if so,
// set the <new_stream>'s handle and <this> handle to be in blocking
// mode.
// Save/restore errno.
// Only disable ACE_NONBLOCK if we weren't in non-blocking mode
// originally.
// Reset the event association inherited by the new handle.
/* ACE_WIN32 */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Defines the Internet domain address family address format.
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// Transform the current address into string format.
// ACE_TRACE ("ACE_MEM_Addr::ACE_MEM_Addr");
// ACE_INET_Addr::operator== takes port number into account, so get
// the addresses without a port number and compare.
// Transform the string into the current addressing format.
// Return the address.
// Set a pointer to the address.
// Return the character representation of the hostname.
/* ACE_HAS_DUMP */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Establish a connection.
// This is necessary due to the weird inheritance relationships of
// ACE_MEM_Stream.
// Do not close the handle.
// now we should setup the mmap malloc.
// @@ Need to handle timeout here.
// Receive the signaling strategy theserver support.
// If either side don't support MT, we will not use it.
/* ACE_WIN32 || !_ACE_USE_SV_SEM */
// Byte-order is not a problem for this read.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// MEM_IO.cpp
/* __ACE_INLINE__ */
//      ACELIB_DEBUG ((LM_INFO, "MEM_Stream closed\n"));
//  Nothing available or we are really screwed.
// The offset.
// Send the offset value over the socket.
// unsuccessful send, release the memory in the shared-memory.
// Here, we assume we already have acquired the lock necessary.
// And we are allowed to write.
// nothing in the queue.
// Here, we assume we already have acquired the lock necessary
// and there are soemthing in the queue.
// Last message in the queue.
// @@ Give me a rule on naming and how the queue should
//    be kept in the shared memory and we are done
//    with this.
//  size_t baselen = ACE_OS::strlen (basename);
// Building names.  @@ Check buffer overflow?
// @@ Here, we assume the shared memory fill will never be resued.
//    So we can determine whether we are server or client by examining
//    if the simple message queues have already been set up in
//    the Malloc object or not.
// We are server.
// we are client.
// @@ Don't know how to handle timeout yet.
// Need to handle timeout here.
// @@ We can probably skip the lock in certain circumstance.
// @@ Don't know how to handle timeout yet.
// @@ We can probably skip the lock in certain curcumstances.
/* ACE_WIN32 || !_ACE_USE_SV_SEM */
/* ACE_HAS_DUMP */
/* ACE_WIN32 || !_ACE_USE_SV_SEM */
// Allows a client to read from a socket without having to provide
// a buffer to read.  This method determines how much data is in the
// socket, allocates a buffer of this size, reads in the data, and
// returns the number of bytes read.
// Something went seriously wrong.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Defines the member functions for the memory mapping facility.
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// This function does the dirty work of actually calling ACE_OS::mmap
// to map the file into memory.
// If the system does not replace any previous mappings, then
// unmap() before (potentially) mapping to the same location.
/* ACE_LACKS_AUTO_MMAP_REPLACEMENT */
// mmap through character device doens't care about it's size
// So map with /dev/* is done with a special case.
/* is done with a special case.
// Something wrong found, bail out.
// Set length to length_request
// Get the current filesize
// Flag to indicate if we need to extend the back store
// File length requested by user
// Check <length_request>
// Set length to file_request or size_t max.
/* ACE_MMAP_NO_ZERO */
// Make sure that we have not been asked to do the impossible.
// File length implicitly requested by user
// Check to see if we need to extend the backing store
// If the length of the mapped region is less than the
// length of the file then we force a complete new remapping
// by setting the descriptor to ACE_INVALID_HANDLE (closing
// down the descriptor if necessary).
// Remember to extend the backing store
// Set length to length_request
// Check if we need to extend the backing store.
// Remember than write increases the size by one.
// This will make the file size <requested_file_length>
// Unmappable file type.
/* INTEGRITY */
// Map a file specified by FILE_NAME.
// Map a file from an open file descriptor HANDLE.  This function will
// lookup the length of the file if it is not given.
// Close down and remove the file from the file system.
/* __QNXNTO__ */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_MEM_SAP::ACE_MEM_SAP");
// ACE_TRACE ("ACE_MEM_SAP::~ACE_MEM_SAP");
// already initialized.
// Cleanup OS resources
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// We need the following call to make things work correctly on
// Win32, which requires use to do a <close_writer> before doing the
// close in order to avoid losing data.  Note that we don't need to
// do this on UNIX since it doesn't have this "feature".  Moreover,
// this will cause subtle problems on UNIX due to the way that
// fork() works.
/* ACE_WIN32 */
// Close down the socket.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/* __ACE_INLINE__ */
//#define ACE_ENABLE_TIMEPROBES
// Setup Timeprobes
/* ACE_ENABLE_TIMEPROBES */
// Set the read and write pointers in the <Message_Block> to point
// to the buffer in the <ACE_Data_Block>.
/*size_t len = static_cast<size_t> (this->end () - this->wr_ptr ());*/
// Note that for this to work correct, end () *must* be >= mark ().
/* size_t len = static_cast<size_t> (this->end () - this->wr_ptr ()); */
// Note that for this to work correct, end() *must* be >= wr_ptr().
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// We need to acquire the lock before retrieving the count
// We need to resize!
// We now assume ownership.
// Resize the underlying <ACE_Data_Block>.
// Reset later if memory alloc'd ok
// If the user didn't pass one in, let's use the
// <ACE_Allocator::instance>.
/* ACE_INITIALIZE_MEMORY_BEFORE_USE */
// ACE_ALLOCATOR returns on alloc failure but we cant throw, so setting
// the size to 0 (i.e. "bad bit") ...
// The memory is legit, whether passed in or allocated, so set
// the size.
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// data_block allocator
// message_block allocator
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// data_block allocator
// message_block allocator
// data block
// data block
// Should we also initialize all the other fields, as well?
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// data_block allocator
// message_block allocator
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// Align ourselves
/* ACE_LACKS_CDR_ALIGNMENT */
// Set our rd & wr pointers
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time of deadline
// data block
// Align ourselves
/* ACE_LACKS_CDR_ALIGNMENT */
// Set our rd & wr pointers
// Get the alignment offset of the incoming ACE_Message_Block
/* ACE_LACKS_CDR_ALIGNMENT */
// Actual offset for the incoming message block assuming that it
// is also aligned to the same "align" byte
// Copy wr_offset amount of data in to <this->data_block>
// Dont move the write pointer, just leave it to the application
// to do what it wants
/* ACE_LACKS_CDR_ALIGNMENT */
/* ACE_HAS_TIMED_MESSAGE_BLOCKS */
// Allocate the <ACE_Data_Block> portion, which is reference
// counted.
// Message block initialization may fail, while the construction
// succeds.  Since ACE may throw no exceptions, we have to do a
// separate check and clean up, like this:
// placement destructor ...
// free ...
// Reset the data_block_ pointer.
// Sanity check...
// Just to be safe...
// decrement reference count
// this will cause deletion of this
// Check if we were passed in a lock
// Make sure that the lock passed in and our lock are the same
// In this case no locking is required.
// The lock passed in does not match our lock
// Lock to be used is our lock
// This is the case when no lock was passed in
// Lock to be used is our lock
// If there's a locking strategy then we need to acquire the lock
// before decrementing the count.
// We must delete this outside the scope of the locking_strategy_
// since otherwise we'd be trying to "release" through a deleted
// pointer!
// We want to hold the data block in a temporary variable because we
// invoked "delete this;" at some point, so using this->data_block_
// could be a bad idea.
// This flag is set to 1 when we have to destroy the data_block
// Do we have a valid data block
// Grab the lock that belongs to my data block
// if we have a lock
// One guard for all
// Call non-guarded release with @a lock
// This is the case when we have a valid data block but no lock
// Call non-guarded release with no lock
// This is the case when we don't even have a valid data block
// Free up all the continuation messages.
// We will now commit suicide: this object *must* have come from the
// allocator given.
/* static */ ACE_Message_Block *
// Create a new <ACE_Message_Block>, but share the <base_> pointer
// data (i.e., don't copy that).
// We need to acquire the lock before incrementing the count.
/* ACE_HAS_TIMED_MESSAGE_BLOCKS */
// Increment the reference counts of all the continuation messages.
// Create a new <ACE_Message_Block> that contains unique copies of
// the message block fields, but a reference counted duplicate of
// the <ACE_Data_Block>.
// If there is no allocator, use the standard new and delete calls.
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// Get a pointer to a
// "duplicated" <ACE_Data_Block>
// (will simply increment the
// reference count).
// Otherwise, use the message_block_allocator passed in.
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// Get a pointer to a
// "duplicated" <ACE_Data_Block>
// (will simply increment the
// reference count).
// If allocation failed above, release everything done so far and return NULL
// Set the read and write pointers in the new <Message_Block> to the
// same relative offset as in the existing <Message_Block>.  Note
// that we are assuming that the data_block()->base() pointer
// doesn't change when it's duplicated.
/* First in the list: set leading pointers */
/* Continuing on: append to nb and walk down the list */
// Copy all of the payload memory into the new object. The new block
// was allocated with max_size_ (and, thus, it's cur_size_ is the same
// as max_size_). Maintain the same "has been written" boundary in the
// new block by only copying cur_size_ bytes.
// You always want to clear this one to prevent memory leaks but you
// might add some others later.
// size
// type
// data
// allocator
// locking strategy
// flags
// Message block initialization may fail while the construction
// succeds.  Since as a matter of policy, ACE may throw no
// exceptions, we have to do a separate check like this.
// placement destructor ...
// free ...
// Set new flags minus the mask...
// Get a pointer to a "cloned"<ACE_Data_Block> (will copy the
// values rather than increment the reference count).
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time to deadline
// Get a pointer to a
// "duplicated"<ACE_Data_Block>
// (will simply increment the
// reference count).
// This is the ACE_NEW_MALLOC macro with the return check removed.
// We need to do it this way because if it fails we need to release
// the cloned data block that was created above. If we used
// ACE_NEW_MALLOC_RETURN, there would be a memory leak because the
// above db pointer would be left dangling.
// size
// type
// cont
// data
// allocator
// locking strategy
// flags
// priority
// execution time
// absolute time to deadline
// Set the read and write pointers in the new <Message_Block> to the
// same relative offset as in the existing <Message_Block>.
// save the root message block to return
// we're a continuation of the previous block, add ourself to its chain
// This is private.
/* Need ACE_Allocator */
/* __ACE_INLINE__ */
// You always want to clear this one to prevent memory leaks but you
// might add some others later.
// Set new flags minus the mask...
/* ACE_MESSAGE_BLOCK_T_CPP */
/* __ACE_INLINE__ */
/* __ACE_INLINE__ */
// Note - we send ACTIVATED in the 3rd arg to tell the completion
// routine it's _NOT_ being woken up because of deactivate().
// Update the states once I succeed.
// Fail to enqueue the message.
// Make sure the MQ is not deactivated before proceeding.
// Operation on deactivated MQ not allowed.
// Increase the waiting thread count.
// Get a message from the completion port.
// Decrease waiting thread count.
// Really get a valid MB from the queue.
// Woken up by deactivate () or pulse ().
// Get the number of shutdown messages necessary to wake up all
// waiting threads.
// Get the number of shutdown messages necessary to wake up all
// waiting threads.
/* ACE_HAS_DUMP */
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// #include Message_Queue.h instead of Message_Queue_T.h to avoid
// circular include problems.
/* ACE_HAS_WIN32_OVERLAPPED_IO */
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_DUMP */
// Clean up the queue if we have not already done so!
// Take a look at the first item without removing it.
// Zap the message.
// Enqueue an <ACE_MESSAGE_TYPE *> into the <Message_Queue> in
// accordance with its <msg_priority> (0 is lowest priority).  Returns
// -1 on failure, else the number of items still on the queue.
// Zap the message.
// Zap the message.
// Block indefinitely waiting for an item to arrive,
// does not ignore alerts (e.g., signals).
// Zap the message.
// Remove an item from the front of the queue.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Dequeue the message.
// Delete the message block.
// Remove the item with the lowest priority from the queue.  If timeout == 0
// block indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Dequeue the message.
// Delete the message block.
// Remove an item from the end of the queue.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Dequeue the message.
// Delete the message block.
// Remove an item with the lowest deadline time.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Dequeue the message.
// Delete the message block.
// Create a chained ACE_Message_Blocks wrappers around the 'chained'
// ACE_MESSAGE_TYPES.
// Zap the messages.
// Create a chained ACE_Message_Blocks wrappers around the 'chained'
// ACE_MESSAGE_TYPES.
// Zap the message.
// We need to keep a reference to the head of the chain
// mb_tail will point to the last ACE_Message_Block
// Run through rest of the messages and wrap them
// Check if queue is empty (holds locks).
// Check if queue is full (holds locks).
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Check if queue is empty (does not hold locks).
// Check if queue is full (does not hold locks).
// Check if queue is empty (holds locks).
// Check if queue is full (holds locks).
// Not a pulse
// Just a pulse
/* ACE_HAS_DUMP */
/// Make a unique name using our process id and hex address.
/* ACE_HAS_MONITOR_POINTS==1 */
/* ACE_HAS_MONITOR_POINTS==1 */
// Remove all the <ACE_Message_Block>s in the <ACE_Message_Queue>
// and <release> their memory.
// Subtract off all of the bytes associated with this message.
// Make sure to use <release> rather than <delete> since this is
// reference counted.
// The monitor should output only if the size has actually changed.
// Don't bother locking since if someone calls this function more than
// once for the same queue, we're in bigger trouble than just
// concurrency control!
// Implementation of the public deactivate() method
// (assumes locks are held).
// Wakeup all waiters.
// Free up the remaining messages on the queue.
// Clean up the queue if we have not already done so!
// There's no need to check the return value of deactivate_i() since
// it never fails!
// Free up the remaining messages on the queue.
// Tell any blocked threads that the queue has a new item!
// Actually put the node at the end (no locking so must be called with
// locks held).
// Update the queued size and length, taking into account any chained
// blocks (total_size_and_length() counts all continuation blocks).
// Keep count of how many blocks we're adding and, if there is a chain of
// blocks, find the end in seq_tail and be sure they're properly
// back-connected along the way.
// List was empty, so build a new one.
// seq_tail->next (0);   This is a condition of the while() loop above.
// Link at the end.
// seq_tail->next (0);   This is a condition of the while() loop above.
// Actually put the node(s) at the head (no locking)
// Update the queued size and length, taking into account any chained
// blocks (total_size_and_length() counts all continuation blocks).
// Keep count of how many blocks we're adding and, if there is a chain of
// blocks, find the end in seq_tail and be sure they're properly
// back-connected along the way.
// Actually put the node at its proper position relative to its
// priority.
// Since this method uses enqueue_head_i() and enqueue_tail_i() for
// special situations, and this method doesn't support enqueueing
// chains of blocks off the 'next' pointer, make sure the new_item's
// next pointer is 0.
// Check for simple case of an empty queue, where all we need to
// do is insert <new_item> into the head.
// Figure out where the new item goes relative to its priority.
// We start looking from the lowest priority (at the tail) to
// the highest priority (at the head).
// Break out when we've located an item that has
// greater or equal priority.
// Check for simple case of inserting at the head of the queue,
// where all we need to do is insert <new_item> before the
// current head.
// Check for simple case of inserting at the tail of the
// queue, where all we need to do is insert <new_item> after
// the current tail.
// Insert the new message behind the message of greater or
// equal priority.  This ensures that FIFO order is
// maintained when messages of the same priority are
// inserted consecutively.
// Make sure to count all the bytes in a composite message!!!
// Actually put the node at its proper position relative to its
// deadline time.
// Since this method uses enqueue_head_i() and enqueue_tail_i() for
// special situations, and this method doesn't support enqueueing
// chains of blocks off the 'next' pointer, make sure the new_item's
// next pointer is 0.
// Check for simple case of an empty queue, where all we need to
// do is insert <new_item> into the head.
// Figure out where the new item goes relative to its priority.
// We start looking from the smallest deadline to the highest
// deadline.
// Break out when we've located an item that has
// greater or equal priority.
// Check for simple case of inserting at the tail of the queue,
// where all we need to do is insert <new_item> after the
// current tail.
// Insert the new message behind the message of
// lesser or equal deadline time.  This ensures that FIFO order is
// maintained when messages of the same priority are
// inserted consecutively.
// Make sure to count all the bytes in a composite message!!!
/* ACE_HAS_TIMED_MESSAGE_BLOCKS */
// Actually get the first ACE_Message_Block (no locking, so must be
// called with locks held).  This method assumes that the queue has at
// least one item in it when it is called.
// The prev pointer of first message block must point to 0...
// Subtract off all of the bytes associated with this message.
// Make sure that the prev and next fields are 0!
// Only signal enqueueing threads if we've fallen below the low
// water mark.
// Get the earliest (i.e., FIFO) ACE_Message_Block with the lowest
// priority (no locking, so must be called with locks held).  This
// method assumes that the queue has at least one item in it when it
// is called.
// Find the earliest (i.e., FIFO) message enqueued with the lowest
// priority.
// Find the first version of the earliest message (i.e.,
// preserve FIFO order for messages at the same priority).
// If every message block is the same priority, pass back the first
// one.
// Patch up the queue.  If we don't have a previous then we are at
// the head of the queue.
// Pass back the chosen block
// Subtract off all of the bytes associated with this message.
// Make sure that the prev and next fields are 0!
// Only signal enqueueing threads if we've fallen below the low
// water mark.
// Actually get the last ACE_Message_Block (no locking, so must be
// called with locks held).  This method assumes that the queue has at
// least one item in it when it is called.
// Subtract off all of the bytes associated with this message.
// Make sure that the prev and next fields are 0!
// Only signal enqueueing threads if we've fallen below the low
// water mark.
// Actually get the ACE_Message_Block with the lowest deadline time
// (no locking, so must be called with locks held).  This method assumes
// that the queue has at least one item in it when it is called.
// Find the last message enqueued with the lowest deadline time
// If every message block is the same deadline time,
// pass back the first one
// Patch up the queue.  If we don't have a previous
// then we are at the head of the queue.
// Pass back the chosen block
// Subtract off all of the bytes associated with this message.
// Make sure that the prev and next fields are 0!
// Only signal enqueueing threads if we've fallen below the low
// water mark.
/* ACE_HAS_TIMED_MESSAGE_BLOCKS */
// Take a look at the first item without removing it.
// Wait for at least one item to become available.
// Wait while the queue is full.
// Wait while the queue is empty.
// Block indefinitely waiting for an item to arrive, does not ignore
// alerts (e.g., signals).
// Enqueue an <ACE_Message_Block *> into the <Message_Queue> in
// accordance with its <msg_priority> (0 is lowest priority).  Returns
// -1 on failure, else the number of items still on the queue.
// Enqueue an <ACE_Message_Block *> into the <Message_Queue> in
// accordance with its <msg_deadline_time>.  Returns
// -1 on failure, else the number of items still on the queue.
// Block indefinitely waiting for an item to arrive,
// does not ignore alerts (e.g., signals).
// Remove an item from the front of the queue.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Remove item with the lowest priority from the queue.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Remove an item from the end of the queue.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// Remove an item with the lowest deadline time.  If timeout == 0 block
// indefinitely (or until an alert occurs).  Otherwise, block for upto
// the amount of time specified by timeout.
// By default, don't do anything.
// = Initialization and termination methods.
// Note, the ACE_Dynamic_Message_Queue assumes full responsibility
// for the passed ACE_Dynamic_Message_Strategy object, and deletes
// it in its own dtor
// dtor: free message strategy and let base class dtor do the rest.
// start with an empty list
// Get the current time
// Refresh priority status boundaries in the queue.
// patch up pointers for the new tail of the queue
// the list has become empty
// point to the head and tail of the list
// cut the pending messages out of the queue entirely
// Patch up pointers for the (possibly) new head and tail of the
// queue.
// put late messages behind pending messages (if any) being returned
// Patch up pointers for the new tail of the queue
// the list has become empty
// Put beyond late messages at the end of the list being
// returned.
// Decrement message and size counts for removed messages.
// Subtract off all of the bytes associated with this message.
// Detach all messages with status given in the passed flags from the
// queue and return them by setting passed head and tail pointers to
// the linked list they comprise.  This method is intended primarily
// as a means of periodically harvesting messages that have missed
// their deadlines, but is available in its most general form.  All
// messages are returned in priority order, from head to tail, as of
// the time this method was called.
// get the current time
// refresh priority status boundaries in the queue
// *now* it's appropriate to wait for an enqueued item
// call the internal dequeue method, which selects an item from the
// highest priority status portion of the queue that has messages
// enqueued.
// Dequeue and return the <ACE_Message_Block *> at the (logical) head
// of the queue.
/* ACE_HAS_DUMP */
// dump the state of the queue
// Get the current time.
// Refresh priority status boundaries in the queue.
// Where we enqueue depends on the message's priority status.
// Check for simple case of an empty pending queue, where
// all we need to do is insert <new_item> into the tail of
// the queue.
// Enqueue the new message in priority order in the pending
// sublist
// Check for simple case of an empty pending queue,
// where all we need to do is insert <new_item> into the
// tail of the queue.
// Check for simple case of an empty beyond late queue, where all
// we need to do is insert <new_item> into the head of the queue.
// Otherwise, we can just splice the new message in
// between the pending and beyond late portions of the
// queue.
// Enqueue the new message in priority order in the late
// sublist
// Check for simple case of an empty beyond late queue,
// where all we need to do is insert <new_item> into the
// head of the queue.
// all beyond late messages have the same (zero) priority,
// so just put the new one at the end of the beyond late
// messages
// should never get here, but just in case...
// Enqueue an <ACE_Message_Block *> in accordance with its priority.
// priority may be *dynamic* or *static* or a combination or *both* It
// calls the priority evaluation function passed into the Dynamic
// Message Queue constructor to update the priorities of all enqueued
// messages.
// Find message after which to enqueue new item, based on message
// priority and priority status.
// If the new message has highest priority of any, put it at the
// head of the list (and sublist).
// insert the new item into the list
// If the new item has lowest priority of any in the sublist,
// move the tail pointer of the sublist back to the new item
// Enqueue a message in priority order within a given priority status
// sublist.
// first, try to dequeue from the head of the pending list
// Second, try to dequeue from the head of the late list
// finally, try to dequeue from the head of the beyond late list
// nothing to dequeue: set the pointer to zero and return an error code
// Subtract off all of the bytes associated with this message.
// Only signal enqueueing threads if we've fallen below the low
// water mark.
// Dequeue and return the <ACE_Message_Block *> at the head of the
// logical queue.  Attempts first to dequeue from the pending portion
// of the queue, or if that is empty from the late portion, or if that
// is empty from the beyond late portion, or if that is empty just
// sets the passed pointer to zero and returns -1.
// Refresh the queue using the strategy specific priority status
// function.
// refresh priority status boundaries in the queue
// Make sure the head of the beyond late queue is set (there
// may not have been any beyond late messages previously)
// Zero out the late queue pointers, and set them only if
// there turn out to be late messages in the pending sublist
// Advance through the beyond late messages in the pending queue
// do while
// point tail of beyond late sublist to previous item
// there are no late messages left in the queue
// switch
// if we got here, something is *seriously* wrong with the queue
/* FALLTHRU */
// There are no pending or late messages left in the
// queue.
// switch
// Make sure the head of the late queue is set (there may
// not have been any late messages previously, or they may
// have all become beyond late).
// advance through the beyond late messages in the pending queue
// do while
// if we got here, something is *seriously* wrong with the queue
// Point tail of late sublist to previous item
// there are no pending messages left in the queue
// switch
// do nothing - the pending queue is unchanged
// switch
// if we got here, something is *seriously* wrong with the queue
// Refresh the pending queue using the strategy specific priority
// status function.
// make sure the head of the beyond late queue is set
// (there may not have been any beyond late messages previously)
// advance through the beyond late messages in the late queue
// do while
// point tail of beyond late sublist to previous item
// there are no late messages left in the queue
// if we got here, something is *seriously* wrong with the queue
// there are no late messages left in the queue
// switch
// do nothing - the late queue is unchanged
// switch
// if we got here, something is *seriously* wrong with the queue
// if we got here, something is *seriously* wrong with the queue
// Refresh the late queue using the strategy specific priority status
// function.
// Private method to hide public base class method: just calls base
// class method.
// Just call priority enqueue method: tail enqueue semantics for
// dynamic message queues are unstable: the message may or may not be
// where it was placed after the queue is refreshed prior to the next
// enqueue or dequeue operation.
// Just call priority enqueue method: head enqueue semantics for
// dynamic message queues are unstable: the message may or may not be
// where it was placed after the queue is refreshed prior to the next
// enqueue or dequeue operation.
// Factory method for a statically prioritized ACE_Message_Queue.
// Factory method for a dynamically prioritized (by time to deadline)
// ACE_Dynamic_Message_Queue.
// Factory method for a dynamically prioritized (by laxity)
// <ACE_Dynamic_Message_Queue>.
// factory method for a wrapped VxWorks message queue
/* defined (ACE_VXWORKS) */
/* ACE_HAS_WIN32_OVERLAPPED_IO */
/* !ACE_MESSAGE_QUEUE_T_CPP */
/* __ACE_INLINE__ */
////////////////////////////////
// class ACE_Message_Queue_Vx //
////////////////////////////////
/* ACE_HAS_DUMP */
// Don't bother locking since if someone calls this function more than
// once for the same queue, we're in bigger trouble than just
// concurrency control!
// Had already created a msgQ, so delete it.
// Clean up the queue if we have not already done so!
// Don't lock, because we don't have a lock.  It shouldn't be
// necessary, anyways.
// Don't bother to free up the remaining message on the list,
// because we don't have any way to iterate over what's in the
// queue.
// Don't need to guard, because this is fixed.
// Don't need to guard, because this is a system call.
// No-op.
// No-op.
// Don't try to send a composite message!!!!  Only the first
// block will be sent.
// Always use this method to actually send a message on the queue.
// Just delegate to enqueue_tail_i.
// Should always take this branch.
// Just delegate to enqueue_tail_i.
// Actually get the first ACE_Message_Block (no locking, so must be
// called with locks held).  This method assumes that the queue has at
// least one item in it when it is called.
// We don't allocate a new Message_Block:  the caller must provide
// it, and must ensure that it is big enough (without chaining).
/*dequeued*/)
/*dequeued*/)
/*dequeued*/)
// Take a look at the first item without removing it.
// Always return here, and let the VxWorks message queue handle blocking.
// Always return here, and let the VxWorks message queue handle blocking.
/* ACE_VXWORKS */
//#define ACE_BUILD_DLL
/* __ACE_INLINE__ */
/// Const strings for timeprobe event type descriptions.
/////////////////////////////////
// class ACE_Metrics_Timeprobe //
/////////////////////////////////
// Returns true if a timeprobe matches the passed id.
// Flush the ACE metrics timeprobe into shared memory.
/////////////////////////////
// Class ACE_Metrics_Cache //
/////////////////////////////
// Constructor.
// Initialize probe and count arrays.
// Ensure that the high res timer global scale factor
// is set before any of its static methods are used
// Destructor.
// Obtain an allocator pointer correctly thunked for the current
// address space.  If there is no allocator stored in the instance,
// the singleton allocator in the current process is used.
// Flush the ACE metrics cache into shared memory.
/* defined (ACE_COMPILE_TIMEPROBES) */
/* ACE_METRICS_CACHE_CPP */
// MMAP_Memory_Pool.cpp
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1  */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/// Sync @a len bytes of the memory region to the backing store starting
/// at <addr_>.
// Change the protection of the pages of the mapped region to <prot>
// starting at <this->base_addr_> up to <len> bytes.
// Change protection of all pages in the mapped region.
// Change the protection of the pages of the mapped region to <prot>
// starting at <addr> up to <len> bytes.
// For plaforms that give the faulting address.
// For plaforms that do NOT give the faulting address, let the
// options decide whether to guess or not.
// If no options are specified, default to true.
/* (defined (ACE_HAS_SIGINFO_T) && !defined (ACE_LACKS_SI_ADDR)) || defined (ACE_WIN32) */
// Only change the defaults if <options> != 0.
// Only create a new unique filename for the backing store file
// if the user didn't supply one...
// Create a temporary file.
/* ACE_DEFAULT_BACKING_STORE */
// -17 for ace-malloc-XXXXXX
// Add the filename to the end
// If requested an unique filename, use mktemp to get a random file.
/* ACE_DISABLE_MKTEMP */
/* ACE_DEFAULT_BACKING_STORE */
/* ACE_WIN32 */
// Compute the new map_size of the backing store and commit the
// memory.
// Write to the end of every block to ensure that we have enough
// space in the backing store.
// round_up(1) is one page.
// We're willing to risk it all in the name of efficiency...
// The following loop will execute multiple times (if
// this->write_each_page == 1) or just once (if
// this->write_each_page == 0).
// Increment by one to put us at the beginning of the next chunk...
/* __Lynx__ */
// Memory map the file up to <map_size> bytes.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Unmap the existing mapping.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Remap the file; try to stay at the same location as a previous mapping
// but do not force it with MAP_FIXED. Doing so will give the OS permission
// to map locations currently holding other things (such as the heap, or
// the C library) into the map file, producing very unexpected results.
// WinCE does not allow users to specify alloc addr.
// ACE_HAS_WINCE
/* 0 */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Ask operating system for more shared memory, increasing the mapping
// accordingly.  Note that this routine assumes that the appropriate
// locks are held when it is called.
// ACELIB_DEBUG ((LM_DEBUG, "(%P|%t) acquiring more chunks, nbytes =
// %B, rounded_bytes = %B\n", nbytes, rounded_bytes));
// ACELIB_DEBUG ((LM_DEBUG, "(%P|%t) acquired more chunks, nbytes = %B,
// rounded_bytes = %B, map_size = %B\n", nbytes, rounded_bytes,
// map_size));
// Ask system for initial chunk of shared memory.
// First time in, so need to acquire memory.
// After the first time, reset the flag so that subsequent calls
// will use MAP_FIXED
// Reopen file *without* using O_EXCL...
// After the first time, reset the flag so that subsequent calls
// will use MAP_FIXED
// Update the mapped segment information
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/* ACE_WIN32 */
//  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("Remapping with fault address at: %@\n"), addr));
// ACE_OS::lseek (this->mmap_.handle (), 0, SEEK_END);
// Extend the mapping to cover the size of the backing store.
// for backwards compatibility
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) new mapping address = %@\n"), (char *) this->base_addr_ + current_map_size));
// Make sure that the pointer causing the problem is within the
// range of the backing store.
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) si_signo = %d, si_code = %d, addr = %@\n"), siginfo->si_signo, siginfo->si_code, siginfo->si_addr));
// ACELIB_ERROR_RETURN ((LM_ERROR, "(%P|%t) address %@ out of range\n",
// siginfo->si_addr), -1);
/* ACE_HAS_SIGINFO_T && !defined ACE_LACKS_SI_ADDR */
// If guess_on_fault_ is true, then we want to try to remap without
// knowing the faulting address.  guess_on_fault_ can only be true
// on platforms that do not provide the faulting address through
// signals or exceptions.  We check to see if the mapping is up to
// date. If it is, then this fault isn't due to this mapping and we
// pass it on.
// Check if the current mapping is up to date.
// The mapping is up to date so this really is a bad
// address.  Thus, remove current signal handler so process
// will fail with default action and core file will be
// written.
// Extend the mapping to cover the size of the backing store.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
/* = M_DELETE_WRITER */)
// Close and maybe delete old writer
// Set the q's module pointer to point to us.
// Don't allow the caller to change the reader status.
/* = M_DELETE_READER */)
// Close and maybe delete old writer
// Set the q's module pointer to point to us.
// don't allow the caller to change the reader status
// Link this ACE_Module on top of ACE_Module M.
/* = M_DELETE */)
// We may already have readers and/or writers.
// Make sure that the memory is allocated before proceeding.
// These calls will delete writer_q and/or reader_q, if
// necessary.
// Save the flags
// Setup back pointers (this must come last, after we've made sure
// there's memory allocated here.
// Set and get pointer to sibling ACE_Task in ACE_Module.
// Do nothing...
// Only close down if we haven't already done so.
/* = M_DELETE */)
/* = M_DELETE_NONE */)
// Only pay attention to the flags parameter if we haven't already
// set the task delete policies.
// Copy task pointer to prevent problems when ACE_Task::close
// changes the task pointer
// Change so that close doesn't get called again from the task base.
// Now close the task.
// Should we also delete it ?
// Only delete the Tasks if there aren't any more threads
// running in them.
// If this assert happens it is likely because the task was
// activated with the THR_DETACHED flag, which means that we
// can't join() with the thread.  Not using THR_DETACHED should
// solve this problem.
// Set the tasks pointer to 0 so that we don't try to close()
// this object again if the destructor gets called.
// Finally remove the delete bit.
/* ACE_MODULE_CPP */
/* current_time */,
//====================================================================
/// Destroys the timers associated with our event handler
/// before its destructor is called.
/// We access the registry through ACE_Singleton, which
/// doesn't call the destructor, so we call this method to
/// do a remove_ref() on all monitor points left in the registry.
/// which needs to be done before the registry goes away.
/// This call checks for a null monitor_point.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/// Overridden in derived classes.
/// Thread-safe and guaranteed to be unique.
/// This is thread-safe on its own so we don't have
/// to guard it here.
/// Since we know external key is unique,
/// we don't check for failure.
// (JP) There is a problem with this failing on a single ACE_Message_Queue
//      monitor per process. I think it is the message queue associated
//      with the default reactor, maybe because at that low level, ACE
//      is using malloc with placement, then free, which may bypass the
//      normal destructors. In any case, it happens only at shutdown
//      and there seems to be no memory leak.
//          ACELIB_ERROR ((LM_ERROR,
//                      "monitor point %s unregistration failed\n",
//                      this->name ()));
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
//=============================================================
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// Temporary debugging code.
//        ACELIB_DEBUG ((LM_DEBUG, "adding %s\n", type->name ()));
/// Temporary debugging code.
//        ACELIB_DEBUG ((LM_DEBUG, "removing %s\n", name_str.c_str ()));
// (JP) There is a problem with this failing on a single ACE_Message_Queue
//      monitor per process. I think it is the message queue associated
//      with the default reactor, maybe because at that low level, ACE
//      is using malloc with placement, then free, which may bypass the
//      normal destructors. In any case, it happens only at shutdown
//      and there seems to be no memory leak.
//          ACELIB_ERROR_RETURN ((LM_ERROR,
//                             "registry remove: unbind failed for %s\n",
//                             name),
//                            false);
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
// No platform-specific or periodic code is needed, receive() can be
// called directly whenever the size changes.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* __ACE_INLINE__ */
/* __ACE_INLINE__ */
// Wait for any of handles_ to be active, or until timeout expires.
// If <alertable> is enabled allow asynchronous completion of
// ReadFile and WriteFile operations. QS_ALLINPUT allows
// <MsgWaitForMultipleObjectsEx> to wait for any message is in the
// queue.
// Process all pending message from this thread's message queue
// Should inform the main thread
/* ACE_WIN32 && !ACE_LACKS_MSG_WFMO */
// Extends ACE_INET_Addr with support for multi-homed addresses.
/* __ACE_INLINE__ */
// Default constructor
// Initialize the primary INET addr
// check for secondary INET addrs
// we have a non-zero pointer and size
// size the array
// Initialize the primary INET addr
// check for secondary INET addrs
// we have a non-zero pointer and size
// size the array
/* ACE_HAS_WCHAR */
// Initialize the primary INET addr
// check for secondary INET addrs
// we have a non-zero pointer and size
// size the array
// Set implementations  (NEED BETTER COMMENT HERE)
//
// WCHAR version of ::set
//
/* ACE_HAS_WCHAR */
// Copy primary address(es) to the first slot(s) of the user-supplied array
// Copy secondary addresses to remaining slots of the user-supplied
// array.  Secondary address [i] is copied to slot [i+1]
// Copy primary address(es) to the first slot(s) of the user-supplied array
// Copy secondary addresses to remaining slots of the user-supplied
// array.  Secondary address [i] is copied to slot [i+1]
/* ACE_HAS_IPV6 */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Mutex::dump");
/* ACE_MUTEX_USE_PROCESS_LOCK */
/* ACE_HAS_DUMP */
/* ACE_MUTEX_USE_PROCESS_LOCK */
// ACE_TRACE ("ACE_Mutex::ACE_Mutex");
// These platforms need process-wide mutex to be in shared memory.
// Let's see if the shared memory entity already exists.
// We own this shared memory object!  Let's set its size.
/* ACE_HAS_ALLOC_HOOKS */
/*mutex unlocked*/,
/* ACE_MUTEX_PROCESS_LOCK_IS_MUTEX */
// ACE_TRACE ("ACE_Mutex::~ACE_Mutex");
/* ACE_HAS_DUMP */
// Default constructor.
// Establish binding with the ACE_Name Server at remote_addr.
// Initiate the connection.
// Establish binding with the ACE_Name Server at remote_addr.
// Obtain underlying handle.
/* VIRTUAL */ ACE_HANDLE
// Transmit request via a blocking send.
// Receive reply via blocking read.
// Transmit request via a blocking send.
// Read the first 4 bytes to get the length of the message This
// implementation assumes that the first 4 bytes are the length of
// the message.
// FALLTHROUGH
// FALLTHROUGH
// We've shutdown unexpectedly
// NOTREACHED
// Transform the length into host byte order.
// Receive the rest of the request message.
// @@ beware of blocking read!!!.
// Subtract off the size of the part we skipped over...
// Decode the request into host byte order.
// Close down the connection to the server.
// Default "do nothing" constructor.
// Create a ACE_Name_Request message.
// Type of request.
// Name
// size in bytes
//
// size in bytes
//
// size in bytes
// Max time waiting for request.
// If timeout is a NULL pointer, then block forever...
// Do a "timed wait."
// Keep track of how long client is willing to wait.
// Set up pointers and copy name value and type into request.
//
// Compute size of the fixed portion of the message...
// ... then add in the amount of the variable-sized portion.
// Initialize length_ in order to avoid problems with byte-ordering.
// = Set/get the length of the encoded/decoded message.
// = Set/get the type of the message.
// = Set/get the len of the name
// = Set/get the len of the value
// = Set/get the len of the type
// = Set/get the blocking semantics.
// = Set/get the timeout.
// = Set/get the name
// = Set/get the value
// = Set/get the type
// Encode the transfer buffer into network byte order so that it can
// be sent to the server.
// Compute the length *before* doing the marshaling.
// Decode the transfer buffer into host byte byte order so that it can
// be used by the server.
// Decode the fixed-sized portion first.
// Decode the variable-sized portion.
// Print out the current values of the ACE_Name_Request.
/* ! ACE_NLOGGING */
/* ACE_HAS_DUMP */
// Default constructor.
// Initialize to a known quantity.
// Create a ACE_Name_Reply message.
// Type of reply.
// Initialize length_ to avoid problems with byte-ordering.
// = Set/get the length of the encoded/decoded message.
// = Set/get the type of the message.
// Get the status of the reply (0 == success, -1 == failure).
// Set the status of the reply (0 == success, -1 == failure).
// = Set/get the errno of a failed reply.
// Encode the transfer buffer into network byte order
// so that it can be sent to the client.
// Get length *before* marshaling.
// Decode the transfer buffer into host byte order so that it can be
// used by the client.
// Print out current values of the ACE_Name_Reply object.
/* ACE_HAS_DUMP */
// Name_Space.cpp
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_TRACE */
/* __ACE_INLINE__ */
// Make life easier later on...
// The ACE_Naming_Context static service object is now defined
// by the ACE_Object_Manager, in Object_Manager.cpp.
// Perform factory operation to select appropriate type of
// Name_Space subclass.
// This only works on Win32 platforms when ACE_USES_WCHAR is turned on
// Use ACE_Registry
/* ACE_WIN32 && ACE_USES_WCHAR */
// Use NET_LOCAL name space, set up connection with remote server.
// Use NODE_LOCAL or PROC_LOCAL name space.
// Initialize.
// Note that <char_rep> *allocates* the memory!  Thus, caller is
// responsible for deleting it!
/* ACE_HAS_DUMP */
/* ACE_DEFAULT_NAMESPACE_DIR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_DEFAULT_NAMESPACE_DIR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Argc can be 0 on some platforms like VxWorks.
// Default is to use the PROC_LOCAL context...
// Make the database name the same as the process name by default
// (note that this makes a copy of the process_name_ so that we can
// clean it up in the destructor).
/* ACE_HAS_TRACE */
/* NOTREACHED */
// The following Factory is used by the ACE_Service_Config and
// svc.conf file to dynamically initialize the state of the Name
// Server client.
//=============================================================================
/**
//=============================================================================
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// Copy constructor.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_PRAGMA_ONCE */
// ACE_TRACE ("ACE_Node<T, C>::ACE_Node");
// ACE_TRACE ("ACE_Node<T, C>::ACE_Node");
// ACE_TRACE ("ACE_Node<T, C>::ACE_Node");
/* ACE_NODE_CPP */
/* __ACE_INLINE__ */
// Release all the event handlers still in the queue ...
// ... free up the dynamically allocated resources ...
// ... cleanup the list of allocated blocks ...
// ... swap with empty lists to reset the contents ...
// Easy case, skip to the next node
// ... another easy case, skip this node too, but clear the
// mask first ...
// ... this is the more complicated case, we want to remove the
// node from the notify_queue_ list.  First save the next node
// on the list:
// ... then remove it ...
// ... release resources ...
// ... now this is a free node ...
// ... go to the next node, if there is one ...
// No pending notifications.
/* __ACE_INLINE __ */
/* __ACE_INLINE__ */
// ACE_NT_Service destructor.
// This default implementation of ACE_NT_Service::open sets the
// service's status to START_PENDING with the estimated time until
// STARTED set to the value given when this object was constructed.
// Then the svc function is called, which implements the guts of the
// service.  Note that this function is running in a thread created by
// the OS, not by ACE_Thread_Manager.  The thread manager does not
// know anything about this thread.  The service can, however, use
// ACE_Thread_Manager to start more threads if desired.  When the svc
// function returns, the service status is set to STOPPED, and exit
// codes set based on errno/GetLastError if the svc function returns
// -1.
//
// The svc function is expected to set the service status to SERVICE_RUNNING
// after it initializes.
//
// The handle_control function will be called for each time there is a
// request for the service.  It is up to that function and svc to
// cooperate to both respond appropriately to the request (by at least
// updating the service's status) and to fulfill the request.
/* how to cancel? */
// Insure ACE_OS::last_error finds GetLastError unless we set errno.
// Make sure that this_exe is quoted
// If there was an error, stash GetLastError before CloseServiceHandle
// smashes it. ACE_OS::last_error will find the saved error value.
// Sets the startup type for the service.  Returns -1 on error, 0 on
// success.
// No change to service type
// New startup type
// No change to error ctrl
// No change to pathname
// No change to load group
// No change to tag
// No change to dependencies
// No change to acct/passwd
// No change to name
// Returns the current startup type.
// The query buffer will hold strings as well as the defined struct.
// The string pointers in the struct point to other areas in the
// passed memory area, so it has to be large enough to hold the
// struct plus all the strings.
// To distinguish this error from the QueryServiceConfig failure
// below, return the DWORD equivalent of -2, rather than -1.
// Zero is a valid return value for QueryServiceConfig, so if
// QueryServiceConfig fails, return the DWORD equivalent of -1.
// There's no thread descriptor involved with a NT-started
// thread, so the first arg is 0.
// Need to create a temporary copy of this variable since the
// QueryServiceStatus call will modify the setting depending on the
// current state of the Service.  If the service is currently
// STOPPED, the value will be cleared.
// test_access
//
// Open a new handle, ignoring any handle open in svc_sc_handle_.
// This function's results are returned without leaving the handle
// open.
// Guilty until proven innocent
// report_status
//
// Reports the current status.  If new_status is not 0, it sets the
// status to the new value before reporting.  NOTE - this assumes that
// no actual service status values have the value 0.  This is true in
// WinNT 4.  If the status is a 'pending' type, the supplied time hint
// is used unless it's 0, in which case the existing hint is used.
// The dwWaitHint is not updated by this function.  The checkpoint is
// incremented by one after a pending report.
/* Fall through */
// Poll until the service reaches the desired state.
// If we cannot query the service, we are done.
// If the service has the desired state, we are done.
// If we time-out, we are done
// remember the service state, the first time we wait
// update the state change.
// The check-point should have increased
// Service control failure, we are done.
/* ACE_WIN32 && !ACE_LACKS_WIN32_SERVICES */
/**
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ! ACE_LACKS_ACE_TOKEN */
/* ! ACE_LACKS_ACE_SVCCONF */
/* ACE_HAS_TRACE */
/* __ACE_INLINE__ */
// ACE_DISABLE_WIN32_ERROR_WINDOWS
/* ACE_APPLICATION_PREALLOCATED_OBJECT_DEFINITIONS */
/* ACE_APPLICATION_PREALLOCATED_ARRAY_DEFINITIONS */
/* ACE_APPLICATION_PREALLOCATED_OBJECT_DELETIONS */
/* ACE_APPLICATION_PREALLOCATED_ARRAY_DELETIONS */
// Note the following fix was derived from that proposed by Jochen Kalmbach
// http://blog.kalmbachnet.de/?postid=75
/*lpTopLevelExceptionFilter*/)
// ACE_DISABLE_WIN32_ERROR_WINDOWS
// Singleton pointer.
// Handy macros for use by ACE_Object_Manager constructor to
// preallocate or delete an object or array, either statically (in
// global data) or dynamically (on the heap).
/* ACE_HAS_STATIC_PREALLOCATION */
/**
// Initialize the static service objects using the descriptors created
// above.
// Add to the list of static configured services.
/* ! ACE_LACKS_ACE_SVCCONF */
// Instead of popping up a window for exceptions, just print something out
/* ACE_DISABLE_WIN32_ERROR_WINDOWS */
// Initialize an ACE_Object_Manager.  There can be instances of this object
// other than The Instance.  This can happen if a user creates one for some
// reason.  All objects set up their per-object information and managed
// objects, but only The Instance sets up the static preallocated objects and
// the (static) ACE_Service_Config signal handler.
// First, indicate that the ACE_Object_Manager instance is being
// initialized.
// Only The Instance sets up with ACE_OS_Object_Manager and initializes
// the preallocated objects.
// Make sure that the ACE_OS_Object_Manager has been created,
// and register with it for chained fini ().
/* ACE_HAS_BUILTIN_ATOMIC_OP */
// Construct the ACE_Service_Config's signal handler.
/* ! ACE_LACKS_ACE_SVCCONF */
// Allocate the preallocated (hard-coded) object instances.
/* ACE_HAS_THREADS */
/* ! ACE_LACKS_ACE_TOKEN && ACE_HAS_TOKENS_LIBRARY */
/* ACE_MT_SAFE */
// Hooks for preallocated objects and arrays provided by application.
// Initialize the main thread's TS storage.
/* ACE_HAS_TSS_EMULATION */
/* _DEBUG && _MSC_VER || __INTEL_COMPILER || __MINGW32__ */
// The system does not display the critical-error-handler message box
// And this will catch all unhandled exceptions.
// VC++ 8.0 and above
// And this will stop the abort system call from being treated as a crash
// Note the following fix was derived from that proposed by Jochen Kalmbach
// http://blog.kalmbachnet.de/?postid=75
// See also:
// http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337
//
// Starting with VC8 (VS2005), Microsoft changed the behaviour of the CRT in some
// security related and special situations. The are many situations in which our
// ACE_UnhandledExceptionFilter will never be called. This is a major change to
// the previous versions of the CRT and is not very well documented.
// The CRT simply forces the call to the default-debugger without informing the
// registered unhandled exception filter. Jochen's solution is to stop the CRT
// from calling SetUnhandledExceptionFilter() after we have done so above.
// NOTE this only works for intel based windows builds.
// VC++ 8.0 and above || MingW32 >= 3.15
// add 5 for 5 op-codes for jmp far
// JMP absolute
// _M_IX86
// (_MSC_VER >= 1400) // VC++ 8.0 and above.
/* ACE_DISABLE_WIN32_ERROR_WINDOWS */
/* ! ACE_LACKS_ACE_SVCCONF */
// Open the main thread's ACE_Log_Msg.
// Finally, indicate that the ACE_Object_Manager instance has
// been initialized.
// Allow tracing again (useful if user does init/fini/init)
/* ACE_HAS_TRACE */
// Had already initialized.
// With ACE_HAS_TSS_EMULATION, ts_storage_ is initialized by the call to
// ACE_OS::tss_open () in the function body.
/* ! ACE_LACKS_ACE_SVCCONF */
/* ACE_MT_SAFE */
/* ACE_MT_SAFE */
// If instance_ was not 0, then another ACE_Object_Manager has
// already been instantiated (it is likely to be one initialized by way
// of library/DLL loading).  Let this one go through construction in
// case there really is a good reason for it (like, ACE is a static/archive
// library, and this one is the non-static instance (with
// ACE_HAS_NONSTATIC_OBJECT_MANAGER, or the user has a good reason for
// creating a separate one) but the original one will be the one retrieved
// from calls to ACE_Object_Manager::instance().
// Be sure that no further instances are created via instance ().
// Don't delete this again in fini()
// This function should be called during construction of static
// instances, or before any other threads have been created in
// the process.  So, it's not thread safe.
// The object has already been registered.
// The preallocated lock has not been constructed yet.
// Therefore, the program is single-threaded at this point.  Or,
// the ACE_Object_Manager instance has been destroyed, so the
// preallocated lock is not available.  Allocate a lock to use,
// for interface compatibility, though there should be no
// contention on it.
// Can't register with the ACE_Object_Manager here!  The
// lock's declaration is visible to the ACE_Object_Manager
// destructor, so it will clean it up as a special case.
// Use the Object_Manager's preallocated lock.
// The Object_Manager and its internal lock have not been
// constructed yet.  Therefore, the program is single-
// threaded at this point.  Or, the ACE_Object_Manager
// instance has been destroyed, so the internal lock is not
// available.  Either way, we can not use double-checked
// locking.  So, we'll leak the lock.
// Allocate a new lock, but use double-checked locking to
// ensure that only one thread allocates it.
// Register the lock for destruction at program
// termination.  This call will cause us to grab the
// ACE_Object_Manager::instance ()->internal_lock_
// again; that's why it is a recursive lock.
// The Object_Manager and its internal lock have not been
// constructed yet.  Therefore, the program is single-
// threaded at this point.  Or, the ACE_Object_Manager
// instance has been destroyed, so the internal lock is not
// available.  Either way, we can not use double-checked
// locking.  So, we'll leak the lock.
// Allocate a new lock, but use double-checked locking to
// ensure that only one thread allocates it.
// Register the lock for destruction at program
// termination.  This call will cause us to grab the
// ACE_Object_Manager::instance ()->internal_lock_
// again; that's why it is a recursive lock.
// The preallocated lock has not been constructed yet.
// Therefore, the program is single-threaded at this point.  Or,
// the ACE_Object_Manager instance has been destroyed, so the
// preallocated lock is not available.  Allocate a lock to use,
// for interface compatibility, though there should be no
// contention on it.
// Can't register with the ACE_Object_Manager here!  The lock's
// declaration is visible to the ACE_Object_Manager destructor,
// so it will clean it up as a special case.
// Use the Object_Manager's preallocated lock.
// The Object_Manager and its internal lock have not been
// constructed yet.  Therefore, the program is single-
// threaded at this point.  Or, the ACE_Object_Manager
// instance has been destroyed, so the internal lock is not
// available.  Either way, we can not use double-checked
// locking.  So, we'll leak the lock.
// Allocate a new lock, but use double-checked locking to
// ensure that only one thread allocates it.
// Register the lock for destruction at program
// termination.  This call will cause us to grab the
// ACE_Object_Manager::instance ()->internal_lock_
// again; that's why it is a recursive lock.
/* ACE_MT_SAFE */
// Clean up an ACE_Object_Manager.  There can be instances of this object
// other than The Instance.  This can happen if (on Win32) the ACE DLL
// causes one to be created, or if a user creates one for some reason.
// Only The Instance cleans up the static preallocated objects.  All objects
// clean up their per-object information and managed objects.
// Too late.  Or, maybe too early.  Either fini () has already
// been called, or init () was never called.
// No mutex here.  Only the main thread should destroy the singleton
// ACE_Object_Manager instance.
// Indicate that this ACE_Object_Manager instance is being
// shut down.
// Call all registered cleanup hooks, in reverse order of
// registration.
/* ! ACE_LACKS_ACE_SVCCONF */
/* ACE_HAS_TRACE */
// Close and possibly delete all service instances in the Service
// Repository.
// Unlink all services in the Service Repository and close/delete
// all ACE library services and singletons.
/* ! ACE_LACKS_ACE_SVCCONF */
// This must come after closing ACE_Service_Config, since it will
// close down it's dlls--it manages ACE_DLL_Manager.
/* ! ACE_THREAD_MANAGER_LACKS_STATICS */
// Close the main thread's TSS, including its Log_Msg instance.
/* main thread */);
//
// Note:  Do not access Log Msg after this since it is gone
//
// Close the ACE_Allocator.
// Hooks for deletion of preallocated objects and arrays provided by
// application.
// Cleanup the dynamically preallocated arrays.
// (none)
// Cleanup the dynamically preallocated objects.
/* ACE_HAS_THREADS */
/* ! ACE_LACKS_ACE_TOKEN && ACE_HAS_TOKENS_LIBRARY */
/* ACE_MT_SAFE */
/* ! ACE_HAS_STATIC_PREALLOCATION */
/* ACE_HAS_THREADS */
/* ! ACE_LACKS_ACE_SVCCONF */
/* ACE_MT_SAFE */
// Indicate that this ACE_Object_Manager instance has been shut down.
// Then, ensure that the ACE_OS_Object_Manager gets shut down.
/**
/// Save the main thread ID, so that destruction can be suppressed.
// Ensure that the Object_Manager gets initialized before any
// application threads have been spawned.  Because this will be called
// during construction of static objects, that should always be the
// case.
// else if this destructor is not called by the main thread, then do
// not delete the ACE_Object_Manager.  That causes problems, on
// WIN32 at least.
/* ! ACE_HAS_NONSTATIC_OBJECT_MANAGER */
// This is global so that it doesn't have to be declared in the header
// file.  That would cause nasty circular include problems.
// ACE_SHOULD_MALLOC_STATIC_OBJECT_LOCK isn't (currently) used by ACE.
// But, applications may find it useful for avoiding recursive calls
// if they have overridden operator new.  Thanks to Jody Hagins
// <jody@atdesk.com> for contributing it.
// The preallocated ACE_STATIC_OBJECT_LOCK has not been
// constructed yet.  Therefore, the program is single-threaded
// at this point.  Or, the ACE_Object_Manager instance has been
// destroyed, so the preallocated lock is not available.
// Allocate a lock to use, for interface compatibility, though
// there should be no contention on it.
// Allocate a buffer with malloc, and then use placement
// new for the object, on the malloc'd buffer.
// do not use ACE_NEW macros for placement new
/* ! ACE_SHOULD_MALLOC_STATIC_OBJECT_LOCK */
/* ! ACE_SHOULD_MALLOC_STATIC_OBJECT_LOCK */
// Can't register with the ACE_Object_Manager here!  The lock's
// declaration is visible to the ACE_Object_Manager destructor,
// so it will clean it up as a special case.
// Return the preallocated ACE_STATIC_OBJECT_LOCK.
// It was malloc'd, so we need to explicitly call the dtor
// and then free the memory.
/* ! ACE_SHOULD_MALLOC_STATIC_OBJECT_LOCK */
/* ! ACE_SHOULD_MALLOC_STATIC_OBJECT_LOCK */
/* ACE_HAS_THREADS */
/* ACE_HAS_ALLOC_HOOKS */
// this is only windows and only used here,
// defined in ace/config-win32-common.h.
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_ALLOC_HOOKS */
// Clear the flag so that fini () doesn't delete again.
/* ACE_HAS_NONSTATIC_OBJECT_MANAGER */
/*****************************************************************************/
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// If instance_ was not 0, then another ACE_OS_Object_Manager has
// already been instantiated (it is likely to be one initialized by
// way of library/DLL loading).  Let this one go through
// construction in case there really is a good reason for it (like,
// ACE is a static/archive library, and this one is the non-static
// instance (with ACE_HAS_NONSTATIC_OBJECT_MANAGER, or the user has
// a good reason for creating a separate one) but the original one
// will be the one retrieved from calls to
// ACE_Object_Manager::instance().
// Be sure that no further instances are created via instance ().
// Don't delete this again in fini()
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// This function should be called during construction of static
// instances, or before any other threads have been created in the
// process.  So, it's not thread safe.
// I (coryan) removed it, using asserts in the OS layer
// brings down the Log msg stuff
// ACE_ASSERT (instance_pointer == instance_);
// First, indicate that this ACE_OS_Object_Manager instance is being
// initialized.
/* ACE_HAS_WINCE_BROKEN_ERRNO */
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
/* ACE_HAS_TSS_EMULATION */
/* ACE_MT_SAFE */
// Open Winsock (no-op on other platforms).
// Register the exit hook, for use by ACE_OS::exit ().
/* ACE_HAS_ALLOC_HOOKS */
// Finally, indicate that the ACE_OS_Object_Manager instance has
// been initialized.
/* Since MS found it necessary to deprecate these. */
/* __clang__ */
/* __clang__ */
/* ACE_WIN32 */
// Had already initialized.
// Clean up an ACE_OS_Object_Manager.  There can be instances of this object
// other than The Instance.  This can happen if a user creates one for some
// reason.  All objects clean up their per-object information and managed
// objects, but only The Instance cleans up the static preallocated objects.
// Too late.  Or, maybe too early.  Either fini () has already
// been called, or init () was never called.
// No mutex here.  Only the main thread should destroy the singleton
// ACE_OS_Object_Manager instance.
// Indicate that the ACE_OS_Object_Manager instance is being shut
// down.  This object manager should be the last one to be shut
// down.
// If another Object_Manager has registered for termination, do it.
// Protect against recursive calls.
// Call all registered cleanup hooks, in reverse order of
// registration.
// Only clean up preallocated objects when the singleton Instance is being
// destroyed.
// Close down Winsock (no-op on other platforms).
// Cleanup the dynamically preallocated objects.
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ! ACE_HAS_BROKEN_PREALLOCATED_OBJECTS_AFTER_FORK */
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ! ACE_HAS_BROKEN_PREALLOCATED_OBJECTS_AFTER_FORK */
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ! ACE_HAS_BROKEN_PREALLOCATED_OBJECTS_AFTER_FORK */
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ! ACE_HAS_BROKEN_PREALLOCATED_OBJECTS_AFTER_FORK */
// This line must not be broken to avoid tickling a bug with SunC++'s preprocessor.
/* ! ACE_HAS_BROKEN_PREALLOCATED_OBJECTS_AFTER_FORK */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_WINCE_BROKEN_ERRNO */
/* ACE_MT_SAFE */
/* ! ACE_HAS_STATIC_PREALLOCATION */
/* ACE_HAS_ALLOC_HOOKS */
// Indicate that this ACE_OS_Object_Manager instance has been shut down.
// To avoid duplication of these const strings in OS.o.
/* ACE_LACKS_PERROR */
// @@ Need to use the following information.
// Default language
/*****************************************************************************/
/**
/// Constructor.
/// Destructor.
/// Save the main thread ID, so that destruction can be suppressed.
// Ensure that the Object_Manager gets initialized before any
// application threads have been spawned.  Because this will be called
// during construction of static objects, that should always be the
// case.
// else if this destructor is not called by the main thread, then do
// not delete the ACE_OS_Object_Manager.  That causes problems, on
// WIN32 at least.
/* ! ACE_HAS_NONSTATIC_OBJECT_MANAGER */
// -*- C++ -*-
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// normalize the length.
// Check to see if there's room for the requested length, including
// any part of an existing string, if any.
// Increase the length of the underlying chunks if the request made is
// for bigger sized chunks.
// We now know the request will fit; see if it can fit in the current
// chunk or will need a new one.
// Need a new chunk. Save the current one so the current string
// can be copied to the new chunk.
// We must allocate new memory.
// We can reuse previously allocated memory.
// Copy any initial characters to the new chunk.
// Reset the old chunk.
/* ACE_OBSTACK_T_CPP */
// -*- C++ -*-
// Inlining this class on debug builds with gcc on Solaris can cause
// deadlocks during static initialization. On non debug builds it
// causes compilation errors.
/* ACE_INLINE */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_WINCE_BROKEN_ERRNO */
/* ACE_HAS_INLINED_OSCALLS */
/* ! ACE_HAS_MINIMAL_ACE_OS */
// Rename "main ()" on platforms that don't allow it to be called "main ()".
// Also, create ACE_Object_Manager static instance(s) in "main ()".
// ACE_MAIN_OBJECT_MANAGER defines the ACE_Object_Manager(s) that will
// be instantiated on the stack of main ().  Note that it is only used
// when compiling main ():  its value does not affect the contents of
// ace/OS.o.
/* ! ACE_MAIN_OBJECT_MANAGER */
/* forward declaration */
/* user's entry point, e.g., main */
/* what the user calls "main" */
/* !ACE_VXWORKS && !__RTP__ */
/* user's entry point, e.g., main */
/* what the user calls "main" */
/* user's entry point, e.g., main */
/* what the user calls "main" */
/* ! (ACE_WIN32 && ACE_USES_WCHAR) */
/* user's entry point, e.g., main */
/* what the user calls "main" */
/* ACE_WIN32 && ACE_USES_WCHAR */
/* ACE_HAS_WINCE */
// CE only gets a command line string;  no argv. So we need to convert it
// when the main entrypoint expects argc/argv. ACE_ARGV supports this.
/* !ACE_HAS_WINCE */
/* ACE_HAS_NONSTATIC_OBJECT_MANAGER && !ACE_HAS_WINCE && !ACE_DOESNT_INSTANTIATE_NONSTATIC_OBJECT_MANAGER */
/* ACE_DOESNT_DEFINE_MAIN */
// -*- C++ -*-
/* ACE_HAS_INLINED_OSCALLS */
// Windows Server 2003 changed the behavior of a zero-length input
// string to inet_addr(). It used to return 0 (INADDR_ANY) but now
// returns -1 (INADDR_NONE). It will return INADDR_ANY for a 1-space
// string, though, as do previous versions of Windows.
/* ACE_WIN32 */
// Broadcast addresses are weird...
// Network byte ordered
// ACE_LACKS_INET_ADDR
// inet_aton() returns OK (0) on success and ERROR (-1) on failure.
// Must reset errno first. Refer to WindRiver SPR# 34949, SPR# 36026
// inet_aton() returns 0 upon failure, not -1 since -1 is a valid
// address (255.255.255.255).
/* ACE_LACKS_INET_ATON */
// -*- C++ -*-
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_LACKS_CLOSEDIR */
// Check if filename is a directory.
/*
/*"));
/* WIN32 */
/* WIN32 */
/* ACE_LACKS_CLOSEDIR */
// Make sure to close the handle explicitly to avoid a leak!
/* ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_LACKS_READDIR */
// A sanity check here.  "namelist" had better not be zero.
// @@ This code shoulduse readdir_r() rather than readdir().
// If we get here, we have a dirent that the user likes.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_STRUCT_DIR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Don't use memcpy here since d_name is now a pointer
/* ACE_LACKS_STRUCT_DIR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_STRUCT_DIR */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* !ACE_HAS_SCANDIR */
/* ACE_HAS_INLINED_OSCALLS */
// -*- C++ -*-
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_WINCE */
/* ACE_HAS_WINCE */
/* ACE_WIN32 */
// @@ (brunsch) Yuck, maybe there is a way to combine the code
// here with the char version
/* ACE_WIN32 */
// Just emulate with ascii version
/* ACE_WIN32 */
/* ACE_HAS_WCHAR */
/* ACE_HAS_INLINED_OSCALLS */
// -*- C++ -*-
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_LINUX && !ACE_LACKS_NETWORKING */
// Include if_arp so that getmacaddr can use the
// arp structure.
/**/ <net/if_arp.h>
/** Define a structure for use with the netbios routine */
/** Reset the netbios */
// Ethernet.
/* ACE_HAS_PHARLAP_RT */
/* ACE_HAS_PHARLAP */
/** obtain the local host name */
/** Get the hostent to use with ioctl */
// It's easiest to know the first MAC-using interface. Use the BSD
// getifaddrs function that simplifies access to connected interfaces.
// Check to see if it's up and is not either PPP or loopback
/*s*/, SIOCGIFHWADDR, &ifr) < 0)
// find first eligible device
// get device flags
// Check to see if it's up and is not either PPP or loopback
// did we find any?
// fall-through
/*empty*/;
/* ACE_LACKS_GETADDRINFO */
// IPv6 support requries actual OS-provided getnameinfo
/* ACE_LACKS_GETNAMEINFO */
/* defined (ACE_LACKS_NETDB_REENTRANT_FUNCTIONS) */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_SIGINFO_T */
/* ACE_HAS_INLINED_OSCALLS */
// This function is called by the OS when the ACE DLL is loaded. We
// use it to determine the default module containing ACE's resources.
/* ACE_DISABLES_THREAD_LIBRARY_CALLS */
/* ACE_HAS_DLL && ACE_HAS_DLL == 1 */
/* ACE_WIN32 */
/* ACE_WIN32 */
/* 0 */
/* ACE_HAS_DUMP */
/* namespace ACE_OS */
/*****************************************************************************/
/// Translate fopen's mode char to open's mode.  This helper function
/// is here to avoid maintaining several pieces of identical code.
// Close anonymous namespace
// Let the chips fall where they may if the user passes in a NULL
// mode string.  Convert to an empty mode string to prevent a
// crash.
/* defined(ACE_HAS_NONCONST_FDOPEN) && !defined (ACE_USES_WCHAR)) */
/* defined(ACE_HAS_NONCONST_FDOPEN) && !defined (ACE_USES_WCHAR)) */
/* ACE_HAS_WCHAR */
/* ACE_WIN32 */
// The following *printf functions aren't inline because
// they use varargs.
// ACE_OS_TRACE ("ACE_OS::fprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_STDIO_USE_STDLIB_FOR_VARARGS */
// ACE_OS_TRACE ("ACE_OS::fprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_HAS_WCHAR */
// ACE_OS_TRACE ("ACE_OS::asprintf");
/* ACE_LACKS_VA_FUNCTIONS */
// ACE_OS_TRACE ("ACE_OS::asprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_HAS_WCHAR */
// ACE_OS_TRACE ("ACE_OS::printf");
/* ACE_LACKS_VA_FUNCTIONS */
/* !ACE_FACE_DEV || !ACE_STDIO_USE_STDLIB_FOR_VARARGS */
// ACE_OS_TRACE ("ACE_OS::printf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_HAS_WCHAR */
// ACE_OS_TRACE ("ACE_OS::snprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_STDIO_USE_STDLIB_FOR_VARARGS */
// ACE_OS_TRACE ("ACE_OS::snprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_HAS_WCHAR */
// ACE_OS_TRACE ("ACE_OS::sprintf");
/* ACE_LACKS_VA_FUNCTIONS */
// ACE_OS_TRACE ("ACE_OS::sprintf");
/* ACE_LACKS_VA_FUNCTIONS */
/* ACE_HAS_WCHAR */
/* ACE_HAS_WCHAR */
/* !ACE_HAS_VASPRINTF */
// helpers for vsnprintf_emulation
// ' used as a flag is a POSIX extension to ISO std C
// C,S specs are POSIX extensions
// last byte is not available for writes, must be null
// Find the sign bit manually, signbit() is only available with C99/C++11
// Avoid std::modf(long double, long double*) on MinGW-W64 64-bit:
// see https://sourceforge.net/p/mingw-w64/bugs/478
// Find the next conversion and set n to the positional arg number
// Output up to next % in format string
// Check if positional args are used (%1$d)
// POSIX extension
// Parse flags (+- #'0)
// Parse field width (integer, *, or *n$)
// Parse precision (.integer, .*, or .*n$)
// would be nice to have a helper function for this, but va_list
// can't portably be passed to another function (even by pointer)
// Parse conversion specifier (diouxXfFeEgGaAcCsSpn) and convert arg
// Output remaining part of format string
// ACE_HAS_VSNPRINTF_EMULATION
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_LACKS_MKTEMP || ACE_LACKS_MKSTEMP || ACE_LACKS_REALPATH */
/* ACE_LACKS_MKSTEMP */
/* ACE_HAS_ALLOC_HOOKS */
// @@ This will probably not work since it doesn't consider
// alignment properly.
/* ACE_HAS_WINCE */
// Shut down the ACE_Object_Manager, if it had registered its exit_hook.
// With ACE_HAS_NONSTATIC_OBJECT_MANAGER, the ACE_Object_Manager is
// instantiated on the main's stack.  ::exit () doesn't destroy it.
/* ACE_HAS_NONSTATIC_OBJECT_MANAGER && !ACE_HAS_WINCE && !ACE_DOESNT_INSTANTIATE_NONSTATIC_OBJECT_MANAGER */
/* ACE_WIN32 */
// You may be asking yourself, why are we doing this?  Well, in winbase.h,
// MS didn't follow their normal Api_FunctionA and Api_FunctionW style,
// so we have to #undef their define to get access to the unicode version.
// And because we don't want to #undef this for the users code, we keep
// this method in the .cpp file.
/* ACE_WIN32 && UNICODE !ACE_USES_TCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_WIN32 */
/* ACE_WIN32 */
// Return a dynamically allocated duplicate of <str>, substituting the
// environment variables of form $VAR_NAME.  Note that the pointer is
// allocated with <ACE_OS::malloc> and must be freed by
// <ACE_OS::free>.
// WinCE doesn't have environment variables so we just skip it.
// Always use the ACE_TCHAR for Windows.
// Use char * for environment on non-Windows.
/* ACE_WIN32 */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_WIN32 */
/* ACE_HAS_WINCE */
// Short circuit if 0
// If negative and base 10, print a - and then do the
// number.
// Don't overwrite the negative sign.
// Drop negative sign so character selection is correct.
// Convert to base <radix>, but in reverse order
// Now reverse the string to get the correct result
/* !ACE_HAS_ITOA */
// Short circuit if 0
// If negative and base 10, print a - and then do the
// number.
// Convert to base <radix>, but in reverse order
// Now reverse the string to get the correct result
/* ACE_HAS_WCHAR && ACE_LACKS_ITOW */
// check for null template string failed!
// the template string doesn't contain "XXXXXX"!
// Find an unused filename for this process.  It is assumed
// that the user will open the file immediately after
// getting this filename back (so, yes, there is a race
// condition if multiple threads in a process use the same
// template).  This appears to match the behavior of the
// SunOS 5.5 mktemp().
// maximum of 26 unique files per template, per process
/* ACE_LACKS_MKTEMP && !ACE_DISABLE_MKTEMP */
// Single Unix Specification V3:
//   Return an error if parameter is a null pointer.
// Single Unix Specification V3:
//   Return an error if the file_name argument points
//   to an empty string.
// Single Unix Specification V3:
//   Return an error if parameter is a null pointer.
//
// To match glibc realpath() and Win32 _fullpath() behavior,
// allocate room for the return value if resolved_name is
// a null pointer.
/* ACE_HAS_ALLOC_HOOKS */
// file_name is relative path so CWD needs to be added
/* ACE_HAS_ALLOC_HOOKS */
// Extra buffer needed to expand symbolic links
// Skip multiple separators
// Process one path component
/* ACE_HAS_ALLOC_HOOKS */
// Are we done?
// Remove trailing separator if not at root
// Remove "./"
// Remove "../"
// Remove the last path component if not at root
/* ACE_HAS_ALLOC_HOOKS */
// Check if current path is a link
/* ACE_HAS_ALLOC_HOOKS */
// Check if there is room to expand link?
/* ACE_HAS_ALLOC_HOOKS */
// Move tail and prefix it with expanded link
// Absolute link?
// Relative link, remove expanded link component
// Source path is now in expand_buf
/* ACE_LACKS_SYMLINKS */
/* ACE_LACKS_REALPATH */
/*
/*
/* ACE_LACKS_STRTOL */
/*
/*
/* ACE_HAS_WCHAR && ACE_LACKS_WCSTOL */
/*
/* ACE_LACKS_STRTOUL */
/*
/* ACE_HAS_WCHAR && ACE_LACKS_WCSTOUL */
/*
/*
/* ACE_LACKS_STRTOLL */
/*
/*
/* ACE_HAS_WCHAR && ACE_LACKS_WCSTOLL */
/*
/* ACE_LACKS_STRTOULL */
/*
/* ACE_HAS_WCHAR && ACE_LACKS_WCSTOULL */
// The "XXXXXX" template to be filled in.
// Do not change!
// Use ACE_Time_Value::msec(ACE_UINT64&) as opposed to
// ACE_Time_Value::msec(void) to avoid truncation.
// Use a const ACE_Time_Value to resolve ambiguity between
// ACE_Time_Value::msec (long) and ACE_Time_Value::msec(ACE_UINT64&) const.
// Add the process and thread ids to ensure uniqueness.
// ACE_thread_t may be a char* (returned by ACE_OS::thr_self()) so
// we need to use a C-style cast as a catch-all in order to use a
// static_cast<> to an integral type.
// We only care about UTF-8 / ASCII characters in generated
// filenames.  A UTF-16 or UTF-32 character could potentially cause
// a very large space to be searched in the below do/while() loop,
// greatly slowing down this mkstemp() implementation.  It is more
// practical to limit the search space to UTF-8 / ASCII characters
// (i.e. 127 characters).
//
// Note that we can't make this constant static since the compiler
// may not inline the return value of ACE_Numeric_Limits::max(),
// meaning multiple threads could potentially initialize this value
// in parallel.
// Use high-order bits rather than low-order ones (e.g. rand() %
// MAX_VAL).  See Numerical Recipes in C: The Art of Scientific
// Computing (William  H. Press, Brian P. Flannery, Saul
// A. Teukolsky, William T. Vetterling; New York: Cambridge
// University Press, 1992 (2nd ed., p. 277).
//
// e.g.: MAX_VAL * rand() / (RAND_MAX + 1.0)
// Factor out the constant coefficient.
// @@ These nested loops may be ineffecient.  Improvements are
//    welcome.
// This do/while() loop allows this alphanumeric character
// selection to work for EBCDIC, as well.
/* Do not share while open. */
/* S_IRUSR | S_IWUSR */
/* ACE_WIN32 */
// Create the file with the O_EXCL bit set to ensure that we're
// not subject to a symbolic link attack.
//
// Note that O_EXCL is subject to a race condition over NFS
// filesystems.
// Couldn't create a unique temporary file.
/* ACE_LACKS_MKSTEMP */
/* !ACE_HAS_GETPROGNAME && !ACE_HAS_SETPROGNAME */
/* !ACE_HAS_GETPROGNAME */
/* !ACE_HAS_SETPROGNAME */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_MEMCHR */
/* ACE_HAS_ALLOC_HOOKS */
/* (ACE_LACKS_STRDUP && !ACE_STRDUP_EQUIVALENT) || ... */
/* (ACE_LACKS_WCSDUP && !ACE_WCSDUP_EQUIVALENT) || ... */
/* ACE_HAS_WCHAR */
/* ACE_HAS_WCHAR */
/* ACE_LACKS_STRERROR */
// Adapt to the various ways that strerror() indicates a bad errnum.
// Most modern systems set errno to EINVAL. Some older platforms return
// a pointer to a NULL string. This code makes the behavior more consistent
// across platforms. On a bad errnum, we make a string with the error number
// and set errno to EINVAL.
/* ACE_WIN32 */
/* ACE_LACKS_STRERROR */
/**
/* ACE_LACKS_STRERROR */
/* (ACE_NEEDS_STRSIGNAL_RANGE_CHECK */
/* ACE_SYS_SIGLIST */
/* ACE_HAS_STRSIGNAL */
// Substring length
// Check if the substring is longer than the string being searched.
// Go upto <len>
// Found a match!  Return the index.
// Substring length
// Check if the substring is longer than the string being searched.
// Go upto <len>
// Found a match!  Return the index.
// Unroll the loop...
/* ACE_HAS_MEMCPY_LOOP_UNROLL */
/* ACE_LACKS_STRRCHR */
// We have reached the end
/* ACE_LACKS_STRTOK_R */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSTOK */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_LACKS_STRCASECMP */
// The following case analysis is necessary so that characters which
// look negative collate low against normal characters but high
// against the end-of-string NUL.
/* ACE_LACKS_STRCASECMP */
// The following case analysis is necessary so that characters which
// look negative collate low against normal characters but high
// against the end-of-string NUL.
/* ACE_LACKS_STRCASECMP */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_WINSOCK2 */
// Query for the buffer size.
/* ACE_HAS_WINSOCK2_GQOS */
/* ACE_HAS_WINSOCK2_GQOS */
/* ACE_HAS_WINSOCK2_GQOS */
/* ACE_HAS_WINSOCK2_GQOS */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_WIN32 || HPUX */
/* ACE_HAS_INLINED_OSCALLS */
// @@ Is it possible to inline a call to ::TransmitFile() on
//    MS Windows instead of emulating here?
// @@ We may want set up a signal lease (or oplock) if supported by
//    the platform so that we don't get a bus error if the mmap()ed
//    file is truncated.
/* ACE_WIN32 */
/* ACE_HAS_SENDFILE==0 */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_WIN32 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
// Construct the WinSock2 QOS structure.
/* ACE_HAS_WINSOCK2 */
// @@ Eliminate magic number.
/* ACE_HAS_WINCE */
/* ACE_WIN32 */
// @@ Eliminate magic number.
/* ACE_HAS_WINCE */
/* ACE_WIN32 */
// the divide and conquer logic should remain consistent
// with send_partial_i
// keep dividing the current buffer_size in half and then
// attempt to send the modified iovec buffer until some
// data is sent, or we get an errno that is not ENOBUFS
// if the buffer division splits an iovec, we need
// to set its iov_len properly
// if ENOBUFS is received, we apply a divide and
// conquer strategy, but if bytes are sent we
// cannot guarantee this is the same behavior
/* ACE_HAS_WINSOCK2 */
// the divide and conquer logic should remain consistent
// with sendv_partial_i
// keep dividing the current buffer_size in half and then
// attempt to send the modified buffer until some data is
// sent, or we get an errno that is not ENOBUFS
// if ENOBUFS is received, we apply a divide and
// conquer strategy, but if bytes are sent we
// cannot guarantee this is the same behavior
/* ACE_LACKS_SEND && ACE_WIN32 */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
// "Fake" readv for operating systems without it.  Note that this is
// thread-safe.
// In case there's a single element, skip the memcpy.
/* ACE_HAS_ALLOC_HOOKS */
// iov_len is int on some platforms, size_t on others
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_READV */
// "Fake" writev for operating systems without it.  Note that this is
// thread-safe.
// 'handle' may be a datagram socket (or similar) so this operation
// must not be divided into multiple smaller writes.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_WRITEV */
// for sysBspRev(), sysModel()
/**/ <sysLib.h>
// for kernelVersion()
/**/ <kernelLib.h>
/* ACE_VXWORKS && ACE_LACKS_UNAME */
/* Since MS found it necessary to deprecate these. */
/* __clang__ */
/* __clang__ */
// PharLap doesn't do GetSystemInfo.  What's really wanted is the
// CPU architecture, so we can get that with EtsGetSystemInfo. Fill
// in what's wanted in the SYSTEM_INFO structure, and carry on. Note
// that the CPU type values in EK_KERNELINFO have the same values
// are the ones defined for SYSTEM_INFO.
/* ACE_HAS_PHARLAP */
// Get information from the two structures
// We have to make sure that the size of (processor + subtype)
// is not greater than the size of name->machine.  So we give
// half the space to the processor and half the space to
// subtype.  The -1 is necessary for because of the space
// between processor and subtype in the machine name.
// I'm guessing here
// @@ We could provide WinCE specific info here.  But let's
//    defer that to some later point.
/* !ACE_HAS_WIN32_GETVERSION */
// We don't know what this is!
/* ACE_LACKS_HOSTNAME */
/* ACE_LACKS_HOSTNAME */
/* ACE_WIN32 */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_INLINED_OSCALLS */
// for ACE_ASSERT
// Green Hills compiler gets confused when __stdcall is embedded in
// parameter list, so we define the type ACE_WIN32THRFUNC_T and use it
// instead.
/* defined (__IBMCPP__) && (__IBMCPP__ >= 400) */
/*****************************************************************************/
// Yes, this is an ugly C-style cast, but the correct C++ cast is
// different depending on whether the t_id is an integral type or a
// pointer type. FreeBSD uses a pointer type, but doesn't have a _np
// function to get an integral type like other OSes, so use the
// bigger hammer.
// ACE_THREAD_T_IS_A_STRUCT
/* ACE_WIN32 */
/*****************************************************************************/
/* ! VxWorks SMP */
/* ! VxWorks SMP */
/* static */
// Really this must be used for ACE_TSS_Emulation code to make the TSS
// cleanup
// Really this must be used for ACE_TSS_Emulation code to make the TSS
// cleanup
/* ACE_HAS_THR_C_FUNC */
// TSS Singleton implementation.
// Create the one native TSS key, if necessary.
// Double-checked lock . . .
// Major problems, this should *never* happen!
// Get the tss_storage from thread-OS specific storage.
// This should not happen!
// Check to see if this is the first time in for this thread.
// This block can also be entered after a fork () in the child process.
// Use the ts_storage passed as argument, if non-zero.  It is
// possible that this has been implemented in the stack. At the
// moment, this is unknown.  The cleanup must not do nothing.
// If ts_storage is zero, allocate (and eventually leak) the
// storage array.
// Zero the entire TSS array.  Do it manually instead of
// using memset, for optimum speed.  Though, memset may be
// faster :-)
// Store the pointer in thread-specific storage.  It gets
// deleted via the ACE_TSS_Emulation_cleanup function when the
// thread terminates.
// This should not happen!
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
// Initialize the tss_keys_used_ pointer on first use.
// Loop through all possible keys and check whether a key is free
// If the key is not set as used, we can give out this key, if not
// we have to search further
// On VxWorks, in particular, don't check to see if the field
// is 0.  It isn't always, specifically, when a program is run
// directly by the shell (without spawning a new task) after
// another program has been run.
/* ! ACE_HAS_THREAD_SPECIFIC_STORAGE */
// Zero the entire TSS array.  Do it manually instead of using
// memset, for optimum speed.  Though, memset may be faster :-)
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
/* ACE_HAS_TSS_EMULATION */
/* WIN32 || ACE_HAS_TSS_EMULATION */
/*****************************************************************************/
// Moved class ACE_TSS_Ref declaration to OS.h so it can be visible to
// the single file of template instantiations.
// Check for equality.
// Check for inequality.
// moved class ACE_TSS_Info declaration
// to OS.h so it can be visible to the
// single file of template instantiations
// Check for equality.
// Check for inequality.
//  ACE_OS_TRACE ("ACE_TSS_Info::dump");
/* 0 */
/* ACE_HAS_DUMP */
// Moved class ACE_TSS_Keys declaration to OS.h so it can be visible
// to the single file of template instantiations.
/**
/// Register a newly-allocated key
/// @param key the key to be monitored
/// @param destructor the function to call to delete objects stored via this key
/// Mark a key as being used by this thread.
/// This thread is no longer using this key
/// call destructor if appropriate
/// This key is no longer used
///   Release key if use count == 0
///   fail if use_count != 0;
/// @param key the key to be released
/// Cleanup the thread-specific objects.  Does _NOT_ exit the thread.
/// For each used key perform the same actions as free_key.
/// Release a key used by this thread
/// @param info reference to the info for this key
/// @param destructor out arg to receive destructor function ptr
/// @param tss_obj out arg to receive pointer to deletable object
/// remove key if it's unused (thread_count == 0)
/// @param info reference to the info for this key
/// Find the TSS keys (if any) for this thread.
/// @param thread_keys reference to pointer to be filled in by this function.
/// @return false if keys don't exist.
/// Accessor for this threads ACE_TSS_Keys instance.
/// Creates the keys if necessary.
/// Ensure singleton.
/// ACE_TSS_Cleanup access only via TSS_Cleanup_Instance
// Array of <ACE_TSS_Info> objects.
/// Table of <ACE_TSS_Info>'s.
/// Key for the thread-specific ACE_TSS_Keys
/// Used by find_tss_keys() or tss_keys() to find the
/// bit array that records whether each TSS key is in
/// use by this thread.
/*****************************************************************************/
/**
// During static construction or construction of the ACE_Object_Manager,
// there can be only one thread in this constructor at any one time, so
// it's safe to check for a zero mutex_.  If it's zero, we create a new
// mutex and condition variable.
// must be normal use
// Variable to hold the mutex_ to delete outside the scope of the
// guard.
// scope the guard
// end of guard scope
// = Static object initialization.
// variables to hold the destructors, keys
// and pointers to the object to be destructed
// the actual destruction is deferred until the guard is released
// count of items to be destroyed
// scope the guard
// if not initialized or already cleaned up
// Minor hack: Iterating in reverse order means the LOG buffer which is
// accidentally allocated first will be accidentally deallocated (almost)
// last -- in case someone logs something from the other destructors.
// applications should not count on this behavior because platforms which
// do not use ACE_TSS_Cleanup may delete objects in other orders.
// if this key is in use by this thread
// defer deleting the in-use key until all others have been deleted
// remove the in_use bit vector last
// end of guard scope
// defined (ACE_HAS_TSS_EMULATION)
// defined (ACE_HAS_TSS_EMULATION)
// inserting it does not use it
// but it does "allocate" it
// assume CLEANUP_GUARD is held by caller
// This was a good idea, but POSIX says it's legal to delete used keys.
// When this is done, any existing TSS objects controlled by this key are leaked
// There is no "right thing" to do in this case
// only remove it if all threads are done with it
// 0
/* !ACE_HAS_TSS_EMULATION */
// variables to hold the destructor and the object to be destructed
// the actual call is deferred until the guard is released
// scope the guard
// If this entry was never set, just bug out. If it is set, but is the
// wrong key, assert.
// sanity check
// end of scope for the Guard
// if there's a destructor and an object to be destroyed
// assume guard is held by caller
// Find the TSS keys (if any) for this thread
// do not create them if they don't exist
// if this key is in use by this thread
// save destructor & pointer to tss object
// until after the guard is released
// If the key's ACE_TSS_Info in-use bit for this thread is not set,
// set it and increment the key's thread_count_.
// Retrieve the key's ACE_TSS_Info and increment its thread_count_.
// Iterate through all the thread-specific items and dump them all.
/* ACE_HAS_DUMP */
// This should not happen!
// Double-check;
// Initialize in_use_ with a new key.
// Major problems, this should *never* happen!
// This should not happen!
// Store the dynamically allocated pointer in thread-specific
// storage.
// Major problems, this should *never* happen!
/* ACE_WIN32 || ACE_HAS_TSS_EMULATION */
/*****************************************************************************/
// = Static initialization.
// This is necessary to deal with POSIX pthreads insanity.  This
// guarantees that we've got a "zero'd" thread id even when
// ACE_thread_t, ACE_hthread_t, and ACE_thread_key_t are implemented
// as structures...  Under no circumstances should these be given
// initial values.
// Note: these three objects require static construction.
/* ! ACE_HAS_TSS_EMULATION */
/* ! ACE_HAS_TSS_EMULATION */
/*****************************************************************************/
// scope the cleanup instance
// Call TSS destructors for current thread.
/* ACE_HAS_TSS_EMULATION || ACE_WIN32 */
// Just close the ACE_Log_Msg for the current (which should be
// main) thread.  We don't have TSS emulation; if there's native
// TSS, it should call its destructors when the main thread
// exits.
/* ! ACE_HAS_TSS_EMULATION  &&  ! ACE_HAS_MINIMAL_ACE_OS */
// Finally, free up the ACE_TSS_Cleanup instance.  This method gets
// called by the ACE_Object_Manager.
// the pointer deletes the Cleanup when it goes out of scope
/* WIN32 || ACE_HAS_TSS_EMULATION */
/* ACE_HAS_TSS_EMULATION */
/*****************************************************************************/
// CONDITIONS BEGIN
/*****************************************************************************/
// The <external_mutex> must be locked before this call is made.
// This is needed to ensure that <waiters_> and <was_broadcast_> are
// consistent relative to each other.
// We are broadcasting, even if there is just one waiter...
// Record the fact that we are broadcasting.  This helps the
// cond_wait() method know how to optimize itself.  Be sure to
// set this with the <waiters_lock_> held.
// This is really bad, we have the lock but can't release it anymore
// Wake up all the waiters.
// Wait for all the awakened threads to acquire their part of
// the counting semaphore.
/* ACE_VXWORKS */
// This is okay, even without the <waiters_lock_> held because
// no other waiter threads can wake up to access it.
/* ACE_HAS_THREADS */
/* ACE_VXWORKS */
/* ACE_HAS_THREADS */
/* ACE_HAS_WCHAR */
/* ACE_VXWORKS */
/* ACE_HAS_THREADS */
/* ACE_VXWORKS */
/* ACE_HAS_THREADS */
/* ACE_HAS_WCHAR */
// If there aren't any waiters, then this is a no-op.  Note that
// this function *must* be called with the <external_mutex> held
// since other wise there is a race condition that can lead to the
// lost wakeup bug...  This is needed to ensure that the <waiters_>
// value is not in an inconsistent internal state while being
// updated by another thread.
// No-op
/* ACE_HAS_THREADS */
// Prevent race conditions on the <waiters_> count.
// This call will automatically release the mutex and wait on the semaphore.
/* ACE_HAS_SIGNAL_OBJECT_AND_WAIT */
// We keep the lock held just long enough to increment the count of
// waiters by one.  Note that we can't keep it held across the call
// to ACE_OS::sema_wait() since that will deadlock other calls to
// ACE_OS::cond_signal().
// Wait to be awakened by a ACE_OS::cond_signal() or
// ACE_OS::cond_broadcast().
// Reacquire lock to avoid race conditions on the <waiters_> count.
// We're ready to return, so there's one less waiter.
// Release the lock so that other collaborating threads can make
// progress.
// Bad things happened, so let's just return below.
/* NOOP */;
// This call atomically signals the <waiters_done_> event and
// waits until it can acquire the mutex.  This is important to
// prevent unfairness.
// We must always regain the <external_mutex>, even when
// errors occur because that's the guarantee that we give to
// our callers.
/* NOTREACHED */
/* ACE_HAS_SIGNAL_OBJECT_AND_WAIT */
// If we're the last waiter thread during this particular broadcast
// then let all the other threads proceed.
/* ACE_VXWORKS */
// We must always regain the <external_mutex>, even when errors
// occur because that's the guarantee that we give to our callers.
/* ACE_HAS_THREADS */
// Handle the easy case first.
// Prevent race conditions on the <waiters_> count.
// Note that we must convert between absolute time (which is
// passed as a parameter) and relative time (which is what
// WaitForSingleObjects() expects).
// Watchout for situations where a context switch has caused the
// current time to be > the timeout.
// This call will automatically release the mutex and wait on the
// semaphore.
/* ACE_HAS_SIGNAL_OBJECT_AND_WAIT */
// We keep the lock held just long enough to increment the count
// of waiters by one.  Note that we can't keep it held across
// the call to WaitForSingleObject since that will deadlock
// other calls to ACE_OS::cond_signal().
// Wait to be awakened by a ACE_OS::signal() or
// ACE_OS::broadcast().
/* ACE_USES_WINCE_SEMA_SIMULATION */
// Can't use Win32 API on our simulated semaphores.
/* ACE_USES_WINCE_SEMA_SIMULATION */
// Inline the call to ACE_OS::sema_wait () because it takes an
// ACE_Time_Value argument.  Avoid the cost of that conversion . . .
/* ACE_WIN32 || VXWORKS */
// Reacquire lock to avoid race conditions.
/* ACE_WIN32 || VXWORKS */
// This call atomically signals the <waiters_done_> event and
// waits until it can acquire the mutex.  This is important to
// prevent unfairness.
// We must always regain the <external_Mutex>, even when
// errors occur because that's the guarantee that we give to
// our callers.
/* NOTREACHED */
/* ACE_HAS_SIGNAL_OBJECT_AND_WAIT */
// Note that this *must* be an "if" statement rather than an "else
// if" statement since the caller may have timed out and hence the
// result would have been -1 above.
// Release the signaler/broadcaster if we're the last waiter.
/* ACE_WIN32 */
// We must always regain the <external_mutex>, even when errors
// occur because that's the guarantee that we give to our callers.
/* ACE_HAS_WTHREADS || ACE_HAS_VXWORKS */
/* ACE_HAS_THREADS */
/* ACE_LACKS_COND_T */
// Handle the easy case first.
// Watchout for situations where a context switch has caused the
// current time to be > the timeout.
// Prevent race conditions on the <waiters_> count.
// Note that we must convert between absolute time (which is
// passed as a parameter) and relative time (which is what
// WaitForSingleObjects() expects).
// Watchout for situations where a context switch has caused the
// current time to be > the timeout.
// We keep the lock held just long enough to increment the count of
// waiters by one.  Note that we can't keep it held across the call
// to WaitForSingleObject since that will deadlock other calls to
// ACE_OS::cond_signal().
// Wait to be awakened by a ACE_OS::signal() or ACE_OS::broadcast().
// Can't use Win32 API on simulated semaphores.
/* ACE_USES_WINCE_SEMA_SIMULATION */
// Reacquire lock to avoid race conditions.
// Release the signaler/broadcaster if we're the last waiter.
// We must always regain the <external_mutex>, even when errors
// occur because that's the guarantee that we give to our callers.
/* This assignment must only be done if error != 0,
/* ACE_HAS_THREADS */
// We keep the lock held just long enough to increment the count of
// waiters by one.  Note that we can't keep it held across the call
// to ACE_OS::sema_wait() since that will deadlock other calls to
// ACE_OS::cond_signal().
// Wait to be awakened by a ACE_OS::cond_signal() or
// ACE_OS::cond_broadcast().
// Can't use Win32 API on simulated semaphores.
/* ACE_USES_WINCE_SEMA_SIMULATION */
// Reacquire lock to avoid race conditions.
// Release the signaler/broadcaster if we're the last waiter.
// We must always regain the <external_mutex>, even when errors
// occur because that's the guarantee that we give to our callers.
// Reset errno in case mutex_lock() also fails...
/* This assignment must only be done if error != 0,
/* ACE_HAS_THREADS */
/* ACE_HAS_WTHREADS */
/*****************************************************************************/
// CONDITIONS END
/*****************************************************************************/
/*****************************************************************************/
// MUTEXES BEGIN
/*****************************************************************************/
// ACE_OS_TRACE ("ACE_OS::mutex_init");
/* Tests show that VxWorks 6.x pthread lib does not only
// have we initialized the local attributes.
// Only do these initializations if the <attributes> parameter
// wasn't originally set.
// we have initialized these attributes
// ACE_ADAPT_RETVAL used it for intermediate status
/* _POSIX_THREAD_PROCESS_SHARED && !ACE_LACKS_MUTEXATTR_PSHARED */
/* ACE_HAS_RECURSIVE_MUTEXES */
/* VxWorks 6.x API reference states:
// ACE_ADAPT_RETVAL used it for intermediate status
// Only do the deletions if the <attributes> parameter wasn't
// originally set.
// @@todo (brunsch) This idea should be moved into ACE_OS_Win32.
/* ACE_HAS_WINCE */
/* ACE_HAS_WINCE */
// Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
/* NOTREACHED */
/* ACE_HAS_PTHREADS */
/* ACE_HAS_THREADS */
/* ACE_LACKS_PTHREAD_MUTEX_DESTROY */
/* NOTREACHED */
/* Threads variety case */
/* ACE_HAS_THREADS */
// Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
/* ACE_HAS_THREADS && ACE_HAS_WTHREADS */
/* ACE_HAS_THREADS && ACE_HAS_WTHREADS */
/* ACE_HAS_WCHAR */
// ACE_OS_TRACE ("ACE_OS::mutex_lock");
// Note, don't use "::" here since the following call is often a macro.
//
// Timeout can't occur, so don't bother checking...
//
// We will ignore abandonments in this method
// Note that we still hold the lock
// This is a hack, we need to find an appropriate mapping...
/* NOTREACHED */
/* Threads variety case */
/* ACE_HAS_THREADS */
//
// Timeout can't occur, so don't bother checking...
//
// something goofed, but we hold the lock ...
// This is a hack, we need to find an appropriate mapping...
/* NOTREACHED */
/* ACE_HAS_THREADS and ACE_HAS_WTHREADS */
// "timeout" should be an absolute time.
// Calls ACE_Time_Value::operator timespec_t().
// Note that the mutex should not be a recursive one, i.e., it
// should only be a standard mutex or an error checking mutex.
// We need to adjust this to make the errno values consistent.
// Note that we must convert between absolute time (which is passed
// as a parameter) and relative time (which is what the system call
// expects).
// We will ignore abandonments in this method
// Note that we still hold the lock
// This is a hack, we need to find an appropriate mapping...
/* NOTREACHED */
// Note that we must convert between absolute time (which is passed
// as a parameter) and relative time (which is what the system call
// expects).
// Convert the VxWorks errno to one that's common for to ACE
// platforms.
/* ACE_HAS_PTHREADS */
/* ACE_HAS_THREADS && ACE_HAS_MUTEX_TIMEOUTS */
// Note, don't use "::" here since the following call is often a macro.
// Try for 0 milliseconds - i.e. nonblocking.
// We will ignore abandonments in this method.  Note that
// we still hold the lock.
/* NOTREACHED */
// couldn't get the semaphore
// error
// got the semaphore
/* Threads variety case */
/* ACE_HAS_THREADS */
// Try for 0 milliseconds - i.e. nonblocking.
// something goofed, but we hold the lock ...
/* NOTREACHED */
/* ACE_HAS_THREADS and ACE_HAS_WTHREADS */
// Note, don't use "::" here since the following call is often a macro.
/* NOTREACHED */
/* Threads variety case */
/* ACE_HAS_THREADS */
/* ACE_HAS_PTHREADS */
/* ACE_HAS_THREADS */
/*****************************************************************************/
// MUTEXES END
/*****************************************************************************/
/*****************************************************************************/
// EVENTS BEGIN
/*****************************************************************************/
/* ACE_WIN32 */
// mutex_destroy()/cond_destroy() are called in a loop if the object
// is BUSY.  This avoids conditions where we fail to destroy these
// objects because at time of destroy they were just being used in
// another thread possibly causing deadlocks later on if they keep
// being used after we're gone.
// First destroy the mutex so locking after this will return
// errors.
// Now fix event to manual reset, raise signal and broadcast
// until is's possible to destroy the condition.
/* ACE_HAS_ALLOC_HOOKS */
// !name_ (not owned by this process)
// USYNC_THREAD:
// First destroy the mutex so locking after this will return errors.
// Now fix event to manual reset, raise signal and broadcast until
// it's possible to destroy the condition.
/* ACE_WIN32 */
/* ACE_WIN32 */
// @@todo (brunsch) This idea should be moved into ACE_OS_Win32.
/* ACE_HAS_WINCE */
/* ACE_HAS_WINCE */
// Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
/* ACE_SHM_OPEN_REQUIRES_ONE_SLASH */
// Let's see if the shared memory entity already exists.
// Still can't get it.
// We own this shared memory object!  Let's set its size.
/* ACE_WIN32 */
// Wakeup all waiters.
// Auto-reset event: wakeup one waiter.
/* ACE_WIN32 */
/* ACE_WIN32 */
// wakeup all
// Auto-reset event
/* ACE_WIN32 */
// Do a "poll".
// Wait for upto <relative_time> number of milliseconds.  Note
// that we must convert between absolute time (which is passed
// as a parameter) and relative time (which is what
// WaitForSingleObjects() expects).
// <timeout> parameter is given in absolute or relative value
// depending on parameter <use_absolute_time>.
// Time is given in absolute time, we should use
// gettimeofday() to calculate relative time
// Watchout for situations where a context switch has caused
// the current time to be > the timeout.  Thanks to Norbert
// Rapp <NRapp@nexus-informatics.de> for pointing this.
// time is given in relative time, just convert it into
// milliseconds and use it
// This is a hack, we need to find an appropriate mapping...
// AUTO: reset state
// event is currently not signaled
// cond_timedwait() expects absolute time, check <use_absolute_time> flag
// Semaphores use ETIMEDOUT (POSIX)
// Reset the auto_event_signaled_ to false now that we have woken up.
/* ACE_WIN32 */
/*****************************************************************************/
// EVENTS END
/*****************************************************************************/
// Get the class TS and RT class IDs.
// Get this LWP's scheduling parameters.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
// RT class.
/* TS class */
/* ! ACE_HAS_STHREADS && ! sun */
/* ! ACE_HAS_STHREADS && ! sun */
/* ! ACE_HAS_STHREADS && ! sun */
/* ! ACE_HAS_STHREADS && ! sun */
// ACE_OS_TRACE ("ACE_OS::rwlock_init");
// NT, POSIX, and VxWorks don't support this natively.
// Since we cannot use the user specified name for all three
// objects, we will create three completely new names.
// Success!
// Save/restore errno.
/* We're about to return -1 anyway, so
/* ACE_HAS_THREADS */
/* ! ACE_HAS_THREADS || ACE_LACKS_RWLOCK_T */
// quantums not supported
// Thanks to Thilo Kielmann <kielmann@informatik.uni-siegen.de> for
// providing this code for 1003.1c PThreads.  Please note that this
// has only been tested for POSIX 1003.1c threads, and may cause
// problems with other PThreads flavors!
/* !ACE_HAS_PTHREAD_SCHEDPARAM */
/* !ACE_HAS_PTHREAD_SCHEDPARAM */
// We need to be able to set LWP priorities on Suns, even without
// ACE_HAS_STHREADS, to obtain preemption.
/* sun */
// sched_params.scope () == ACE_SCOPE_LWP, which isn't POSIX
// PharLap ETS can act on the current thread - it can set the
// quantum also, unlike Win32. All this only works on the RT
// version.
// I don't know of a way to set the quantum on Win32.
/* ACE_HAS_PHARLAP_RT */
// Setting the REALTIME_PRIORITY_CLASS on Windows is almost always
// a VERY BAD THING. This include guard will allow people
// to easily disable this feature in ACE.
// It won't work at all for Pharlap since there's no SetPriorityClass.
// Set the priority class of this process to the REALTIME process class
// _if_ the policy is ACE_SCHED_FIFO.  Otherwise, set to NORMAL.
/* ACE_DISABLE_WIN32_INCREASE_PRIORITY */
// Now that we have set the priority class of the process, set the
// priority of the current thread to the desired value.
// There is no way for us to set the priority of the thread when we
// are setting the priority of a different process.  So just ignore
// the priority argument when ACE_SCOPE_PROCESS is specified.
// Setting the priority class will automatically increase the base
// priority of all the threads within a process while maintaining the
// relative priorities of the threads within it.
/* ACE_HAS_PHARLAP_RT */
// There is only one class of priorities on VxWorks, and no time
// quanta.  So, just set the current thread's priority.
// Set the thread priority on the current thread.
/* ACE_HAS_STHREADS */
// Get the priority class ID.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
/* ignored */,
/* ignored */,
/* ! ACE_HAS_PRIOCNTL */
/* ! ACE_HAS_PRIOCNTL */
// Set priority class, priority, and quantum of this LWP or process as
// specified in sched_params.
// Get the priority class ID.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
// SunOS doesn't support non-zero quantums in time-sharing class:  use
// real-time class instead.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
// Don't change ts_uprilim (user priority limit)
// Package up the TS class ID and parameters for the
// priority_control () call.
// must have non-zero quantum for RR, to make it meaningful
// A zero quantum with FIFO has special significance:  it actually
// means infinite time quantum, i.e., run-to-completion.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
// rtparms.rt_tqsecs is ignored with RT_TQINF
// Package up the RT class ID and parameters for the
// priority_control () call.
/* ! ACE_HAS_PRIOCNTL */
/* ! ACE_HAS_PRIOCNTL */
/* ! defined (ACE_NO_THREAD_ADAPTER) */
/* ! defined (ACE_NO_THREAD_ADAPTER) */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_CPP11 */
// *** Set Stack Size
/* ACE_NEEDS_HUGE_THREAD_STACKSIZE */
/* Tests show that VxWorks 6.x pthread lib does not only
/* PTHREAD_STACK_MIN */
/* !ACE_LACKS_PTHREAD_ATTR_SETSTACK */
/* !ACE_LACKS_PTHREAD_ATTR_SETSTACKSIZE */
// *** Set Stack Address
/* !ACE_LACKS_PTHREAD_ATTR_SETSTACKADDR */
/* ACE_LACKS_PTHREAD_ATTR_SETSTACK */
// *** Deal with various attributes
// *** Set Detach state
// Note: if ACE_LACKS_SETDETACH and THR_DETACHED is enabled, we
// call ::pthread_detach () below.  If THR_DETACHED is not
// enabled, we call ::pthread_detach () in the Thread_Manager,
// after joining with the thread.
/* ACE_LACKS_SETDETACH */
// *** Set Policy
// If we wish to set the priority explicitly, we have to enable
// explicit scheduling, and a policy, too.
// SunOS, thru version 5.6, only supports SCHED_OTHER.
// NonStop OSS standard pthread supports only SCHED_FIFO.
// Make sure to enable explicit scheduling, in case we didn't
// enable it above (for non-default priority).
/* SCHED_IO */
/* ACE_HAS_ONLY_SCHED_OTHER */
// *** Set Priority (use reasonable default priorities)
// If we wish to explicitly set a scheduling policy, we also
// have to specify a priority.  We choose a "middle" priority as
// default.  Maybe this is also necessary on other POSIX'ish
// implementations?
// THR_SCHED_DEFAULT
/* ACE_HAS_PTHREADS */
/* For MIT pthreads... */
// The following code forces priority into range.
// Default policy, whether set or not
/*  PTHREAD_MAX_PRIORITY */
// SunOS, through 5.6, POSIX only allows priorities > 0 to
// ::pthread_attr_setschedparam.  If a priority of 0 was
// requested, set the thread priority after creating it, below.
/* sun && ACE_HAS_ONLY_SCHED_OTHER */
// *** Set scheduling explicit or inherited
/* ACE_LACKS_SETINHERITSCHED */
/* ACE_LACKS_SETSCHED */
/* ACE_LACKS_SETSCHED */
// *** Set pthread name
// *** Set Scope
/* ACE_LACKS_PTHREAD_SCOPE_PROCESS */
/* ACE_LACKS_PTHREAD_SCOPE_PROCESS */
/* !ACE_LACKS_THREAD_PROCESS_SCOPING */
/* !ACE_HAS_PTHREAD_ATTR_SETCREATESUSPEND_NP */
// Increment the number of LWPs by one to emulate the
// SunOS semantics.
// Suppress the ENOTSUP because it's harmless.
// This should never happen on SunOS:
// ::thr_getconcurrency () should always succeed.
// Unlikely: ::thr_getconcurrency () is supported
// but ::thr_setconcurrency () is not?
/* ! ACE_LACKS_THR_CONCURRENCY_FUNCS */
// This is a SunOS or POSIX implementation of pthreads, where we
// assume that ACE_thread_t and ACE_hthread_t are the same.  If this
// *isn't* correct on some platform, please let us know.
// SunOS prior to 5.7:
// If the priority is 0, then we might have to set it now because we
// couldn't set it with ::pthread_attr_setschedparam, as noted
// above.  This doesn't provide strictly correct behavior, because
// the thread was created (above) with the priority of its parent.
// (That applies regardless of the inherit_sched attribute: if it
// was PTHREAD_INHERIT_SCHED, then it certainly inherited its
// parent's priority.  If it was PTHREAD_EXPLICIT_SCHED, then "attr"
// was initialized by the SunOS ::pthread_attr_init () to contain
// NULL for the priority, which indicated to SunOS ::pthread_create
// () to inherit the parent priority.)
// Check the priority of this thread, which is the parent
// of the newly created thread.  If it is 0, then the
// newly created thread will have inherited the priority
// of 0, so there's no need to explicitly set it.
// The only policy supported by by SunOS, thru version 5.6,
// is SCHED_OTHER, so that's hard-coded here.
// The memset to 0 sets the priority to 0, so we don't need
// to explicitly set sparam.sched_priority.
// It would be useful if we could make this work.  But, it requires
// a mechanism for determining the ID of an LWP to which another
// thread is bound.  Is there a way to do that?  Instead, just rely
// on the code in ACE_Thread_Adapter::invoke () to set the LWP
// priority.
// If the thread is bound, then set the priority on its LWP.
/* ? How do we find the ID of the LWP
/* 0 */
/* ACE_NEEDS_LWP_PRIO_SET */
/* sun && ACE_HAS_ONLY_SCHED_OTHER */
// If we need to set the priority, then we need to start the
// thread in a suspended mode.
// With SunOS threads, ACE_thread_t and ACE_hthread_t are the same.
// Set the priority of the new thread and then let it
// continue, but only if the user didn't start it suspended
// in the first place!
// Have to duplicate the handle because
// CWinThread::~CWinThread() closes the original handle.
/* ! ACE_HAS_WINCE */
// cwin_thread will be deleted in AfxThreadExit()
// Warning: If AfxThreadExit() is called from within the
// thread, ACE_TSS_Cleanup->thread_exit() never gets called !
/* ACE_HAS_MFC */
// If we need to set the priority, then we need to start the
// thread in a suspended mode.
// Set the priority of the new thread and then let it
// continue, but only if the user didn't start it suspended
// in the first place!
/* 0 */
// Close down the handle if no one wants to use it.
/* NOTREACHED */
// The hard-coded values below are what ::sp () would use.  (::sp ()
// hardcodes priority to 100, flags to VX_FP_TASK, and stacksize to
// 20,000.)  stacksize should be an even integer.  If a stack is not
// specified, ::taskSpawn () is used so that we can set the
// priority, flags, and stacksize.  If a stack is specified,
// ::taskInit ()/::taskActivate() are used.
// If called with thr_create() defaults, use same default values as ::sp ():
// Assumes that there is a floating point coprocessor.  As noted
// above, ::sp () hardcodes this, so we should be safe with it.
/* Don't support setting of stack, because it doesn't seem to work. */
/* 0 */
// The call below to ::taskSpawn () causes VxWorks to assign a
// unique task name of the form: "t" + an integer, because the
// first argument is 0.
/* Don't support setting of stack, because it doesn't seem to work. */
// If a task name (thr_id) was not supplied, then the task will
// not have a unique name.  That's VxWorks' behavior.
// Carve out a TCB at the beginning of the stack space.  The TCB
// occupies 400 bytes with VxWorks 5.3.1/I386.
// The TID is defined to be the address of the TCB.
// The task was successfully initialized, now activate it.
/* 0 */
/* ACE_HAS_STHREADS */
/* ACE_HAS_THREADS */
// Can't call it here because on NT, the thread is exited
// directly by ACE_Thread_Adapter::invoke ().
//   ACE_TSS_Cleanup::instance ()->thread_exit (status);
// An ACE_Thread_Descriptor really is an ACE_OS_Thread_Descriptor.
// But without #including ace/Thread_Manager.h, we don't know that.
/* ACE_HAS_MFC && (ACE_HAS_MFC != 0) */
// Call TSS destructors.
/* not main thread */);
// Exit the thread.
// Allow CWinThread-destructor to be invoked from AfxEndThread.
// _endthreadex will be called from AfxEndThread so don't exit the
// thread now if we are running an MFC thread.
// Not spawned by ACE_Thread_Manager, use the old buggy
// version.  You should seriously consider using
// ACE_Thread_Manager to spawn threads.  The following code is
// know to cause some problem.
/* ACE_HAS_MFC && ACE_HAS_MFS != 0*/
/* ACE_HAS_PTHREADS */
/* ACE_HAS_THREADS */
// Leave this in the global scope to allow
// users to adjust the delay value.
// We can't get the status of the thread
// This method can not support joining all threads
// Make sure we are not joining ourself
// Whether the task exists or not
// we will return a successful value
// Verify that the task id still exists
// Wait a bit to see if the task is still active.
// Adapt the return value into errno and return value.
// The ACE_ADAPT_RETVAL macro doesn't exactly do what
// we need to do here, so we do it manually.
/* ACE_HAS_VXTHREADS */
/* ACE_HAS_WTHREADS || ACE_HAS_TSS_EMULATION */
// Handle of the thread, which is NPTL thread-id, normally a big number
// The process-id is expected as <thr_id>, which can be a thread-id of
// linux-thread, thus making binding to cpu of that particular thread only.
// If you are using this flag for NPTL-threads, however, please pass as a
// thr_id process id obtained by ACE_OS::getpid ()
// The process-id is expected as <thr_id>, which can be a thread-id of
// linux-thread, thus making binding to cpu of that particular thread only.
// If you are using this flag for NPTL-threads, however, please pass as a
// thr_id process id obtained by ACE_OS::getpid ()
// The process-id is expected as <thr_id>, which can be a thread-id of
// linux-thread, thus making binding to cpu of that particular thread only.
// If you are using this flag for NPTL-threads, however, please pass as a
// thr_id process id obtained by ACE_OS::getpid (), but whole process will bind your CPUs
//
// The process-id is expected as <thr_id>, which can be a thread-id of
// linux-thread, thus making binding to cpu of that particular thread only.
// If you are using this flag for NPTL-threads, however, please pass as a
// thr_id process id obtained by ACE_OS::getpid (), but whole process will bind your CPUs
//
/* ACE_WIN32 || ACE_HAS_TSS_EMULATION */
/* ACE_HAS_THR_C_DEST */
// can't trace here. Trace uses TSS
// ACE_OS_TRACE ("ACE_OS::thr_keycreate_native");
/* ACE_HAS_STHREADS */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
/* ACE_HAS_THR_C_DEST */
// ACE_OS_TRACE ("ACE_OS::thr_keycreate");
// Extract out the thread-specific table instance and stash away
// the key and destructor so that we can free it up later on...
// Extract out the thread-specific table instance and stash away
// the key and destructor so that we can free it up later on...
/* NOTREACHED */
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREADS */
// For some systems, e.g. LynxOS, we need to ensure that
// any registered thread destructor action for this slot
// is now disabled. Otherwise in the event of a dynamic library
// unload of libACE, by a program not linked with libACE,
// ACE_TSS_cleanup will be invoked again at the thread exit
// after libACE has been actually been unmapped from memory.
/* ACE_HAS_BROKEN_THREAD_KEYFREE */
/* ACE_LACKS_PTHREAD_KEY_DELETE */
/* ACE_HAS_PTHREADS */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
// Release the key in the TSS_Emulation administration
// Extract out the thread-specific table instance and free up
// the key and destructor.
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREADS */
// Set the thread priority on the current thread.
// If the thread is in the RT class, then set the priority on its
// LWP.  (Instead of doing this if the thread is in the RT class, it
// should be done for all bound threads.  But, there doesn't appear
// to be an easy way to determine if the thread is bound.)
// Find what scheduling class the thread's LWP is in.
// This thread's LWP is in the RT class, so we need to set
// its priority.
// else this is not an RT thread.  Nothing more needs to be
// done.
/* ACE_NEEDS_LWP_PRIO_SET */
// ACE_OS_TRACE ("ACE_OS::thr_setspecific_native");
/* ACE_HAS_STHREADS */
/* ACE_HAS_STHREADS */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREAD_SPECIFIC_STORAGE */
// ACE_OS_TRACE ("ACE_OS::thr_setspecific");
// for TSS_Cleanup purposes treat stetting data to zero
// like detaching.  This is a consequence of POSIX allowing
// deletion of a "used" key.
// for TSS_Cleanup purposes treat stetting data to zero
// like detaching.  This is a consequence of POSIX allowing
// deletion of a "used" key.
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_TSS_EMULATION */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREADS */
// The process ID will provide uniqueness between processes on the
// same machine. The "this" pointer of the <object> will provide
// uniqueness between other "live" objects in the same process. The
// uniqueness of this name is therefore only valid for the life of
// <object>.
// The process ID will provide uniqueness between processes on the
// same machine. The "this" pointer of the <object> will provide
// uniqueness between other "live" objects in the same process. The
// uniqueness of this name is therefore only valid for the life of
// <object>.
/**/ <usrLib.h>   /* for ::sp() */
/**/ <sysLib.h>   /* for ::sysClkRateGet() */
// This global function can be used from the VxWorks shell to pass
// arguments to a C main () function.
//
// usage: -> spa main, "arg1", "arg2"
//
// All arguments must be quoted, even numbers.
// The called entrypoint can get the function name plus the normal 10
// optional arguments.
// Hardcode a program name because the real one isn't available
// through the VxWorks shell.
// Peel off arguments to spa () and put into argv.  va_arg () isn't
// necessarily supposed to return 0 when done, though since the
// VxWorks shell uses a fixed number (10) of arguments, it might 0
// the unused ones.  This function could be used to increase that
// limit, but then it couldn't depend on the trailing 0.  So, the
// number of arguments would have to be passed.
// Try to read another arg, and warn user if the limit was exceeded.
//
// Note that the VxWorks shell arguments change from int to long when
// using a 64bit compiler. Cast the argument up so that the format
// specifier remains correct for either build type.
// fill unused argv slots with 0 to get rid of leftovers
// from previous invocations
// The hard-coded options are what ::sp () uses, except for the
// larger stack size (instead of ::sp ()'s 20000).
// task name
// task priority
// task options
// stack size
// entry point
// first argument to main ()
// second argument to main ()
// ::taskSpawn () returns the taskID on success: return 0 instead if
// successful
/* !ACE_LACKS_VA_FUNCTIONS */
// A helper function for the extended spa functions
// We use <= to make sure that we get the last argument
// Is it a double quote that hasn't been escaped?
// We have just entered a double quoted string, so
// save the starting position of the contents.
// We have just left a double quoted string, so
// zero out the ending double quote.
// Escape the next character
// The next character is automatically skipped because
// of the memmove().
// Skip over whitespace in between arguments
// Save the starting point for the next time around
// Make sure we don't skip over a character due
// to the above loop to skip over whitespace
// This global function can be used from the VxWorks shell to pass
// arguments to a C main () function.
//
// usage: -> spae main, "arg1 arg2 \"arg3 with spaces\""
//
// All arguments must be within double quotes, even numbers.
// Peel off arguments to spa () and put into argv.  va_arg () isn't
// necessarily supposed to return 0 when done, though since the
// VxWorks shell uses a fixed number (10) of arguments, it might 0
// the unused ones.
// fill unused argv slots with 0 to get rid of leftovers
// from previous invocations
// The hard-coded options are what ::sp () uses, except for the
// larger stack size (instead of ::sp ()'s 20000).
// task name
// task priority
// task options
// stack size
// entry point
// first argument to main ()
// second argument to main ()
// ::taskSpawn () returns the taskID on success: return 0 instead if
// successful
// This global function can be used from the VxWorks shell to pass
// arguments to a C main () function.  The function will be run
// within the shells task.
//
// usage: -> spaef main, "arg1 arg2 \"arg3 with spaces\""
//
// All arguments must be within double quotes, even numbers.
// Unlike the spae function, this fuction executes the supplied
// routine in the foreground, rather than spawning it in a separate
// task.
// Peel off arguments to spa () and put into argv.  va_arg () isn't
// necessarily supposed to return 0 when done, though since the
// VxWorks shell uses a fixed number (10) of arguments, it might 0
// the unused ones.
// fill unused argv slots with 0 to get rid of leftovers
// from previous invocations
// Return the return value of the invoked ace_main routine.
/* !ACE_LACKS_VA_FUNCTIONS */
// This global function can be used from the VxWorks shell to pass
// arguments to and run a main () function (i.e. ace_main).
//
// usage: -> vx_execae ace_main, "arg1 arg2 \"arg3 with spaces\"", [prio, [opt, [stacksz]]]
//
// All arguments must be within double quotes, even numbers.
// This routine spawns the main () function in a separate task and waits till the
// task has finished.
// Peel off arguments to run_main () and put into argv.
// fill unused argv slots with 0 to get rid of leftovers
// from previous invocations
// The hard-coded options are what ::sp () uses, except for the
// larger stack size (instead of ::sp ()'s 20000).
// task name
// task priority
// task options
// stack size
// entrypoint caller
// entry point
// first argument to main ()
// second argument to main ()
// ::taskSpawn () returns the taskID on success: return _vx_call_rc instead if
// successful
/** Wind River workbench allows the user to spawn a kernel task as a
/* ACE_AS_STATIC_LIBS && ... */
/* ACE_VXWORKS && !__RTP__ */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_LACKS_STRPTIME */
/* Need ACE_OS::sprintf() */
/* end blank namespace */
/* ACE_HAS_WINCE */
// buflen must be at least 26 wchar_t long.
// Again, 26 is a magic number.
// This is really stupid, converting FILETIME to timeval back and
// forth.  It assumes FILETIME and DWORDLONG are the same structure
// internally.
/* ACE_HAS_WINCE */
/* return t1 - t0 in seconds */
/* extract the tm structure from time_t */
/* make sure t1 is > t0 */
// Accumulate the time until t[0] catches up to t[1]'s year.
// Normalize
// accumulate the seconds
/* ACE_LACKS_DIFFTIME */
// This is really stupid, converting FILETIME to timeval back and
// forth.  It assumes FILETIME and DWORDLONG are the same structure
// internally.
/* Normal years.  */
/* Leap years.  */
// based on leap select which group to use
// this the correct year but bias the value to start at the 1900
/* ACE_HAS_TR24731_2005_CRT */
// SYSTEMTIME is 1-indexed, tm is 0-indexed
// SYSTEMTIME is real; tm is since 1900
// Ignored in below function call.
/* ACE_HAS_THREADS  &&  ! ACE_HAS_MT_SAFE_MKTIME */
/* ACE_HAS_WINCE */
// an escaped %
/* not supported yet: weekday via locale long/short names
/* not supported yet:
/* not supported yet:
/* not supported yet:
/* day of month (1-31) */
/* FALL THROUGH */
/* %m/%d/%y */
/* hour (0-23) */
/* FALL THROUGH */
/* not supported yet:
/* day of year (0-366) */
/* an escaped % */
/* minute (0-59) */
/* not supported yet:
/* not supported yet:
/* %H:%M */
/* seconds (0-61) */
/* %H:%M:%S */
/* day of week (0=Sun-6) */
/* not supported yet: date, based on locale
/* not supported yet:
/* the year - 1900 (0-99) */
/* the full year (1999) */
/* unrecognised */
/* switch (format[fi]) */
/* if (percent) */
/* if (percent) */
/* while (format[fi] */
/* ACE_LACKS_STRPTIME */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_VXCPULIB */
/* ACE_LACKS_STRENVDUP */
// Determine the length of the buffer.
// Account for environment variables.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_STRENVDUP */
// If must quote, we only do it if the arg contains spaces, or
// is empty. Perhaps a check for other c | ord(c) <= 32 is in
// order?
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Add one for the extra space between each string.
// Step through all argv params and copy each one into buf; separate
// each param with white space.
/* ACE_HAS_ALLOC_HOOKS */
// Initial null charater to make it a null string.
/* ACE_HAS_ALLOC_HOOKS */
// Replace the null char that strecpy put there with white
// space.
// Null terminate the string.
/* ACE_HAS_ALLOC_HOOKS */
// The number of arguments.
/* path */, const char * /* arg0 */, ...)
// Need to write this code.
// ACE_OSCALL_RETURN (::execv (path, argv), int, -1);
/* path */, const char * /* arg0 */, ...)
// Need to write this code.
//  ACE_OSCALL_RETURN (::execve (path, argv, envp), int, -1);
/* file */, const char * /* arg0 */, ...)
// Need to write this code.
//  ACE_OSCALL_RETURN (::execvp (file, argv), int, -1);
/* ACE_HAS_STHREADS */
// ACE_Base_Thread_Adapter::sync_log_msg() is used to update the
// program name and process id in ACE's log framework.  However, we
// can't invoke it from (the child process of) threaded programs
// because it calls async signal unsafe functions, which will result
// in undefined behavior (only async signal safe functions can be
// called after fork() until an exec()).
//
// This is no great loss.  Using the ACE log framework in the child
// process will undoubtedly call async signal unsafe functions too.
// So it doesn't really matter that the program name and process id
// will not be updated.
/* ! ACE_HAS_MINIMAL_ACE_OS && !ACE_HAS_THREADS */
/* ACE_WIN32 */
// Create a contiguous command-line argument buffer with each arg
// separated by spaces.
// No process attributes.
// No thread attributes.
// Allow handle inheritance.
// Don't create a new console window.
// No environment.
// No current directory.
// No process attributes.
// No thread attributes.
// Can's inherit handles on CE
// Don't create a new console window.
// No environment.
// No current directory.
// Can't use startup info on CE
/* ! ACE_HAS_WINCE */
// Free resources allocated in kernel.
// Return new process id.
// CreateProcess failed.
// Wide-char builds need to convert the command-line args to
// narrow char strings for execv ().
/* ACE_HAS_WCHAR */
// Error.
// Child process.
// Need a 0-pointer end-of-array marker
// Back to 0-indexed
// Don't worry about freeing the cargv or the strings it points to.
// Either the process will be replaced, or we'll exit.
// The OS layer should not print stuff out
// ACELIB_ERROR ((LM_ERROR,
//             "%p Exec failed\n"));
// If the execv fails, this child needs to exit.
/* ACE_HAS_WCHAR */
// Server process.  The fork succeeded.
/* ACE_WIN32 */
// Remember the original file pointer position
// Go to the correct position
/* ACE_HAS_WIN32_OVERLAPPED_IO */
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// Reset the original file pointer position
/* ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_HAS_P_READ_WRITE */
// Remember the original file pointer position
// Go to the correct position
/* ACE_HAS_P_READ_WRITE */
// Remember the original file pointer position
/* ACE_HAS_WIN32_OVERLAPPED_IO */
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// Reset the original file pointer position
/* ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_HAS_P_READ_WRITE */
// Remember the original file pointer position
// Go to the correct position
/* ACE_HAS_P_READ_WRITE */
/* ACE_LACKS_STRENVDUP */
// Reset the number of arguments
// First pass: count arguments.
// '#' is the start-comment token..
// Skip whitespace..
// Increment count and move to next whitespace..
// Grok quotes....
// Scan past the string..
// '\0' implies unmatched quote..
// Second pass: copy arguments.
// Make sure that the buffer we're copying into is always large
// enough.
/* ACE_HAS_ALLOC_HOOKS */
// Make a new argv vector of argc + 1 elements.
/* ACE_HAS_ALLOC_HOOKS */
// Skip whitespace..
// Copy next argument and move to next whitespace..
// Check for environment variable substitution here.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_STRENVDUP */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Write <len> bytes from <buf> to <handle> (uses the <write>
// system call on UNIX and the <WriteFile> call on Win32).
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_WCHAR */
// The following wcs*_emulation methods were created based on BSD code:
/*-
/* ACE_HAS_WCHAR && ACE_LACKS_WCSCAT */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSCHR */
/* !ACE_HAS_WCHAR || ACE_LACKS_WCSCMP */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSCPY */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSCSPN */
// The following case analysis is necessary so that characters which
// look negative collate low against normal characters but high
// against the end-of-string NUL.
/* ACE_HAS_WCHAR && ACE_LACKS_WCSICMP */
/* !ACE_HAS_WCHAR || ACE_LACKS_WCSLEN */
/* !ACE_HAS_WCHAR || ACE_LACKS_WCSCAT */
/* !ACE_HAS_WCHAR || ACE_LACKS_WCSNCMP */
// NUL pad the remaining n-1 bytes
/* !ACE_HAS_WCHAR || ACE_LACKS_WCSNCPY */
// The following case analysis is necessary so that characters which
// look negative collate low against normal characters but high
// against the end-of-string NUL.
/* ACE_HAS_WCHAR && ACE_LACKS_WCSNICMP */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSPBRK */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSRCHR */
// Skip any characters in charset, excluding the terminating \0.
/* ACE_HAS_WCHAR && ACE_LACKS_WCSSPN */
/* ACE_HAS_WCHAR && ACE_LACKS_WCSSTR */
// -*- C++ -*-
/* ACE_HAS_INLINED_OSCALLS */
//=============================================================================
///**
/**
// *
// *
// *
// *  @brief  Contains OS specific data structures for QoS networking.
// *
// *  @author Craig Rodrigues  <crodrigu@bbn.com>
// */
//=============================================================================
/* ACE_HAS_WINSOCK2_GQOS */
/* defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) */
/* ACE_HAS_WINSOCK2_GQOS */
/* defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
// TBD...
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
// TBD...
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_WINSOCK2 */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Inherit the logging features if the parent thread has an
// ACE_Log_Msg instance in thread-specific storage.
// Extract the arguments.
// Pick up the cancel-related flags before deleting this.
// Delete ourselves since we don't need <this> anymore.  Make sure
// not to access <this> anywhere below this point.
// On SunOS, the LWP priority needs to be set in order to get
// preemption when running in the RT class.  This is the ACE way to
// do that . . .
// thr_getprio () on the current thread should never fail.
// ACE_OS::thr_setprio () has the special logic to set the LWP priority,
// if running in the RT class.
/* ACE_NEEDS_LWP_PRIO_SET */
// If both flags are set, ignore this.
// Invoke the start hook to give the user a chance to
// perform some initialization processing before the
// <func> is invoked.
// Call thread entry point.
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// If we changed this to 1, change the respective if in
// Task::svc_run to 0.
// Call the <Task->close> hook.
// This calls the Task->close () hook.
// This prevents a second invocation of the cleanup code
// (called later by <ACE_Thread_Manager::exit>.
/* 0 */
// Call TSS destructors.
/* not main thread */);
// Exit the thread.  Allow CWinThread-destructor to be invoked
// from AfxEndThread.  _endthreadex will be called from
// AfxEndThread so don't exit the thread now if we are running
// an MFC thread.
// Not spawned by ACE_Thread_Manager, use the old buggy
// version.  You should seriously consider using
// ACE_Thread_Manager to spawn threads.  The following code
// is know to cause some problem.
/* ACE_HAS_MFC && ACE_HAS_MFS != 0*/
/* ACE_WIN32 */
/* ACE_WIN32 || ACE_HAS_TSS_EMULATION */
/* !ACE_HAS_INLINED_OSCALLS */
// Pagefile_Memory_Pool.cpp
/* __ACE_INLINE__ */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1  */
//if !defined (ACE_HAS_WINCE)
/* !ACE_HAS_WINCE */
// Initialize local copy of pool statistics.
// Only create a new unique filename for the backing store file if
// the user didn't supply one...
// Check local_cb_ for consistency.  Remap, if extra space is too
// small and/or we didn't map the whole shared memory section
// Get the block from extra space and update shared and local
// control block
// Map the shared memory and get information, if we created the
// shared memory.
// We created the shared memory. So we have to allocate the
// requested memory.
// We just mapped the memory and return the base address
// If the shared memory is not mapped or the address, that caused
// the memory fault is outside of the commited range of chunks, we
// return.
// We can solve the problem by committing additional chunks.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
// Cleanup cached pool pointer.
// Reset local pool statistics.
// Release the pool
// Create file mapping, if not yet done
// Allow access by all users.
/* ACE_LACKS_WIN32_SECURITY_DESCRIPTORS */
// Get an object handle to the named reserved memory object.
/* !ACE_LACKS_WIN32_SECURITY_DESCRIPTORS */
// Do the initial mapping.
// Map a view to the shared memory.  Note: <MapViewOfFile[Ex]>
// does *not* commit the pages!
// There was no previous mapping, so we map the first chunk and
// initialize the shared pool statistics.
// 1st block is used to keep shared memory statistics.
// The shared memory exists, so we map the first chunk to the
// base address of the pool to get the shared pool statistics.
// 1st block is used to keep shared memory statistics.
// If the shared memory is larger than the part we've already
// committed, we have to remap it.
// Update local copy of the shared memory statistics.
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1 */
/* ACE_WIN32 && !ACE_HAS_PHARLAP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_PAIR_T_CPP */
// Provide the class hierarchy that defines the parse tree of Service
// Nodes.
/* ACE_HAS_DUMP */
// The modules were linked as popped off the yacc stack, so they're in
// reverse order from the way they should be pushed onto the stream.
// So traverse mods_ and and reverse the list, then iterate over it to push
// the modules in the stream in the correct order.
/* ACE_HAS_ALLOC_HOOKS */
// Don't try anything else with this one
/* ACE_NLOGGING */
/* ACE_HAS_DUMP */
// Find the last list entry (if any) ...
// ... and insert n there.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_NLOGGING */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_NLOGGING */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_NLOGGING */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// Preprocessor symbols will not be expanded if they are
// stringified.  Force the preprocessor to expand them during the
// argument prescan by calling a macro that itself calls another
// that performs the actual stringification.
// Check if function is using the ACE naming convention.  If so,
// it is likely that the ACE factory function macros
// (e.g. ACE_FACTORY_DECLARE) were used to declare and define it, so
// mangle the function name to include the ACE versioned namespace
// name as is done in the ACE macros.  Otherwise, leave the function
// name as is.
// Null terminator included in versioned_namespace_name_len since
// it is static constant.
// - 1;
// + 1;  // Null terminator.
/* ACE_HAS_VERSIONED_NAMESPACE == 1 */
// Locate the factory function <function_name> in the shared
// object.
/* ACE_NLOGGING */
// Invoke the factory function and record it's return value.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
/* ACE_NLOGGING */
/* ACE_HAS_DUMP */
// Locate the factory function <function_name> in the statically
// linked svcs.
// Invoke the factory function and record it's return value.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_USES_CLASSIC_SVC_CONF == 1 */
/* ACE_HAS_ALLOC_HOOKS */
/* !__ACE_INLINE__ */
//---------------------------------------------------------------------------
// Better to arrange some os_include/netinet/ip.h and
// os_include/netinet/icmp.h files ?
//---------------------------------------------------------------------------
/*
/**/ <netinet/in_systm.h>
/**/ <netinet/ip.h>
/**/ <netinet/ip_icmp.h>
/* #if ! defined (ACE_WIN32) */
/*
// length of the header
// Version of IP
// Type of service
// total length of the packet
// unique identifier
// flags
// Time to live
// protocol (TCP, UDP etc)
// IP checksum
// type sub code
// time data
/* #if ! defined (ACE_WIN32) */
// Minimal size of ICMP packet, header only
// For ICMP data with Echo request
// trying to increase the size of socket receive buffer - some
// protection from multiple responses e.g., when falling to the
// multi-cast address
// If more than .5 ms left, wait on select()
// coming back to wait on select()
//= success
// new timeout, we are coming back to sit on select
// start of IP header
// Warning... using knowledge of IP header layout. This avoids a maze of
// #if blocks for various systems. The first byte of the header has the
// IP version in the left-most 4 bits and the length in the other 4 bits.
// Bump the version off
// Zero-extended length remains
// Now it counts bytes, not words
// start of ICMP header
//= success
/*
// to connect the socket
/* #if defined (ACE_WIN32) */
/* #if defined (ACE_WIN32) */
// checksum ICMP header and data.
/* ACE_HAS_ICMP_SUPPORT == 1 */
// ACE_HAS_STREAM_PIPES || __QNX__
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_WIN32 */
// Bind listener to any port and then find out what the port was.
// Establish a connection within the same process.
// Close down the acceptor endpoint since we don't need it anymore.
// Make sure that the TCP stack doesn't try to buffer small writes.
// Since this communication is purely local to the host it doesn't
// affect network performance.
/* ! ACE_LACKS_TCP_NODELAY */
/* !ACE_LACKS_SO_RCVBUF */
/* !ACE_LACKS_SO_SNDBUF */
// Enable "msg no discard" mode, which ensures that record
// boundaries are maintained when messages are sent and received.
/* __QNX__ */
/* ! ACE_LACKS_SOCKETPAIR && ! ACE_HAS_STREAM_PIPES */
/* ! ACE_LACKS_SO_SNDBUF */
// OpenVMS implements socketpair(AF_UNIX...) by returning AF_INET sockets.
// Since these are plagued by Nagle as any other INET socket we need to set
// TCP_NODELAY on the write handle.
/* ACE_OPENVMS && !ACE_LACKS_TCP_NODELAY */
/* ! ACE_LACKS_SOCKETPAIR && ! ACE_HAS_STREAM_PIPES */
// Point both the read and write HANDLES to the appropriate socket
// HANDLEs.
// Do nothing...
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_WIN32 */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// This is basically an interface to ACE_OS::readv, that doesn't use
// the struct iovec explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_WIN32 */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* !ACE_LACKS_VA_FUNCTIONS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// not implemented!
// not implemented yet.
/* ACE_HAS_DUMP */
/* ACE_HAS_POSITION_INDEPENDENT_POINTERS == 1*/
/* ACE_PI_MALLOC_CPP */
//
// @@ Support aiocb64??
//
// Get to the platform specific implementation.
// Post myself.
// Event is not used on POSIX.
/* event */,      // Event is not used on POSIX.
//
// @@ Support offset_high with aiocb64.
//
// Other fields in the <aiocb> will be initialized by the
// subclasses.
// ****************************************************************
/* completion_key */,
// Grab the handle from the <handler> if <handle> is invalid
// @@ If <proactor> is 0, let us not bother about getting this
// Proactor, we have already got the specific implementation
// Proactor.
// If no proactor was passed
// Grab the proactor from the <Service_Config> if
// <handler->proactor> is zero
/* 0 */
// *********************************************************************
// <errno> is available in the aiocb.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// ************************************************************
// Create the Asynch_Result.
// *********************************************************************
// Get all the data copied.
// <errno> is available in the aiocb.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// *********************************************************************
// *********************************************************************
//
// @@ Use aiocb64??
//
// Copy all the data.
// <errno> is available in the aiocb.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// *********************************************************************
// ************************************************************
//
// @@ Support offset_high with aiocb64.
//
// Copy the data.
// <error> is available in <aio_resultp.aio_error>
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// *********************************************************************
// *********************************************************************
// Copy the data.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// *********************************************************************
// to avoid purge_pending_notifications
// if we are already opened,
// we could not create a new handler without closing the previous
// suspend after register
// Sanity check: make sure that enough space has been allocated by
// the caller.
// Common code for both WIN and POSIX.
// Create future Asynch_Accept_Result
// Enqueue result
// to avoid memory  leak
// If this is the only item, then it means there the set was empty
// before. So enable the accept handle in the reactor.
//@@ New method cancel_uncompleted
// It performs cancellation of all pending requests
//
// Parameter flg_notify can be
//     0  - don't send notifications about canceled accepts
//    !0  - notify user about canceled accepts
//          according POSIX standards we should receive notifications
//          on canceled AIO requests
//
//  Return value : number of cancelled requests
//
//if we should not notify
// we have to delete result
//else notify as any cancelled AIO
// Store the new handle.
// Since this is not a real POSIX asynch I/O operation, we can't
// call ::aiocancel () or ACE_POSIX_Asynch_Operation::cancel ().
// We delegate real cancelation to cancel_uncompleted (1)
// ERRORS
// AIO_ALLDONE
// AIO_CANCELED
// 1. It performs cancellation of all pending requests
// 2. Removes itself from Reactor ( ACE_Asynch_Pseudo_Task)
// 3. close the socket
//
//  Parameter flg_notify can be
//     0  - don't send notifications about canceled accepts
//    !0  - notify user about canceled accepts
//          according POSIX standards we should receive notifications
//          on canceled AIO requests
//
//  Return codes : 0 - OK ,
//                -1 - Errors
// handle_close is called in two cases:
//  1. Pseudo task is closing (i.e. proactor destructor)
//  2. The listen handle is closed (we don't have exclusive access to this)
/* fd */)
// An <accept> has been sensed on the <listen_handle>. We should be
// able to just go ahead and do the <accept> now on this <fd>. This
// should be the same as the <listen_handle>.
// Deregister this info pertaining to this accept call.
// Disable the handle in the reactor if no more accepts are pending.
// Issue <accept> now.
// @@ We shouldnt block here since we have already done poll/select
// thru reactor. But are we sure?
// there is nobody to notify
// Notify client as usual, "AIO" finished with errors
// Store the new handle.
// Notify the main process about this completion
// Send the Result through the notification pipe.
// *********************************************************************
// Copy the data.
// Create the interface result class.
// Call the application handler.
// *********************************************************************
// to avoid purge_pending_notifications
//int result =
// Ignore result as we pass ACE_INVALID_HANDLE
//if (result == -1)
//  return result;
// Common code for both WIN and POSIX.
// Create future Asynch_Connect_Result
// update handle
//  Enqueue result we will wait for completion
// don't suspend after register
//connect_i
//  return code :
//   -1   errors  before  attempt to connect
//    0   connect started
//    1   connect finished ( may be unsuccessfully)
// save it
// Reuse the address
// set non blocking mode
// failure
// connect started
// connect finished
//@@ New method cancel_uncompleted
// It performs cancellation of all pending requests
//
// Parameter flg_notify can be
//     0  - don't send notifications about canceled accepts
//    !0  - notify user about canceled accepts
//          according POSIX standards we should receive notifications
//          on canceled AIO requests
//
//  Return value : number of cancelled requests
//
// Since this is not a real asynch I/O operation, we can't just call
// ::aiocancel () or ACE_POSIX_Asynch_Operation::cancel ().
// Delegate real cancelation to cancel_uncompleted (1)
// ERRORS
// AIO_ALLDONE
// AIO_CANCELED
// not found
// This previously just did a "return -1" and let handle_close() clean
// things up. However, this entire object may be gone as a result of
// the application's completion handler, so don't count on 'this' being
// legitimate on return from post_result().
// remove_io_handler() contains flag DONT_CALL
// not found
// *********************************************************************
// Copy the data.
// We will not do this because (a) the header and trailer blocks may
// be the same message_blocks and (b) in cases of failures we have
// no idea how much of what (header, data, trailer) was sent.
/*
// Create the interface result class.
// Call the application handler.
// *********************************************************************
/**
/// Constructor. Result pointer will have all the information to do
/// the file transmission (socket, file, application handler, bytes
/// to write).
/// Destructor.
/// Do the transmission. All the info to do the transmission is in
/// the <result> member.
/// The asynch result pointer made from the initial transmit file
/// request.
/// Message bloack used to do the transmission.
/// ACT to transmit header.
/// ACT to transmit data.
/// ACT to transmit trailer.
/// Current offset of the file being transmitted.
/// Total size of the file.
/// Number of bytes transferred on the stream.
/// This is called when asynchronous writes from the socket complete.
/// This is called when asynchronous reads from the file complete.
/// Issue asynch read from  the file.
/// To read from the file to be transmitted.
/// Write stream to write the header, trailer and the data.
// ************************************************************
// Constructor.
// Allocate memory for the message block.
// Init the file size.
// Destructor.
// Do the transmission.
// Initiate transmitting the header. When that completes
// handle_write_stream will be called, there start transmitting the file.
// No proactor is given for the <open>'s. Because we are using the
// concrete implementations of the  Asynch_Operations, and we have
// already given them the specific proactor, so they wont need the
// general <proactor> interface pointer.
// Open Asynch_Read_File.
// Open Asynch_Write_Stream.
// Transmit the header.
// Update bytes transferred so far.
// Check the success parameter.
// Failure.
// Failure.
// @@ Completion key.
// @@ Error no.
// This is crucial to prevent memory leaks. This deletes
// the result pointer also.
// Write stream successful.
// Partial write to socket.
// Duplicate the message block and retry remaining data
// @@ Handle this error.
// @@ Handling *partial write* to a socket.  Let us not continue
// further before this write finishes. Because proceeding with
// another read and then write might change the order of the
// file transmission, because partial write to the stream is
// always possible.
// Not a partial write. A full write.
// Check ACT to see what was sent.
// If it is the "trailer" that is just sent, then transmit file
// is complete.
// Call the application handler.
// @@ Success.
// @@ Completion key.
// @@ Errno.
// If header/data was sent, initiate the file data transmission.
// @@ Handle this error.
// @@ Handle this error.
// Failure.
//
// Failure.
// @@ Completion key.
// Error no.
// Read successful.
// Increment offset.
// Write data to network.
// @@ Handle this error.
// Is there something to read.
// File is sent. Send the trailer.
// @@ Is this right??
// Previous reads and writes are over. For the new read, adjust
// the wr_ptr and the rd_ptr to the beginning.
// Inititiate an asynchronous read from the file.
// @@ offset_high !!! if aiocb64 is used.
// Act
// *********************************************************************
// Adjust these parameters if there are default values specified.
// Configure the result parameter.
// Make the auxillary handler and initiate transmit.
// This deletes the <result> in it too.
// *********************************************************************
// failure
// make sure the addresses are of the same type
// copy the remote_address_ into addr
// success
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// <errno> is available in the aiocb.
// Create the interface result class.
// Call the application handler.
//***************************************************************************
/***************************************************************************
// Copy the data which was returned by GetQueuedCompletionStatus
// <errno> is available in the aiocb.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
/***************************************************************************/
/*number_of_bytes_recvd*/,
// Create the Asynch_Result.
//***************************************************************************
/***************************************************************************
/*number_of_bytes_sent*/,
/*addr*/,
/* ACE_HAS_AIO_CALLS */
// we should start pseudo-asynchronous accept task
// one per all future acceptors
// Destructor.
/* ACE_HAS_SIG_C_FUNC */
// Decrement <wait_time> with the amount of time spent in the method
// setup OS notification methods for this aio
// @@ TODO: This gets the completion method back to this proactor to
// find the completed aiocb. It would be so much better to not only get
// the proactor, but the aiocb as well.
/* ACE_HAS_SIG_C_FUNC */
// Wait for the signals.
// Wait for <milli_seconds> amount of time.
// Check for errors
// but let continue work in case of errors
// we should check "post_completed" queue
// timeout
// interrupted system call
// start index to scan aiocb list
// max number to iterate
// Call the application code.
// Bytes transferred.
// No completion key.
// Error
// process post_completed results
// Uncomment this  if you want to test
// and research the behavior of you system
// ACELIB_DEBUG ((LM_DEBUG,
//            "(%t) NumAIO=%d NumQueue=%d\n",
//             ret_aio, ret_que));
/* ACE_HAS_AIO_CALLS && !ACE_HAS_BROKEN_SIGEVENT_STRUCT */
/* __ACE_INLINE__ */
/**/ <sys/systeminfo.h>
/* ACE_HAS_SYS_SYSTEMINFO_H */
/* sun */
// *********************************************************************
/**
/// Constructor.
/// Destructor.
/// This method calls the <handler>'s <handle_wakeup> method.
// *********************************************************************
// set family
// set family
// set family
// do the same
//#else defined (LINUX, __FreeBSD__ ...)
//setup here os_id_
// @@ Implement it.
// @@ Implement it.
/* completion_key*/,
// Call completion hook
// No completion key.
// This is crucial to prevent memory leaks
/**
/// Constructor. You need the posix proactor because you need to call
/// <application_specific_code>
/// Destructor.
/// Send the result pointer through the notification pipe.
/// This is the call back method when <Asynch_Read> from the pipe is
/// complete.
/// The implementation proactor class.
/// Message block to get ACE_POSIX_Asynch_Result pointer from the pipe.
/// Pipe for the communication between Proactor and the
/// Asynch_Accept/Asynch_Connect and other post_completions
/// To do asynch_read on the pipe.
/// Default constructor. Shouldnt be called.
// Open the pipe.
// Set write side in NONBLOCK mode
// Set read side in BLOCK mode
// Let AIOCB_Proactor know about our handle
// Open the read stream.
// Completion Key
// Proactor
// Issue an asynch_read on the read_stream of the notify pipe.
// enough to read 1 byte
// ACT
// Priority
// 1. try to cancel pending aio
// 2. close both handles
// Destuctor of ACE_Pipe does not close handles.
// We can not use ACE_Pipe::close() as it
// closes  read_handle and than write_handle.
// In some systems close() may wait for
// completion for all asynch. pending requests.
// So we should close write_handle firstly
// to force read completion ( if 1. does not help )
// and then read_handle and not vice versa
// Send the result pointer through the pipe.
/* 0 */
/*result*/)
// 1. Start new read to avoid pipe overflow
// Set the message block properly. Put the <wr_ptr> back in the
// initial position.
// One accept has completed. Issue a read to handle any
// <post_completion>s in the future.
// enough to read 1 byte
// ACT
// Priority
// 2. Do the upcalls
// this->posix_aiocb_proactor_->process_result_queue ();
// Public constructor for common use.
// Check for correct value for max_aio_operations
// start pseudo-asynchronous accept task
// one per all future acceptors
// Special protected constructor for ACE_SUN_Proactor
//check for correct value for max_aio_operations
// @@ We should create Notify_Pipe_Manager in the derived class to
// provide correct calls for virtual functions !!!
// Destructor.
// stop asynch accept task
// Initialize the array.
// already deleted
// Try to cancel all uncompleted operations; POSIX systems may have
// hidden system threads that still can work with our aiocbs!
// active operation
//  not active operation
// Get the error and return status of the aio_ operation.
//don't delete uncompleted AIOCB's
// not completed !!!
/* 0 */
// completed , OK
// If it is not possible cancel some operation (num_pending > 0 ),
// we can do only one thing -report about this
// and complain about POSIX implementation.
// We know that we have memory leaks, but it is better than
// segmentation fault!
// ?? or just always return 0;
// Android API 23 introduced a define _POSIX_AIO_MAX 1 which gets used by _SC_AIO_MAX.
// Previously, without the define, the value returned was -1, which got ignored.
// Officially, the Android OS does not support AIO so if ACE_HAS_AIO_CALLS is defined
// then a 3rd party library must be in use and this check is invalid.
// Define max limit AIO's for concrete OS
// -1 means that there is no limit, but it is not true
// (example, SunOS 5.6)
// Although HPUX 11.00 allows to start 2048 AIO's for all process in
// system it has a limit 256 max elements for aio_suspend () It is a
// pity, but ...
/* HPUX || __FreeBSD__ */
// check for user-defined value
// ACE_AIO_MAX_SIZE if defined in POSIX_Proactor.h
// check for max number files to open
// Remember! this issues a Asynch_Read
// on the notify pipe for doing the Asynch_Accept/Connect.
// We are responsible for delete as all pointers set to 0 after
// delete, it is save to delete twice
// Decrement <wait_time> with the amount of time spent in the method
// this protected method should be called with locked mutex_
// we can't use GUARD as Proactor uses non-recursive mutex
//  don't waste time if queue is empty - it is normal
//  or check queue size before dequeue_head
//    ACELIB_ERROR_RETURN ((LM_ERROR,
//                       ACE_TEXT("%N:%l:(%P | %t):%p\n"),
//                       ACE_TEXT("ACE_POSIX_AIOCB_Proactor::getq_result failed")),
//                      0);
// 0, No bytes transferred.
// No completion key.
//0, No error.
// Indefinite blocking.
// Block on <aio_suspend> for <milli_seconds>
// Check for errors
// Timeout
// Interrupted call
// let continue work
// we should check "post_completed" queue
// max number to iterate
// Call the application code.
// No completion key.
// process post_completed results
// Get the error status of the aio_ operation.
// The following aio_ptr anathema is required to work around a bug in an over-aggressive
// optimizer in GCC 4.1.2.
// not completed
// else transfer_count is already 0, error_status reports the error.
// completed
// parameter index defines initial slot to scan
// parameter count tells us how many slots should we scan
// save time
// like a wheel
// Dont process null blocks.
// completed
// end for
// all processed , nothing found
// decrement count active aios
// for next iteration
// for next iteration
//make attempt to start deferred AIO
//It is safe as we are protected by mutex_
// Just check the status of the list
// Save operation code in the aiocb
// No free slot
// Find a free slot and store.
//Store result ptr anyway
// started OK
// OS AIO queue overflow
// Invalid request, there is no point
// to start it later
// we reserve zero slot for ACE_AIOCB_Notify_Pipe_Manager
// so make check for ACE_AIOCB_Notify_Pipe_Manager request
// Notify_Pipe ?
// should be free,
// only 1 request
// is allowed
//try to find free slot as usual, but starting from 1
//setup OS notification methods for this aio
// start_aio_i  has new return codes
//     0    AIO was started successfully
//     1    AIO was not started, OS AIO queue overflow
//     -1   AIO was not started, other errors
// Start IO
// The following aio_ptr anathema is required to work around a bug in
// the optimizer for GCC 4.1.2
// if (ret_val == -1)
//Ok, it will be deferred AIO
// This protected method is called from
// find_completed_aio after any AIO completion
// We should call this method always with locked
// ACE_POSIX_AIOCB_Proactor::mutex_
//
// It tries to start the first deferred AIO
// if such exists
//  nothing to do
// check for
// deferred AIO
//started OK , decrement count of deferred AIOs
//try again later
// Invalid Parameters , should never be
//AL notify  user
// we are with locked mutex_ here !
// This new method should be called from
// ACE_POSIX_Asynch_Operation instead of usual ::aio_cancel
// It scans the result_list_ and defines all AIO requests
// that were issued for handle "handle"
//
// For all deferred AIO requests with handle "handle"
// it removes its from the lists and notifies user
//
// For all running AIO requests with handle "handle"
// it calls ::aio_cancel. According to the POSIX standards
// we will receive ECANCELED  for all ::aio_canceled AIO requests
// later on return from ::aio_suspend
// Skip empty slot
// Not ours
// Canceling a deferred operation
// we are with locked mutex_ here !
// Cancel started aio
//notification in the future
//it is OS responsiblity
// release mutex_
// ALLDONE
// CANCELLED
// NOT CANCELLED
// This method is called from cancel_aio
// to cancel a previously submitted AIO request
// Check the return value and return 0/1/2 appropriately.
// (rc == AIO_NOTCANCELED)
// *********************************************************************
// = Set up the mask we'll use to block waiting for SIGRTMIN. Use that
// to add it to the signal mask for this thread, and also set the process
// signal action to pass signal information when we want it.
// Clear the signal set.
// Add the signal number to the signal set.
// Set up the signal action for SIGRTMIN.
// we do not have to create notify manager
// but we should start pseudo-asynchronous accept task
// one per all future acceptors
// = Keep <Signal_set> with the Proactor, mask all the signals and
//   setup signal actions for the signals in the <signal_set>.
// = Keep <signal_set> with the Proactor.
// Empty the signal set first.
// For each signal number present in the <signal_set>, add it to
// the signal set we use, and also set up its process signal action
// to allow signal info to be passed into sigwait/sigtimedwait.
// Mask all the signals.
// we do not have to create notify manager
// but we should start pseudo-asynchronous accept task
// one per all future acceptors
// @@ Enable the masked signals again.
// Decrement <wait_time> with the amount of time spent in the method
// Get this process id.
// Set the signal information.
/* ACE_HAS_SIGVAL_SIGVAL_INT */
// Queue the signal.
// Fix the signal number.
// + 1 to nullify loop increment.
// Should never be called
/*if 0*/
// Set up the specified signal so that signal information will be
// passed to sigwaitinfo/sigtimedwait. Don't change the default
// signal handler - having a handler and waiting for the signal can
// produce undefined behavior.
// But can not use SIG_DFL
// With SIG_DFL after delivering the first signal
// SIG_DFL handler resets  SA_SIGINFO flags
// and we will lose all information sig_info
// At least all SunOS have such behavior
// Nothing else to mask.
// Realtime flag.
// (SIG_DFL);
//try to find free slot as usual, starting from 0
// setup OS notification methods for this aio
// store index!!, not pointer in signal info
/* ACE_HAS_SIGVAL_SIGVAL_INT */
// Wait for the signals.
// Not a timeout, not EINTR: tell caller of error
// Decide what to do. We always check the completion queue since it's an
// easy, quick check. What is decided here is whether to check for
// I/O completions and, if so, how completely to scan.
// 1 if AIO Completion possible
// start index to scan aiocb list
// max number of aiocbs to scan
// AIO signal received
// define index to start
// nothing will happen if it contains garbage
/* ACE_HAS_SIGVAL_SIGVAL_INT */
// Assume we have a correctly-functioning implementation, and that
// there is one I/O to process, and it's correctly specified in the
// siginfo received. There are, however, some special situations
// where this isn't true...
// Solaris 6
// 1. Solaris 6 always loses any RT signal,
//    if it has more SIGQUEMAX=32 pending signals
//    so we should scan the whole aiocb list
// 2. Moreover,it has one more bad habit
//    to notify aio completion
//    with SI_QUEUE code instead of SI_ASYNCIO, hence the
//    OS_SUN_56 addition to the si_code check, above.
// Unknown signal code.
// may some other third-party libraries could send it
// or message queue could also generate it !
// So print the message and check our completions
// Call the application code.
// No completion key.
// Error
// process post_completed results
// Uncomment this  if you want to test
// and research the behavior of you system
/* ACE_HAS_POSIX_REALTIME_SIGNALS */
// *********************************************************************
/* bytes_transferred */,
/* success */,
/* completion_key */,
/* error */)
// *********************************************************************
/* bytes_transferred */,
/* success */,
/* completion_key */,
/*  error */)
/* ACE_HAS_AIO_CALLS */
// Its iterator.
// Defines the memory allocator used, no need for locking because it
// is only used in one thread of control.
// Initialize ACE_Select_Reactor.
// Allocate enough space for all the handles.
// TODO: This can be wrong, maybe we should use other kind of
// allocator here?
// The event handlers are assigned to a new As the Event
/* ACE_HAS_ALLOC_HOOKS */
// This loops "ensures" exception safety.
/* ACE_HAS_ALLOC_HOOKS */
// If the priority is out of range assign the minimum priority.
// Update the priority ranges....
// The range for which there exists any Event_Tuple is computed on
// the ordering loop, minimizing iterations on the dispatching loop.
// clear the bit from that dispatch mask,
// so when we need to restart the iteration (rebuilding the iterator...)
// we will not dispatch the already dipatched handlers
// so it will not rebuild it ...
// Even if we are aborting the loop due to this->state_changed
// or another error we still want to cleanup the buckets.
/* ACE_HAS_DUMP */
/**/ "ace/config-lite.h"
// This only works on Win32 platforms and on Unix platforms with aio
// calls.
/* !ACE_HAS_WINCE && !ACE_LACKS_ACE_SVCCONF */
/* !ACE_HAS_AIO_CALLS */
/* ACE_HAS_AIO_CALLS */
/* __ACE_INLINE__ */
/// Process-wide ACE_Proactor.
/// Controls whether the Proactor is deleted when we shut down (we can
/// only delete it safely if we created it!)
/**
/// Constructor.
/// Destructor.
/// Proactor calls this to shut down the timer handler
/// gracefully. Just calling the destructor alone doesnt do what
/// <destroy> does. <destroy> make sure the thread exits properly.
/// Proactor calls this to refresh the timer event thread, to wake
/// up the thread from a sleep.  This is needed to make the thread
/// recompute its sleep time after changes to the timer queue.
/// Run by a daemon thread to handle deferred processing. In other
/// words, this method will do the waiting on the earliest timer and
/// event.
/// Event to wait on.
/// Proactor.
/// Flag used to indicate when we are shutting down.
// Mark for closing down.
// Signal timer event.
// Wait for the Timer Handler thread to exit.
// Check whether the timer queue has any items in it.
// Get the earliest absolute time.
// Get current time from timer queue since we don't know
// which <gettimeofday> was used.
// Compare absolute time with curent time received from the
// timer queue.
// Block for relative time.
// The timer queue has no entries, so wait indefinitely.
// Check for timer expiries.
// timeout: expire timers
// Error.
// *********************************************************************
// Create the Asynch_Timer.
/* ACE_HAS_CPP11 */
// Post a completion.
// The completion has been posted.  The proactor is now responsible
// for managing the asynch_timer memory.
// Do nothing
// Do nothing
// Do nothing
// *********************************************************************
// POSIX Proactor.
/* Default order: CB, SIG, AIOCB */
/* ACE_HAS_POSIX_REALTIME_SIGNALS */
/* !ACE_HAS_BROKEN_SIGEVENT_STRUCT */
/* ACE_POSIX_AIOCB_PROACTOR */
// WIN_Proactor.
/* ACE_HAS_AIO_CALLS */
// Set the timer queue.
// Create the timer handler
// Activate <timer_handler>.
/* threads */)
// Perform Double-Checked Locking Optimization.
/* ! ACE_HAS_WINCE || ! ACE_LACKS_ACE_SVCCONF */
// Early check. It is ok to do this without lock, since we care just
// whether it is zero or non-zero.
// First time you are in. Increment the thread count.
// Run the event loop.
// Check the end loop flag. It is ok to do this without lock,
// since we care just whether it is zero or non-zero.
// <end_event_loop> is not set. Ready to do <handle_events>.
// Leaving the event loop. Decrement the thread count.
// Obtain the lock in the MT environments.
// Decrement the thread count.
// Handle events for -tv- time.  handle_events updates -tv- to reflect
// time elapsed, so do not return until -tv- == 0, or an error occurs.
// Early check. It is ok to do this without lock, since we care just
// whether it is zero or non-zero.
// First time you are in. Increment the thread count.
// Run the event loop.
// Check the end loop flag. It is ok to do this without lock,
// since we care just whether it is zero or non-zero.
// <end_event_loop> is not set. Ready to do <handle_events>.
// Leaving the event loop. Decrement the thread count.
// Decrement the thread count.
// Obtain the lock in the MT environments.
// Obtain the lock, set the end flag and post the wakeup
// completions.
// Set the end flag.
// Number of completions to post.
// Post completions to all the threads so that they will all wake
// up.
// Close the implementation.
// Delete the implementation.
// Delete the timer handler.
// Delete the timer queue.
// absolute time.
// Signal the timer thread to make sure that new events are
// dispatched and the sleep time is updated.
// No need to singal timer event here. Even if the cancel timer was
// the earliest, we will have an extra wakeup.
// No need to signal timer event here. Even if the cancel timer was
// the earliest, we will have an extra wakeup.
// Cleanup old timer queue.
// New timer queue.
// Set the proactor in the timer queue's functor
/* !ACE_WIN32 || !ACE_HAS_AIO_CALLS */
/* threads */)
// not implemented
// not implemented
// not implemented
/* ACE_HAS_WIN32_OVERLAPPED_IO || ACE_HAS_AIO_CALLS */
// This only works on standard Win32 platforms and on Unix platforms supporting
// aio calls.
/* __ACE_INLINE__ */
// This function acts as a signal handler for SIGCHLD. We don't really want
// to do anything with the signal - it's just needed to interrupt a sleep.
// See wait() for more info.
/* ACE_WIN32 */
/* !defined (ACE_WIN32) */
/* ACE_WIN32 */
// Free resources allocated in kernel.
/* ACE_WIN32 */
// If any handles were duplicated for the child process and
// still not closed, get them now.
// Stash the passed/duped handle sets away in this object for later
// closing if needed or requested. At the same time, figure out which
// ones to include in command line options if that's needed below.
// If we are going to end up running a new program (i.e. Win32, or
// NO_EXEC option is set) then get any handles passed in the options,
// and tack them onto the command line with +H <handle> options,
// unless the command line runs out of space.
// Note that we're using the knowledge that all the options, argvs, etc.
// passed to the options are all sitting in the command_line_buf. Any
// call to get the argv then splits them out. So, regardless of the
// platform, tack them all onto the command line buf and take it
// from there.
// Because the length of the to-be-formatted +H option is not
// known, and we don't have a snprintf, guess at the space
// needed (20 chars), and use that as a limit.
// silence warnings coming from MinGW64 compilers
/* __GNUC__ */
/* __GNUC__ */
/* ACE_WIN64 */
/* ACE_WIN32 */
// Note that WinCE does not have process name included in the command line as argv[0]
// like other OS environment.  Therefore, it is user's whole responsibility to call
// 'ACE_Process_Options::process_name(const ACE_TCHAR *name)' to set the proper
// process name (the execution file name with path if needed).
// must be NULL in CE
// must be NULL in CE
// must be false in CE
// must be NULL in CE
// environment variables, must be NULL in CE
// must be NULL in CE
// must be NULL in CE
// environment variables
// Save STD file descriptors and redirect
// something went wrong
// restore STD file descriptors (if necessary)
// Save STD file descriptors and redirect
// Wide-char builds need narrow-char strings for commandline and
// environment variables.
// Need 0 at the end
// Need 0 at the end
/* ACE_USES_WCHAR */
// priority
// uStackSize
// options
// taskOptions
// something went wrong
/* ACE_USES_WCHAR */
// restore STD file descriptors (if necessary)
/* ACE_WIN32 */
// Fork the new process.
// If we're the child and the options specified a non-default
// process group, try to set our pgid to it.  This allows the
// <ACE_Process_Manager> to wait for processes by their
// process-group.
// We can't emit this log message because ACELIB_ERROR(), etc.
// will invoke async signal unsafe functions, which results
// in undefined behavior in threaded programs.
/* ACE_LACKS_SETPGID */
// We can't emit this log message because ACELIB_ERROR(), etc.
// will invoke async signal unsafe functions, which results
// in undefined behavior in threaded programs.
/* ACE_LACKS_SETREGID */
// Set user and group id's.
// We can't emit this log message because ACELIB_ERROR(), etc.
// will invoke async signal unsafe functions, which results
// in undefined behavior in threaded programs.
/* ACE_LACKS_SETREUID */
// If we're not supposed to exec, return the process id.
// Error.
// Child process...exec the
// close down unneeded descriptors
// Set close-on-exec for all FDs except standard handles
// If we must, set the working directory for the child
// process.
// Should check for error here!
// Child process executes the command.
// Wide-char builds not on Windows need narrow-char strings for
// exec() and environment variables. Don't need to worry about
// releasing any of the converted string memory since this
// process will either exec() or exit() shortly.
// Need 0 at the end
// Need 0 at the end
/* ACE_USES_WCHAR */
// Add the new environment variables to the environment
// context of the context before doing an <execvp>.
// Now the forked process has both inherited variables and
// the user's supplied variables.
// If the execv fails, this child needs to exit.
// Exit with the errno so that the calling process can
// catch this and figure out what went wrong.
// ... otherwise, this is never reached.
// Server process.  The fork succeeded.
/* ACE_WIN32 */
// nothing to do
// nothing to do
// nothing to do
/* ACE_WIN32 */
// Don't try to get the process exit status if wait failed so we can
// keep the original error code intact.
// The error status of <GetExitCodeProcess> is nonetheless not
// tested because we don't know how to return the value.
// 1 msec
// if sleeptime > waittime
// Need one we can change
// Got a child or an error - all done
// pid 0, nothing is ready yet, so wait.
// Do a (very) short sleep (only this thread sleeps).
/* !ACE_WIN32 && !ACE_LACKS_UNIX_SIGNALS */
// Need to wait but limited to specified time.
// Force generation of SIGCHLD, even though we don't want to
// catch it - just need it to interrupt the sleep below.
// If this object has a reactor set, assume it was given at
// open(), and there's already a SIGCHLD action set, so no
// action is needed here.
// Need one we can change
// Got a child or an error - all done
// pid 0, nothing is ready yet, so wait.
// Do a sleep (only this thread sleeps) til something
// happens. This relies on SIGCHLD interrupting the sleep.
// If SIGCHLD isn't delivered, we'll need to do something
// with sigaction to force it.
// Timed out
// Restore the previous SIGCHLD action if it was changed.
/* ACE_WIN32 */
// Total starts out at 1 due to the final block nul terminator
// Convert each individual character string to the equivalent wide
// character string.
// Convert the char string to wchar_t
// Add the length of the string plus the nul terminator
// Save it and set up for the next string
// Copy each string into the buffer leaving a nul terminator between
// each string and adding a second nul terminator at the end
/* ACE_HAS_WINCE */
/* ACE_WIN32 */
/* ACE_WIN32 */
/* !ACE_HAS_WINCE */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_WIN32 */
/* !ACE_HAS_WINCE */
/* ACE_HAS_ALLOC_HOOKS */
// Ensure only once execution.
// Get the existing environment.
// Add the string to our env buffer.
// Skip to the next word.
/* defined ACE_WIN32 */
/* ACE_WIN32 */
/* ACE_WIN32 */
// Start varargs.
// Add the rest of the varargs.
// End varargs.
// Append the string to are environment buffer.
/* ACE_WIN32 */
// To address the potential buffer overflow,
// we now allocate the buffer on heap with a variable size.
// Add in the variable name.
// Add the rest of the varargs.
// Must restart varargs on each time through this loop,
// End varargs.
// In case that vsnprintf is not supported,
// e.g., LynxOS and VxWorks 5, we have to
// fall back to vsprintf.
// ALERT: Since we have to use vsprintf here, there is still a chance that
// the stack_buf overflows, i.e., the length of the resulting string
// can still possibly go beyond the allocated stack_buf.
// vsprintf is failed.
// vsnprintf is failed.
// Append the string to our environment buffer.
/* ACE_WIN32 */
// ACE_LACKS_VA_FUNCTIONS
// Add one for the null char.
// If environment larger than allocated buffer return. Also check to
// make sure we have enough room.
// Copy the new environment string.
// Update the argv array.
// Update our index.
// Make sure the buffer is null-terminated.
// Tell the new process to use our std handles.
// STD handles may have value 0 (not ACE_INVALID_HANDLE) if there is no such
// handle in the process.  This was observed to occur for stdin in console
// processes that were launched from services.  In this case we need to make
// sure not to return -1 from setting std_in so that we can process std_out
// and std_err.
/* ACE_WIN32 */
/* ACE_WIN32 */
// Success.
/* ACE_WIN32 */
/* ACE_WIN32 */
/* !ACE_HAS_WINCE */
/* ACE_HAS_ALLOC_HOOKS */
/* !ACE_HAS_WINCE */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Check to see if the next argument will overflow the
// command_line buffer.
// Success.
// Store all ... args in argp.
// Useless macro.
/**
// Store all ... args in argp.
// sprintf the format and args into command_line_buf_.
// Useless macro.
/* ACE_HAS_WCHAR && !ACE_HAS_WINCE */
// ACE_LACKS_VA_FUNCTIONS
/* !ACE_HAS_WINCE */
// We need to free up any previous allocated memory first.
// We need to make a dynamically allocated copy here since
// ACE_Tokenizer modifies its arguments.
// This tokenizer will replace all spaces with end-of-string
// characters and will preserve text between "" and '' pairs.
// "
// subtract one for the ending zero.
// Cause the specified handle to be passed to a child process
// when it's spawned.
/* ACE_HAS_WINCE */
// Get a copy of the handles the ACE_Process_Options duplicated
// for the spawned process.
// Get a copy of the handles passed to the spawned process. This
// will be the set of handles previously passed to @arg pass_handle().
// Process_Manager.cpp
/* __ACE_INLINE__ */
// This function acts as a signal handler for SIGCHLD. We don't really
// want to do anything with the signal - it's just needed to interrupt
// a sleep.  See wait() for more info.
/* ACE_WIN32 */
// Singleton instance.
// Controls whether the <Process_Manager> is deleted when we shut down
// (we can only delete it safely if we created it!)
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Perform Double-Checked Locking Optimization.
// Register with the Object_Manager so that the wrapper to
// delete the proactor will be called when Object_Manager is
// being terminated.
/* ACE_HAS_SIG_C_FUNC */
// We can't safely delete it since we don't know who created it!
// Register with the Object_Manager so that the wrapper to
// delete the proactor will be called when Object_Manager is
// being terminated.
/* ACE_HAS_SIG_C_FUNC */
// Structure assignment.
// Create and initialize the table to keep track of the process pool.
// Register signal handler object.
/* !defined(ACE_WIN32) */
// Initialize the synchronization variables.
/* ACE_HAS_THREADS */
// Close up and release all resources.
/*  !ACE_WIN32  */
// This is called when the Reactor notices that a Process has exited.
// What has actually happened is a SIGCHLD invoked the <handle_signal>
// routine, which fooled the Reactor into thinking that this routine
// needed to be called.  Since we don't know which Process exited, we
// must reap as many exit statuses as are immediately available.
/* handle */,
// Reactor is telling us we're gone; don't unregister again later.
/* !ACE_WIN32 */
// On Unix, this routine is called asynchronously when a SIGCHLD is
// received.  We just tweak the reactor so that it'll call back our
// <handle_input> function, which allows us to handle Process exits
// synchronously.
//
// On Win32, this routine is called synchronously, and is passed the
// HANDLE of the Process that exited, so we can do all our work here.
// remove this HANDLE/Event_Handler combination
// return 0 : stay registered
// <GetExitCodeProcess> failed.
// return -1: unregister
/* !ACE_WIN32 */
/* !ACE_WIN32 */
// Create a new process.
// Create a new process.
// Only include the pid in the parent's table.
// bad news: spawned, but not registered in table.
// Create N new processs.
// We're in the child or something's gone wrong.
// Append a process into the pool (does not check for duplicates).
// Must be called with locks held.
// Try to resize the array to twice its existing size (or the DEFAULT_SIZE,
// if there are no array entries) if we run out of space...
// If we have a Reactor, then we're supposed to reap Processes
// automagically.  Get a handle to this new Process and tell the
// Reactor we're interested in <handling_input> on it.
/* ACE_WIN32 */
// Insert a process into the pool (checks for duplicates and doesn't
// allow them to be inserted twice).
// Check for duplicates and bail out if they're already
// registered...
// Remove a process from the pool.
// set "process not found" error
// Remove a process from the pool.  Must be called with locks held.
// If there's an exit_notify_ <Event_Handler> for this pid, call its
// <handle_close> method.
/* ACE_WIN32 */
// Compact the table by moving the last item into the slot vacated
// by the index being removed (this is a structure assignment).
// Check for duplicates and bail out if they're already
// registered...
// set "no such process" error
// Check for duplicates and bail out if they're already
// registered...
// set "no such process" error
// Check to see if the process identified by the given pid is managed by
// this instance of ACE_Process_Manager.
// set "no such process" error
// Locate the index in the table associated with <pid>.  Must be
// called with the lock held.
// Locate the index in the table associated with <h>.  Must be
// called with the lock held.
/* ACE_WIN32 */
// Wait for all the Processs to exit, or until <timeout> elapses.
// Returns the number of Processes remaining, or -1 on an error.
// wait() failed
// timeout
// else Process terminated...wait for more...
// Collect a single child process' exit status.  Store the exit code
// in *<stat_loc> if non-zero.  Call the appropriate exit_notify.  If
// <pid> == 0, wait for any of the Process_Manager's children (or as
// near as possible -- on Unix, we might accidentally get some other
// Process_Manager's Process, or an unmanaged Process, or a child
// process started by some other means.
// Collect a single child processes' exit status, unless <timeout>
// elapses before the process exits.  Same caveats about accidental
// Process reaping on Unix as above.
// fake context after which the lock is released
// release the lock.
// Wait for any Process spawned by this Process_Manager.
// Green Hills produces a warning that result >=
// WAIT_OBJECT_0 is a pointless comparison because
// WAIT_OBJECT_0 is zero and DWORD is unsigned long, so this
// test is skipped for Green Hills.  Same for mingw.
// <GetExitCodeProcess> failed!
// uh oh...handle removed from process_table_, even though
// we're holding a lock!
/* !defined(ACE_WIN32) */
// 1 msec
// if sleeptime > waittime
// Need one we can change
// Got a child or an error - all done
// pid 0, nothing is ready yet, so wait.
// Do a (very) short sleep (only this thread sleeps).
// Force generation of SIGCHLD, even though we don't want to
// catch it - just need it to interrupt the sleep below.
// If this object has a reactor set, assume it was given at
// open(), and there's already a SIGCHLD action set, so no
// action is needed here.
// Need one we can change
// Got a child or an error - all done
// pid 0, nothing is ready yet, so wait.
// Do a sleep (only this thread sleeps) til something
// happens. This relies on SIGCHLD interrupting the sleep.
// If SIGCHLD isn't delivered, we'll need to do something
// with sigaction to force it.
// Timed out
// Restore the previous SIGCHLD action if it was changed.
/* !ACE_LACKS_UNIX_SIGNALS */
/* !defined (ACE_WIN32) */
//we always need to get our id, because we could have been moved in the table meanwhile
// oops, reaped an unmanaged process!
// Notify either the process-specific handler or the generic handler.
// If process-specific, call handle_close on the handler.  Returns 1
// if process found, 0 if not.  Must be called with locks held.
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Process_Mutex::dump");
/* ACE_HAS_DUMP */
// For all platforms other than Win32, we are going to create a
// machine-wide unique name if one is not provided by the user.  On
// Win32, unnamed synchronization objects are acceptable.
/* _ACE_USE_SV_SEM */
/* !_ACE_USE_SV_SEM */
/* _ACE_USE_SV_SEM */
/* _ACE_USE_SV_SEM */
/* ACE_HAS_WCHAR */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Process_Semaphore::dump");
/* ACE_HAS_DUMP */
/* ACE_WIN32 || ACE_HAS_POSIX_SEM */
// ACE_TRACE ("ACE_Process_Semaphore::ACE_Process_Semaphore");
// Explicitly destroy the semaphore.
// ACE_TRACE ("ACE_Process_Semaphore::remove");
// Block the thread until the semaphore count becomes
// greater than 0, then decrement it.
// ACE_TRACE ("ACE_Process_Semaphore::acquire");
/* defined (ACE_WIN32) || defined (ACE_HAS_POSIX_SEM) */
// Conditionally decrement the semaphore if count is greater
// than 0 (i.e., won't block).
// ACE_TRACE ("ACE_Process_Semaphore::tryacquire");
/* defined (ACE_WIN32) || defined (ACE_HAS_POSIX_SEM) */
// Increment the semaphore, potentially unblocking
// a waiting thread.
// ACE_TRACE ("ACE_Process_Semaphore::release");
/* defined (ACE_WIN32) || defined (ACE_HAS_POSIX_SEM) */
/*****************************************************************************/
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// Initialize interval timer.
/* ACE_HAS_PRUSAGE_T */
// Terminate the interval timer.
/* ACE_HAS_PRUSAGE_T */
// Return the resource utilization.
// Compute the amount of resource utilization since the start time.
// Compute the elapsed time.
// Convert nanoseconds into seconds.
// Convert nanoseconds into seconds.
// Convert nanoseconds into seconds.
// Determine the difference between T1 and T2.
// Normalize the time.
// Compute the amount of resource utilization since the start time.
// integral shared memory size
// integral unshared data "
// integral unshared stack "
// page reclaims - total vmfaults
// page faults
// swaps
// block input operations
// block output operations
// messages sent
// messages received
// signals received
// voluntary context switches
// involuntary context switches
/* ACE_HAS_LIMITED_RUSAGE_T */
// Determine the difference between T1 and T2.
// Normalize the time.
/* ACE_HAS_PRUSAGE_T */
// Compute the amount of time that has elapsed between start and stop.
/* defined (ACE_HAS_PRUSAGE_T) || defined (ACE_HAS_GETRUSAGE) */
/* ACE_HAS_DUMP */
// Initialize interval timer.
/* ACE_HAS_GETRUSAGE */
// nanoseconds
/* ACE_HAS_GETRUSAGE */
/* ACE_HAS_GETRUSAGE */
// Return the resource utilization.
/* ACE_HAS_GETRUSAGE */
/* ACE_HAS_GETRUSAGE */
// Compute the amount of resource utilization since the start time.
// Use ACE_Time_Value's as intermediate because the type of ru_utime can
// be multiple types and using the - operator is not safe when this are
// 64bit FILETIMEs on Windows
/* ACE_HAS_GETRUSAGE */
/* ACE_HAS_GETRUSAGE */
// Determine the difference between T1 and T2.
// Normalize the time.
/* ACE_HAS_GETRUSAGE */
/* ACE_HAS_DUMP */
/* nanoseconds */
/* defined (ACE_HAS_PRUSAGE_T) ||
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Constructor.
// Destructor.
// Constructor.
// Copy constructor.
// Make a deep copy of the passed tree.
// Destructor.
// Use the locked public method, to be totally safe, as the class
// can be used with an allocator and placement new.
// Assignment operator.
// Clear out the existing tree.
// Make a deep copy of the passed tree.
// Use the same allocator as the rhs.
// Less than comparison function for keys, default functor
// implementation returns 1 if k1 < k2, 0 otherwise.
// Method for right rotation of the tree about a given node.
// Method for left rotation of the tree about a given node.
// Method for restoring Red-Black properties after a specific deletion case.
// CLR pp. 263 says that nil nodes are implicitly colored BLACK
// CLR pp. 263 says that nil nodes are implicitly colored BLACK
// CLR pp. 263 says that nil nodes are implicitly colored BLACK
// CLR pp. 263 says that nil nodes are implicitly colored BLACK
// Return a pointer to a matching node if there is one, a pointer to
// the node under which to insert the item if the tree is not empty
// and there is no such match, or 0 if the tree is empty.
// Start at the root.
// While there are more nodes to examine.
// If the search key is greater than the current node's key.
// If the right subtree is not empty, search to the right.
// If the right subtree is empty, we're done searching,
// and are positioned to the left of the insertion point.
// Else if the search key is less than the current node's key.
// If the left subtree is not empty, search to the left.
// If the left subtree is empty, we're done searching,
// and are positioned to the right of the insertion point.
// If the keys match exactly, we're done as well.
// Rebalance the tree after insertion of a node.
// If we got here, something is drastically wrong!
// Handle case 1 (see CLR book, pp. 269).
// Transform case 2 into case 3 (see CLR book, pp. 269).
// Handle case 3 (see CLR book, pp. 269).
// Handle case 1 (see CLR book, pp. 269).
// Transform case 2 into case 3 (see CLR book, pp. 269).
// Handle case 3 (see CLR book, pp. 269).
// Method to find the successor node of the given node in the tree.
// Method to find the predecessor node of the given node in the tree.
// Method to find the minimum node of the subtree rooted at the given node.
// Method to find the maximum node of the subtree rooted at the given node.
// Delete children (left and right) of the node. Must be called with
// lock held.
// Close down an RB_Tree.  this method should only be called with
// locks already held.
// Returns a pointer to the item corresponding to the given key, or 0
// if it cannot find the key in the tree.  This method should only be
// called with locks already held.
// Try to find a match.
// Found a match
// Assign the entry for any match.
// The node is not there.
// Inserts a *copy* of the key and the item into the tree: both the
// key type EXT_ID and the item type INT_ID must have well defined
// semantics for copy construction and < comparison.  This method
// returns a pointer to the inserted item copy, or 0 if an error
// occurred.  NOTE: if an identical key already exists in the tree, no
// new item is created, and the returned pointer addresses the
// existing item associated with the existing key.  This method should
// only be called with locks already held.
// Find the closest matching node, if there is one.
// If the keys match, just return a pointer to the node's item.
// Otherwise if we're to the left of the insertion point, insert
// into the right subtree.
// If there is already a right subtree, complain.
// The right subtree is empty: insert new node there.
// If the node was successfully inserted, set its
// parent, rebalance the tree, color the root black, and
// return a pointer to the inserted item.
// Otherwise, we're to the right of the insertion point, so
// insert into the left subtree.
// (result == RIGHT)
// If there is already a left subtree, complain.
// The left subtree is empty: insert new node there.
// If the node was successfully inserted, set its
// parent, rebalance the tree, color the root black, and
// return a pointer to the inserted item.
// The tree is empty: insert at the root and color the root
// black.
// Inserts a *copy* of the key and the item into the tree: both the
// key type EXT_ID and the item type INT_ID must have well defined
// semantics for copy construction.  The default implementation also
// requires that the key type support well defined < semantics.  This
// method passes back a pointer to the inserted (or existing) node,
// and the search status.  If the node already exists, the method
// returns 1.  If the node does not exist, and a new one is
// successfully created, and the method returns 0.  If there was an
// error, the method returns -1.
// Find the closest matching node, if there is one.
// If the keys match, just return a pointer to the node's item.
// Otherwise if we're to the left of the insertion
// point, insert into the right subtree.
// If there is already a right subtree, complain.
// The right subtree is empty: insert new node there.
// If the node was successfully inserted, set its parent, rebalance
// the tree, color the root black, and return a pointer to the
// inserted item.
// Otherwise, we're to the right of the insertion point, so
// insert into the left subtree.
// (result == RIGHT)
// If there is already a left subtree, complain.
// The left subtree is empty: insert new node there.
// If the node was successfully inserted, set its
// parent, rebalance the tree, color the root black, and
// return a pointer to the inserted item.
// The tree is empty: insert at the root and color the root black.
// Removes the item associated with the given key from the tree and
// destroys it.  Returns 1 if it found the item and successfully
// destroyed it, 0 if it did not find the item, or -1 if an error
// occurred.  This method should only be called with locks already
// held.
// Find a matching node, if there is one.
// If there is a matching node: remove and destroy it.
// Return the internal id stored in the deleted node.
// No matching node was found: return 0.
/// Recursive function to dump the state of an object.
/* !ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/// Function to dump node itself.  Does not show parameterized node contents
/// in its basic form, but template specialization can be used to
/// provide definitions for various EXT_ID and INT_ID types.
/* !ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/// Tests the red-black invariant(s) throughout the whole tree.
// Recurse from the root, starting with the measured black height at
// 0, and the expected black height at -1, which will cause the
// count from first measured path to a leaf to be used as the
// expected one from that point onward (the key is to check
// consistency).
/// Recursive function to test the red-black invariant(s) at all nodes in a subtree.
// Count each leaf (zero pointer) as a black node (per CLR algorithm description).
// Check the invariant that a red node cannot have a red child.
// Count each black node traversed.
// Delete the node and reorganize the tree to satisfy the Red-Black
// properties.
// Replace node z with node y, since y's pointer may well be
// held externally, and be linked with y's key and item.
// We will end up deleting the old unlinked, node z.
//Reassign the y pointer to z because the node that y points to will be
//deleted
// CLR pp. 263 says that nil nodes are implicitly colored BLACK
// Constructor.
// Position the iterator at the first (or last) node in the tree.
// Copy constructor.
// Assignment operator.
// Destructor.
// Dump the state of an object.
// Constructor.
// Destructor.
// Constructor.
// Destructor.
/* !ACE_RB_TREE_CPP */
/* !ACE_LACKS_ACE_SVCCONF */
/*
//@@ REACTOR_SPL_COMMENT_INCLUDE_START_HOOK
// Only include the headers needed to compile.
/* ACE_USE_DEV_POLL_REACTOR_FOR_REACTOR_IMPL */
/* ACE_USE_TP_REACTOR_FOR_REACTOR_IMPL */
/* We are on Win32 and we have winsock and ACE_USE_SELECT_REACTOR_FOR_REACTOR_IMPL is not defined */
/* ACE_USE_MSG_WFMO_REACTOR_FOR_REACTOR_IMPL */
/* !defined (ACE_WIN32) || !defined (ACE_HAS_WINSOCK2) || (ACE_HAS_WINSOCK2 == 0) || defined (ACE_USE_SELECT_REACTOR_FOR_REACTOR_IMPL) */
/*
//@@ REACTOR_SPL_COMMENT_INCLUDE_END_HOOK
/* __ACE_INLINE__ */
/*
//@@ REACTOR_SPL_CONSTRUCTOR_COMMENT_HOOK_START
/* ACE_USE_DEV_POLL_REACTOR_FOR_REACTOR_IMPL */
/* ACE_USE_TP_REACTOR_FOR_REACTOR_IMPL */
/* We are on Win32 and we have winsock and ACE_USE_SELECT_REACTOR_FOR_REACTOR_IMPL is not defined */
/* ACE_USE_MSG_WFMO_REACTOR_FOR_REACTOR_IMPL */
/* !defined (ACE_WIN32) || !defined (ACE_HAS_WINSOCK2) || (ACE_HAS_WINSOCK2 == 0) || defined (ACE_USE_SELECT_REACTOR_FOR_REACTOR_IMPL) */
/*
//@@ REACTOR_SPL_CONSTRUCTOR_COMMENT_HOOK_END
// Process-wide ACE_Reactor.
// Controls whether the Reactor is deleted when we shut down (we can
// only delete it safely if we created it!)
// Perform Double-Checked Locking Optimization.
// We can't register the Reactor singleton as a framework component twice.
// Therefore we test to see if we had an existing reactor instance, which
// if so means it must have already been registered.
/* ! ACE_HAS_WINCE || ! ACE_LACKS_ACE_SVCCONF */
// The <handle_events> method timed out without dispatching
// anything.  Because of rounding and conversion errors and
// such, it could be that the wait loop (WFMO, select, etc.)
// timed out, but the timer queue said it wasn't quite ready
// to expire a timer. In this case, the ACE_Time_Value we
// passed into handle_events won't have quite been reduced
// to 0, and we need to go around again. If we are all the
// way to 0, just return, as the entire time the caller
// wanted to wait has been used up.
// Else there were some events dispatched; go around again
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
/* ACE_WIN32 */
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// Remember the old reactor.
// Assign *this* <Reactor> to the <Event_Handler>.
// Reset the old reactor in case of failures.
// First, try to remember this reactor in the event handler, in case
// the event handler goes away before the notification is delivered.
/* __ACE_INLINE __ */
/* ACE_HAS_DUMP */
// Used to wakeup the reactor.
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ACE_HAS_WINCE
// Input: term        the character to terminate on
//        search      the character to search for
//        replace     the character with which to replace search
// Output: a buffer containing the contents of stream
// Method: call the recursive helper function read_helper
// Input: term       the termination character
//        search     the character to search for
//        replace    the character with which to replace search
// Purpose: read in a file to a buffer using only a single dynamic
//          allocation.
// Method: read until the local buffer is full and then recurse.
//         Must continue until the termination character is reached.
//         Allocate the final buffer based on the number of local
//         buffers read and as the recursive calls bottom out,
//         copy them in reverse order into the allocated buffer.
// This is our temporary workspace.
// Read in the file char by char
// Don't insert EOF into the buffer...
// Check for possible substitutions.
// Substitutions must be made before checking for termination.
// Increment the number of bytes.
// Don't bother going any farther if the total size is 0.
// Recurse, when the recursion bottoms out, allocate the result
// buffer.
// Use the allocator to acquire the memory.  The + 1 allows
// space for the null terminator.
// Null terminate the buffer.
// Copy buf into the appropriate location starting from end of
// buffer.  Peter says this is confusing and that we should use
// memcpy() ;-)
/**
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::ACE_Recursive_Thread_Mutex");
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::~ACE_Recursive_Thread_Mutex");
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::remove");
// The counter part of the following two functions for Win32 are
// located in file Synch.i
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::get_thread_id");
// @@ The structure CriticalSection in Win32 doesn't hold the thread
// handle of the thread that owns the lock.  However it is still not
// clear at this point how to translate a thread handle to its
// corresponding thread id.
/* ACE_WIN32 */
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::get_nesting_level");
// This is really a Win32-ism...
// Nothing inside of a CRITICAL_SECTION object should ever be
// accessed directly.  It is documented to change at any time.
//
// It has been reported that this this works for all three
// architectures.  However, this does not work on Win64 before SP1.
/* ACE_WIN32 */
/* !ACE_HAS_WINCE */
// ACE_TRACE ("ACE_Recursive_Thread_Mutex::dump");
/* ACE_HAS_DUMP */
/* ACE_HAS_THREADS */
/* __ACE_INLINE __ */
/* __ACE_INLINE__ */
/* !ACE_REFCOUNTABLE_T_CPP */
/* !ACE_REFCOUNTED_AUTO_PTR_CPP */
// Funky macro to deal with strange error passing semantics
// of Win32 Reg*() functions
// Simple binding constructor
// Binding constructor
// (Name version)
// Binding constructor
// (String version)
// Name accessor
// (Name version)
// Name accessors
// (String version)
// Name accessors
// (String version)
// Type accessor
// Simple object constructor
// Object accessors and set methods
// Simple context constructor
// Context constructor
// This is incorrect.
// Rather than copying key, we should call ::DuplicateHandle()
// But since this is private (and not used), I don't care much
// Not implemented
// Destructor
// Insert <object> with <name> into <this> context
// (Name version)
// Insert <object> with <name> into <this> context
// (String version)
// temporary object
// resolve succeeded
// resolve failed
// Insert or update <object> with <name> into <this> context
// (Name version)
// Insert or update <object> with <name> into <this> context
// (String version)
// Update <object> with <name> in <this> context
// (Name version)
// Update <object> with <name> in <this> context
// (String version)
// find the old one first
// no need to delete first
// Find <object> with <name> in <this> context
// (Name version)
// Find <object> with <name> in <this> context
// (String version)
// Get object state
// Reset object state
// No need to set object.data()
// Remove object with <name> in <this> context
// (Name version)
// Remove object with <name> in <this> context
// (String version)
// Create new <naming_context> relative to <this> context
// This method may not mean a lot in this implementation
// Make sure that we reset the state and close keys
// Insert <naming_context> with <name> relative to <this> context
// (Name version)
// Insert <naming_context> with <name> relative to <this> context
// (String version)
// If create succeeds
// If new key: success
// Set the correct parent
// Set the correct name
// reason == REG_OPENED_EXISTING_KEY
// Failed to make new key
// reset result to failure
// Close the key first
// Reset key
// Insert or update <naming_context> with <name> relative to <this> context
// (Name version)
/* const */ Naming_Context &naming_context,
// Insert or update <naming_context> with <name> relative to <this> context
// (String version)
/* const */ Naming_Context &naming_context,
// Set the correct parent
// Set the correct name
// Rename <naming_context> to <name>
// (Name version)
/* const */ Naming_Context &new_naming_context)
// Rename <naming_context> to <name>
// (String version)
/* const */ Naming_Context &new_naming_context)
// find the old one first
// naming_context is found: delete entry
// successful deletion; rebind
// beware of race conditions here
// (lets resolve this later)
// Remove naming_context with <name> from <this> context
// (Name version)
// Remove naming_context with <name> from <this> context
// (String version)
// Find <naming_context> with <name> in <this> context
// (Name version)
// Find <naming_context> with <name> in <this> context
// (String version)
// set the correct parent
// set the correct name
// Same as unbind_context() with <this> as naming_context
// hopefully the parent_key_ is still open
// Sync content of context to disk
// Close the handle of the context
// Convert a <name> to a <string>
// Iterator through the components of name
// If this is not the first component, we will add separators
// Add to string
// Convert a <string> to a <name>
// Rememeber: NPOS is -1
// Find the separator
// If we have not gone past the end
// Get the substring
// Skip past the seperator
// Get the last substring
// Update positions
// Insert component into name
// Set key
// Get key
// Set parent
// Get parent
// Set name
// (Name version)
// Get name
// (Name version)
// Set name
// (String version)
// Get name
// (String version)
// Get name
// (String version)
// Empty list
// listing function: iterator creator
// This is useful when there are many objects and contexts
// in <this> context and you only want to look at a few entries
// at a time
// Make sure that the list is empty
// Correctly initalize the iterator
// Make sure that the iterator uses <this> naming context
// Start iterations from the objects
// Get the next <how_many> values
// listing function: iterator creator
// This gives back a listing of all entries in <this> context.
// Make sure that the list is empty
// Create an iterator
// Make sure that the iterator uses <this> naming context
// Start iterations from the objects
// Default constructor
// Next entry
// Get next n (where n is one)
// Success
// Next <how_many> entries
// Make sure that the list is empty
// Destroy iterator
// Set/Get naming_context
// Set/Get current enumeration
// Make a copy
// While there are more entries to be added to the list
// Object found
// Readjust counters
// Add to list
// Create binding
// Add to binding list
// Continue to add to list
// Enumeration of objects complete
// Reset index
// Current enumeration will become CONTEXTS
// If we were able to add objects
// Strange error
// Reset index
// Current enumeration will become COMPLETE
// strange error
// If we reach here, all of <how_many> pairs were added to the list
// Since more entries may be available
// current enumeration will remain OBJECTS
// Make a copy
// While there are more entries to be added to the list
// Object found
// Readjust counters
// Add to list
// Create binding
// Add to binding list
// Continue to add to list
// Enumeration of objects complete
/* FALL THROUGH */
// Strange error
// Reset index
// Current enumeration will become CONTEXTS
// If we were able to add contexts
// If we reach here, all of <how_many> pairs were added to the list
// Since more entries may be available
// current enumeration will remain CONTEXTS
// No more values
// Factory method to connect to predefined registries
// This method works for both remote and local machines
// However, for remote machines CLASSES_ROOT and CURRENT_USER
// types are not allowed
/* static */
// Make sure that for these types, the machine is local
// ACE_HAS_WINCE
// Check if <machine_name> is the local host
/* static */
/* ACE_WIN32 && !ACE_LACKS_WIN32_REGISTRY */
// This only works on Win32 platforms when ACE_USES_WCHAR is turned on
// Directory
// Separator
// Filename
// Create new context or bind to existing one
// Pointer to data
// Size
// Represent value as an ACE_Registry::Object
// Add new <key>/<value> pair
/* ACE_HAS_WCHAR */
// Pointer to data
// Size
// Represent value as an ACE_Registry::Object
// Add new <key>/<value> pair
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
// This object will be used to query the size of the data.
// Note: The query_object.data will be null for this invocation.
/* ACE_USES_WCHAR */
// Resize the value passed by the user
// Note: -1 is used because the size includes the null terminator
// Represent new space as an ACE_Registry::Object
/* ACE_USES_WCHAR */
// Iterator through all entries
// Yeeesss! STL rules!
// Key
// Value
// Complete binding
/* ACE_HAS_DUMP */
/* ACE_WIN32 && ACE_USES_WCHAR */
// Initialize Addr
// Connect to Name Server process.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
/* __ACE_INLINE__ */
/* ACE_MT_SAFE */
// Make a typedef to simplify access to the Singleton below.
// Initialize the statics from ACE_TSS_Connection;
// ************************************************************
// Necessary to make some compilers work...
/* ACE_HAS_DUMP */
// Do the work of sending a request and getting a reply.
// Transmit request via a blocking send.
// Receive reply via blocking read.
// First grab the local shadow mutex.
// Acquire failed, deal with it...
// Whoah, we detected wouldblock via the shadow mutex!
// No error, but would block,
// Update the local shadow copy.
// Our shadow call may have failed.  However, it's still a race
// to the remote server.  If we beat the client which holds the
// local token, we need to fix things locally to reflect the
// actual ownership.  All that should happen is that our waiter
// is moved to the front of the waiter list.
// If we can detect locally that the tryacquire will fail, there is
// no need to go remote.
// Save/restore errno.
// Check for error.
// Save/restore errno.
// Make sure that the local shadow reflects our new ownership.
// whether success or failure, we're going to release the shadow.
// If race conditions exist such that we are no longer the owner,
// this release will perform a remove.
// ACE_Token_Proxy::token_acquired (vp);
// @@ special operation
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_TOKENS_LIBRARY */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Explicitly destroy the lock.
// Release the lock.
// Release the lock.
// Acquire the lock.
// Release the lock.
// Release the lock.
// Release the lock.
// Release the lock.
// Release the lock.
/* ACE_REVERSE_LOCK_T_CPP */
/**
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_RW_Mutex::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_RW_Mutex::ACE_RW_Mutex");
// ACE_TRACE ("ACE_RW_Mutex::~ACE_RW_Mutex");
/* ACE_HAS_THREADS */
/* __ACE_INLINE__ */
/* ACE_WIN32 */
// ACE_TRACE ("ACE_RW_Process_Mutex::ACE_RW_Process_Mutex");
// ACE_TRACE ("ACE_RW_Process_Mutex::~ACE_RW_Process_Mutex");
// ACE_TRACE ("ACE_RW_Process_Mutex::dump");
/* ACE_HAS_DUMP */
/**
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_RW_Thread_Mutex::ACE_RW_Thread_Mutex");
// ACE_TRACE ("ACE_RW_Thread_Mutex::dump");
/* ACE_HAS_DUMP */
/* ACE_HAS_THREADS */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_NLOGGING */
// Ask system for more local memory via sbrk(2).
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) acquiring more chunks, nbytes = %d, rounded_bytes = %d\n"), nbytes, rounded_bytes));
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) acquired more chunks, nbytes = %d, rounded_bytes = %d, new break = %u\n"), nbytes, rounded_bytes, cp));
/* No-op for now... */
// Ask system for initial chunk of local memory.
// Note that we assume that when ACE_Sbrk_Memory_Pool is used,
// ACE_Malloc's constructor will only get called once.  If this
// assumption doesn't hold, we are in deep trouble!
/* ACE_HAS_DUMP */
// Round up the request to a multiple of the page size.
/* !ACE_LACKS_SBRK */
//=============================================================================
/**
//=============================================================================
/* __ACE_INLINE__ */
/**/ <sys/priocntl.h>
/* ACE_HAS_PRIOCNTL && ACE_HAS_THREADS */
// Assume that ACE_SCHED_OTHER indicates TS class, and that other
// policies indicate RT class.
// Call ACE_OS::priority_control only for processes (lightweight
// or otherwise). Calling ACE_OS::priority_control for thread
// priorities gives incorrect results.
// Get the priority class ID and attributes.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
/* ignored */,
/* ignored */,
// Just hope that priority range wasn't configured from -1
// .. 1
// OK, now we've got the class ID in pcinfo.pc_cid.  In
// addition, the maximum configured time-share priority is in
// ((tsinfo_t *) pcinfo.pc_clinfo)->ts_maxupri.  The minimum
// priority is just the negative of that.
// Here we handle the case for ACE_SCOPE_THREAD. Calling
// ACE_OS::priority_control for thread scope gives incorrect
// results.
/* ACE_HAS_PRIOCNTL && defined (ACE_HAS_STHREADS) */
// Call ACE_OS::priority_control only for processes (lightweight
// or otherwise). Calling ACE_OS::priority_control for thread
// priorities gives incorrect results.
// Assume that ACE_SCHED_OTHER indicates TS class, and that other
// policies indicate RT class.
// Get the priority class ID and attributes.
// The following is just to avoid Purify warnings about unitialized
// memory reads.
/* ignored */,
/* ignored */,
// OK, now we've got the class ID in pcinfo.pc_cid.  In addition,
// the maximum configured real-time priority is in ((rtinfo_t *)
// pcinfo.pc_clinfo)->rt_maxpri, or similarly for the TS class.
// Here we handle the case for ACE_SCOPE_THREAD. Calling
// ACE_OS::priority_control for thread scope gives incorrect
// results.
/* ACE_HAS_PRIOCNTL && defined (ACE_HAS_STHREADS) */
// unknown priority:  should never get here
// including STHREADS, and PTHREADS
/* ACE_HAS_THREADS */
// unknown priority:  should never get here
// including STHREADS and PTHREADS
/* ACE_HAS_THREADS */
/* __ACE_INLINE__ */
/* !ACE_WIN32 */
/* ACE_WIN32 */
// Performs sanity checking on the ACE_HANDLE.
// It's too expensive to perform more exhaustive validity checks on
// Win32 due to the way that they implement SOCKET HANDLEs.
/* !ACE_WIN32 */
/* ACE_WIN32 */
// Performs sanity checking on the ACE_HANDLE.
// It's too expensive to perform more exhaustive validity checks on
// Win32 due to the way that they implement SOCKET HANDLEs.
/* !ACE_WIN32 */
/* ACE_WIN32 */
// Don't bother setting errno.  It isn't used in the select()-based
// reactors and incurs a TSS access.
// errno = EINVAL;
// Initialize the ACE_Event_Handler pointers to 0.
/* ACE_WIN32 */
// Try to increase the number of handles if <size> is greater than
// the current limit.
// Initialize a repository of the appropriate <size>.
/* !ACE_WIN32 */
// Unbind all of the <handle, ACE_Event_Handler>s.
// Post-increment (*not* pre-increment) before unbind()ing since
// the current iterator will be invalidated during the unbind()
// operation.
// We could use the "end()" iterator but leveraging max_handlep1_
// allows us to optimize away unnecessary accesses of nil event
// handler pointers.
// iterator == ACE_Event_Handler*
/* ACE_WIN32 */
// this code assumes the handle is in range.
/* ACE_WIN32 */
// Bind the <ACE_Event_Handler *> to the <ACE_HANDLE>.
// Is this handle already in the Reactor?
// Entry already exists.
// Cannot use a different handler for an existing handle.
// Remember that this handle is already registered in the
// Reactor.
// Check if this handle is already registered.
// Cannot use a different handler for an existing handle.
// Remember that this handle is already registered in the
// Reactor.
/* ACE_WIN32 */
// Note the fact that we've changed the state of the <wait_set_>,
// which is used by the dispatching loop to determine whether it can
// keep going or if it needs to reconsult select().
// this->select_reactor_.state_changed_ = 1;
// If new entry, call add_reference() if needed.
// Remove the binding of <ACE_HANDLE>.
// Retrieve event handler before unbinding it from the map.  The
// iterator pointing to it will no longer be valid once the handler
// is unbound.
// Clear out the <mask> bits in the Select_Reactor's wait_set.
// And suspend_set.
// Note the fact that we've changed the state of the <wait_set_>,
// which is used by the dispatching loop to determine whether it can
// keep going or if it needs to reconsult select().
// this->select_reactor_.state_changed_ = 1;
// If there are no longer any outstanding events on this <handle>
// then we can totally shut down the Event_Handler.
// Should not happen!
// We've deleted the last entry, so we need to figure out
// the last valid place in the array that is worth looking
// at.
// Compute the maximum of six values.
/* ACE_WIN32 */
// The handle has been completely removed.
// Close down the <Event_Handler> unless we've been instructed not
// to.
// Call remove_reference() if the removal is complete and reference
// counting is needed.
// Don't use ACE_Array_Base::end() since it may be larger than
// event_handlers[max_handlep1_].
// Advance to the next element containing a non-zero event handler.
// There's no need to do this for the Windows case since the hash
// map will only contain non-zero event handlers.
// Pass back the <next_item> that hasn't been seen in the Set.
// Returns 0 when all items have been seen, else 1.
// Move forward by one element in the set.
// No need to explicitly limit search to "current" to
// max_handlep1_ range.
// Don't use ACE_Array_Base::end() since it may be larger than
// event_handlers[max_handlep1_].
/* ACE_WIN32 */
// Advance to the next element containing a non-zero event handler.
// There's no need to do this for the Windows case since the hash
// map will only contain non-zero event handlers.
/* !ACE_WIN32 */
// Dump the state of an object.
/* ACE_WIN32 */
/* ACE_HAS_DUMP */
/* ACE_WIN32 */
/* ACE_HAS_DUMP */
// Must always be > 0 or < 0 to optimize the loop exit condition.
// purge_pending_notifications
// Removes all entries from the notify_queue_ and each one that
// matches <eh> is put on the free_queue_. The rest are saved on a
// local queue and copied back to the notify_queue_ at the end.
// Returns the number of entries removed. Returns -1 on error.
// ACE_NOTSUP_RETURN if ACE_HAS_REACTOR_NOTIFICATION_QUEUE is not defined.
/* defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE) */
/* defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE) */
/* ACE_HAS_DUMP */
/* F_SETFD */
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// There seems to be a Win32 bug with this...  Set this into
// non-blocking mode.
// Please see Bug 2820, if we just close the pipe then we break
// the reference counting rules.  Basically, all the event
// handlers "stored" in the pipe had their reference counts
// increased.  We need to decrease them before closing the
// pipe....
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// Just consider this method a "no-op" if there's no
// <ACE_Select_Reactor> configured.
// No failures, the handler is now owned by the notification queue
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// No failures.
// Handles pending threads (if any) that are waiting to unblock the
// Select_Reactor.
// If eh == 0 then another thread is unblocking the
// <ACE_Select_Reactor> to update the <ACE_Select_Reactor>'s
// internal structures.  Otherwise, we need to dispatch the
// appropriate handle_* method on the <ACE_Event_Handler>
// pointer we've been passed.
// has no dispatchable buffer
/*ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// Dispatch one message from the notify queue, and put another in
// the pipe if one is available.  Remember, the idea is to keep
// exactly one message in the pipe at a time.
/* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
// If eh == 0 then another thread is unblocking the
// <ACE_Select_Reactor> to update the <ACE_Select_Reactor>'s
// internal structures.  Otherwise, we need to dispatch the
// appropriate handle_* method on the <ACE_Event_Handler> pointer
// we've been passed.
// Should we bail out if we get an invalid mask?
// This is kind of a weird, fragile beast.  We first read with a
// regular read.  The read side of this socket is non-blocking, so
// the read may end up being short.
//
// If the read is short, then we do a recv_n to insure that we block
// and read the rest of the buffer.
//
// Now, you might be tempted to say, "why don't we just replace the
// first recv with a recv_n?"  I was, too.  But that doesn't work
// because of how the calling code in handle_input() works.  In
// handle_input, the event will only be dispatched if the return
// value from read_notify_pipe() is > 0.  That means that we can't
// return zero from this func unless it's an EOF condition.
//
// Thus, the return value semantics for this are:
// -1: nothing read, fatal, unrecoverable error
// 0: nothing read at all
// 1: complete buffer read
// Check to see if we've got a short read.
// If so, try to recover by reading the remainder.  If this
// doesn't work we're in big trouble since the input stream
// won't be aligned correctly.  I'm not sure quite what to
// do at this point.  It's probably best just to return -1.
// Return -1 if things have gone seriously  wrong.
// Precondition: this->select_reactor_.token_.current_owner () ==
// ACE_Thread::self ();
// If there is only one buffer in the pipe, this will loop and call
// read_notify_pipe() twice.  The first time will read the buffer, and
// the second will read the fact that the pipe is empty.
// Dispatch the buffer
// NOTE: We count only if we made any dispatches ie. upcalls.
// Bail out if we've reached the <notify_threshold_>.  Note that
// by default <notify_threshold_> is -1, so we'll loop until all
// the notifications in the pipe have been dispatched.
// Reassign number_dispatched to -1 if things have gone seriously
// wrong.
// Enqueue ourselves into the list of waiting threads.  When we
// reacquire the token we'll be off and running again with ownership
// of the token.  The postcondition of this call is that
// <select_reactor_.token_.current_owner> == <ACE_Thread::self>.
// -------------------------------------------
// Perform GET, CLR, SET, and ADD operations on the Handle_Sets.
//
// GET = 1, Retrieve current value
// SET = 2, Set value of bits to new mask (changes the entire mask)
// ADD = 3, Bitwise "or" the value into the mask (only changes
//          enabled bits)
// CLR = 4  Bitwise "and" the negation of the value out of the mask
//          (only changes enabled bits)
//
// Returns the original mask.  Must be called with locks held.
// Block out all signals until method returns.
/* ACE_WIN32 */
// Find the old reactor masks.  This automatically does the work of
// the GET_MASK operation.
// The work for this operation is done in all cases at the
// beginning of the function.
// State was changed. we need to reflect that change in the
// dispatch_mask I assume that only ACE_Reactor::CLR_MASK should
// be treated here  which means we need to clear the handle|mask
// from the current dispatch handler
/* FALLTHRU */
/* FALLTHRU */
// The following code is rather subtle...  Note that if we are
// doing a ACE_Reactor::SET_MASK then if the bit is not enabled
// in the mask we need to clear the bit from the ACE_Handle_Set.
// On the other hand, if we are doing a ACE_Reactor::CLR_MASK or
// a ACE_Reactor::ADD_MASK we just carry out the operations
// specified by the mask.
// READ, ACCEPT, and CONNECT flag will place the handle in the
// read set.
// WRITE and CONNECT flag will place the handle in the write set
// EXCEPT (and CONNECT on Win32) flag will place the handle in
// the except set.
/* ACE_WIN32 */
//  Use handle and mask in order to modify the sets
// (wait/suspend/ready/dispatch), that way, the dispatch_io_set loop
// will not be interrupt, and there will no reason to rescan the
// wait_set and re-calling select function, which is *very*
// expensive. It seems that wait/suspend/ready sets are getting
// updated in register/remove bind/unbind etc functions.  The only
// thing need to be updated is the dispatch_set (also can  be found
// in that file code as dispatch_mask).  Because of that, we need
// that dispatch_set to be member of the ACE_Select_Reactor_impl in
// Select_Reactor_Base.h file  That way we will have access to that
// member in that function.
// We kind of invalidate the iterator in dispatch_io_set because its
// an array and index built from the original dispatch-set. Take a
// look at dispatch_io_set for more details.
// We only need to clr_bit, because we are interested in clearing the
// handles that was removed, so no dispatching to these handles will
// occur.
// That will make the dispatch_io_set iterator re-start and rescan
// the dispatch set.
// The select reactor has no handlers that can be resumed by the
// application. So return 0;
/* ACE_LACKS_PRAGMA_ONCE */
// For timer_queue_
/*
//@@ REACTOR_SPL_INCLUDE_FORWARD_DECL_ADD_HOOK
/* __ACE_INLINE__ */
// Make this call signal safe.
/* ACE_WIN32 */
// number_ready > 0 meaning there are handles in the ready_set
// &wait_set != &(this->ready_set_) means that we need to copy
// the handles from the ready_set to the wait set because the
// wait_set_ doesn't contain all the handles in the ready_set_
// Must always requeue ourselves "next" on Win32.
/* ACE_WIN32 */
// Enqueue ourselves into the list of waiting threads.
/* defined (ACE_MT_SAFE) && (ACE_MT_SAFE != 0) */
// Pass over both the Event_Handler *and* the mask to allow the
// caller to dictate which Event_Handler method the receiver
// invokes.  Note that this call can timeout.
// Performs operations on the "ready" bits.
// Can't initialize ourselves more than once.
// Allows the signal handler to be overridden.
// Allows the timer queue to be overridden.
// Allows the Notify_Handler to be overridden.
// We're all set to go.
// This will close down all the allocated resources properly.
// First try to open the Reactor with the hard-coded default.
// The hard-coded default Reactor size failed, so attempt to
// determine the size at run-time by checking the process file
// descriptor limit on platforms that support this feature.
// reset the errno so that subsequent checks are valid
// There is no need to deallocate resources from previous open()
// call since the open() method deallocates any resources prior
// to exiting if an error was encountered.
// Set the default reactor size to be the current limit on the
// number of file descriptors available to the process.  This
// size is not necessarily the maximum limit.
// Initialize ACE_Select_Reactor_T.
// Close down the ACE_Select_Reactor_T instance, detaching any
// remaining Event_Handers.  This had better be called from the main
// event loop thread...
/* ACE_NSIG <= 0 */
/* ACE_NSIG <= 0 */
/* ACE_NSIG <= 0 */
/* ACE_NSIG <= 0 */
// Main event loop driver that blocks for <max_wait_time> before
// returning (will return earlier if I/O or signal events occur).
// Avoid multiple TSS accesses.
/* ACE_LINUX && ERESTARTNOHAND */
// On MVS Open Edition and Win32, there can be a number of failure
// codes on a bad socket, so check_handles on anything other than
// EINTR.  VxWorks doesn't even bother to always set errno on error
// in select (specifically, it doesn't return EBADF for bad FDs).
/* __MVS__ || ACE_WIN32 */
// Check for removed handlers.
// Call add_reference() if needed.
// Call remove_reference() if needed.
// Perform GET, CLR, SET, and ADD operations on the select()
// Handle_Sets.
//
// GET = 1, Retrieve current value
// SET = 2, Set value of bits to new mask (changes the entire mask)
// ADD = 3, Bitwise "or" the value into the mask (only changes
//          enabled bits)
// CLR = 4  Bitwise "and" the negation of the value out of the mask
//          (only changes enabled bits)
//
// Returns the original mask.
// If the handle is not suspended, then set the ops on the
// <wait_set_>, otherwise set the <suspend_set_>.
// Must be called with locks held.
// Must be called with locks held
// Must be called with locks held
// Kobi: we need to remove that handle from the
// dispatch set as well. We use that function with all the relevant
// masks - rd/wr/ex - all the mask. it is completely suspended
// Must be called with locks held
// Must be called with locks held
// Insert the <handle, event_handle> tuple into the Handler
// Repository.
// Unbind this handle.
// Update the countdown to reflect time waiting for the mutex.
// Check if we have timers to fire.
// This arg is ignored on Windows and causes pointer truncation
// warnings on 64-bit compiles.
/* ACE_WIN32 */
// If timers are pending, override any timeout from the select()
// call.
// Must be called with lock held.
// If there are any bits enabled in the <ready_set_> then we'll
// handle those first, otherwise we'll block in <select>.
// This arg is ignored on Windows and causes pointer
// truncation warnings on 64-bit compiles.
/* ACE_WIN32 */
// Resynchronize the fd_sets so their "max" is set properly.
/* ACE_WIN32 */
// Normally, select() will reset the bits in dispatch_set
// so that only those filed descriptors that are ready will
// have bits set.  However, when an error occurs, the bit
// set remains as it was when the select call was first made.
// Thus, we now have a dispatch_set that has every file
// descriptor that was originally waited for, which is not
// correct.  We must clear all the bit sets because we
// have no idea if any of the file descriptors is ready.
//
// NOTE: We dont have a test case to reproduce this
// problem. But pleae dont ignore this and remove it off.
// Return the number of events to dispatch.
// Check to see if the ACE_HANDLE associated with the
// Select_Reactor's notify hook is enabled.  If so, it means that
// one or more other threads are trying to update the
// ACE_Select_Reactor_T's internal tables or the notify pipe is
// enabled.  We'll handle all these threads and notifications, and
// then break out to continue the event loop.
// Same as dispatch_timer_handlers
// No need to do anything with the state changed. That is because
// unbind already handles the case where someone unregister some
// kind of handle and unbind it. (::unbind calls the function
// state_changed ()  to reflect ant change with that)
//   return this->state_changed_ ? -1 : 0;
// clear the bit from that dispatch mask,
// so when we need to restart the iteration (rebuilding the iterator...)
// we will not dispatch the already dispatched handlers
// Handle output events (this code needs to come first to handle the
// obscure case of piggy-backed data coming along with the final
// handshake message of a nonblocking connection).
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("ACE_Select_Reactor_T::dispatch - EXCEPT\n")));
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("ACE_Select_Reactor_T::dispatch - READ\n")));
// The following do/while loop keeps dispatching as long as there
// are still active handles.  Note that the only way we should ever
// iterate more than once through this loop is if signals occur
// while we're dispatching other handlers.
// We expect that the loop will decrease the number of active
// handles in each iteration.  If it does not, then something is
// inconsistent in the state of the Reactor and we should avoid
// the loop.  Please read the comments on bug 2540 for more
// details.
// Note that we keep track of changes to our state.  If any of
// the dispatch_*() methods below return -1 it means that the
// <wait_set_> state has changed as the result of an
// <ACE_Event_Handler> being dispatched.  This means that we
// need to bail out and rerun the select() loop since our
// existing notion of handles in <dispatch_set> may no longer be
// correct.
//
// In the beginning, our state starts out unchanged.  After
// every iteration (i.e., due to signals), our state starts out
// unchanged again.
// Perform the Template Method for dispatching all the handlers.
// First check for interrupts.
// Bail out -- we got here since <select> was interrupted.
// If any HANDLES in the <ready_set_> are activated as a
// result of signals they should be dispatched since
// they may be time critical...
// Record the fact that the Reactor has dispatched a
// handle_signal() method.  We need this to return the
// appropriate count below.
// Handle timers early since they may have higher latency
// constraints than I/O handlers.  Ideally, the order of
// dispatching should be a strategy...
// State has changed or timer queue has failed, exit loop.
// Check to see if there are no more I/O handles left to
// dispatch AFTER we've handled the timers...
// Next dispatch the notification handlers (if there are any to
// dispatch).  These are required to handle multi-threads that
// are trying to update the <Reactor>.
// State has changed or a serious failure has occurred, so exit
// loop.
// Finally, dispatch the I/O handlers.
// State has changed, so exit loop.
// if state changed, we need to re-eval active_handle_count,
// so we will not end with an endless loop
/* ACE_WIN32 */
// Stash the current time -- the destructor of this object will
// automatically compute how much time elapsed since this method was
// called.
// Update the countdown to reflect time waiting for the mutex.
/* ACE_MT_SAFE */
// We use the data member dispatch_set_ as the current dispatch
// set.
// We need to start from a clean dispatch_set
// As it stands now, we catch and then rethrow all Win32
// structured exceptions so that we can make sure to release the
// <token_> lock correctly.
/* ACE_WIN32 || MVS || ACE_VXWORKS */
/*
// Win32 needs to do the check this way because fstat won't work on
// a socket handle.  MVS Open Edition needs to do it this way because,
// even though the docs say to check a handle with either select or
// fstat, the fstat method always says the handle is ok.
// pSOS needs to do it this way because file handles and socket handles
// are maintained by separate pieces of the system.  VxWorks needs the select
// variant since fstat always returns an error on socket FDs.
// This arg is ignored on Windows and causes pointer truncation
// warnings on 64-bit compiles.
/* ACE_WIN32 */
/* !ACE_WIN32 && !MVS && !VXWORKS */
/* ACE_WIN32 || MVS */
/* ACE_MT_SAFE */
/* ACE_HAS_DUMP */
/* ACE_SELECT_REACTOR_T_CPP */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_TRACE ("ACE_Semaphore::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Semaphore::ACE_Semaphore");
// if the user does not provide a name, we generate a unique name here
// ACE_TRACE ("ACE_Semaphore::~ACE_Semaphore");
/* __ACE_INLINE__ */
/* !ACE_LACKS_UNIX_SIGNALS */
/**
/// ctor
// Modify the TSS if the repo has changed
// Set the signal handler to point to the handle_signal() function.
// Trigger a reconfiguration.
// = Set by command-line options.
/// Pathname of file to write process id.
/// Shall we become a daemon process?
/// Number of the signal used to trigger reconfiguration.
/* ACE_HAS_DUMP */
// Using PERMUTE_ARGS (default) in order to have all
// unrecognized options and their value arguments moved
// to the end of the argument vector. We'll pick them up
// after processing our options and pass them on to the
// base class for further parsing.
//FUZZ: disable check_for_lack_ACE_OS
// Start at argv[1].
// Do not report errors
//FUZZ: enable check_for_lack_ACE_OS
//FUZZ: disable check_for_lack_ACE_OS
//FUZZ: enable check_for_lack_ACE_OS
// There's no point in dealing with this on NT since it
// doesn't really support signals very well...
/* ACE_LACKS_UNIX_SIGNALS */
// unknown arguments are benign
/* parse_args_i () */
// Guard against reentrant processing.
// Check for things we need to do on a per-process basis and which
// may not be safe, or wise to do an a per instance basis
// Become a daemon before doing anything else.
// If we have to become a daemn and that fails
// return -1 here
// Write process id to file.
// Only use STDERR if the caller hasn't already set the flags.
// Only use the static <logger_key_> if the caller doesn't
// override it in the parameter list or if the key supplied is
// equal to the default static logger key.
// Initialize the Service Repository (this will still work if
// user forgets to define an object of type ACE_Service_Config).
// Initialize the ACE_Reactor (the ACE_Reactor should be the
// same size as the ACE_Service_Repository).
// There's no point in dealing with this on NT since it doesn't
// really support signals very well...
// Only attempt to register a signal handler for positive
// signal numbers.
/* ACE_LACKS_UNIX_SIGNALS */
/// Return the global configuration instance. Always returns the same
/// instance
// Totally remove <svc_name> from the daemon by removing it from the
// ACE_Reactor, and unlinking it if necessary.
// Suspend <svc_name>.  Note that this will not unlink the service
// from the daemon if it was dynamically linked, it will mark it as
// being suspended in the Service Repository and call the <suspend>
// member function on the appropriate <ACE_Service_Object>.  A service
// can be resumed later on by calling the <resume> method...
// Resume a SVC_NAME that was previously suspended or has not yet
// been resumed (e.g., a static service).
// TODO: Need to find a more customizable way of instantiating the
// gestalt but perhaps we should leave this out untill such
// customizations are identified.
// TODO: Need to find a more customizable way of instantiating the
// gestalt but perhaps we should leave this out untill such
// customizations are identified.
// Only print out an error if it wasn't the svc.conf file that was
// missing.
/// Return the "global" configuration instance, for the current
/// thread. This may be the same as instance(), but on some occasions,
/// it may be a different one. For example, ACE_Service_Config_Guard
/// provides a way of temporarily replacing the "current"
/// configuration instance in the context of a thread.
// The most likely reason is that the current thread was spawned
// by some native primitive, like pthreads or Windows API - not
// from ACE. This is perfectly legal for callers who are not, or
// do not need to be ACE-aware. Such callers must have no
// expectation that the pluggable, multi-context configuration
// support will work - they would always get the global context,
// because at this point there is no information what the "parent"
// thread's configuration context was.
/// A mutator to set the "current" (TSS) gestalt instance.
/* ACE_USES_CLASSIC_SVC_CONF == 0 */
// Note, the only place we need to put a case statement.  This is
// also the place where we'd put the RTTI tests, if the compiler
// actually supported them!
// Signal handling API to trigger dynamic reconfiguration.
/* ! ACE_NDEBUG */
/* ! ACE_NDEBUG */
// Trigger reconfiguration to re-read configuration files.
/* ! ACE_NLOGGING */
// Tidy up and perform last rites on a terminating ACE_Service_Config.
// Delete the service repository.  All the objects inside the
// service repository should already have been finalized.
// Do away with the singleton ACE_Service_Config (calls dtor)
// Clear the LM_DEBUG bit from log messages if appropriate
/// Perform user-specified close activities and remove dynamic memory.
// ************************************************************
/* static */
/* !ACE_LACKS_UNIX_SIGNALS */
// Relocation starts where the next service will be inserted (if any)
// On this thread (for the duration of the initialize() method),
// we're about to do two things that require locking: (1) fiddle
// with the repository and (2) load a DLL and hence lock the
// DLL_Manager.
//
// Now if we don't lock the repo here, it is possible that two
// threads may deadlock on initialization because they can acquire
// locks (1) and (2) in different order, for instance:
//
// T1: loads a DLL (2) and registers a service (1);
//
// T2: may be relocating a service (1), which could lead to a
// (re)opening or uping the ref count on a DLL (2);
//
// To prevent this, we lock the repo here, using the repo_monitor_
// member guard.
// No name?
/// Destructor
// Lookup without ignoring suspended services. Making sure
// not to ignore any inactive services, since those may be forward
// declarations
// We inserted it (as inactive), so we expect to find it, right?
// Something has registered a proper (non-forward-decl) service with
// the same name as our dummy.
// Relocate any services inserted since we were created.
// Any (static, i.e. DLL = 0) services registered in
// the context of this guard aren't really static because
// their code belongs in the DLL's code segment
// ----------------------------------------
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Delete the dynamically allocated static_svcs instance.
/// Performs the common initialization tasks for a new or previously
/// closed instance. Must not be virtual, as it is also called from
/// the constructor.
// Only initialize the repo_ if (a) we are being constructed, or;
// (b) we're being open()-ed, perhaps after previously having been
// close()-ed. In both cases: repo_ == 0 and we need a repository.
/// Add the default statically-linked services to the Service
/// Repository.
// Nothing to do
/* load_static_svcs () */
/// Find a static service descriptor by name
/// @brief
/// @brief Captures a list of the direcives processed (explicitely) for this
/// Gestalt so that services can be replicated in other repositories
/// upon their first initialization.
///
/// This is part of the mechanism ensuring distinct local instances
/// for static service objects, loaded in another repository.
/// When process_directive(Static_Svc_Descriptor&) is called, it
/// associates a service object with the Gestalt and makes the
/// resource (a Service Object) local to the repository. This is but
/// the first step in using such SO. The next is the
/// "initialization" step. It is typically done through a "static"
/// service configuration directive.
///
/// In contrast a "dynamic" directive, when processed through the
/// overloaded process_directives(string) both creates the SO
/// locally and initializes it, where the statics directive must
/// first locate the SO and then calls the init() method. This means
/// that durig the "static" initialization there's no specific
/// information about the hosting repository and the gestalt must
/// employ some lookup strategy to find it elsewhere.
/// Queues a static service object descriptor which, during open()
/// will be given to process_directive() to create the Service
/// Object. Normally, only called from static initializers, prior to
/// calling open() but loading a service from a DLL can cause it too.
/* ACE_HAS_DUMP */
//  if (this->repo_->find (svc_name, &srp) == -1)
/// If initialization fails ...
// ... report and remove this entry.
// If everything is ok, activate it
// If there is an active service already, remove it first
// before it can be re-installed.
// If there is an inactive service by that name it may have been
// either inactivated, or just a forward declaration for a service,
// that is in the process of being initialized. If it is the latter,
// then we have detected an attempt to initialize the same dynamic
// service while still processing previous attempt. This can lock up
// the process, because the ACE_DLL_Manager::open () is not
// re-entrant - it uses a Singleton lock to serialize concurent
// invocations. This use case must be handled here, because if the
// DLL_Manager was re-entrant we would have entered an infinite
// recursion here.
// Reserve a spot for the dynamic service by inserting an incomplete
// service declaration, i.e. one that can not produce a service
// object if asked (a forward declaration).  This declaration
// ensures maintaining the proper partial ordering of the services
// with respect to their finalization. For example, dependent static
// services must be registered *after* the dynamic service that
// loads them, so that their finalization is complete *before*
// finalizing the dynamic service.
// make_service_type() is doing the dynamic loading and also runs
// any static initializers
// All good. Tthe ACE_Service_Type instance is now owned by the
// repository and we should make sure it is not destroyed upon
// exit from this method.
/* (ACE_USES_CLASSIC_SVC_CONF == 1) */
/// Dynamically link the shared object file and retrieve a pointer to
/// the designated shared object in this file.
/// @note This is obsolete (and error-prone) in the presense of dynamic
/// services with their own static services. This method will allow those
/// static services to register *before* the dynamic service that owns them.
/// Upon finalization of the static services the process may crash, because
/// the dynamic service's DLL may have been already released, together with
/// the memory in which the static services reside.
/// It may not crash, for instance, when the first static service to register
/// is the same as the dynamic service being loaded. You should be so lucky! ..
/// Dynamically link the shared object file and retrieve a pointer to
/// the designated shared object in this file.
// We just get ps to avoid having remove() delete it.
// Not using LM_ERROR here to avoid confusing the test harness
// Not using LM_ERROR here to avoid confusing the test harness
// Totally remove <svc_name> from the daemon by removing it from the
// ACE_Reactor, and unlinking it if necessary.
/// Suspend @a svc_name.  Note that this will not unlink the service
/// from the daemon if it was dynamically linked, it will mark it as
/// being suspended in the Service Repository and call the <suspend>
/// member function on the appropriate <ACE_Service_Object>.  A service
/// can be resumed later on by calling the <resume> method...
// Resume a SVC_NAME that was previously suspended or has not yet
// been resumed (e.g., a static service).
// The service is already there, just return
// This is just a temporary to force the compiler to use the right
// constructor in ACE_Service_Type. Note that, in cases where we are
// called from a static initializer which is part of a DLL, there is
// not enough information about the actuall DLL in this context.
// AC 970827 Skip the heap check because yacc allocates a buffer
// here which will be reported as a memory leak for some reason.
// Were we called in the context of the current instance?
// Temporarily (for the duration of this call) make sure that *any*
// static service registrations will happen with this instance. Such
// registrations are possible as a side-effect of dynamically
// loading a DLL, which has other static services registered. Thus
// this instance will own both the DLL and those static services,
// which implies that their finalization will be performed in the
// correct order, i.e. prior to finalizing the DLL
// This is a hack, better errors should be provided...
// Always set the last error if ace_yyparse() fails.
// Other code may use errno to determine the type
// of problem that occurred from processing directives.
/* ACE_USES_CLASSIC_SVC_CONF == 1 */
// To avoid recursive processing of the same file and the same repository
// we maintain an implicit stack of dummy "services" named after the file
// being processed. Anytime we have to open a new file, we then can check
// to see if it is not already being processed by searching for a dummy
// service with a matching name.
// Register a dummy service as a forward decl, using the file name as name.
// The entry will be automaticaly removed once the thread exits this block.
/*
// Invalid svc.conf file.  We'll report it here and break out of
// the method.
// Use stat to find out if the file exists.  I didn't use access()
// because stat is better supported on most non-unix platforms.
// If it exists, but we couldn't open it for reading then we
// must not have permission to read it.
// Keep track of the number of errors.
/* ACE_USES_CLASSIC_SVC_CONF == 1 */
// Temporarily (for the duration of this call) make sure that *any* static
// service registrations will happen with this instance. Such registrations
// are possible as a side-effect of dynamically loading a DLL, which has
// other static services registered. Thus this instance will own both the
// DLL and those static services, which implies that their finalization
// will be performed in the correct order, i.e. prior to finalizing the DLL
/* ACE_USES_CLASSIC_SVC_CONF == 1 */
/* process_directive () */
/* init_svc_conf_file_queue () */
// Record the current log setting upon entering this thread.
// Guard against reentrant processing. For example,
// if the singleton gestalt (ubergestalt) was already open,
// do not open it again...
// Only use STDERR if the caller hasn't already set the flags.
// Only use the static <logger_key_> if the caller doesn't
// override it in the parameter list or if the key supplied is
// equal to the default static logger key.
// If -d was included as a startup parameter, the user wants debug
// information printed during service initialization.
// The user has requested no debugging info.
// check if default file is already listed
// Load the default "svc.conf" entry. here if there weren't
// overriding -f arguments in <parse_args>.
// See if we need to load the static services.
// Reset debugging back to the way it was when we came into
// into <open_i>.
// Make sure to save/restore errno properly.
/* open_i () */
// Process just a single directive.
/* process_commandline_directives () */
// Start at argv[1].
/*
/* parse_args_i () */
// Process service configuration directives from the files queued for
// processing
// Iterate through all the svc.conf files.
/* process_directives () */
// Tidy up and perform last rites on a terminating ACE_Service_Gestalt.
// Delete the list fo svc.conf files
/* close () */
/* __ACE_INLINE__ */
// Allocate a Service Manager.
/* ACE_HAS_DUMP */
// Static variables.
// Reuse the listening address, even if it's already in use!
//FUZZ: disable check_for_lack_ACE_OS
// Start at argv[0]
//FUZZ: enable check_for_lack_ACE_OS
// Determine all the services offered by this daemon and return the
// information back to the client.
// Trigger a reconfiguration of the Service Configurator via its
// svc.conf file.
// Send ourselves a signal!  ACE_OS::kill (ACE_OS::getpid (),
// this->signum_);
/* 0 */
// Flag the main event loop that a reconfiguration should occur.
// The next trip through the <ACE_Reactor::run_event_loop> should
// pick this up and cause a reconfiguration.  Note that we can't
// trigger the reconfiguration automatically since that might "pull
// the rug" out from underneath the existing services in a
// problematic way.
// isolate the request-processing code
// Kill trailing newlines.
// Return a list of the configured services.
// Trigger a reconfiguration by re-reading the local <svc.conf> file.
// Just process a single request passed in via the socket
// remotely.
// Additional management services may be handled here...
// Accept new connection from client and carry out the service they
// request.
// Try to find out if the implementation of the reactor that we are
// using requires us to reset the event association for the newly
// created handle. This is because the newly created handle will
// inherit the properties of the listen handle, including its event
// associations.
// stream
// remote address
// timeout
// restart
// reset new handler
// Read service request from client.
// Keep looping until we actually get the request.  Note that Win32
// sets the socket into non-blocking mode, so we may need to loop if
// the system is heavily loaded.  Read bytes into the buffer until a
// '\n' or '\r' is found in the buffer, otherwise the buffer
// contains an incomplete string.
/* NOTREACHED */
// Restore existing SIGPIPE handler
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Using printf, since the log facility may not have been
// initialized yet. Using a "//" prefix, in case the executable
// happens to be a code generator and the output gets embedded in
// the generated C++ code.
// [ST] dump, this=%p, name=%s, type=%p, so=%p, active=%d\n",
/* ACE_HAS_ALLOC_HOOKS */
// Returning 1 currently only makes sense for dummy instances, used
// to "reserve" a spot (kind of like forward-declarations) for a
// dynamic service. This is necessary to help enforce the correct
// finalization order, when such service also has any (dependent)
// static services
// No implementation was found.
// Ensure type is 0 to prevent invalid access after call to fini.
// Ensure that closing the DLL is done after type_->fini() as it may
// require access to the code for the service object destructor,
// which resides in the DLL
/* ACE_HAS_ALLOC_HOOKS */
// register service allocator function by full name in ACE singleton registry
/* __ACE_INLINE__ */
/// Process-wide Service Repository.
/// Controls whether the Service_Repository is deleted when we shut
/// down (we can only delete it safely if we created it)!
/* ACE_HAS_DUMP */
// Perform Double-Checked Locking Optimization.
// We can't safely delete it since we don't know who created it!
/// Initialize the Repository to a clean slate.
// Create a new array and swap it with the local array
/// Finalize (call fini() and possibly delete) all the services.
// Do not be tempted to use the prefix decrement operator.  Use
// postfix decrement operator since the index is unsigned and may
// wrap around the 0
//
// debug output for empty service entries
//
// Remove all the Service_Object and Stream instances
//
// <fini> the services in reverse order.
// Collect any errors.
//
// Remove all the Module instances
//
// <fini> the services in reverse order.
// Collect any errors.
/// Close down all the services.
// Do not use the prefix decrement operator since the index is
// unsigned and may wrap around the 0.
// Delete services in reverse order.
/// Locate an entry with @a name in the table.  If @a ignore_suspended is
/// set then only consider services marked as resumed.  If the caller
/// wants the located entry, pass back a pointer to the located entry
/// via @a srp.  If @a name is not found -1 is returned.  If @a name is
/// found, but it is suspended and the caller wants to ignore suspended
/// services a -2 is returned.  Must be called with locks held.
// skip any empty slots
/// @brief Relocate (a static) service to another DLL.
///
/// Works by having the service type keep a reference to a specific
/// DLL. No locking, caller makes sure calling it is safe. You can
/// forcefully relocate any DLLs in the given range, not only the
/// static ones - but that will cause Very Bad Things (tm) to happen.
// skip any gaps
// ups the refcount on adll
/// Insert the ACE_Service_Type SR into the repository.  Note that
/// services may be inserted either resumed or suspended. Using same
/// name as in an existing service causes the delete () to be called
/// for the old one, i.e. make sure @code sr is allocated on the heap!
// Establish scope for locking while manipulating the service
// storage
// @TODO: Do we need a recursive mutex here?
// Adding an entry.
// New services are always added where current_size_ points,
// because if any DLL relocation needs to happen, it will be
// performed on services with indexes between some old
// current_size_ and the new current_size_ value.  See
// ACE_Service_Type_Dynamic_Guard ctor and dtor for details.
// If necessary, delete but outside the lock. (s may be 0, but
// that's okay, too)
/// Resume a service that was previously suspended.
/// Suspend a service so that it will not be considered active under
/// most circumstances by other portions of the ACE_Service_Repository.
/**
// Not found!?
/**
// Not found
// We may need the old ptr - to be delete outside the lock!
// simply leave a gap
/* ACE_HAS_DUMP */
/// Initializes the iterator and skips over any suspended entries at
/// the beginning of the table, if necessary.  Note, you must not
/// perform destructive operations on elements during this iteration...
/// Obtains a pointer to the next valid service in the table.  If there
/// are no more entries, returns 0, else 1.
/// Advance the iterator by the proper amount.  If we are ignoring
/// suspended entries and the current entry is suspended, then we must
/// skip over this entry.  Otherwise, we must advance the NEXT index to
/// reference the next valid service entry.
// skip over gaps
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// It's ok to call this, even though we may have already deleted it
// in the fini() method since it would then be NULL.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Cast to remove const-ness.
// Call fini() if an only if, the object was successfuly
// initialized, i.e. init() returned 0. This is necessary to
// maintain the ctor/dtor-like semantics for init/fini.
/* ACE_HAS_DUMP */
//
// Change the Module's name to what's in the svc.conf file.  We must
// do this so the names match up so everything shuts down properly
// during the call to ACE_Stream_Type::fini which calls
// MT_Stream::remove([name]) for all the modules.  If the calls to
// remove fail, we end up with a double delete during
// shutdown. Bugzilla #3847
//
// Note, these operations are somewhat too familiar with the
// implementation of ACE_Module and ACE_Module::close...
// Close the module and delete the memory.
/* ACE_HAS_DUMP */
// Final arg is an indication to *not* delete the Module.
// Locate and remove <mod_name> from the ACE_Stream.
// We need to do this first so we don't bomb out if we delete m!
// Final arg is an indication to *not* delete the Module.
// Do not call m->fini (); as this will result in a double delete
// of the ACE_Module_type when ACE_Service_Repository::fini is called
// @@@ Eliminated ommented out explicit template instantiation code
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Creates a shared memory segment of SIZE bytes.
// The "do-nothing" constructor.
// The overall size of the segment.
// This cast is legit since the original length in open() is an int.
// Unmaps the shared memory segment.
// Closes (unmaps) the shared memory segment.
// Shared_Memory_Pool.cpp
/* ACE_HAS_DUMP */
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) segment size = %d, offset = %d\n"), buf.shm_segsz, offset));
// If segment 'counter' starts at a location greater than the
// place we are searching for. We then decrement the offset to
// the start of counter-1. (flabar@vais.net)
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) segment size = %d, offset = %d\n"), buf.shm_segsz, offset));
/// Handle SIGSEGV and SIGBUS signals to remap shared memory properly.
// While FreeBSD 5.X has a siginfo_t struct with a si_addr field,
// it does not define SEGV_MAPERR.
// Make sure that the pointer causing the problem is within the
// range of the backing store.
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) si_signo = %d, si_code = %d, addr = %u\n"), siginfo->si_signo, siginfo->si_code, siginfo->si_addr));
// The above if case will check to see that the address is in the
// proper range.  Therefore there is a segment out there that the
// pointer wants to point into.  Find the segment that someone else
// has used and attach to it (flabar@vais.net)
// ret value to get shmid from the st table.
// NOTE: this won't work if we dont have SIGINFO_T or SI_ADDR
/* ACE_HAS_SIGINFO_T && !defined (ACE_LACKS_SI_ADDR) */
// Only change the defaults if <options> != 0.
// Convert the string into a number that is used as the segment
// key.
/* ACE_LACKS_SSCANF */
// The conversion to a number failed so hash with crc32
// ACE::crc32 is also used in <SV_Semaphore_Simple>.
// Make sure that the segment can be shared between unrelated
// processes.
// ACE_HAS_SYSV_IPC
// Ask system for more shared memory.
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) acquiring more chunks, nbytes = %d, rounded_bytes = %d\n"), nbytes, rounded_bytes));
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("(%P|%t) acquired more chunks, nbytes = %d, rounded_bytes = %d\n"), nbytes, rounded_bytes));
// Ask system for initial chunk of shared memory.
// Acquire the semaphore to serialize initialization and prevent
// race conditions.
// This implementation doesn't care if we don't get the key we
// want...
// This implementation doesn't care if we don't get the key we
// want...
// Skip over the first entry...
// Instruct the memory pool to release all of its resources.
// Implement the algorithm for rounding up the request to an
// appropriate chunksize.
/* !ACE_LACKS_SYSV_SHMEM */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// The overall size of the segment.
// This cast is ok since the 'open' method for this class allows only
// an 'int' size. Therefore, this case should not lose information.
// Removes the shared memory segment.
// Closes (detaches) the shared memory segment.
/* Provide the abstract base class used to access dynamic linking
/* __ACE_INLINE__ */
// Initializes object when dynamic linking occurs.
// Terminates object when dynamic unlinking occurs.
// Returns information on active object.
// Need to give a default implementation.
// #include "ace/Log_Category.h"
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Restore the signal mask.
//ACE_TRACE ("ACE_Sig_Guard::~ACE_Sig_Guard");
/* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
/* !ACE_LACKS_UNIX_SIGNALS */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Since Service_Config::signal_handler_ is static and has an
// ACE_Sig_Action instance, Win32 will get errno set unless this is
// commented out.
/* ACE_WIN32 */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
/* ACE_NSIG <= 0  */
/* ACE_NSIG <= 0  */
// ACE_TRACE ("ACE_Sig_Action::ACE_Sig_Action");
// Structure assignment...
/* !ACE_HAS_TANDEM_SIGNALS */
/* ACE_NSIG <= 0  */
/* ACE_NSIG <= 0  */
// ACE_TRACE ("ACE_Sig_Adapter::ACE_Sig_Adapter");
// ACE_TRACE ("ACE_Sig_Adapter::ACE_Sig_Adapter");
// ACE_TRACE ("ACE_Sig_Adapter::ACE_Sig_Adapter");
// We have to dispatch a handler that was registered by a
// third-party library.
// Make sure this handler executes in the context it was
// expecting...
// Restore the original disposition.
/* __ACE_INLINE__ */
/* ACE_HAS_SIG_C_FUNC */
// Array of Event_Handlers that will handle the signals.
// Remembers if a signal has occurred.
/* ACE_HAS_DUMP */
// Register an ACE_Event_Handler along with the corresponding SIGNUM.
// This method does NOT acquire any locks, so it can be called from a
// signal handler.
// Define a "null" action.
// Return a pointer to the old <ACE_Sig_Handler> if the user
// asks for this.
// Make sure that <new_disp> points to a valid location if the
// user doesn't care...
/* ACE_HAS_LYNXOS4_SIGNALS */
// Register an ACE_Event_Handler along with the corresponding SIGNUM.
// This method acquires a lock, so it can't be called from a signal
// handler, e.g., <dispatch>.
// Reset to default disposition.
// Allow the event handler to close down if necessary.
// Register either the new disposition or restore the default.
// Remove an ACE_Event_Handler.
// Master dispatcher function that gets called by a signal handler and
// dispatches one handler...
// Save/restore errno.
// We can't use the <sig_pending> call here because that acquires
// the lock, which is non-portable...
// Darn well better be in range since the OS dispatched this...
// Win32 is weird in the sense that it resets the signal
// disposition to SIG_DFL after a signal handler is
// dispatched.  Therefore, to workaround this "feature" we
// must re-register the <ACE_Event_Handler> with <signum>
// explicitly.
/* ACE_WIN32*/
// ----------------------------------------
// The following classes are local to this file.
// There are bugs with HP/UX's C++ compiler that prevents this stuff
// from compiling...
// Keeps track of the id that uniquely identifies each registered
// signal handler.  This id can be used to cancel a timer via the
// <remove_handler> method.
// If this is true then a 3rd party library has registered a
// handler...
// Make life easier by defining typedefs...
/* static */
/* static */
// This will cause problems...
/* ACE_HAS_DUMP */
// This is the method that does all the dirty work...  The basic
// structure of this method was devised by Detlef Becker.
// Our signal handler.
// An external signal handler.
// Get current signal disposition.
// Check whether we are already in control of the signal
// handling disposition...
// Drat, a 3rd party library has already installed a signal ;-(
// Upto here we never disabled RESTART_MODE.  Thus,
// RESTART_MODE can only be changed by 3rd party libraries.
// Toggling is disallowed since we might break 3rd party
// code.
// Note that we've seen a 3rd party handler...
// Create a new 3rd party disposition, remembering its
// preferred signal blocking etc...;
// Add the external signal handler to the set of handlers
// for this signal.
// Add our new handler at this point.
// Add the ACE signal handler to the set of handlers for this
// signal (make sure it goes before the external one if there is
// one of these).
// We couldn't reinstall our handler, so let's pretend like
// none of this happened...
// If ACE_Sig_Handlers::dispatch() was set we're done.
// Otherwise, we need to register our handler function so that
// all signals will be dispatched through ACE.
// Make sure that new_disp points to a valid location if the
// user doesn't care...
// Default is to restart signal handlers.
/* ACE_HAS_LYNXOS4_SIGNALS */
// Finally install (possibly reinstall) the ACE signal
// handler disposition with the SA_RESTART mode enabled.
// Yikes, lots of roll back at this point...
// Return the signal key so that programs can cancel this
// handler if they want!
// Remove the ACE_Event_Handler currently associated with <signum>.
// Install the new disposition (if given) and return the previous
// disposition (if desired by the caller).  Returns 0 on success and
// -1 if <signum> is invalid.
// Iterate through the set of handlers for this signal.
// Type-safe downcast would be nice here...
// Remove the handler if (1) its key matches the key we've
// been told to remove or (2) if we've been told to remove
// *all* handlers (i.e., <sigkey> == -1).
// If there are no more handlers left for a signal then
// register the new disposition or restore the default
// disposition.
// Master dispatcher function that gets called by a signal handler and
// dispatches *all* the handlers...
// The following is #ifdef'd out because it's entirely non-portable
// to acquire a mutex in a signal handler...
/* 0 */
// Save/restore errno.
// Darn well better be in range since the OS dispatched this...
// Return the first item in the list of handlers.  Note that this will
// trivially provide the same behavior as the ACE_Sig_Handler
// version if there is only 1 handler registered!
// The following is a strange bit of logic that tries to give the same
// semantics as what happens in ACE_Sig_Handler when we replace the
// current signal handler with a new one.  Note that if there is only
// one signal handler the behavior will be identical.  If there is
// more than one handler then things get weird...
// Find the first handler...
// ... then remove it from the set ...
// ... and then insert the new signal handler into the beginning of
// the set (note, this is a bit too tied up in the implementation of
// ACE_Unbounded_Set...).
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
/* ACE_HAS_DUMP */
// Pointer to the Singleton instance.  This works around a bug with
// G++ and it's (mis-)handling of templates and statics...
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
// Perform the Double-Check pattern...
// The program is still starting up, and therefore assumed
// to be single threaded.  There's no need to double-check.
// Or, the ACE_Object_Manager instance has been destroyed,
// so the preallocated lock is not available.  Either way,
// don't register for destruction with the
// ACE_Object_Manager:  we'll have to leak this instance.
// Obtain a lock from the ACE_Object_Manager.  The pointer
// is static, so we only obtain one per ACE_Singleton
// instantiation.
/* ACE_FACE_SAFETY_BASE */
/* ACE_FACE_SAFETY_BASE */
// Failed to acquire the lock!
/* ACE_MT_SAFE */
// Register for destruction with ACE_Object_Manager.
/* ACE_MT_SAFE */
// Pointer to the Singleton instance.
/* !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES) */
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
/* ACE_HAS_DUMP */
// Pointer to the Singleton instance.  This works around a bug with
// G++ and it's (mis-)handling of templates and statics...
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
// Perform the Double-Check pattern...
// The program is still starting up, and therefore assumed
// to be single threaded.  There's no need to double-check.
// Or, the ACE_Object_Manager instance has been destroyed,
// so the preallocated lock is not available.  Either way,
// don't register for destruction with the
// ACE_Object_Manager:  we'll have to leak this instance.
// Obtain a lock from the ACE_Object_Manager.  The pointer
// is static, so we only obtain one per
// ACE_Unmanaged_Singleton instantiation.
/* ACE_FACE_SAFETY_BASE */
/* ACE_FACE_SAFETY_BASE */
// Failed to acquire the lock!
/* ACE_MT_SAFE */
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
/* ACE_HAS_DUMP */
// Pointer to the Singleton instance.  This works around a bug with
// G++ and it's (mis-)handling of templates and statics...
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
// Perform the Double-Check pattern...
// The program is still starting up, and therefore assumed
// to be single threaded.  There's no need to double-check.
// Or, the ACE_Object_Manager instance has been destroyed,
// so the preallocated lock is not available.  Either way,
// don't register for destruction with the
// ACE_Object_Manager:  we'll have to leak this instance.
// Obtain a lock from the ACE_Object_Manager.  The pointer
// is static, so we only obtain one per ACE_Singleton instantiation.
/* ACE_FACE_SAFETY_BASE */
/* ACE_FACE_SAFETY_BASE */
// Failed to acquire the lock!
/* ACE_MT_SAFE */
// Register for destruction with ACE_Object_Manager.
/* ACE_MT_SAFE */
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
/* ACE_HAS_DUMP */
// Pointer to the Singleton instance.  This works around a bug with
// G++ and it's (mis-)handling of templates and statics...
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
// Perform the Double-Check pattern...
// The program is still starting up, and therefore assumed
// to be single threaded.  There's no need to double-check.
// Or, the ACE_Object_Manager instance has been destroyed,
// so the preallocated lock is not available.  Either way,
// don't register for destruction with the
// ACE_Object_Manager:  we'll have to leak this instance.
// Obtain a lock from the ACE_Object_Manager.  The pointer
// is static, so we only obtain one per
// ACE_Unmanaged_Singleton instantiation.
/* ACE_FACE_SAFETY_BASE */
/* ACE_FACE_SAFETY_BASE */
// Failed to acquire the lock!
/* ACE_MT_SAFE */
// Pointer to the Singleton instance.
/* !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES) */
/*************************************************************************/
// Pointer to the Singleton instance.
/* !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES) */
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
/* ACE_HAS_DUMP */
// Pointer to the Singleton instance.  This works around a bug with
// G++ and it's (mis-)handling of templates and statics...
/* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
// Perform the Double-Check pattern...
// The program is still starting up, and therefore assumed
// to be single threaded.  There's no need to double-check.
// Or, the ACE_Object_Manager instance has been destroyed,
// so the preallocated lock is not available.  Either way,
// don't register for destruction with the
// ACE_Object_Manager:  we'll have to leak this instance.
// Obtain a lock from the ACE_Object_Manager.  The pointer
// is static, so we only obtain one per
// ACE_Unmanaged_Singleton instantiation.
/* ACE_FACE_SAFETY_BASE */
/* ACE_FACE_SAFETY_BASE */
// Failed to acquire the lock!
/* ACE_MT_SAFE */
//ACE_REGISTER_FRAMEWORK_COMPONENT(ACE_DLL_Singleton<TYPE,ACE_LOCK>, singleton);
/**********************************************************************/
// @todo make this a constant somewhere (or it there already is one
// then use it.
/* ACE_SINGLETON_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_SOCK::ACE_SOCK");
// Returns information about the remote peer endpoint (if there is
// one).
// Close down a ACE_SOCK.
// General purpose constructor for performing server ACE_SOCK
// creation.
// ACE_TRACE ("ACE_SOCK::ACE_SOCK");
// ACE_TRACE ("ACE_SOCK::ACE_SOCK");
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_HAS_WINCE
// Do nothing routine for constructor.
// Performs the timed accept operation.
// Handle the case where we're doing a timed <accept>.
// Set the handle into non-blocking mode if it's not already
// in it.
// Check to see if we were originally in blocking mode, and if so,
// set the <new_stream>'s handle and <this> handle to be in blocking
// mode.
// Save/restore errno.
// Only disable ACE_NONBLOCK if we weren't in non-blocking mode
// originally.
// Reset the event association inherited by the new handle.
/* ACE_WIN32 */
// General purpose routine for accepting new connections.
// On Win32 the third parameter to <accept> must be a NULL
// pointer if we want to ignore the client's address.
// Reset the size of the addr, so the proper UNIX/IPv4/IPv6 family
// is known.
// On Win32 the third parameter to <accept> must be a NULL
// pointer if we want to ignore the client's address.
// Reset the size of the addr, which is only necessary for UNIX
// domain sockets.
// ACE_HAS_WINCE
/* ACE_HAS_DUMP */
/* defined (ACE_HAS_IPV6) */
/*
// We probably don't need a bind_port written here.
// There are currently no supported OS's that define
// ACE_LACKS_WILDCARD_BIND.
/* ACE_HAS_IPV6 */
// Preserve across close() below.
// General purpose routine for performing server ACE_SOCK creation.
/* ACE_HAS_IPV6 */
// General purpose routine for performing server ACE_SOCK creation.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Here's the general-purpose constructor.
/* This is the general-purpose open routine.  Note that it performs
// Depending on the addresses passed as described above, figure out what
// address family to specify for the new socket. If either address is
// !ACE_Addr::sap_any, use that family. If they don't match, it's an error.
// Both specified; family must match
// Assign an arbitrary port number from the transient range!!
/* ACE_HAS_IPV6 */
// We are binding just the local address.
// We are connecting to the remote address.
// We are binding to the local address and connecting to the
// remote addresses.
// sparc
/**/ <netinet/in6_var.h>
/* _AIX */
/* ACE_HAS_IPV6 */
/* ACE_HAS_GETIFADDRS */
/* ACE_VXWORKS <= 0x670 && __RTP__ && ACE_HAS_IPV6 */
/**/ <iphlpapi.h>
/**/ <ws2tcpip.h>
// ACE_HAS_WINCE
// These defines support a generic usage based on
// the various SIGCF*IF ioctl implementations
/* SIOCGLIFCONF */
/* ACE_HAS_THREADS */
// private:
//  Used internally so not exported.
// Does this box have ipv4 turned on?
// Does this box have ipv6 turned on?
/* ACE_HAS_IPV6 */
/* ACE_HAS_IPV6 */
// Bind socket to an unused port.
// What do we do if it is PF_"INET6?  Since it's 4 bytes, it must be an
// IPV4 address. Is there a difference?  Why is this test done? dhinton
/* ACE_HAS_IPV6 */
/* !ACE_HAS_IPV6 */
// address_family == PF_INET6 and a non default IP address means to bind
// to the IPv4-mapped IPv6 address
/* ACE_HAS_IPV6 */
// The OS kernel should select a free port for us.
// Get interface structure and initialize the addresses using UNIX
// techniques
// Get host ip address if necessary.
// see mk_broadcast@SOCK_Dgram_Bcast.cpp
/* !defined(AIX) && !defined (__QNX__) && !defined (__FreeBSD__) && !defined(__NetBSD__) && !defined (__Lynx__) */
// Compare host ip address with interface ip address.
/* !ACE_WIN32 && !__INTERIX */
// below, ACE_LACKS_GETNAMEINFO
// Not the same as errno!
/* ACE_HAS_IPV6 */
// get the host entry for the address in question
// if it's not found in the host file or the DNS datase, there is nothing
// much we can do. embed the IP address
// check if the canonical name is the FQDN
// list of address
// list of aliases
// for every address and for every alias within the address, check and
// see if we can locate a FQDN
// we got an FQDN from an alias. use this
// the hostname is too huge to fit into a
// buffer of size MAXHOSTNAMELEN
// should we check other aliases as well
// before bailing out prematurely?
// for right now, let's do it. this (short name)
// is atleast better than embedding the IP
// address in the profile
// The canonical name may be an FQDN when we reach here.
// Alternatively, the canonical name (a non FQDN) may be the best
// we can do.
// The hostname is too large to fit into a buffer of size
// MAXHOSTNAMELEN.
/* ACE_LACKS_GETNAMEINFO */
// moved the ACE_HAS_WINCE impl ahaid of ACE_HAS_WINSOCK2 because
// WINCE in fact has winsock2, but doesn't properly support the
// WSAIoctl for obtaining IPv6 address info.
// If successful, output some information from the data we received
// PharLap ETS has its own kernel routines to rummage through the device
// configs and extract the interface info, but only for Pharlap RT.
/* ACE_HAS_PHARLAP_RT */
// Locate all of the IP devices in the system, saving a DEVHANDLE
// for each. Then allocate the ACE_INET_Addrs needed and fetch all
// the IP addresses.  To locate the devices, try the available
// device name roots and increment the device number until the
// kernel says there are no more of that type.
// Arbitrary, but should be enough.
// Ethernet.
// SLIP.
// PPP.
// Already in net order.
// There's no call to close the DEVHANDLE.
// All non-CE, non-Pharlap Windows. Must support Winsock2.
// Get an (overlapped) DGRAM socket to test with
// SIO_GET_INTERFACE_LIST does not work for IPv6
// Instead recent versions of Winsock2 add the new opcode
// SIO_ADDRESS_LIST_QUERY.
// If this is not available forget about IPv6 local interfaces:-/
// Get an (overlapped) DGRAM socket to test with.
// If it fails only return IPv4 interfaces.
/* ACE_HAS_IPV6 */
// Now go through the list and transfer the good ones to the list of
// because they're down or don't have an IP address.
// We assume IPv4 addresses here
// Set the address for the caller.
// Now go through the list and transfer the good ones to the list of
// because they're down or don't have an IP address.
// IN6ADDR_ANY?
// Set the address for the caller.
// Clean up
/* ACE_HAS_IPV6 */
/* ACE_HAS_WINCE */
// Take advantage of the BSD getifaddrs function that simplifies
// access to connected interfaces.
// Count number of interfaces.
// Now create and initialize output array.
// caller must free
// Pull the address out of each INET interface.  Not every interface
// is for IP, so be careful to count properly.  When setting the
// INET_Addr, note that the 3rd arg (0) says to leave the byte order
// (already in net byte order from the interface structure) as is.
// Check to see if it's up.
// Sometimes the kernel returns 0.0.0.0 as the interface
// address, skip those...
// Skip the ANY address
/* ACE_HAS_IPV6 */
// Call specific routine as necessary.
// ioctl likes to have an extra IFREQ structure to mark the end of
// what it returned, so increase the num_ifs by one.
//HPUX requires two passes, First for IPv4, then for IPv6
// Now create and initialize output array.
// caller must free
// get the number of returned ifs
/* ACE_HAS_IPV6 */
// skip the interface name
// ACE_WIN32 || ACE_HAS_GETIFADDRS || __hpux || _AIX
// return an array of all configured IP interfaces on this host, count
// rc = 0 on success (count == number of interfaces else -1 caller is
// responsible for calling delete [] on parray
// COMMON (SVR4 and BSD) UNIX CODE
// Call specific routine as necessary.
// ioctl likes to have an extra ifreq structure to mark the end of
// what it returned, so increase the num_ifs by one.
// request all families be returned
// Now create and initialize output array.
// caller must free
// get the number of returned ifs
// Pull the address out of each INET interface.  Not every interface
// is for IP, so be careful to count properly.  When setting the
// INET_Addr, note that the 3rd arg (0) says to leave the byte order
// (already in net byte order from the interface structure) as is.
// Sometimes the kernel returns 0.0.0.0 as an IPv4 interface
// address; skip those...
/* !defined (__QNX__) && !defined (__FreeBSD__) && !defined(__NetBSD__) && !defined (ACE_HAS_RTEMS) && !defined (__Lynx__) */
// Retrieve IPv6 local interfaces by scanning /proc/net/if_inet6 if
// it exists.  If we cannot open it then ignore possible IPv6
// interfaces, we did our best;-)
// Format the address intoa proper IPv6 decimal address specification and
// resolve the resulting text using getaddrinfo().
/* ACE_HAS_IPV6 && !ACE_LACKS_FSCANF */
// no implementation
/* ACE_WIN32 */
// Helper routine for get_ip_interfaces, differs by UNIX platform so
// put into own subroutine.  perform some ioctls to retrieve ifconf
// list of ifreq structs.
/* SIOCGLIFNUM */
/* SIOCGLIFNUM */
// Note: DEC CXX doesn't define "unix".  BSD compatible OS: HP UX,
// AIX, SunOS 4.x perform some ioctls to retrieve ifconf list of
// ifreq structs no SIOCGIFNUM on SunOS 4.x, so use guess and scan
// algorithm
// Probably hard to put this many ifs in a unix box..
// HACK - set to an unreasonable number
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// get if address out of ifreq buffers.  ioctl puts a blank-named
// interface to mark the end of the returned interfaces.
/* In OpenBSD, the length of the list is returned. */
/* !defined (__QNX__) && !defined (__FreeBSD__) && !defined(__NetBSD__)  && !defined (ACE_HAS_RTEMS) && !defined (__Lynx__) */
/* ACE_HAS_ALLOC_HOOKS */
// Scan the lines according to the expected format but don't really read any input
/* ACE_HAS_IPV6  && !ACE_LACKS_FSCANF */
// no implementation
/* sparc && SIOCGIFNUM */
// Routine to return a handle from which ioctl() requests can be made.
// Solaris 2.x
// Note: DEC CXX doesn't define "unix" BSD compatible OS: HP UX,
// AIX, SunOS 4.x
/* sparc */
// We only get to this point if ipvn_enabled was -1 in the caller.
// Perform Double-Checked Locking Optimization.
// as of the release of Windows 2008, even hosts that have IPv6 interfaces disabled
// will still permit the creation of a PF_INET6 socket, thus rendering the socket
// creation test inconsistent. The reccommended solution is to get the list of
// endpoint addresses and see if any match the desired family.
// assume enabled to avoid recursion during interface lookup.
// Determine if the kernel has IPv6 support by attempting to
// create a PF_INET6 socket and see if it fails.
/* ACE_HAS_IPV6 */
// Assume it's always enabled since ACE requires some version of
// TCP/IP to exist.
/* ACE_HAS_IPV6*/
/* ACE_HAS_IPV6 */
/* !ACE_HAS_IPV6 */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_HAS_WINCE
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Only open a new socket if we don't already have a valid handle.
// Only open a new socket if we don't already have a valid handle.
// Save/restore errno.
// Enable non-blocking, if required.
// Save/restore errno.
// Check whether the connection is in progress.
// This expression checks if we were polling.
// In order to detect when the socket that has been
// bound to is in TIME_WAIT we need to do the connect
// (which will always return EWOULDBLOCK) and then do an
// ACE::handle_timed_complete() (with timeout==0,
// i.e. poll). This will do a select() on the handle
// which will immediately return with the handle in an
// error state. The error code is then retrieved with
// getsockopt(). Good sockets however will return from
// the select() with ETIME - in this case return
// EWOULDBLOCK so the wait strategy can complete the
// connection.
/* ACE_WIN32 */
/* ACE_WIN32 */
// Wait synchronously using timeout.
// EISCONN is treated specially since this routine may be used to
// check if we are already connected.
// Start out with non-blocking disabled on the new_stream.
// Actively connect and produce a new ACE_SOCK_Stream if things go well...
/* flags */,
/* perms */,
// On windows, the IPv4-mapped IPv6 address format can only be used on a dual-stack socket.
/* perms */)
// On windows, the IPv4-mapped IPv6 address format can only be used on a dual-stack socket.
// ACE_HAS_WINCE
// Try to complete a non-blocking connection.
// We failed to get connected.
// Win32 has a timing problem - if you check to see if the
// connection has completed too fast, it will fail - so wait
// <ACE_NON_BLOCKING_BUG_DELAY> microseconds to let it catch up
// then retry to see if it's a real failure.
/* ACE_NON_BLOCKING_BUG_DELAY */
// Save/restore errno.
/* ACE_NON_BLOCKING_BUG_DELAY */
// Save/restore errno.
// Start out with non-blocking disabled on the <new_stream>.
// ACE_HAS_WINCE
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/**/ <iphlpapi.h>
// This is a workaround for platforms with non-standard
// definitions of the ip_mreq structure
/* ! defined (IMR_MULTIADDR) */
/* ACE_HAS_DUMP */
// Allows a client to read from a socket without having to provide a
// buffer to read.  This method determines how much data is in the
// socket, allocates a buffer of this size, reads in the data, and
// returns the number of bytes read.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
/* FIONREAD */
// Here's the shared open function.  Note that if we are using the
// PF_INET protocol family and the address of LOCAL == the address of
// the special variable SAP_ANY then we are going to arbitrarily bind
// to a portnumber.
/* defined (ACE_HAS_IPV6) */
/* ACE_HAS_IPV6 */
// Here's the general-purpose open routine.
/* ACE_HAS_IPV6 */
// Here's the general-purpose constructor used by a connectionless
// datagram ``server''...
// Send an iovec of size N to ADDR as a datagram (connectionless
// version).
/* ACE_HAS_SOCKADDR_MSG_NAME */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
// Recv an iovec of size N to ADDR as a datagram (connectionless
// version).
/* ACE_HAS_SOCKADDR_MSG_NAME */
/* ACE_HAS_4_4BSD_SENDMSG_RECVMSG */
/* ACE_HAS_MSG */
// Send an iovec of size N to ADDR as a datagram (connectionless
// version).
// Determine the total length of all the buffers in <iov>.
// The iov_len is unsigned on Linux, RTEMS and with Borland. If we go
// ahead and try the if, it will emit a warning.
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// Recv an iovec of size N to ADDR as a datagram (connectionless
// version).
// The iov_len is unsigned on Linux, RTEMS and with Borland. If we go
// ahead and try the if, it will emit a warning.
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// iov_len is int on some platforms, size_t on others
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_MSG */
// Goes fine, call <recv> to get data
// Check the status of the current socket.
// Goes fine, call <send> to transmit the data.
// Only let this attempt to set unknown interface when INET6 is
// specifically requested. Otherwise we will just try INET.
// For Win32 net_if is distintly different between INET6 and INET
// so it is always either an INET6 if or an INET if.
/* ACE_HAS_IPV6 */
/* !ACE_HAS_IPV6 */
/* IP_MULTICAST_IF */
// Send interface option not supported - ignore it.
// (We may have been invoked by ::subscribe, so we have to allow
// a non-null interface parameter in this function.)
/* !IP_MULTICAST_IF */
// Scratch copy.
// This port number is not necessary, just convenient
// The net_if name failed to be found. It seems that older linux
// kernals only support the actual interface name (eg. "eth0"),
// not the IP address string of the interface (eg. "192.168.0.1"),
// which newer kernals seem to automatically translate.
// So assume that we have been given an IP Address and translate
// that instead, similar to the above for windows.
// Still doesn't work, unknown device specified.
/* ACE_WIN32 || __INTERIX */
// Set return info, if requested.
// XXX: This will not work on any operating systems that do not support
//      if_nametoindex or that is not Win32 >= Windows XP/Server 2003
// Scratch copy.
// Initial call to determine actual memory size needed
// With output bufferlength 0 this can't be right.
// Get required output buffer and retrieve info for real.
// clean up
// initialize
// clean up
/* ACE_WIN32 */
/* ACE_WIN32 */
// now set the multicast address
// Set return info, if requested.
/* ACE_LINUX && ACE_HAS_IPV6 */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Close up and release resources.
// Release the dynamically allocated memory.
// Shut down the descriptor.
// Here's the simple-minded constructor.
// Here's the general-purpose constructor used by a connectionless
// datagram ``server''...
// Here's the general-purpose open routine.
// Make broadcast available for Datagram socket.
// Get interface structure and initialize the addresses using UNIX
// techniques.
// Get host ip address
/*
/* !defined(AIX) && !defined (__QNX__) && !defined (__FreeBSD__) && !defined(__NetBSD__) && !defined (ACE_VXWORKS) && !defined(__APPLE__) */
// Silently skip link interfaces
/* __QNX__ || ACE_VXWORKS */
// Compare host ip address with interface ip address.
// Note that some systems seem to generate 0 (AF_UNDEF) for
// the sa_family, even when there are no errors!  Thus, we
// only print an error if this is not the case, or if we're
// in "debugging" mode.
/* !ACE_WIN32 && !__INTERIX */
// Broadcast the datagram to every interface.  Returns the average
// number of bytes sent.
// Broadcast datagram to every interfaces.
// Send the message to every interface.
// Broadcast an iovec of size N to ADDR as a datagram (note that addr
// must be preassigned to the broadcast address of the subnet...).
/* ACE_HAS_MSG */
/* ACE_HAS_ALLOC_HOOKS */
/**/ <iphlpapi.h>
/**/ <net/ifaddrs.h>
/**/ <ifaddrs.h>
/*ACE_VXWORKS */
/* ACE_HAS_GETIFADDRS */
/* __ACE_INLINE__ */
// This is a workaround for platforms with non-standard
// definitions of the ip_mreq structure
/* ! defined (IMR_MULTIADDR) */
// Helper (inline) functions.
// Convert ACE_INET_Addr to string, using local formatting rules.
// results here.
// clip port# info?
// clip port# info.
// op== for ip_mreq structs.
// Show default send addr, port#, and interface.
// Show list of subscribed addresses.
// Get subscribed address (w/out port# info - not relevant).
// Get interface address/specification.
// Receives on system default iface. (Note that null_iface_opt_
// option processing has already occurred.)
// Dump info.
/* ACE_SOCK_DGRAM_MCAST_DUMPABLE */
/* ACE_HAS_DUMP */
// Constructor.
// Destructor.
// Free memory and optionally unsubscribe from currently subscribed group(s).
/* ACE_HAS_ALLOC_HOOKS */
// Only perform the <open> initialization if we haven't been opened
// earlier.
// No sanity check?  We should probably flag an error if the user
// makes multiple calls to open().
// Invoke lower-layer ::open.
// always use 0
// ACE_SOCK::open calls this if reuse_addr is set, so we only need to
// process port reuse option.
/* SO_REUSEPORT */
// Create an address/port# to bind the socket to. Use mcast_addr to
// initialize bind_addy to pick up the correct protocol family. If
// OPT_BINDADDR_YES is set, then we're done. Else use mcast_addr's
// port number and use the "any" address.
// Bind to "any" address and explicit port#.
// Bind to "any" address and explicit port#.
/* ACE_HAS_IPV6 */
// Bind to the address (which may be INADDR_ANY) and port# (which may be 0)
// Cache the actual bound address (which may be INADDR_ANY)
// and the actual bound port# (which will be a valid, non-zero port#).
// (Unexpected failure - should be bound to something)
// (Shouldn't happen - bind_addy is a valid addy; punt.)
/* ACE_HAS_ALLOC_HOOKS */
// Take advantage of the BSD getifaddrs function that simplifies
// access to connected interfaces.
// Not every interface is for IP, and not all are up and multicast.
// Some OSes can return interfaces with no ifa_addr if the
// interface has no assigned address.
// If there is an address but it's not the family we want, ignore it.
// Check to see if it's up and supports multicast.
// Sometimes the kernel returns 0.0.0.0 as the interface
// address, skip those...
// Skip the ANY address
/* ACE_HAS_IPV6 */
// Ok, now join on this interface.
// Initial call to determine actual memory size needed
// Note... GetAdaptersAddresses returns different bufLen values depending
// on how many multicast joins there are on the system. To avoid this,
// specify that we don't want to know about multicast addresses. This
// does not avoid multicastable interfaces and makes the size-check
// more reliable across varying conditions.
// With output bufferlength 0 this can't be right.
// Get required output buffer and retrieve info for real.
// clean up
// The ACE_SOCK_Dgram::make_multicast_ifaddr (IPv4), called by join(),
// can only deal with a dotted-decimal address, not an interface name.
// clean up
// Subscribe on all local multicast-capable network interfaces, by
// doing recursive calls with specific interfaces.
// Iterate through all the interfaces, figure out which ones
// offer multicast service, and subscribe to them.
// Convert to 0-based for indexing, next loop check.
/* ACE_WIN32 */
// Subscribe on a specific interface, or on the default interface.
/* ACE_HAS_IPV6 - Fall into IPv4-only case */
// Validate passed multicast addr and iface specifications.
// If port# is 0, insert bound port# if it is set. (To satisfy lower-level
// port# validation.)
// Check for port# different than bound port#.
// If bind_addr_opt_ is enabled, check for address different than
// bound address.
// force equal port numbers
// Attempt subscription.
// Add this addr/iface info to the list of subscriptions.
// (Assumes this is unique addr/iface combo - most systems don't allow
// re-sub to same addr/iface.)
// (should not fail)
// this still isn't really right. If ACE_GUARD_RETURN fails, we leak.
// Need to add one of Chris' fancy ace auto pointers (bound?).
/* ACE_SOCK_DGRAM_MCAST_DUMPABLE */
// Attempt subscribe and return status.
/* ACE_LINUX && ACE_HAS_IPV6 */
// Open the socket IFF this is the first ::subscribe and ::open
// was not explicitly invoked.
// Only do this if net_if == 0, i.e., INADDR_ANY
// Check for error or "short-circuit" return.
// Tell IP stack to pass messages sent to this group.
// Fall through for IPv4 case
/* ACE_HAS_IPV6 */
// Create multicast addr/if struct.
// Tell IP stack to pass messages sent to this group.
// Initial call to determine actual memory size needed
// With output bufferlength 0 this can't be right.
// Get required output buffer and retrieve info for real.
// clean up
// clean up
/* ACE_WIN32 */
// Unsubscribe on all local multicast-capable network interfaces, by
// doing recursive calls with specific interfaces.
// NOTE - <get_ip_interfaces> doesn't always get all of the
// interfaces.  In particular, it may not get a PPP interface.  This
// is a limitation of the way <get_ip_interfaces> works with
// old versions of MSVC.  The reliable way of getting the interface
// list is available only with MSVC 5 and newer.
// Convert to 0-based for indexing, next loop check
/* ACE_HAS_IPV6 */
// Unsubscribe on all local multicast-capable network interfaces, by
// doing recursive calls with specific interfaces.
// NOTE - <get_ip_interfaces> doesn't always get all of the
// interfaces.  In particular, it may not get a PPP interface.  This
// is a limitation of the way <get_ip_interfaces> works with
// old versions of MSVC.  The reliable way of getting the interface list
// is available only with MSVC 5 and newer.
// Convert to 0-based for indexing, next loop check
/* !ACE_HAS_IPV6 */
// Unsubscribe.
// (Unconditionally) Remove this addr/if from subscription list.
// (Addr/if is removed even if unsubscribe failed)
/* ACE_SOCK_DGRAM_MCAST_DUMPABLE */
// Attempt unsubscribe and return status.
// Check for error or "short-circuit" return.
// Validate addr/if specifications and create addr/if struct.
// Tell network device driver to stop reading datagrams with the
// <mcast_addr>.
// IPv4
// Validate addr/if specifications and create addr/if struct.
// Tell network device driver to stop reading datagrams with the
// <mcast_addr>.
// Validate addr/if specifications and create addr/if struct.
// Tell network device driver to stop reading datagrams with the
// <mcast_addr>.
// Note, this is not IPv6 friendly...
/* ACE_HAS_IPV6 */
/*Hack: Do _not_ ::advance after remove*/)
/* ACE_SOCK_DGRAM_MCAST_DUMPABLE */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Allows a client to read from a socket without having to provide
// a buffer to read.  This method determines how much data is in the
// socket, allocates a buffer of this size, reads in the data, and
// returns the number of bytes read.
/* ACE_HAS_ALLOC_HOOKS */
// It's ok to blindly cast this value since 'inlen' is an int and, thus,
// we can't get more than that back. Besides, if the recv() fails, we
// don't want that value cast to unsigned and returned.
// u_long is the Windows type; size_t is everyone else's. A u_long
// should go into a size_t anywhere without an issue.
/* FIONREAD */
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// This is basically an interface to ACE_OS::readv, that doesn't use
// the struct iovec_Base explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
/* */  "ace/SOCK_Netlink.h"
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
//! protocol of your choosing
//! RAW or DGRAM valid
/* ACE_HAS_NETLINK */
/* __ACE_INLINE__ */
// Do nothing routine for constructor.
// Performs the timed accept operation.
// Handle the case where we're doing a timed <accept>.
// Set the handle into non-blocking mode if it's not already
// in it.
// Check to see if we were originally in blocking mode, and if so,
// set the <new_association>'s handle and <this> handle to be in blocking
// mode.
// Save/restore errno.
// Only disable ACE_NONBLOCK if we weren't in non-blocking mode
// originally.
// Reset the event association inherited by the new handle.
/* ACE_WIN32 */
// General purpose routine for accepting new connections.
// On Win32 the third parameter to <accept> must be a NULL
// pointer if we want to ignore the client's address.
// Reset the size of the addr, so the proper UNIX/IPv4/IPv6 family
// is known.
/* ACE_HAS_DUMP */
// We probably don't need a bind_port written here.
// There are currently no supported OS's that define
// ACE_LACKS_WILDCARD_BIND.
// Multihomed version of same.
// TODO: Add multi-address support to IPV6
// We probably don't need a bind_port written here.
// There are currently no supported OS's that define
// ACE_LACKS_WILDCARD_BIND.
//  A port number of 0 means that the user is requesting that the
//  operating system choose an arbitrary, unused port.  Since some
//  operating systems don't provide this service, ACE provides an
//  emulation layer.  Therefore, the "ACE way" to bind an arbitrary,
//  unused port is to call ACE:bind_port, which either
//
//    (1)  Calls ACE_OS::bind with port 0, if the operating system
//         directly supports the automated selection, or
//
//    (2)  Performs more complicated logic to emulate this feature if
//         it's missing from the OS.
//
//  The emulation logic in choice (2) is compiled if and only if
//  ACE_LACKS_WILDCARD_BIND is defined at compile time.
//
//  Along these lines, the following block of code seems like it would
//  be sufficient to support the wildcard bind operation:
//
//      if (local_inet_addr.sin_port == 0)
//         {
//           if (ACE::bind_port (this->get_handle (),
//               ACE_NTOHL (ACE_UINT32 (local_inet_addr.sin_addr.s_addr))) == -1)
//             error = 1;
//
//         }
//      else
//
//  Unfortunately, this code is insufficient because it does not
//  address the possibility of secondary addresses.
//
//  However, rather than writing the correct code now, I'm putting it
//  off, because this class, ACE_SOCK_SEQPACK_Acceptor, is currently
//  only used with SCTP, and ACE currently supports SCTP only through
//  the OpenSS7 and LKSCTP implmentations, which are available only on
//  Linux.  Linux has native support for the wildcard bind, so the
//  following code works regardless of whether or not the port is 0.
// The total number of addresses is the number of secondary
// addresses plus one.
// Create an array of sockaddr_in to hold the underlying
// representations of the primary and secondary
// addresses.
// Populate the array by invoking the get_addresses method
// on the Multihomed_INET_Addr
// bind the primary first
// do we need to bind multiple addresses?
// all of the secondary addresses need the local port set
// copy only the sockaddrs that we need to bindx
// now call bindx
// Call bind
/* ACE_HAS_LKSCTP */
/* ACE_HAS_ALLOC_HOOKS */
// General purpose routine for performing server ACE_SOCK creation.
/* ACE_HAS_IPV6 */
// Multihomed version of same.
/* ACE_HAS_IPV6 */
// General purpose routine for performing server ACE_SOCK creation.
// Multihomed version of same.
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// We need the following call to make things work correctly on
// Win32, which requires use to do a <close_writer> before doing the
// close in order to avoid losing data.  Note that we don't need to
// do this on UNIX since it doesn't have this "feature".  Moreover,
// this will cause subtle problems on UNIX due to the way that
// fork() works.
/* ACE_WIN32 */
// Close down the socket.
// Developed according to the API discussed in 7.1.4 of
// draft-ietf-tsvwg-sctpsocket-09.txt to abruptly free a transport
// transport association's resources.
//
// setsockopt() SO_LINGER configures socket to reap immediately.
// Normal close then aborts the association.
//
/*
/* ACE_HAS_VOID_PTR_SCTP_GETPADDRS */
// check to see if we have more addresses than we have
// space in our ACE_INET_Addr array
// since our array is too small, we will only copy the first
// few that fit
// first we cast the sockaddr to sockaddr_in
// since we only support ipv4 at this time.
// now we fillup the ace_inet_addr array
/* err < 0 */
// sctp_getladdrs will return -1 on error
// indicate the num of addrs returned to the calling function
// make sure we free the struct using the system function
/*
// The array of sockaddr_in will be stored in an ACE_Auto_Array_Ptr,
// which causes dynamically-allocated memory to be released as soon
// as the ACE_Auto_Array_Ptr goes out of scope.
// Allocate memory for this array.  Return -1 if the memory cannot
// be allocated.  (This activity requires a temporary variable---a
// bare sockaddr_in* --- because ACE_NEW_RETURN cannot act directory on
// an ACE_Auto_Array_Ptr.)
// Physical size of this array is its logical size multiplied by
// the physical size of one of its elements.
/* Clear the array */
/*
/* Calculate the NEW physical size of the array */
/* Copy each sockaddr_in to the address structure of an ACE_Addr from
/* ACE_HAS_LKSCTP */
/*
/* ACE_HAS_VOID_PTR_SCTP_GETPADDRS */
// check to see if we have more addresses than we have
// space in our ACE_INET_Addr array
// since our array is too small, we will only copy the first
// few that fit
// first we cast the sockaddr to sockaddr_in
// since we only support ipv4 at this time.
// now we fillup the ace_inet_addr array
/* err < 0 */
// sctp_getpaddrs will return -1 on error
// indicate the num of addrs returned to the calling function
// make sure we free the struct using the system function
/*
// The array of sockaddr_in will be stored in an ACE_Auto_Array_Ptr,
// which causes dynamically-allocated memory to be released as soon
// as the ACE_Auto_Array_Ptr goes out of scope.
// Allocate memory for this array.  Return -1 if the memory cannot
// be allocated.  (This activity requires a temporary variable---a
// bare sockaddr_in* --- because ACE_NEW_RETURN cannot act directory on
// an ACE_Auto_Array_Ptr.)
// Physical size of this array is its logical size multiplied by
// the physical size of one of its elements.
/* Clear the array */
/*
/* Calculate the NEW physical size of the array */
/* Copy each sockaddr_in to the address structure of an ACE_Addr from
/* ACE_HAS_LKSCTP */
/* ACE_WIN32 */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Only open a new socket if we don't already have a valid handle.
/* ACE_HAS_LKSCTP */
// Only open a new socket if we don't already have a valid handle.
/* ACE_HAS_LKSCTP */
// Save/restore errno.
// Enable non-blocking, if required.
// Multihomed version of same
// The total number of addresses is the number of secondary
// addresses plus one.
// Create an array of sockaddr_in to hold the underlying
// representations of the primary and secondary
// addresses.
// Populate the array by invoking the get_addresses method on
// the Multihomed_INET_Addr
// bind to the primary addr first
// do we need to bind multiple addrs
// allocate enough memory to hold the number of secondary addrs
// get sockaddr_in for the local handle
// set the local port # assigned by the os to every secondary addr
// copy all of the secondary addrs into a sockaddr structure
// bind other ifaces
// Call bind
// Save/restore errno.
/* ACE_HAS_LKSCTP */
/* ACE_HAS_ALLOC_HOOKS */
// Enable non-blocking, if required.
// Save/restore errno.
// Check whether the connection is in progress.
// This expression checks if we were polling.
// Wait synchronously using timeout.
// EISCONN is treated specially since this routine may be used to
// check if we are already connected.
// Start out with non-blocking disabled on the <new_association>.
// Actively connect and produce a new ACE_SOCK_SEQPACK_Association if things go well...
/* flags */,
/* perms */,
// Multihomed version of same
/* flags */,
/* perms */,
// Try to complete a non-blocking connection.
// We failed to get connected.
// Win32 has a timing problem - if you check to see if the
// connection has completed too fast, it will fail - so wait
// <ACE_NON_BLOCKING_BUG_DELAY> microseconds to let it catch up
// then retry to see if it's a real failure.
/* ACE_WIN32 */
// Save/restore errno.
/* ACE_WIN32 */
// Save/restore errno.
// Start out with non-blocking disabled on the <new_association>.
// Multihomed version of same
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// We need the following call to make things work correctly on
// Win32, which requires us to do a close_writer() before doing the
// close() in order to avoid losing data.  Note that we don't need
// to do this on UNIX since it doesn't have this "feature".
// Moreover, this will cause subtle problems on UNIX due to the way
// that fork() works.
/* ACE_WIN32 */
// Close down the socket.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// This is the do-nothing constructor.
// ACE_TRACE ("ACE_SPIPE::ACE_SPIPE");
/* ACE_HAS_DUMP */
// Close down a ACE_SPIPE.
// Close down the STREAM pipe without removing the rendezvous point.
/* ACE_HAS_STREAM_PIPES */
// Close down the STREAM pipe and remove the rendezvous point from the
// file system.
/// Temporary store of duplex pipe handle.
/* ACE_HAS_STREAM_PIPES */
/* ACE_HAS_ALLOC_HOOKS */
// ACE_HAS_STREAM_PIPES
/* ACE_HAS_WIN32_NAMED_PIPES */
// Remove the underlying file.
/* ACE_HAS_DUMP */
// General purpose routine for performing server ACE_SPIPE creation.
/* ACE_HAS_WIN32_NAMED_PIPES */
// Create a new instance of the Named Pipe (WIN32).  A new instance
// of the named pipe must be created for every client process.  If
// an instance of the named pipe that is already connected to a
// client process is reused with a new client process,
// ::ConnectNamedPipe () would fail.
// Create a new instance of the named pipe
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
// Start the Connect (analogous to listen () for a socket).
// Completion is noted by the event being signalled.  If a
// client connects before this call, the error status will be
// ERROR_PIPE_CONNECTED.  If the client also disconnects before
// this call, the error status will be ERROR_NO_DATA.  In both
// cases, that fact is remembered via already_connected_ and
// noted when the user calls accept().  Else the error status
// should be ERROR_IO_PENDING and the OS will signal the event
// when it's done.
// ConnectNamePipe is suppose to always
// "fail" when passed in overlapped i/o
// Set the associated event as signaled so any reactors or
// proactors waiting for this will respond.
// An undocumented error was returned.
// Sets handle to ACE_INVALID_HANDLE.
/* ACE_HAS_STREAM_PIPES */
// Check to see if we have a valid pipe; if not, nothing to do.
// Substitute the pipe handle back in so it's closed properly in the
// ACE_OS wrapper. But leave the pipe_handle_ value so we can clean up the
// hanging overlapped operation afterwards.
/* ACE_HAS_WIN32_NAMED_PIPES */
// This behavior is shared by UNIX and Win32...
// open () started the Connect in asynchronous mode, and accept() restarts
// the ConnectNamedPipe in overlapped mode.  To avoid leaving a hanging
// overlapped operation that'll write into members of this object,
// wait for the event in the OVERLAPPED structure to be signalled.
// Should be here with the ConnectNamedPipe operation complete.
// Steal the already_connected_ flag to record the results.
/* ACE_HAS_STREAM_PIPES */
// General purpose routine for accepting new connections.
// Note that if THIS->MILLI_SECOND_DELAY == -1 we block on
// ACE_OS::ioctl (). Otherwise, we will wait for the desired number
// of milli seconds using ACE_OS::poll.
// This is for compatibility with ACE_SOCK_Acceptor and
// ACE_TLI_Acceptor.
// Check to see if we have a valid pipe
// open () started the Connect in asynchronous mode.  Wait for the event
// in the OVERLAPPED structure to be signalled, then grab the status.
// Should be here with the ConnectNamedPipe operation complete.
// Steal the already_connected_ flag to record the results.
// Create a new instance of the pipe for the next connection.
/* ACE_HAS_STREAM_PIPES */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Set a pointer to the address.
// Return the address.
// Do nothing constructor.
// Transform the string into the current addressing format.
// Copy constructor.
// Assume it's a local name.
// change "localhost" to "."
// We need to allocate a duplicate so that we can write a
// NUL character into it.
/* ACE_WIN32 */
// Create a ACE_Addr from a ACE_SPIPE pathname.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// Creates a Local ACE_SPIPE.
/* ACE_HAS_DUMP */
/* local_sap */,
/* reuse_addr */,
// Make darn sure that the O_CREAT flag is not set!
// We need to allow for more than one attempt to connect,
// calculate the absolute time at which we give up.
// Loop until success or failure.
// Success!
// Check if we have a busy pipe condition.
// Nope, this is a failure condition.
// This will hold the time out value used in the ::WaitNamedPipe
// call.
// Check if we are to block until we connect.
// Wait for as long as it takes.
// Calculate the amount of time left to wait.
// Check if we have run out of time.
// Mimick the errno value returned by
// ACE::handle_timed_open.
// Exit the connect loop with the failure.
// Get the amount of time remaining for ::WaitNamedPipe.
// Wait for the named pipe to become available.
// Regardless of the return value, we'll do one more attempt to
// connect to see if it is now available and to return
// consistent error values.
// Set named pipe mode if we have a valid handle.
// Check if we are changing the pipe mode from the default.
// We were not able to put the pipe into the requested
// mode.
/* ACE_WIN32 && !ACE_HAS_PHARLAP */
/* !ACE_WIN32 || ACE_HAS_PHARLAP || ACE_HAS_WINCE */
// class copy.
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// Simple-minded do nothing constructor.
// ACE_TRACE ("ACE_SPIPE_Stream::ACE_SPIPE_Stream");
// Send N char *ptrs and int lengths.  Note that the char *'s precede
// the ints (basically, an varargs version of writev).  The count N is
// the *total* number of trailing arguments, *not* a couple of the
// number of tuple pairs!
// ACE_TRACE ("ACE_SPIPE_Stream::send");
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// This is basically an interface to ACE_OS::readv, that doesn't use
// the struct iovec explicitly.  The ... can be passed as an arbitrary
// number of (char *ptr, int len) tuples.  However, the count N is the
// *total* number of trailing arguments, *not* a couple of the number
// of tuple pairs!
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
/* ACE_HAS_ALLOC_HOOKS */
/* !defined (ACE_HAS_ALLOCA) */
// ACE_LACKS_VA_FUNCTIONS
// FUZZ: disable check_for_streams_include
/* ! ACE_LACKS_IOSTREAM_TOTALLY */
/* __ACE_INLINE__ */
// ************************************************************
// @@ Need to figure out how to print the "wide" string
//    on platforms that don't support "wide" strings.
/* !ACE_LACKS_IOSTREAM_TOTALLY */
// *****************************************************************
// Note that this cast may lose data if wide chars are
// actually used!
// Note that this cast may lose data if wide chars are
// actually used!
/* ACE_WSTRING_HAS_USHORT_SUPPORT */
// *****************************************************************
/* ACE_HAS_DUMP */
// Copy constructor.
// Default constructor.
// Set the underlying pointer (does not copy memory).
// Constructor that actually copies memory.
// Constructor that actually copies memory.
// Make sure to NUL terminate this!
// Assignment operator (does copy memory).
// Check for identify.
// Only reallocate if we don't have enough space...
// Return substring.
// case 1. empty string
// case 2. start pos l
// get all remaining bytes
// ************************************************************
/* ACE_HAS_EXPLICIT_STATIC_TEMPLATE_MEMBER_INSTANTIATION */
//=============================================================================
/**
//www.linuxselfhelp.com/gnu/glibc/html_chapter/libc_33.html
//groups.google.com/group/comp.unix.solaris/browse_thread/thread/8b9f3de8be288f1c/31550f93a48231d5?lnk=gst&q=how+to+get+stack+trace+on+solaris+group:comp.unix.solaris#31550f93a48231d5
//www.xs4all.nl/~borkhuis/vxworks/vxw_pt5.html
//=============================================================================
/*
// cannot initialize arrays, so we must assign.
// This is the code for glibc
// this could be more efficient by remembering where we left off in buf_
// put a newline at the end
// zero terminate the string
// hopefully this is enough to get all the necessary #defines.
//@TODO: Replace with a TSS-based pointer to avoid problems in multithreaded environs,
//       or use a mutex to serialize access to this.
// Decrement the num_frames and starting_frame elements,
// then see if we're ready to start or ready to finish.
// These are references so that the structure gets updated
// in the code below.
// At some point try using symFindByValue() to lookup func (and caller?)
// to print out symbols rather than simply addresses.
// VxWorks can pass -1 for "nargs" if there was an error
// Maybe we should take a lock here to guard stateptr?
// See memEdrLib.c in VxWorks RTP sources for an example of stack tracing.
// reinterpret_cast causes an error
//Hopefully a future version of VxWorks will have a system call
//for an RTP to query its own symbols, but this is not possible now.
//An enhancement request has been filed under WIND00123307.
// VxWorks can return -1 for "numArgs" if there was an error
//no point in logging when we're out of buffer
//we saved space for the null terminator
/*
/*
// make a copy of num_frames_arg to eliminate the following warning on some
// solaris platforms:
// Stack_Trace.cpp:318: warning: argument `size_t num_frames' might be clobbered by `longjmp' or `vfork'
// I would like to use ACE_MAX below rather than ?:, but
// I get linker relocation errors such as the following when
// I use it:
// ld: fatal: relocation error: file: .shobj/Stack_Trace.o section:
// .rela.debug_line symbol: : relocation against a discarded symbol,
//         symbol is part of discarded section:
//         .text%const __type_0&ace_max<unsig\ned>(const __type_0&,const __type_0&)
//
/* ACE_STACK_TRACE_SKIP_FRAMES == 0 */
//@@ Should the arithmetic on the following
//line be done with two void* ptrs?  The result
//would be ptrdiff_t, and what is the correct
//sprintf() conversion character for that?
/*_MSC_VER*/
//@TODO: Test with WCHAR
//@TODO: Need a common CriticalSection since dbghelp is not thread-safe
//our handle to dbghelp.dll
//these already have typedefs in DbgHelp.h
//@TODO: See codeproject's StackWalker.cpp for the list of locations to
//search so we get the "enhanced" dbghelp if the user has it but it is not
//first on the path.
//@TODO: Cache this so we don't have to re-link every time.  When to unload?
// Suppress warning 4748 "/GS can not protect parameters and local
// variables from local buffer overrun because optimizations are
// disabled in function"
/* _MSC_VER */
//Not sure what this should do, Chad?
//should be Rbp or Rdi instead?
//What does the "true" parameter mean when tracing the current process?
// Restore the warning state to what it was before entry.
/* _MSC_VER */
// Unsupported platform
// Call determine_starting_frame() on HP aCC build to resolve declared
// method never referenced warning.
/* __ACE_INLINE__ */
// That's a lot of samples :-)
// Probably failed due to running out of memory when trying to
// enqueue the new value.
// sum_ was initialized with ACE_STATS_INTERNAL_OFFSET, so
// subtract that off here.
// The sample standard deviation is:
//
// sqrt (sum (sample_i - mean)^2 / (number_of_samples_ - 1))
// Calculate the mean, scaled, so that we don't lose its
// precision.
// Calculate the summation term, of squared differences from the
// mean.
// Scale up by field width so that we don't lose the
// precision of the mean.  Carefully . . .
// NOTE: please do not reformat this code!  It //
// works with the Diab compiler the way it is! //
//
//
//
//
//
//
//
//
// NOTE: please do not reformat this code!  It //
// works with the Diab compiler the way it is! //
// Square using 64-bit arithmetic.
// Divide the summation by (number_of_samples_ - 1), to get the
// variance.  In addition, scale the variance down to undo the
// mean scaling above.  Otherwise, it can get too big.
// Take the square root of the variance to get the standard
// deviation.  First, scale up . . .
// And scale up, once more, because we'll be taking the square
// root.
// Unscale.
// Build a format string, in case the C library doesn't support %*u.
// The whole part of the division comes from simple integer division.
// Fractional = (dividend % divisor) * 10^precision / divisor
// It would be nice to add round-up term:
// Fractional = (dividend % divisor) * 10^precision / divisor  +
//                10^precision/2 / 10^precision
//            = ((dividend % divisor) * 10^precision  +  divisor) /
//                divisor
// No fractional portion is requested, so don't bother
// calculating it.
// The whole part of the division comes from simple integer division.
// Fractional = (dividend % divisor) * 10^precision / divisor.
// No fractional portion is requested, so don't bother
// calculating it.
// The maximum number of iterations is log_2 (2^64) == 64.
// Can't divide the interval any further.
// Multiply carefully to avoid overflow.
// (mid * 10^precision + fractional)^2 ==
//   n^2 * 10^(precision * 2)
// Do the 64-bit arithmetic carefully to avoid overflow.
// Check to see if the fractional part should be one greater.
// No fractional portion is requested, so don't bother
// calculating it.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Create a Singleton SVC_HANDLER by always returning the same
// SVC_HANDLER.
// If <sh> is NULL then create a new <SVC_HANDLER>.
// Create a SVC_HANDLER by dynamically linking it from a DLL.
// Open the shared library.
// Extract the factory function.
// Call the factory function to obtain the new SVC_Handler (should
// use RTTI here when it becomes available...)
// Create an ACE_Service_Type containing the SVC_Handler and
// insert into this->svc_rep_;
// @@ Somehow, we need to deal with this->thr_mgr_...
// Default behavior is to activate the SVC_HANDLER by calling it's
// open() method, which allows the SVC_HANDLER to determine its own
// concurrency strategy.
// See if we should enable non-blocking I/O on the <svc_handler>'s
// peer.
// Otherwise, make sure it's disabled by default.
// The connection was already made; so this close is a "normal" close
// operation.
// Must have a <Reactor>
// Register with the Reactor with the appropriate <mask>.
// If the implementation of the reactor uses event associations
// If we don't have non-block on, it won't work with
// WFMO_Reactor
// This maybe too harsh
// if (!ACE_BIT_ENABLED (this->flags_, ACE_NONBLOCK))
// goto failure;
// Call up to our parent to do the SVC_HANDLER initialization.
// The connection was already made; so this close is a "normal" close
// operation.
// Must have a thread manager!
// Call up to our parent to do the SVC_HANDLER initialization.
// Turn the <svc_handler> into an active object (if it isn't
// already one as a result of the first activation...)
// Set the peer acceptor's handle into non-blocking mode.  This is a
// safe-guard against the race condition that can otherwise occur
// between the time when <select> indicates that a passive-mode
// socket handle is "ready" and when we call <accept>.  During this
// interval, the client can shutdown the connection, in which case,
// the <accept> call can hang!
// Try to find out if the implementation of the reactor that we are
// using requires us to reset the event association for the newly
// created handle. This is because the newly created handle will
// inherit the properties of the listen handle, including its event
// associations.
// stream
// remote address
// timeout
// restart
// reset new handler
// Ensure that errno is preserved in case the svc_handler
// close() method resets it
// Close down handler to avoid memory leaks.
// If <flags_> is non-0 then we won't create zombies.
/* NOTREACHED */
// In child process.
// Close down the SOCK_Acceptor's handle since we don't need to
// keep it open.
// Ignore the return value here...
// Call up to our ancestor in the inheritance to do the
// SVC_HANDLER initialization.
/* NOTREACHED */
// In parent process.
// We need to close down the <SVC_HANDLER> here because it's
// running in the child.
// Create a new lock if necessary.
// Close down all cached service handlers.
// Initialize the creation strategy.
// First we decide if we need to clean up.
// Initialize the concurrency strategy.
// Initialize the recycling strategy.
// Get the recycling act for the svc_handler
// Check to see if the hint svc_handler has been closed down
// If close, decrement refcount
// If refcount goes to zero, close down the svc_handler
// Hint not successful
// Reset hint
// If hint is not closed, see if it is connected to the correct
// address and is recyclable
// Hint successful
// Tell the <svc_handler> that it should prepare itself for
// being recycled.
// This hint will not be used.
// Hint not successful
// If <sh> is not connected to the correct address or is busy,
// we will not use it.
// Explicit type conversion
// Try to find the address in the cache.  Only if we don't find it
// do we create a new <SVC_HANDLER> and connect it with the server.
// Set the flag
// We need to use a temporary variable here since we are not
// allowed to change <sh> because other threads may use this
// when we let go of the lock during the OS level connect.
//
// Note that making a new svc_handler, connecting remotely,
// binding to the map, and assigning of the hint and recycler
// should be atomic to the outside world.
// Create a new svc_handler
// Actively establish the connection.  This is a timed blocking
// connect.
// If connect() failed because of timeouts, we have to
// reject the connection entirely. This is necessary since
// currently there is no way for the non-blocking connects
// to complete and for the <Connector> to notify the cache
// of the completion of connect().
// Close the svc handler.
// Insert the new SVC_HANDLER instance into the cache.
// Close the svc handler.
// Everything succeeded as planned. Assign <sh> to <potential_handler>.
// Set the recycler and the recycling act
// We found a cached svc_handler.
// Set the flag
// Get the cached <svc_handler>
// Tell the <svc_handler> that it should prepare itself for
// being recycled.
// Yow, Reverse Guard!  Let go of the lock for the duration of the
// actual connect.  This will allow other threads to hack on the
// connection cache while this thread creates the new connection.
// This artificial scope is required since we need to let go of the
// lock *before* registering the newly created handler with the
// Reactor.
// Synchronization is required here as the setting of the
// recyclable state must be done atomically with the finding and
// binding of the service handler in the cache.
// If it is a new connection, activate it.
//
// Note: This activation is outside the scope of the lock of the
// cached connector.  This is necessary to avoid subtle deadlock
// conditions with this lock and the Reactor lock.
// If an error occurs while activating the handler, the
// <activate_svc_handler> method will close the handler.
// This in turn will remove this entry from the internal
// table.
// Synchronization is required here as the setting of the
// handler to zero must be done atomically with the users of
// the cache.
// Reset handler.
// This artificial scope is required since we need to let go of the
// lock *before* registering the newly created handler with the
// Reactor.
// Synchronization is required here as the setting of the
// recyclable state must be done atomically with the finding and
// binding of the service handler in the cache.
// If it is a new connection, activate it.
//
// Note: This activation is outside the scope of the lock of the
// cached connector.  This is necessary to avoid subtle deadlock
// conditions with this lock and the Reactor lock.
// If an error occurs while activating the handler, the
// <activate_svc_handler> method will close the handler.
// This in turn will remove this entry from the internal
// table.
// Synchronization is required here as the setting of the
// handler to zero must be done atomically with the users of
// the cache.
// Reset handler.
// Check if the user passed a hint svc_handler
// If not found
// For all successful cases: mark the <svc_handler> in the cache
// as being <in_use>.  Therefore recyclable is BUSY.
// And increment the refcount
// Synchronization is required here as the setting of the recyclable
// state must be done atomically with respect to other threads that
// are querying the cache.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// Synchronization is required here as the setting of the recyclable
// state must be done atomically with respect to other threads that
// are querying the cache.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// Const cast.
// Synchronization is required here.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as not being <in_use>.
// Therefore recyclable is IDLE.
// Excluded other threads from changing cache while we take this
// entry out.
// The wonders and perils of ACT
// Excluded other threads from changing cache while we take this
// entry out.
// The wonders and perils of ACT
// Mark the <svc_handler> in the cache as CLOSED.
// Excluded other threads from changing cache while we take this
// entry out.
// Reset the <*act_holder> in the confines and protection of the
// lock.
// The wonders and perils of ACT
// Decrement the refcount on the <svc_handler>.
// If the svc_handler state is closed and the refcount == 0, call
// close() on svc_handler.
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Close the underlying acceptor.
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
/* ACE_HAS_DUMP */
// Default behavior is to make a new SVC_HANDLER, passing in the
// Thread_Manager (if any).
/* ACE_HAS_DUMP */
/* ACE_STRATEGIES_T_CPP */
// Stream.cpp
//#include "ace/Module.h"
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Give some idea of what the heck is going on in a stream!
/* ACE_HAS_DUMP */
// Return the "top" ACE_Module in a ACE_Stream, skipping over the
// stream_head.
// We can't insert a module below <stream_tail_>.
// In case the <next_mod> is <stream_tail_>.
// In case the <rep_mod> is <stream_head_>.
// Remove the "top" ACE_Module in a ACE_Stream, skipping over the
// stream_head.
// Skip over the ACE_Stream head.
// Close the top ACE_Module.
// Don't delete the Module unless the flags request this.
// Remove a named ACE_Module from an arbitrary place in the
// ACE_Stream.
// Deleting ACE_Stream Head
// Close down the module.
// Don't delete the Module unless the flags request this.
// Release the memory.
// Actually push a module onto the stack...
// Make sure *all* the allocation succeeded!
// Don't bother checking return value here.
// Remove and cleanup all the intermediate modules.
// Clean up the head and tail of the stream.
// Cleanup the memory.
// Tell all threads waiting on the close that we are done.
// Try to create a data block that contains the user-supplied data.
// Try to create a control block <cb> that contains the control
// field and a pointer to the data block <db> in <cb>'s continuation
// field.
// @@ Michael: The old semantic assumed that cb returns == 0
//             if no memory was available. We will now return immediately
//             without release (errno is set to ENOMEM by the macro).
// If we can't allocate <cb> then we need to delete db and return
// -1.
// This will also release db if it's reference count == 0.
// Link two streams together at their bottom-most Modules (i.e., the
// one just above the Stream tail).  Note that all of this is premised
// on the fact that the Stream head and Stream tail are non-NULL...
// This must be called with locks held.
// Make sure the other side is also linked to us!
// Locate the module just above our Stream tail.
// Locate the module just above the other Stream's tail.
// Reattach the pointers so that the two streams are linked!
// Must be called with locks held...
// Only try to unlink if we are in fact still linked!
// Only relink if we still exist!
// Find the module that's just before our stream tail.
// Restore the writer's next() link to our tail.
// Only fiddle with the other side if it in fact still remains.
// Make sure the other side is also aware that it's been unlinked!
/* ACE_STREAM_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_HAS_DUMP */
// ACE_Module that act as the head and tail of a Stream.
// Performs canonical flushing at the ACE_Stream Head.
// this->is_reader ()
/* ACE_HAS_DUMP */
// Perform flush algorithm as though we were the driver.
/* NOTREACHED */
/* NOTREACHED */
/* ACE_HAS_DUMP */
/* ACE_STREAM_MODULES_CPP */
// For std::swap<>
/* __ACE_INLINE__ */
// Default constructor.
// Constructor that actually copies memory.
// Constructor that actually copies memory.
// Copy constructor.
// this method might benefit from a little restructuring.
// Case 1. Going from memory to more memory
// Case 2. No memory allocation is necessary.
// Free memory if necessary and figure out future ownership
// Populate data.
// Note: No guarantee that rep_ is null terminated.
// Return substring.
// case 1. empty string
// case 2. start pos past our end
// No length == empty string.
// Get all remaining bytes.
// case 1. No memory allocation needed.
// Copy in data from new string.
// case 2. Memory reallocation is needed
// Copy memory from old string into new string.
// Only reallocate if we don't have enough space...
// This can't use set(), because that would free memory if release=false
// Assignment operator (does copy memory).
// Assignment operator (does copy memory).
// Check for self-assignment.
// String retains the original buffer.
// External buffer: string relinquishes control of it.
// Get a copy of the underlying representation.
// Pick smaller of the two lengths and perform the comparison.
// Comparison operator.
// Do not change to prefix operator!  Proper operation of this loop
// depends on postfix decrement behavior.
// ----------------------------------------------
// ----------------------------------------------
// ----------------------------------------------
// This temp is silly but it quiets an optimizer warning in IBM XL C++ 10.
/* ACE_STRING_BASE_CPP */
//&& (defined (__xlC__) || defined (__IBMCPP__))
// Under some mixed shared/static linking conditions, this constant
// will not be initialized at run-time if the
// std::numeric_limits<>::max() trait is used on AIX/XLC++.
// Workaround that problem by making it easier for the compiler to
// realize it can set the constant at compile-time.
/* AIX */
// To provide correct virtual calls.
// we should start pseudo-asynchronous accept task
// one per all future acceptors
// Destructor.
// Decrement <wait_time> with the amount of time spent in the method
// double check
// or -1 ???
/* ACE_MT_SAFE */
// Decrement delta with the amount of time spent waiting
// timeout, do nothing,
// we should process "post_completed" queue
// Check errno  for  EINVAL,EAGAIN,EINTR ??
// aiowait() was interrupted by a signal.
// there are no outstanding asynchronous I/O requests.
// we should process "post_completed" queue
// EFAULT
// Call the application code.
// No completion key.
// Error
// process post_completed results
// Get the error status of the aio_ operation.
// ****** from Sun man pages *********************
// Upon completion of the operation both aio_return and aio_errno
// are set to reflect the result of the operation.
// AIO_INPROGRESS is not a value used by the system
// so the client may detect a change in state
// by initializing aio_return to this value.
// not completed
// zero bytes transferred
// completed
// we call find_completed_aio always with result != 0
//check for non zero
// not found
// means somebody else uses aio directly!!!
// should never be
//make attempt to start deferred AIO
//It is safe as we are protected by mutex_
// start_aio_i has new return codes
// 0  successful start
// 1  try later, OS queue overflow
// -1 invalid request and other errors
// ****** from Sun man pages *********************
// Upon completion of the operation both aio_return and aio_errno
// are set to reflect the result of the operation.
// AIO_INPROGRESS is not a value used by the system
// so the client may detect a change in state
// by initializing aio_return to this value.
// Start IO
// wake up condition
// if (ret_val == -1)
// Defer - retry this later.
//  AIO_CANCELED
// after aiocancel Sun does not notify us
// so we should send notification
// to save POSIX behavoir.
// Also we should do this for deffered aio's
/* ACE_HAS_AIO_CALLS && sun */
/* ACE_USES_WCHAR */
/* __GNUG__ */
// These are states not covered by the tokens in Svc_Conf_Tokens.h
// Visual Studio .NET 2005 (VC8) issues warning C4351 for input_ in the
// constructor initializer list below. Since we like the warned-of new
// behavior (input_ elements will be default-initialized), squash the
// warning here.
/* VC8 */
/* ACE_USES_WCHAR */
/* VC8 */
/* ACE_USES_WCHAR */
// Input related
// Parsing related
// Code set conversion related
/* ACE_USES_WCHAR */
// ******************************************************************
// Global functions
// ******************************************************************
// ******************************************************************
// Inline methods
// ******************************************************************
// ******************************************************************
// Static class methods
// ******************************************************************
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
/* ACE_USES_WCHAR */
// Make sure that the amount we are going to copy
// fits in the buffer
// If we are not currently in any state, skip over whitespace
// Make sure that we count all of the new lines
// The character at currrent is definitely not part of
// the string so we need to move current back one.
// Get the starting point of our string (skipping the quote)
// Now, we need to move back in the string until we find the
// same character that started the string
/* ACE_USES_WCHAR */
// This is considered a path, so we need to
// skip over the ':' and go around the loop
// again
// This is an empty line.
// Let's look for something else.
// String from buffer->index_ to current (inclusive)
// Get the string and save it in ace_yylval
/* ACE_USES_WCHAR */
// Determine the difference between pathname and ident
// We need more from the input source so, we will move the remainder of
// the buffer to the front and signal that we need more
// No BOM was found
/* ACE_USES_WCHAR */
/* ACE_USES_CLASSIC_SVC_CONF = 1 */
/* A Bison parser, made by GNU Bison 2.3.  */
/* Skeleton implementation for Bison's Yacc-like parsers in C
/* As a special exception, you may create a larger work that contains
/* C LALR(1) parser skeleton written by Richard Stallman, by
/* All symbols defined below should begin with ace_yy or YY, to avoid
/* Identify Bison output.  */
/* Bison version.  */
/* Skeleton name.  */
/* Pure parsers.  */
/* Using locations.  */
/* Tokens.  */
/* Put the tokens into the symbol table, so that GDB and other debuggers
/* Tokens.  */
/* Copy the first part of user declarations.  */
// Prototypes.
// Force the pretty debugging code to compile.
// #define YYDEBUG 1
// Bison 2.3 template contains switch statement with a "default:", but
// without a "case:" label. Suppressing a compiler warning for Visual
// C++.
// Normalize the message literal's type to match ace_yyerror() prototype
// Prevent yacc(1) from declaring a trivial YYSTYPE just because
// YYSTYPE is not a macro definition. On the other hand we want
// YYSTYPE_IS_DECLARED to be as localized as possible to avoid
// poluting the global namespace - there may be other yacc(1) parsers
// that want to play nice with ACE
/* Enabling traces.  */
/* Enabling verbose error messages.  */
/* Enabling the token table.  */
/* obsolescent; will be withdrawn */
/* Copy the second part of user declarations.  */
/* Line 216 of yacc.c.  */
/* INFRINGES ON USER NAME SPACE */
/* INFRINGES ON USER NAME SPACE */
/* Suppress unused-variable warnings by "using" E.  */
/* empty */
/* Identity function, used to suppress warnings about constant conditions.  */
/* The parser invokes alloca or malloc; define the necessary symbols.  */
/* INFRINGES ON USER NAME SPACE */
/* INFRINGES ON USER NAME SPACE */
/* INFRINGES ON USER NAME SPACE */
/* Pacify GCC's `empty if-body' warning.  */
/* empty */; } while (YYID (0))
/* The OS might guarantee only one guard page at the bottom of the stack,
/* reasonable circa 2006 */
/* INFRINGES ON USER NAME SPACE */
/* INFRINGES ON USER NAME SPACE */
/* INFRINGES ON USER NAME SPACE */
/* ! defined ace_yyoverflow || YYERROR_VERBOSE */
/* A type that is properly aligned for any stack member.  */
/* The size of the maximum gap between one aligned stack and the next.  */
/* The size of an array large to enough to hold all stacks, each with
/* Copy COUNT objects from FROM to TO.  The source and destination do
/* Relocate STACK from its old location to the new one.  The
/* YYFINAL -- State number of the termination state.  */
/* YYLAST -- Last index in YYTABLE.  */
/* YYNTOKENS -- Number of terminals.  */
/* YYNNTS -- Number of nonterminals.  */
/* YYNRULES -- Number of rules.  */
/* YYNRULES -- Number of states.  */
/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
/* YYDEFGOTO[NTERM-NUM].  */
/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
/* YYPGOTO[NTERM-NUM].  */
/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
/* Like YYERROR except do call ace_yyerror.  This remains here temporarily
/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
/* YY_LOCATION_PRINT -- Print the location on the stream.
/* YYLEX -- calling `ace_yylex' with the right arguments.  */
/* Enable debugging if requested.  */
/* INFRINGES ON USER NAME SPACE */
/*--------------------------------.
/*ARGSUSED*/
/*--------------------------------.
/*------------------------------------------------------------------.
/*------------------------------------------------.
/* The symbols being reduced.  */
/* Nonzero means print parse trace.  It is left uninitialized so that
/* !YYDEBUG */
/* !YYDEBUG */
/* YYINITDEPTH -- initial size of the parser's stacks.  */
/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
/* Return the length of YYSTR.  */
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
/* Fall through.  */
/* Copy into YYRESULT an error message about the unexpected token
/* This is so xgettext sees the translatable formats that are
/* Start YYX at -YYN if negative to avoid negative indexes in
/* Stay within bounds of both ace_yycheck and ace_yytname.  */
/* Avoid sprintf, as that infringes on the user's name space.
/* YYERROR_VERBOSE */
/*-----------------------------------------------.
/*ARGSUSED*/
/* Prevent warnings from -Wmissing-prototypes.  */
/* ! YYPARSE_PARAM */
/* ! YYPARSE_PARAM */
/*----------.
/* ! YYPARSE_PARAM */
/* The look-ahead symbol.  */
/* The semantic value of the look-ahead symbol.  */
/* Number of syntax errors so far.  */
/* Number of tokens to shift before error messages enabled.  */
/* Look-ahead token as an internal (translated) token number.  */
/* Buffer for error messages, and its allocated size.  */
/* Three stacks and their tools:
/* The state stack.  */
/* The semantic value stack.  */
/* The variables used to return semantic value and location from the
/* The number of symbols on the RHS of the reduced rule.
/* Cause a token to be read.  */
/* Initialize stack pointers.
/*------------------------------------------------------------.
/* In all cases, when you get here, the value and location stacks
/* Get the current used size of the three stacks, in elements.  */
/* Give user a chance to reallocate the stack.  Use copies of
/* Each stack pointer address is followed by the size of the
/* no ace_yyoverflow */
/* Extend the stack our own way.  */
/* no ace_yyoverflow */
/*-----------.
/* Do appropriate processing given the current state.  Read a
/* First try to decide what to do without reference to look-ahead token.  */
/* Not known => get a look-ahead token if don't already have one.  */
/* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
/* If the proper action on seeing token YYTOKEN is to reduce or to
/* Count tokens shifted since error; after three, turn off error
/* Shift the look-ahead token.  */
/* Discard the shifted token unless it is eof.  */
/*-----------------------------------------------------------.
/*-----------------------------.
/* ace_yyn is the number of a rule to reduce with.  */
/* If YYLEN is nonzero, implement the default value of the action:
// Initialize left context...
/* Line 1267 of yacc.c.  */
/* Now `shift' the result of the reduction.  Determine what state
/*------------------------------------.
/* If not already recovering from an error, report this error.  */
/* If just tried and failed to reuse look-ahead token after an
/* Return failure if at end of input.  */
/* Else will try to reuse look-ahead token after shifting the error
/*---------------------------------------------------.
/* Pacify compilers like GCC when the user code never invokes
/*CONSTCOND*/ 0)
/* Do not reclaim the symbols of the rule which action triggered
/*-------------------------------------------------------------.
/* Each real token shifted decrements this.  */
/* Pop the current state because it cannot handle the error token.  */
/* Shift the error token.  */
/*-------------------------------------.
/*-----------------------------------.
/*-------------------------------------------------.
/* Fall through.  */
/* Do not reclaim the symbols of the rule which action triggered
/* Make sure YYID is used.  */
// Prints the error string to standard output.  Cleans up the error
// messages.
/* ACE_NLOGGING */
// Note that SRC_REC represents left context, which is the STREAM *
// record.
// Main driver program.
// Try to reopen any filename argument to use YYIN.
/* SVC_CONF_Y_DEBUGGING */
/* ACE_USES_CLASSIC_SVC_CONF == 1 */
/* ACE_LACKS_PRAGMA_ONCE */
/* ACE_LACKS_PLACEMENT_OPERATOR_DELETE */
// If this ACE_ASSERT fails, it may be due to running of out TSS
// keys.  Try using ACE_HAS_TSS_EMULATION, or increasing
// ACE_DEFAULT_THREAD_KEYS if already using TSS emulation.
// Allocate the memory and store it (usually in thread-specific
// storage, depending on config flags).
// If this ACE_ASSERT fails, it may be due to running of out TSS
// keys.  Try using ACE_HAS_TSS_EMULATION, or increasing
// ACE_DEFAULT_THREAD_KEYS if already using TSS emulation.
// Allocate the memory and store it (usually in thread-specific
// storage, depending on config flags).
/* ACE_LACKS_PLACEMENT_OPERATOR_DELETE */
/* ACE_HAS_NEW_NOTHROW */
// Only delete ourselves if we're not owned by a module and have
// been allocated dynamically.
// Will call the destructor, which automatically calls <shutdown>.
// Note that if we are *not* allocated dynamically then the
// destructor will call <shutdown> automatically when it gets run
// during cleanup.
// You cannot delete a 'void*' (X3J16/95-0087 5.3.5.3), but we know
// the pointer was created using new char[] (see operator new code),
// so we use a cast:
// Default constructor.
// This clever idiom transparently checks if we were allocated
// dynamically.  This information is used by the <destroy> method to
// decide if we need to delete <this>...  The idiom is based on a
// paper by Michael van Rooyen (mrooyen@cellnet.co.uk) that appeared
// in the April '96 issue of the C++ Report.  We've spruced it up to
// work correctly in multi-threaded programs by using our ACE_TSS
// class.
// Make sure to reset the flag.
// Default behavior for a ACE_Svc_Handler object is to be registered
// with the ACE_Reactor (thereby ensuring single threading).
/* ACELIB_DEBUGGING */
// Perform termination activities.
// Deregister this handler with the ACE_Reactor.
// Make sure there are no timers.
// Remove self from reactor.
// Remove self from the recycler.
// Remove as hint.
/* ACE_HAS_DUMP */
// Extract the underlying I/O descriptor.
// Set the underlying I/O descriptor.
// We're closing down now, so make sure not to call ourselves
// recursively via other calls to handle_close() (e.g., from the
// Timer_Queue).
/* argc */,
/* argv */[])
// By default, the object is ready and willing to be recycled.
// Enqueue <mb> onto the message queue.
// Update the current number of bytes on the queue.
// Flush the buffer when the number of bytes exceeds the maximum
// buffer size or when the timeout period has elapsed.
// Flush the buffer.
// Get the first <ACE_Message_Block> so that we can write everything
// out via the <send_n>.
// This method assumes the caller holds the queue's lock!
// Update the next timeout period by adding the interval.
/* ACE_HAS_DUMP */
/* ACE_SVC_HANDLER_CPP */
// SV_Message.cpp
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// initial value of process
// Define the ACE_SV_Semaphore operation arrays for the semop() calls.
// Wait for [0] (lock) to equal 0
// then increment [0] to 1 - this locks it.
// UNDO to release the lock if processes exit
// before explicitly unlocking.
// Decrement [1] (proc counter) with undo on
// exit, UNDO to adjust proc counter if
// process exits before explicitly calling close()
// the decrement [0] (lock) back to 0
// Decrement [1] (proc counter) with undo on
// exit.
// Wait for [0] (lock) to equal 0
// then increment [0] to 1 - this lock it
// then increment [1] (proc counter)
// Decrement [0] (lock) back to 0
// Open or create an array of SV_Semaphores.  We return 0 if all is OK, else -1.
// Must include a count for the 2 additional semaphores we use
// internally.
// permission problem or tables full
// When the <ACE_SV_Semaphore_Complex> is created, we know
// that the value of all 3 members is 0.  Get a lock on the
// <ACE_SV_Semaphore_Complex> by waiting for [0] to equal 0,
// then increment it.
// There is a race condition here. There is the possibility
// that between the <semget> above and the <semop> below,
// another process can call out <close> function which can
// remove the <ACE_SV_Semaphore> if that process is the last
// one using it.  Therefor we handle the error condition of
// an invalid <ACE_SV_Semaphore> ID specifically below, and
// if it does happen, we just go back and create it again.
// Get the value of the process counter. If it equals 0, then no
// one has initialized the ACE_SV_Semaphore yet.
// We should initialize by doing a SETALL, but that would
// clear the adjust value that we set when we locked the
// ACE_SV_Semaphore above. Instead we do system calls to
// initialize [1], as well as all the nsems SV_Semaphores.
// Decrement the process counter and then release the lock.
// doesn't exist or tables full
// Decrement the process counter. We don't need a lock to do this.
// Close a ACE_SV_Semaphore.  Unlike the remove above, this function
// is for a process to call before it exits, when it is done with the
// ACE_SV_Semaphore.  We "decrement" the counter of processes using
// the ACE_SV_Semaphore, and if this was the last one, we can remove
// the ACE_SV_Semaphore.
// The following semop() first gets a lock on the ACE_SV_Semaphore,
// then increments [1] - the process number.
// Now that we have a lock, read the value of the process counter to
// see if this is the last reference to the ACE_SV_Semaphore. There
// is a race condition here - see the comments in create ().
/* ACE_HAS_ALLOC_HOOKS */
/* !__ACE_INLINE__ */
/* ACE_HAS_DUMP */
// General ACE_SV_Semaphore operation. Increment or decrement by a
// specific amount (positive or negative; amount can`t be zero).
// Open or create one or more SV_Semaphores.  We return 0 if all is
// OK, else -1.
// Convert name to key.  This function is used internally to create keys
// for the semaphores.
//
// The method for generating names is a 32 bit CRC, but still we
// measured close to collition ratio of nearly 0.1% for
// ACE::unique_name()-like strings.
// Basically "hash" the values in the <name>.  This won't
// necessarily guarantee uniqueness of all keys.
// But (IMHO) CRC32 is good enough for most purposes (Carlos)
// The cast below is legit...
/* defined (ACE_WIN32) && defined (_MSC_VER) */
/* defined (ACE_WIN32) && defined (_MSC_VER) */
// Open or create a ACE_SV_Semaphore.  We return 1 if all is OK, else
// 0.
/* ACE_HAS_WCHAR */
// Remove all SV_Semaphores associated with a particular key.  This
// call is intended to be called from a server, for example, when it
// is being shut down, as we do an IPC_RMID on the ACE_SV_Semaphore,
// regardless of whether other processes may be using it or not.  Most
// other processes should use close() below.
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Creates a shared memory segment of SIZE bytes and *does* attach to
// this segment.
// Constructor interface to this->open_and_attach () member function.
// The "do nothing" constructor.
// Added this constructor to accept an internal id, the one generated
// when a server constructs with the key IPC_PRIVATE.  The client can
// be passed ACE_SV_Shared_Memory::internal_id via a socket and call
// this construtor to attach the existing segment.  This prevents
// having to hard-code a key in advance.  Courtesy of Marvin Wolfthal
// (maw@fsg.com).
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_DUMP */
// Static initialization.
// Note: these three objects require static construction and destruction.
/* static */
/* static */
/* static */
// ACE_TRACE ("ACE_Synch_Options::ACE_Synch_Options");
// ACE_TRACE ("ACE_Synch_Options::set");
// Whoa, possible dependence on static initialization here.  This
// function is called during initialization of the statics above.
// But, ACE_Time_Value::zero is a static object.  Very fortunately,
// its bits have a value of 0.
// Only create a new unique filename for the memory pool file
// if the user didn't supply one...
// Create a temporary file.
/* ACE_DEFAULT_BACKING_STORE */
// -17 for ace-malloc-XXXXXX
// Add the filename to the end
/* ACE_DEFAULT_BACKING_STORE */
// Get the local system time.
// Get the system time of the central time server.
// Try to find it
// No time entry in shared memory (meaning no Clerk exists)
// so return the local time of the host.
// Extract the delta time.
// If delta_time is positive, it means that the system clock is
// ahead of our local clock so add delta to the local time to get an
// approximation of the system time. Else if delta time is negative,
// it means that our local clock is ahead of the system clock, so
// return the last local time stored (to avoid time conflicts).
// Return the last local time. Note that this is stored as the
// second field in shared memory.
// Synchronize local system time with the central time server using
// specified mode (currently unimplemented).
/* __ACE_INLINE__ */
/* ! ACE_TANDEM_T1248_PTHREADS || ACE_THREAD_T_IS_A_STRUCT */
/* ACE_TANDEM_T1248_PTHREADS || ACE_THREAD_T_IS_A_STRUCT */
/// Default ACE_Task service routine
/// Default ACE_Task open routine
/// Default ACE_Task close routine
/// Forward the call to close() so that existing applications don't
/// break.
/// Default ACE_Task put routine.
/// Wait for all threads running in a task to exit.
// If we don't have a thread manager, we probably were never
// activated.
/// Suspend a task.
/// Resume a suspended task.
// If the task passed in is zero, we will use <this>
// Already active.
// If we're joining an existing group of threads then make
// sure to (re)use its group id.
// make sure to reset the cached grp_id
// Use the ACE_Thread_Manager singleton if we're running as an
// active object and the caller didn't supply us with a
// Thread_Manager.
/* ! ACE_THREAD_MANAGER_LACKS_STATICS */
/* ACE_THREAD_MANAGER_LACKS_STATICS */
// Thread Ids were not specified
// thread names were specified
// If spawn_n fails, restore original thread count.
// Reset to prevent inadvertant match on ID
/* ACE_TANDEM_T1248_PTHREADS || ACE_THREAD_T_IS_A_STRUCT */
// Keep the compiler from complaining.
/* ACE_MT_SAFE */
// The thread count must be decremented first in case the <close>
// hook does something crazy like "delete this".
// @@ Is it possible to pass in the exit status somehow?
// t is undefined here. close() could have deleted it.
/* ACE_HAS_SIG_C_FUNC */
// Register ourself with our <Thread_Manager>'s thread exit hook
// mechanism so that our close() hook will be sure to get invoked
// when this thread exits.
/* ACE_HAS_SIG_C_FUNC */
// Call the Task's svc() hook method.
// Reinterpret case between integral types is not mentioned in the C++ spec
/* ACE_HAS_INTEGRAL_TYPE_THR_FUNC_RETURN */
// If we changed this zero change the other if in OS.cpp Thread_Adapter::invoke
// Call the <Task->close> hook.
// This calls the Task->close () hook.
// This prevents a second invocation of the cleanup code
// (called later by <ACE_Thread_Manager::exit>.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_MT_SAFE */
/* ACE_HAS_DUMP */
// If the user doesn't supply a ACE_Message_Queue_Ex pointer then we'll
// allocate one dynamically.  Otherwise, we'll use the one they give.
// These assignments aren't strickly necessary but they help guard
// against odd race conditions...
/// @todo FIXME Need to impl ACE_Moudle to support ACE_Task as well.
/// Now always return 0 for sibling
/*
/* ACE_TASK_EX_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_MT_SAFE */
/* ACE_HAS_DUMP */
// If the user doesn't supply a ACE_Message_Queue pointer then we'll
// allocate one dynamically.  Otherwise, we'll use the one they give.
// These assignments aren't strickly necessary but they help guard
// against odd race conditions...
/* ACE_TASK_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Returns true if we are done, else false.
// Sets the <is_set_> status.
// By setting this to 1, we are "signaling" to anyone calling
// <is_set> or or <set> that the "test and set" object is in the
// "signaled" state, i.e., it's "available" to be set back to 0.
/* ACE_TEST_AND_SET_CPP */
/* !defined (__ACE_INLINE__) */
// Bail out if error occurs.
// Bail out if error occurs.
/* ACE_HAS_THREADS */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Inherit the logging features if the parent thread has an
// ACE_Log_Msg instance in thread-specific storage.
// NOTE: this preprocessor directive should match the one in above
// ACE_Thread_Exit::instance ().  With the Xavier Pthreads package,
// the exit_hook in TSS causes a seg fault.  So, this works around
// that by creating exit_hook on the stack.
// Obtain our thread-specific exit hook and make sure that it knows
// how to clean us up!  Note that we never use this pointer directly
// (it's stored in thread-specific storage), so it's ok to
// dereference it here and only store it as a reference.
// Except if it is null, then the thr_mgr() method crashes.
// -jxh
// Keep track of the <Thread_Manager> that's associated with this
// <exit_hook>.
// Without TSS, create an <ACE_Thread_Exit> instance.  When this
// function returns, its destructor will be called because the
// object goes out of scope.  The drawback with this appraoch is
// that the destructor _won't_ get called if <thr_exit> is called.
// So, threads shouldn't exit that way.  Instead, they should return
// from <svc>.
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
/* ! ACE_USE_THREAD_MANAGER_ADAPTER */
// Extract the arguments.
/* ACE_WIN32 && ACE_HAS_MFC && (ACE_HAS_MFC != 0) */
// Pick up the cancel-related flags before deleting this.
// Delete ourselves since we don't need <this> anymore.  Make sure
// not to access <this> anywhere below this point.
// On SunOS, the LWP priority needs to be set in order to get
// preemption when running in the RT class.  This is the ACE way to
// do that . . .
// thr_getprio () on the current thread should never fail.
// ACE_OS::thr_setprio () has the special logic to set the LWP priority,
// if running in the RT class.
/* ACE_NEEDS_LWP_PRIO_SET */
// If both flags are set, ignore this.
// Invoke the start hook to give the user a chance to
// perform some initialization processing before the
// <func> is invoked.
// Call thread entry point.
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// If we changed this to 1, change the respective if in
// Task::svc_run to 0.
// Call the <Task->close> hook.
// This calls the Task->close () hook.
// This prevents a second invocation of the cleanup code
// (called later by <ACE_Thread_Manager::exit>.
/* 0 */
/* ACE_WIN32 && ACE_HAS_MFC && (ACE_HAS_MFC != 0) */
// Call TSS destructors.
/* not main thread */);
// Exit the thread.  Allow CWinThread-destructor to be invoked
// from AfxEndThread.  _endthreadex will be called from
// AfxEndThread so don't exit the thread now if we are running
// an MFC thread.
// Not spawned by ACE_Thread_Manager, use the old buggy
// version.  You should seriously consider using
// ACE_Thread_Manager to spawn threads.  The following code
// is know to cause some problem.
/* ACE_HAS_MFC && ACE_HAS_MFS != 0*/
/* ACE_WIN32 */
/* ACE_WIN32 || ACE_HAS_TSS_EMULATION */
/* ACE_HAS_INLINED_OSCALLS */
/* ACE_HAS_DUMP */
// Initialize the thread controller.
// Automatically kill thread on exit.
/* ACE_HAS_RECURSIVE_THR_EXIT_SEMANTICS */
// Exit from thread (but clean up first).
// With ACE_HAS_TSS_EMULATION, we let ACE_Thread_Adapter::invoke ()
// exit the thread after cleaning up TSS.
/* ! ACE_HAS_TSS_EMULATION */
// Set the thr_exit_ static to null to keep things from crashing if
// ACE::fini() is enabled here.
// All TSS objects have been destroyed.  Reset this flag so
// ACE_Thread_Exit singleton can be created again.
// NOTE: this preprocessor directive should match the one in
// ACE_Task_Base::svc_run () below.  This prevents the two statics
// from being defined.
// Determines if we were dynamically allocated.
// Implement the Double Check pattern.
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
// Grab hold of the Task * so that we can close() it in the
// destructor.
// Set the this pointer...
// When this object is destroyed the Task is automatically closed
// down!
/* __ACE_INLINE__ */
// Process-wide Thread Manager.
// Controls whether the Thread_Manager is deleted when we shut down
// (we can only delete it safely if we created it!)
/* ! defined (ACE_THREAD_MANAGER_LACKS_STATICS) */
// Cast away const-ness of this in order to use its non-const lock_.
/* ACE_HAS_DUMP */
// Get first at from at_exit_list
// Remove at from at_exit list
// Apply if required
// Do the apply method
// Mark at has been applied to avoid double apply from
// at destructor
// If at is not owner delete at.
// Run at_exit hooks
// We must remove Thread_Descriptor from Thread_Manager list
// Threads created with THR_DAEMON shouldn't exist here, but
// just to be safe, let's put it here.
// Mark thread as terminated.
// Must copy the information here because td will be
// "freed" below.
/* ACE_WIN32 */
/* !ACE_HAS_VXTHREADS */
// Remove thread descriptor from the table. 'this' is invalid
// upon return.
// remove_thr makes use of 'this' invalid on return.
// Code below will free log_msg, so clear our pointer
// now - it's already been saved in log_msg.
// Check if we need delete ACE_Log_Msg instance
// If ACE_TSS_cleanup was not executed first log_msg == 0
// Only inform to ACE_TSS_cleanup that it must delete the log instance
// setting ACE_LOG_MSG thr_desc to 0.
// To keep compatibility, when cleanup_hook is null really is a at_pop
// without apply.
/* ACE_HAS_DUMP */
// Just try to acquire the lock then release it.
/* ACE_THREAD_MANAGER_USES_SAFE_SPAWN */
// Acquire the lock before removing <td> from the thread table.  If
// this thread is in the table already, it should simply acquire the
// lock easily.
// Once we get the lock, we must have registered.
// Release the lock before putting it back to freelist.
// Just try to acquire the lock then release it.
/* ACE_THREAD_MANAGER_USES_SAFE_SPAWN */
// Just try to acquire the lock then release it.
/* ACE_THREAD_MANAGER_USES_SAFE_SPAWN */
// Release the lock before putting it back to freelist.
// The following macro simplifies subsequence code.
// Return the thread descriptor (indexed by ACE_hthread_t).
// Initialize the synchronization variables.
/* ACE_HAS_THREADS */
/* ACE_HAS_THREADS */
/* ACE_HAS_THREADS */
// Perform Double-Checked Locking Optimization.
// We can't safely delete it since we don't know who created it!
// First, we clean up the thread descriptor list.
/* ! defined (ACE_THREAD_MANAGER_LACKS_STATICS) */
// Close up and release all resources.
// Clean up the thread descriptor list.
// Run the entry point for thread spawned under the control of the
// <ACE_Thread_Manager>.  This must be an extern "C" to make certain
// compilers happy...
//
// The interaction with <ACE_Thread_Exit> and
// <ace_thread_manager_adapter> works like this, with
// ACE_HAS_THREAD_SPECIFIC_STORAGE or ACE_HAS_TSS_EMULATION:
//
// o Every thread in the <ACE_Thread_Manager> is run with
//   <ace_thread_manager_adapter>.
//
// o <ace_thread_manager_adapter> retrieves the singleton
//   <ACE_Thread_Exit> instance from <ACE_Thread_Exit::instance>.
//   The singleton gets created in thread-specific storage
//   in the first call to that function.  The key point is that the
//   instance is in thread-specific storage.
//
// o A thread can exit by various means, such as <ACE_Thread::exit>, C++
//   or Win32 exception, "falling off the end" of the thread entry
//   point function, etc.
//
// o If you follow this so far, now it gets really fun . . .
//   When the thread-specific storage (for the thread that
//   is being destroyed) is cleaned up, the OS threads package (or
//   the ACE emulation of thread-specific storage) will destroy any
//   objects that are in thread-specific storage.  It has a list of
//   them, and just walks down the list and destroys each one.
//
// o That's where the ACE_Thread_Exit destructor gets called.
// As early as we can in the execution of the new thread, allocate
// its local TS storage.  Allocate it on the stack, to save dynamic
// allocation/dealloction.
/* ACE_HAS_TSS_EMULATION */
// NOTE: this preprocessor directive should match the one in above
// ACE_Thread_Exit::instance ().  With the Xavier Pthreads package,
// the exit_hook in TSS causes a seg fault.  So, this works around
// that by creating exit_hook on the stack.
// Obtain our thread-specific exit hook and make sure that it knows
// how to clean us up!  Note that we never use this pointer directly
// (it's stored in thread-specific storage), so it's ok to
// dereference it here and only store it as a reference.
// Without TSS, create an <ACE_Thread_Exit> instance.  When this
// function returns, its destructor will be called because the
// object goes out of scope.  The drawback with this appraoch is
// that the destructor _won't_ get called if <thr_exit> is called.
// So, threads shouldn't exit that way.  Instead, they should return
// from <svc>.
/* ACE_HAS_THREAD_SPECIFIC_STORAGE || ACE_HAS_TSS_EMULATION */
// Keep track of the <Thread_Manager> that's associated with this
// <exit_hook>.
// Invoke the user-supplied function with the args.
// Call the appropriate OS routine to spawn a thread.  Should *not* be
// called with the lock_ held...
// First, threads created by Thread Manager should not be daemon threads.
// Using assertion is probably a bit too strong.  However, it helps
// finding this kind of error as early as possible.  Perhaps we can replace
// assertion by returning error.
// Create a new thread running <func>.  *Must* be called with the
// <lock_> held...
// Get a "new" Thread Descriptor from the freelist.
/* ACE_HAS_CPP11 */
// Reset thread descriptor status
/* ACE_HAS_WIN32_STRUCTURAL_EXCEPTIONS */
// Acquire the <sync_> lock to block the spawned thread from
// removing this Thread Descriptor before it gets put into our
// thread table.
// _Don't_ clobber errno here!  result is either 0 or -1, and
// ACE_OS::thr_create () already set errno!  D. Levine 28 Mar 1997
// errno = result;
// Lock release may smash errno
// Have to duplicate handle if client asks for it.
// @@ How are thread handles implemented on AIX?  Do they
// also need to be duplicated?
/* ! ACE_LACKS_DUP */
/* ! ACE_LACKS_DUP */
/* ! ACE_HAS_WTHREADS */
/* ! ACE_HAS_WTHREADS */
// append_thr also put the <new_thr_desc> into Thread_Manager's
// double-linked list.  Only after this point, can we manipulate
// double-linked list from a spawned thread's context.
// Increment the group id.
// Create N new threads running FUNC.
// Increment the group id.
// @@ What should happen if this fails?! e.g., should we try to
// cancel the other threads that we've already spawned or what?
// Create N new threads running FUNC.
// Increment the group id.
// @@ What should happen if this fails?! e.g., should we try to
// cancel the other threads that we've already spawned or what?
// Append a thread into the pool (does not check for duplicates).
// Must be called with locks held.
// Setup the Thread_Manager.
// Return the thread descriptor (indexed by ACE_hthread_t).
// Locate the index in the table associated with <t_id>.  Must be
// called with the lock held.
// Insert a thread into the pool (checks for duplicates and doesn't
// allow them to be inserted twice).
// Check for duplicates and bail out if we're already registered...
// Run the registered hooks when the thread exits.
// currently unused!
// @@ Currently, we have just one hook.  This should clearly be
// generalized to support an arbitrary number of hooks.
/* 0 */
// Remove a thread from the pool.  Must be called with locks held.
/* ACE_WIN32 */
// Tell all waiters when there are no more threads left in the pool.
/* ACE_HAS_THREADS */
// Repeatedly call remove_thr on all table entries until there
// is no thread left.   Must be called with lock held.
// ------------------------------------------------------------------
// Factor out some common behavior to simplify the following methods.
// Since the thread are being joined, we should
// let it remove itself from the list.
//      this->remove_thr (td);
// ACE_HAS_THREADS && ACE_LACKS_PTHREAD_JOIN
// Must set the state first and then try to cancel the thread.
// Note that this call only does something relevant if the OS
// platform supports asynchronous thread cancellation.  Otherwise,
// it's a no-op.
// Only remove a thread from us when there is a "real" error.
// ------------------------------------------------------------------
// Factor out some common behavior to simplify the following methods.
// Suspend a single thread.
// Resume a single thread.
// Cancel a single thread.
// Send a signal to a single thread.
// If we're checking the state of our thread, try to get the cached
// value out of TSS to avoid lookup.
// Always return false.
// Not calling from self, have to look it up from the list.
// Test if a single thread has terminated.
// Test if a single thread is suspended.
// Test if a single thread is active (i.e., resumed).
// Test if a single thread is cancelled.
// Thread information query functions.
// Get group ids for a particular thread id.
// Set group ids for a particular thread id.
// Suspend a group of threads.
// Must remove threads after we have traversed the thr_list_ to
// prevent clobber thr_list_'s integrity.
// Save/restore errno.
// Resume a group of threads.
// Kill a group of threads.
// Cancel a group of threads.
// Must remove threads after we have traversed the thr_list_ to
// prevent clobber thr_list_'s integrity.
// Save/restore errno.
// Resume all threads that are suspended.
// return immediately if we've found the thread we want to join.
/* !ACE_HAS_VXTHREADS */
// If threads are created as THR_DETACHED or THR_DAEMON, we
// can't help much.
// Didn't find the thread we want or the thread is not joinable.
// not currently supported without pthread_join
// ACE_HAS_THREADS && ACE_LACKS_PTHREAD_JOIN
// Wait for group of threads
// We have to make sure that while we wait for these threads to
// exit, we do not have the lock.  Therefore we make a copy of all
// interesting entries and let go of the lock.
/* !ACE_HAS_VXTHREADS */
// If threads are created as THR_DETACHED or THR_DAEMON, we
// can't help much.
// If threads are created as THR_DETACHED or THR_DAEMON, we
// can't help much.
/* !ACE_HAS_VXTHREADS */
// ACE_HAS_THREADS && ACE_LACKS_PTHREAD_JOIN
// Now actually join() with all the threads in this group.
// Must be called when thread goes out of scope to clean up its table
// slot.
// Remove detached thread handle.
// @@ This callback is now taken care of by TSS_Cleanup.  Do we
//    need it anymore?
// On Win32, if we really wants to exit from a thread, we must
// first  clean up the thread specific storage.  By doing so,
// ACE_Thread_Manager::exit will be called again with
// do_thr_exit = 0 and cleaning up the ACE_Cleanup_Info (but not
// exiting the thread.)  After the following call returns, we
// are safe to exit this thread.
/* 0 */
/* ACE_WIN32 */
// Just hold onto the guard while finding this thread's id and
// Find the thread id, but don't use the cache.  It might have been
// deleted already.
// @@ We call Thread_Descriptor terminate this realize the cleanup
// process itself.
// On reasonable systems <ACE_Thread::exit> should not return.
// However, due to horrible semantics with Win32 thread-specific
// storage this call can return (don't ask...).
// Wait for all the threads to exit.
// Check to see if we're using absolute time or not.
// create time value duplicate (preserves time policy)
// convert time value to absolute time
// replace original time by abs time duplicate
/* ACE_HAS_VXTHREADS */
// Just hold onto the guard while waiting.
// Program is not shutting down.  Perform a normal wait on threads.
// Program is shutting down, no chance to wait on threads.
// Therefore, we'll just remove threads from the list.
/* ACE_HAS_VXTHREADS */
// Release the guard, giving other threads a chance to run.
// @@ VxWorks doesn't support thr_join (yet.)  We are working
// on our implementation.   Chorus'es thr_join seems broken.
// Detached handles shouldn't reached here.
/* !ACE_HAS_VXTHREADS */
/* ACE_HAS_THREADS */
// Must remove threads after we have traversed the thr_list_ to
// prevent clobber thr_list_'s integrity.
// Save/restore errno.
// Wait for all threads to exit a task.
// We have to make sure that while we wait for these threads to
// exit, we do not have the lock.  Therefore we make a copy of all
// interesting entries and let go of the lock.
/* !ACE_HAS_VXTHREADS */
// If threads are created as THR_DETACHED or THR_DAEMON, we
// can't wait on them here.
// If threads are created as THR_DETACHED or THR_DAEMON, we can't help much here.
/* !ACE_HAS_VXTHREADS */
// ACE_HAS_THREADS && ACE_LACKS_PTHREAD_JOIN
// Now to do the actual work
// Suspend a task
// Resume a task.
// Kill a task.
/* signum */)
// Cancel a task.
// Locate the index in the table associated with <task> from the
// beginning of the table up to an index.  Must be called with the
// lock held.
// Returns the number of ACE_Task in a group.
// Returns the number of threads in an ACE_Task.
// Returns in task_list a list of ACE_Tasks registered with ACE_Thread_Manager.
// This thread has a task pointer; see if it's already in the
// list. Don't add duplicates.
// No match - add this one
// Returns in thread_list a list of all thread ids
// If we're checking the state of our thread, try to get the cached
// value out of TSS to avoid lookup.
// Always return false.
// Not calling from self, have to look it up from the list.
// Returns in task_list a list of ACE_Tasks in a group.
// Returns in thread_list a list of thread ids in an ACE_Task.
// Returns in thread_list a list of thread handles in an ACE_Task.
// Returns in thread_list a list of thread handles in an ACE_Task.
/**
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Thread_Mutex::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Thread_Mutex::~ACE_Thread_Mutex");
//  ACE_TRACE ("ACE_Thread_Mutex::ACE_Thread_Mutex");
/* ACE_HAS_THREADS */
/**
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Thread_Semaphore::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Thread_Semaphore::ACE_Thread_Semaphore");
/*****************************************************************************/
/* ACE_HAS_THREADS */
/* ACE_NLOGGING */
/* __ACE_INLINE__ */
/* ACE_COMPILE_TIMEPROBES */
/* ACE_LACKS_PRAGMA_ONCE */
//FUZZ: disable check_for_lack_ACE_OS
//FUZZ: enable check_for_lack_ACE_OS
//FUZZ: disable check_for_lack_ACE_OS
//FUZZ: enable check_for_lack_ACE_OS
//
// Stupid MSVC is forcing me to define this; please don't use it.
//
// wrap around to the beginning on overflow
/* ACE_TIMEPROBE_ASSERTS_FIXED_SIZE */
// wrap around to the beginning on overflow
/* ACE_TIMEPROBE_ASSERTS_FIXED_SIZE */
//FUZZ: disable check_for_lack_ACE_OS
//FUZZ: enable check_for_lack_ACE_OS
// Iterates over the array explicitly calling the destructor for
// each probe instance, then deallocates the memory
// Sort the event descriptions
// First element
// When reusing the same ACE_Timeprobe from multiple threads
// with Linux on Intel SMP, it sometimes happens that the
// recorded times go backward in time if they are recorded from
// different threads (see bugzilla #2342).  To obtain the
// correct signed difference between consecutive recorded times,
// one has to cast the time difference to an intermediate signed
// integral type of the same size as ACE_hrtime_t.
// Convert to microseconds.
// Sort the event descriptions
// to convert ACE_hrtime_t
// Modulus increment: loops around at the end.
/* ACE_COMPILE_TIMEPROBES */
/* ACE_TIMEPROBE_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// This constructor is required by ACE_Locked_Free_List::alloc.
/// Pointer to next token.
// Default constructor
// Nothing
// Constructor that specifies a Timer_Hash to call up to
// Nothing
// Registration will be handled by the upcall functor of the timer
// hash.
// This method should never be invoked since we don't invoke
// expire() on the buckets.
// This method should never be invoked since we don't invoke
// expire() on the buckets.
// Calls up to timer_hash's upcall functor
// This method should never be invoked since we don't invoke
// expire() on the buckets.
// Cancellation will be handled by the upcall functor of the timer
// hash.
// Cancellation will be handled by the upcall functor of the timer
// hash.
// Call up to the upcall functor of the timer hash since the timer
// hash does not invoke deletion() on its upcall functor directly.
// Nothing
// Nothing
// Positions the iterator at the first node in the timing hash table
// Check for an empty entry
// Didn't find any
// Positions the iterator at the next node in the bucket or goes to the next
// bucket
// If there is no more in the current bucket, go to the next
// Check for an empty entry
// Didn't find any.
// Returns true when we are at the end (when bucket_item_ == 0)
// Returns the node at the current position in the sequence
// Create an empty queue.
/* ACE_WIN64 */
/* ACE_WIN64 */
// Remove all remaining items in the Queue.
// Remove all remaining items from the queue.
// leave the rest to destructor
// Checks if queue is empty.
// Returns earliest time in a non-empty bucket
/* ACE_HAS_DUMP */
// Reschedule a periodic timer.  This function must be called with the
// mutex lock held.
// Don't use ACE_Utils::truncate_cast<> here.  A straight
// static_cast<>  will provide more unique results when the number
// of seconds is greater than std::numeric_limits<size_t>::max().
// Since schedule() above will allocate a new node
// then here schedule <expired> for deletion. Don't call
// this->free_node() because that will invalidate <h>
// and that's what user have as timer_id.
// Insert a new handler that expires at time future_time; if interval
// is > 0, the handler will be reinvoked periodically.
// Don't use ACE_Utils::truncate_cast<> here.  A straight
// static_cast<>  will provide more unique results when the number
// of seconds is greater than std::numeric_limits<size_t>::max().
// Don't create Hash_Token directly. Instead we get one from Free_List
// and then set it properly.
// This is a Win64 hack, necessary because of the original (bad) decision
// to use a pointer as the timer ID. This class doesn't follow the usual
// timer expiration rules (see comments in header file) and is probably
// not used much. The dynamic allocation of Hash_Tokens without
// recording them anywhere is a large problem for Win64 since the
// size of a pointer is 64 bits, but a long is 32. Since this class
// is not much used, I'm hacking this, at least for now. If it becomes
// an issue, I'll look at it again then.
// Locate and update the inteval on the timer_id
// Make sure we are getting a valid <timer_id>, not an error
// returned by <schedule>.
// Grab the lock before accessing the table.  We don't need to do so
// before this point since no members are accessed until now.
/* ACE_WIN64 */
// Locate and remove the single <ACE_Event_Handler> with a value of
// @a timer_id from the correct table timer queue.
// Make sure we are getting a valid <timer_id>, not an error
// returned by <schedule>.
// Grab the lock before accessing the table.  We don't need to do so
// before this point since no members are accessed until now.
/* ACE_WIN64 */
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
// We could destruct Hash_Token explicitly but we better
// schedule it for destruction. In this case next
// token_list_.remove () will use it.
// Locate and remove all values of <type> from the timer queue.
// loop variable.
// We could destruct Hash_Token explicitly but we better
// schedule it for destruction.
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
// Removes the earliest node and finds the new earliest position
// Finds a new earliest position
// Returns the earliest node without removing it
// Dummy version of expire to get rid of warnings in Sun CC 4.2
// Specialized expire for Timer Hash
// Go through the table and expire anything that can be expired
// Check if this is an interval timer.
// Make sure that we skip past values that have already
// "expired".
// Since this is an interval timer, we need to
// reschedule it.
// Get the dispatch info
/* ACE_TIMER_HASH_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/*
// Define some simple inlined functions to clarify the code.
// Constructor that takes in an <ACE_Timer_Heap_T> to iterate over.
// Positions the iterator at the first node in the heap array
// Positions the iterator at the next node in the heap array
// Returns true the <position_> is at the end of the heap array
// Returns the node at the current position in the heap or 0 if at the end
// Constructor
// Note that timer_ids_curr_ and timer_ids_min_free_ both start at 0.
// Since timer IDs are assigned by first incrementing the timer_ids_curr_
// value, the first ID assigned will be 1 (just as in the previous design).
// When it's time to wrap, the next ID given out will be 0.
// Possibly reduce size to fit in a long.
// Create the heap array.
/* ACE_HAS_ALLOC_HOOKS */
// Create the parallel
// Initialize the "freelist," which uses negative values to
// distinguish freelist elements from "pointers" into the <heap_>
// array.
// Add allocated array to set of such arrays for deletion on
// cleanup.
// Form the freelist by linking the next_ pointers together.
// NULL-terminate the freelist.
// Assign the freelist pointer to the front of the list.
// Note that timer_ids_curr_ and timer_ids_min_free_ both start at 0.
// Since timer IDs are assigned by first incrementing the timer_ids_curr_
// value, the first ID assigned will be 1 (just as in the previous design).
// When it's time to wrap, the next ID given out will be 0.
// Possibly reduce size to fit in a long.
// Create the heap array.
/* ACE_HAS_ALLOC_HOOKS */
// Create the parallel array.
/* ACE_HAS_ALLOC_HOOKS */
// Initialize the "freelist," which uses negative values to
// distinguish freelist elements from "pointers" into the <heap_>
// array.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// clean up any preallocated timer nodes
// Clean up all the nodes still in the queue
// Grab the event_handler and act, then delete the node before calling
// back to the handler. Prevents a handler from trying to cancel_timer()
// inside handle_close(), ripping the current timer node out from
// under us.
// leave the rest to the destructor
// Scan for a free timer ID. Note that since this function is called
// _after_ the check for a full timer heap, we are guaranteed to find
// a free ID, even if we need to wrap around and start reusing freed IDs.
// On entry, the curr_ index is at the previous ID given out; start
// up where we left off last time.
// NOTE - a timer_ids_ slot with -2 is out of the heap, but not freed.
// It must be either freed (free_node) or rescheduled (reschedule).
// We restarted the free search at min. Since min won't be
// free anymore, and curr_ will just keep marching up the list
// on each successive need for an ID, reset min_free_ to the
// size of the list until an ID is freed that curr_ has already
// gone past (see push_freelist).
// Since this ID has already been checked by one of the public
// functions, it's safe to cast it here.
// The freelist values in the <timer_ids_> are negative, so set the
// freed entry back to 'free'. If this is the new lowest value free
// timer ID that curr_ won't see on it's normal march through the list,
// remember it.
// Return the next item off the freelist and use it as the timer id.
// Checks if queue is empty.
// Returns earliest time in a non-empty queue.
/* ACE_HAS_DUMP */
// Insert <moved_node> into its new location in the heap.
// Update the corresponding slot in the parallel <timer_ids_> array.
// Remove the slot'th timer node from the heap, but do not reclaim its
// timer ID or change the size of this timer heap object. The caller of
// this function must call either free_node (to reclaim the timer ID
// and the timer node memory, as well as decrement the size of the queue)
// or reschedule (to reinsert the node in the heap at a new time).
// NOTE - the cur_size_ is being decremented since the queue has one
// less active timer in it. However, this ACE_Timer_Node is not being
// freed, and there is still a place for it in timer_ids_ (the timer ID
// is not being relinquished). The node can still be rescheduled, or
// it can be freed via free_node.
// Only try to reheapify if we're not deleting the last entry.
// Move the end node to the location being removed and update
// the corresponding slot in the parallel <timer_ids> array.
// If the <moved_node->time_value_> is great than or equal its
// parent it needs be moved down the heap.
// Restore the heap property after a deletion.
// Choose the smaller of the two children.
// Perform a <copy> if the child has a larger timeout value than
// the <moved_node>.
// We've found our location in the heap.
// Restore the heap property after an insertion.
// If the parent node is greater than the <moved_node> we need
// to copy it down.
// Insert the new node into its proper resting place in the heap and
// update the corresponding slot in the parallel <timer_ids> array.
// All the containers will double in size from max_size_.
// First grow the heap itself.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// Grow the array of timer ids.
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_ALLOC_HOOKS */
// And add the new elements to the end of the "freelist".
// Grow the preallocation array (if using preallocation)
// Create a new array with max_size elements to link in to
// existing list.
// Add it to the set for later deletion
// Link new nodes together (as for original list).
// NULL-terminate the new list.
// Link new array to the end of the existling list.
// Force rescan of list from beginning for a free slot (I think...)
// This fixed Bugzilla #2447.
// Reschedule a periodic timer.  This function must be called with the
// mutex lock held.
// If we are rescheduling, then the most recent call was to
// remove_first (). That called remove () to remove the node from the
// heap, but did not free the timer ID. The ACE_Timer_Node still has
// its assigned ID - just needs to be inserted at the new proper
// place, and the heap restored properly.
// Only allocate a node if we are *not* using the preallocated heap.
// check to see if the heap needs to grow
// Remove the first element from the freelist.
// Return this timer id to the freelist.
// Only free up a node if we are *not* using the preallocated heap.
// Insert a new timer that expires at time future_time; if interval is
// > 0, the handler will be reinvoked periodically.
// Obtain the next unique sequence number.
// Obtain the memory to the new node.
// Locate and remove the single timer with a value of @a timer_id from
// the timer queue.
// Locate the ACE_Timer_Node that corresponds to the timer_id.
// Check to see if the timer_id is out of range
// Check to see if timer_id is still valid.
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
// Locate and update the inteval on the timer_id
// Locate the ACE_Timer_Node that corresponds to the timer_id.
// Check to see if the timer_id is out of range
// Check to see if timer_id is still valid.
// Reset the timer interval
// Locate and remove all values of @a type from the timer queue.
// Try to locate the ACE_Timer_Node that matches the timer_id.
// We reset to zero so that we don't miss checking any nodes
// if a reheapify occurs when a node is removed.  There
// may be a better fix than this, however.
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
// Returns the earliest node or returns 0 if the heap is empty.
/* ACE_TIMER_HEAP_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Default Constructor
// Positions the iterator at the node right after the dummy node
// Positions the iterator at the next node in the Timer Queue
// Make sure that if we are at the end, we don't wrap around
// Returns true when we are at <head_>
// Returns the node at <position_> or 0 if we are at the end
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Return our instance of the iterator
// Create an empty list.
// Checks if list is empty.
// Returns earliest time in a non-empty list.
// Remove all remaining items in the list.
// delete the dummy node
// Remove all remaining items in the list.
// Leave rest to destructor
/* ACE_HAS_DUMP */
// Reschedule a periodic timer.  This function must be called with the
// lock held.
// Insert a new handler that expires at time future_time; if interval
// is > 0, the handler will be reinvoked periodically.
// Failure return
/// The shared scheduling functionality between schedule() and reschedule()
// We always want to search backwards from the tail of the list, because
// this minimizes the search in the extreme case when lots of timers are
// scheduled for exactly the same time, and it also assumes that most of
// the timers will be scheduled later than existing timers.
// insert after
// Locate and update the inteval on the timer_id
// The interval will take effect the next time this node is expired.
// Locate and remove the single <ACE_Event_Handler> with a value of
// @a timer_id from the timer queue.
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
// Locate and remove all values of <handler> from the timer queue.
// Note : Technically this can overflow.
// Note: Typically Type is an ACE_Event_Handler*
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
/// Shared subset of the two cancel() methods.
// Reads the first node on the list and returns it.
// Note : is_empty() uses get_first()
// Removes the first node on the list and returns it.
/* ACE_TIMER_LIST_T_C */
/* ACE_HAS_DEFERRED_TIMER_COMMANDS */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Block designated signals.
// Block designated signals.
// Beware of negative times and zero times (which cause problems for
// <ualarm>).
// @@ This code should be clever enough to avoid updating the
// <ualarm> if we haven't actually changed the earliest time.
// Schedule a new timer.
// Block designated signals.
// @@ We still need to implement interval timers...
// If <mask> == 0, block *all* signals when the SIGARLM handler is
// running, else just block those in the mask.
// The following code is necessary to selectively "block" certain
// signals when SIGALRM is running.  Also, we always restart system
// calls that are interrupted by the signals.
// This is the signal handler function for the asynchronous timer
// list.  It gets invoked asynchronously when the SIGALRM signal
// occurs.
// Expire the pending timers.
// @@ We need to figure out how to implement interval
// timers...
// Only schedule a new timer if there is one in the list.
// @@ This code should also become smarter to avoid
// unnecessary calls to ualarm().
/* NOTREACHED */
/* NOTREACHED */
// Assume that we start in active mode.
// Thread cancellation point, if ACE supports it.
//
// Note: This call generates a warning under Solaris because the header
//       file /usr/include/pthread.h redefines the routine argument. This
//       is a bug in the Solaris header files and has nothing to do with
//       ACE.
/* ACE_LACKS_PTHREAD_CANCEL */
// Temporarily suspend ownership of the timer queue mutex in
// order to dispatch deferred execution commands.  These
// commands are to be treated as executing in a context
// "external" to the timer queue adapter, and thus must compete
// separately for this lock.
// Re-acquire ownership of the timer queue mutex in order to
// restore the "internal" timer queue adapter context
/* ACE_HAS_DEFERRED_TIMER_COMMANDS */
// If the queue is empty, sleep until there is a change on it.
// Compute the remaining time, being careful not to sleep
// for "negative" amounts of time.
// The earliest time on the Timer_Queue lies in future;
// convert the tv to an absolute time.
// ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("waiting until %u.%3.3u secs\n"),
// tv.sec(), tv.msec()));
// Expire timers anyway, at worst this is a no-op. Release the lock
// while dispatching; the timer queue has its own lock to protect
// itself.
// Thread cancellation point, if ACE supports it.
/* ACE_LACKS_PTHREAD_CANCEL */
// Make sure to set this flag in case we were deactivated earlier.
// Make sure that we only allow a single thread to be spawned for
// our adapter.  Otherwise, too many weird things can happen.
// Enqueues a command object for execution just before waiting on the next
// timer event. This allows deferred execution of commands that cannot
// be performed in the timer event handler context, such as registering
// or cancelling timers on platforms where the timer queue mutex is not
// recursive.
// Serialize access to the command queue.
// Dispatches all command objects enqueued in the most recent event
// handler context.
// Serialize access to the command queue.
// loop through the enqueued commands
/* ACE_HAS_DEFERRED_TIMER_COMMANDS */
/* ACE_TIMER_QUEUE_ADAPTERS_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_TIMER_QUEUE_ITERATOR_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/*
//@@ REACTOR_SPL_INCLUDE_FORWARD_DECL_ADD_HOOK
/* __ACE_INLINE__ */
// This fudge factor can be overriden for timers that need it, such as on
// Solaris, by defining the ACE_TIMER_SKEW symbol in the appropriate config
// header.
/* ACE_TIMER_SKEW */
// Nothing on the Timer_Queue, so use whatever the caller gave us.
// The earliest item on the Timer_Queue is still in the
// future.  Therefore, use the smaller of (1) caller's wait
// time or (2) the delta time between now and the earliest
// time on the Timer_Queue.
// The earliest item on the Timer_Queue is now in the past.
// Therefore, we've got to "poll" the Reactor, i.e., it must
// just check the descriptors and then dispatch timers, etc.
// Nothing on the Timer_Queue, so use whatever the caller gave us.
// The earliest item on the Timer_Queue is still in the
// future.  Therefore, use the smaller of (1) caller's wait
// time or (2) the delta time between now and the earliest
// time on the Timer_Queue.
// The earliest item on the Timer_Queue is now in the past.
// Therefore, we've got to "poll" the Reactor, i.e., it must
// just check the descriptors and then dispatch timers, etc.
/* ACE_HAS_DUMP */
// Cleanup the free_list on the way out
// Schedule the timer.
// Return on failure.
// Inform upcall functor of successful registration.
// Return result;
// We can't check here is the timer queue is empty, in some
// implementations (like the timer heap) calling is_empty()
// would at that moment access member variables without having
// locked ourself for thread safety
// Run the <handle_timeout> method for all Timers whose values are <=
// <cur_time>.
// Keep looping while there are timers remaining and the earliest
// timer is <= the <cur_time> passed in to the method.
/*
// Compute the duration of the timer's interval
// Compute the span between the current time and when
// the timer would have expired in the past (and
// normalize to microseconds).
// Compute the delta time in the future when the timer
// should fire as if it had advanced incrementally.  The
// modulo arithmetic accomodates the likely case that
// the current time doesn't fall precisely on a timer
// firing interval.
// Compute the absolute time in the future when this
// interval timer should expire.
// Create a scope for the lock ...
// Get the current time
// Look for a node in the timer queue whose timer <= the present
// time.
// We do not need the lock anymore, all these operations take place
// with local variables.
// Preinvoke (handles refcount if needed, etc.)
// Release the token before expiration upcall.
// call the functor
// Postinvoke (undo refcount if needed, etc.)
// We have dispatched a timer
// Get the dispatch info
// Check if this is an interval timer.
// Make sure that we skip past values that have already
// "expired".
// Since this is an interval timer, we need to reschedule
// it.
// Call the factory method to free up the node.
/* ACE_TIMER_QUEUE_T_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
// Design/implementation notes for ACE_Timer_Wheel_T.
//
// Each timer queue entry is represented by a ACE_Timer_Node.
// The timing wheel is divided into a number of "spokes"; there are
// spoke_count_ spokes in the wheel. Each timer is hashed into one of the
// spokes. Entries within each spoke are linked in a double-linked list
// in order of increasing expiration. The first ACE_Timer_Node in each
// spoke is a "dummy node" that marks the end of the list of ACE_Timer_Nodes
// in that spoke.
//
// The timer ID for a scheduled timer is formed by its spoke position in
// the wheel, and the number of timers that have been inserted in that spoke
// since the queue was initialized. N bits of the long timer_id are used
// to determine the spoke, and M bits are used as a counter.
// Each time a Node is inserted into a spoke, it's counter
// is incremented. The count is kept in the timer ID field
// of the dummy root Node. In the event of overflow of the counter, the spoke
// must be searched for each new id to make sure it's not already in use. To
// prevent having to do an exhaustive search each time, we keep extra data
// in the dummy root Node.
/**
// calculated in open_i
/**
// calculated in open_i
// count the bits in n.
// Which is nearest?
/**
// Rather than waste bits in our timer id, we might as well round up
// the spoke count to the next power of two - 1 . (i.e 1,3,7,15,...127,etc.)
// Allow between 8 and 4096 spokes
// 20 is plenty, even on 64 bit platforms.
// Create the root nodes. These will be treated specially
/// Destructor just cleans up its memory
// Free all the nodes starting at the root
// Remove any remaining nodes
// Free all the nodes starting at the root
// Leave rest for destructor
/// Searches for a node by timer_id within one spoke.
/// Searches all spokes for a node matching the specified timer_id
/// Uses the spoke encoded in the timer_id as a starting place.
// Search the spoke where timer_id was originally scheduled
//ACELIB_ERROR((LM_ERROR, "Node not found in original spoke.\n"));
// Search the rest of the spokes
// already searched this one
//ACELIB_ERROR((LM_ERROR, "Node not found.\n"));
/**
/**
/// Uses a simple hash to find which spoke to use based on when the
/// timer is due to expire. Hopefully the 64bit int operations avoid
/// any overflow problems.
/// Generates a unique timer_id for the given spoke. It should be pretty
/// fast until the point where the counter overflows.  At that time you
/// have to do exhaustive searches within the spoke to ensure that a particular
/// timer id is not already in use. Some optimizations are in place so
/// that this hopefully doesn't have to happen often.
// Because -1 is used as a special invalid timer_id.
// This field is used as a counter instead of a timer_id.
// Count has overflowed its range.
// Special case when we overflow on an empty spoke. We can just
// wrap the count around without searching for duplicates. We only
// want to do this when the counter overflows, so that we return
// unique timer_id values as often as possible.
// Overflowed count, and the spoke is not empty. Search for an unused
// id value.
//ACELIB_ERROR((LM_ERROR, "Timer id overflow. We have to search now.\n"));
// Look for an unused id. Yes, every new id on this spoke will result in a
// scan until all the spoke's timers get canceled/expired then the spoke will
// start over like new. So, when an empty spot is found, don't reset the
// root node's timer_id - it stays at max until the spoke clears out and
// starts over.
// We did our best, but the spoke is full.
/**
//ACELIB_ERROR((LM_ERROR, "Scheduling %x spoke:%d id:%d\n", (long) n, spoke, id));
// Failure return
/**
/// The shared scheduling functionality between schedule() and reschedule()
// See if we need to update the earliest time
// If the spoke is empty
// We always want to search backwards from the tail of the list, because
// this minimizes the search in the extreme case when lots of timers are
// scheduled for exactly the same time
// insert after
/**
// The interval will take effect the next time this node is expired.
/**
// Note : Technically this can overflow.
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
/**
// Call the close hooks.
// cancel_type() called once per <type>.
// cancel_timer() called once per <timer>.
/// Shared subset of the two cancel() methods.
/// There are a few places where we have to figure out which timer
/// will expire next. This method makes the assumption that spokes
/// are always sorted, and that timers are always in the correct spoke
/// determined from their expiration time.
/// The last time is always passed in, even though you can often calculate
/// it as get_first()->get_timer_value().
// This is possible because we use a count for is_empty()
// We will have to go around the wheel at most one time.
//ACELIB_ERROR((LM_ERROR, "We had to search the whole wheel.\n"));
/**
/* ACE_HAS_DUMP */
/**
/**
/**
/**
//ACELIB_ERROR((LM_ERROR, "Expiring %x\n", (long) n));
// Get the dispatch info
// Make sure that we skip past values that have already
// "expired".
///////////////////////////////////////////////////////////////////////////
// ACE_Timer_Wheel_Iterator_T
/**
/**
/**
/**
/// Helper class for common functionality of next() and first()
// Find the first non-empty entry.
// empty
/**
/**
/* ACE_TIMER_WHEEL_T_CPP */
/* __ACE_INLINE__ */
/* __ACE_INLINE__ */
/* ACE_TIME_POLICY_T_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
/* ACE_HAS_CPP98_IOSTREAMS */
/* ACE_HAS_CPP11 */
/// Static constant representing `zero-time'.
/// Note: this object requires static construction.
/// Constant for maximum time representable.  Note that this time
/// is not intended for use with select () or other calls that may
/// have *their own* implementation-specific maximum time representations.
/// Its primary use is in time computations such as those used by the
/// dynamic subpriority strategies in the ACE_Dynamic_Message_Queue class.
/// Note: this object requires static construction.
/// Increment microseconds (the only reason this is here is to allow
/// the use of ACE_Atomic_Op with ACE_Time_Value).
// ACE_OS_TRACE ("ACE_Time_Value::operator ++ (int)");
// ACE_OS_TRACE ("ACE_Time_Value::operator ++ (void)");
/// Decrement microseconds (the only reason this is here is / to allow
/// the use of ACE_Atomic_Op with ACE_Time_Value).
// ACE_OS_TRACE ("ACE_Time_Value::operator -- (int)");
// ACE_OS_TRACE ("ACE_Time_Value::operator -- (void)");
/// Static constant to remove time skew between FILETIME and POSIX
/// time.  POSIX and Win32 use different epochs (Jan. 1, 1970 v.s.
/// Jan. 1, 1601).  The following constant defines the difference
/// in 100ns ticks.
///
/// In the beginning (Jan. 1, 1601), there was no time and no computer.
/// And Bill said: "Let there be time," and there was time....
///  Initializes the ACE_Time_Value object from a Win32 FILETIME
// // ACE_OS_TRACE ("ACE_Time_Value::ACE_Time_Value");
// Initializes the ACE_Time_Value object from a Win32 FILETIME
// Don't use a struct initializer, gcc don't like it.
// Convert 100ns units to seconds;
// Convert remainder to microseconds;
/// Returns the value of the object as a Win32 FILETIME.
// ACE_OS_TRACE ("ACE_Time_Value::operator FILETIME");
/* ACE_WIN32 */
// ACE_OS_TRACE ("ACE_Time_Value::normalize");
// tv_sec in qnxnto is unsigned
/* __QNX__  */
// To work around the lack of precision of a long double to contain
// a 64-bits time_t + 6 digits after the decimal point for the usec part,
// we perform the multiplication of the 2 timeval parts separately.
//
// This extra precision step is adding a cost when transfering the
// seconds resulting from the usec multiplication.  This operation
// correspond to the normalization process performed in normalize()
// but we must absolutly do it here because the usec multiplication
// result value could exceed what can be stored in a suseconds_t
// type variable.
//
// Since this is a costly operation, we try to detect as soon as
// possible if we are having a saturation in order to abort the rest
// of the computation.
// shall we saturate the result?
// adding usec resulting from tv_sec mult
// extract seconds component of the usec mult
// keep remaining usec
// add the seconds component of the usec mult with the tv_sec mult prod.
// recheck for saturation
// round up the result to save the last usec
/* ACE_HAS_CPP98_IOSTREAMS */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_TIME_VALUE_T_CPP */
// Defines the member functions for the base class of the ACE_TLI
// abstraction.
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Solaris 2.4 ACE_TLI option handling is broken.  Thus, we must do
// the memory allocation ourselves...  Thanks to John P. Hearn
// (jph@ccrl.nj.nec.com) for the help.
/* ACE_HAS_SVR4_TLI */
/* ACE_HAS_SVR4_TLI */
// Geisler: result must be int
/* Set up options for ACE_TLI */
// ret will get the negotiated option back after attempting to set it.
// Assume this will fit in the requested size.
/* XPG5 vs XPG4 */
/* XPG5 vs XPG4 */
// We only request one option at a time.
/* See <sys/socket.h> for info on this format */
/* ACE_HAS_SET_T_ERRNO */
/* ACE_HAS_XTI, else ACE_HAS_SVR4_TLI */
// ret will get the option requested in req.
/* XPG5 vs XPG4 */
/* XPG5 vs XPG4 */
// Just the header on the request
/* See <sys/socket.h> for details on this format */
/* ACE_HAS_SET_T_ERRNO */
/* ACE_HAS_SVR4_TLI */
/* ACE_HAS_TLI */
// Put the actual definitions of the ACE_TLI_Request and
// ACE_TLI_Request_Queue classes here to hide them from clients...
// Dump the state of an object.
// Declare the dynamic allocation hooks.
/* ACE_HAS_DUMP */
// Add 1 for the dummy.
// Add a node to the free list stack.
// Remove a node from the free list stack.
/* ACE_HAS_DUMP */
// This is hideous...
/* I_PUSH */
// Close down the acceptor and release resources.
// Add one more for the dummy node.
// Initialize the ACE_Queue and the free list.
// Listen for a new connection request and allocate appropriate data
// structures when one arrives.
// Something must have gone wrong, so free up allocated space.
// Locate and remove SEQUENCE_NUMBER from the list of pending
// connections.
// Put the sequence # in the dummy node to simply the search...
// Sequence # was not found, since we're back at the dummy node!
// Reusing the address causes problems with FORE's API. The issue
// may be that t_optmgmt isn't fully supported by FORE. t_errno is
// TBADOPT after the t_optmgmt call so maybe options are configured
// differently for XTI than for TLI (at least for FORE's
// implementation - XTI is supposed to be a superset of TLI).
/* ACE_HAS_FORE_ATM_XTI */
// Not sure why but FORE's t_bind call won't work if t_bind.qlen
// != 1 Adjust the backlog accordingly.
/* ACE_HAS_FORE_ATM_XTI */
// Note that if addr.len == 0 then ACE_TLI selects the port
// number.
// Perform the logic required to handle the arrival of asynchronous
// events while we are trying to accept a new connection request.
/* ACE_WIN32 */
// Got one!
/* ACE_HAS_TLI */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Connect the <new_stream> to the <remote_sap>, waiting up to
// <timeout> amount of time if necessary.  It's amazing how
// complicated this is to do in TLI...
/* perms */,
// Only open a new endpoint if we don't already have a valid handle.
// Bind the local endpoint to a specific addr.
// Reusing the address causes problems with FORE's API. The
// issue may be that t_optmgmt isn't fully supported by
// FORE. t_errno is TBADOPT after the t_optmgmt call so
// maybe options are configured differently for XTI than for
// TLI (at least for FORE's implementation - XTI is supposed
// to be a superset of TLI).
/* ACE_HAS_FORE_ATM_XTI */
// Let TLI select the local endpoint addr.
//callptr->addr.buf = (char *) remote_sap.get_addr ();
// Connect to remote endpoint.
// FORE's XTI/ATM driver has problems with ioctl/fcntl calls so (at least
// for now) always have blocking calls.
/* ACE_HAS_FORE_ATM_XTI */
// Enable non-blocking, if required.
// Do a non-blocking connect.
// Check to see if we simply haven't connected yet on a
// non-blocking handle or whether there's really an error.
// Do a blocking connect to the server.
/* I_PUSH */
// If things have gone wrong, close down and return an error.
// Try to complete a non-blocking connection.
// We've successfully connected!
/* SunOS4 */
/* ACE_HAS_XTI || ACE_HAS_SVR4_TLI */
// Start out with non-blocking disabled on the <new_stream>.
/* ACE_WIN32 */
/* ACE_HAS_TLI */
/* Defines the member functions for the base class of the ACE_TLI_Stream
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Send a release and then await the release from the other side.
// Acknowledge the release from the other side and then send the
// release to the other side.
/* ACE_WIN32 */
/* ACE_HAS_TLI */
/* __ACE_INLINE__ */
// FUZZ: disable check_for_streams_include
/* ACE_TOKEN_DEBUGGING */
// @@ Is there a portable way to do this?
// ACELIB_DEBUG ((LM_DEBUG, "\nowner_ = %d", (long) this->owner_));
/* ACE_HAS_DUMP */
/* ACE_TOKEN_USES_SEMAPHORE */
/* ACE_TOKEN_USES_SEMAPHORE */
/* ACE_TOKEN_USES_SEMAPHORE */
/* ACE_TOKEN_USES_SEMAPHORE */
//
// Remove an entry from the list.  Must be called with locks held.
//
// Didn't find the entry...
// Delete at the head.
// Delete in the middle.
// We need to update the tail of the list if we've deleted the last
// entry.
//
// Add an entry into the list.  Must be called with locks held.
//
// No other threads - just add me
// Insert at the end of the queue.
// Insert at head of queue.
// Insert in the middle of the queue somewhere.
// Determine where our thread should go in the queue of waiters.
//  ACE_TRACE ("ACE_Token::ACE_Token");
/* ACE_TOKEN_DEBUGGING */
// Nobody holds the token.
// Its mine!
// Someone already holds the token.
// Check if it is us.
// Do a quick check for "polling" behavior.
//
// We've got to sleep until we get the token.
//
// Which queue we should end up in...
// Allocate queue entry on stack.  This works since we don't exit
// this method's activation record until we've got the token.
// Execute appropriate <sleep_hook> callback.  (@@ should these
// methods return a success/failure status, and if so, what should
// we do with it?)
// Execute virtual method.
// Sleep until we've got the token (ignore signals).
// Note, this should obey whatever thread-specific interrupt
// policy is currently in place...
/* ACE_TOKEN_DEBUGGING */
// We come here if a timeout occurs or some serious
// ACE_Condition object error.
// Stop the loop.
// Do this always and irrespective of the result of wait().
/* ACE_TOKEN_DEBUGGING */
// If timeout occurred
// This thread was still selected to own the token.
// Wakeup next waiter since this thread timed out.
// Return error.
// Return error.
// If this is a normal wakeup, this thread should be runnable.
// By default this is a no-op.
/* virtual */
// Acquire the token, sleeping until it is obtained or until <timeout>
// expires.
// Try to renew the token.
/* ACE_TOKEN_DEBUGGING */
// ACE_ASSERT (ACE_OS::thr_equal (ACE_Thread::self (), this->owner_));
// Check to see if there are any waiters worth giving up the lock
// for.
// If no writers and either we are a writer or there are no readers.
// Immediate return.
// We've got to sleep until we get the token again.
// Determine which queue should this thread go to.
// if requeue_position == 0 then we want to go next,
// otherwise use the queueing strategy, which might also
// happen to be 0.
// Remember nesting level...
// Reset state for new owner.
// Wakeup waiter.
// Sleep until we've got the token (ignore signals).
// Note, this should obey whatever thread-specific interrupt
// policy is currently in place...
/* ACE_TOKEN_DEBUGGING */
// We come here if a timeout occurs or some serious
// ACE_Condition object error.
// Stop the loop.
// Do this always and irrespective of the result of wait().
/* ACE_TOKEN_DEBUGGING */
// If timeout occurred
// This thread was still selected to own the token.
// Wakeup next waiter since this thread timed out.
// Return error.
// Return error.
// If this is a normal wakeup, this thread should be runnable.
// Reinstate nesting level.
// Release the current holder of the token (which had
// better be the caller's thread!).
/* ACE_TOKEN_DEBUGGING */
// Nested release...
//
// Regular release...
//
// Wakeup waiter.
// Reset state for new owner.
// Any waiters...
// No more waiters...
// Wakeup next waiter.
// Writer threads get priority to run first.
// Wake up waiter and make it runable.
/* ACE_HAS_THREADS */
// Make it possible to replace delimiters on-the-fly, e.g., parse
// string until certain token count and then copy rest of the
// original string.
// Check if the previous pass was the last one in the buffer.
// Check if a buffer has been passed
// Skip all leading delimiters.
// Check for end of string.
// If we hit EOS at the start, return 0.
// When we reach this point, buffer_[index_] is a non-delimiter and
// not EOS - the start of our next_token.
// A preserved region is it's own token.
// Skip start preserve designator.
// Zap the stop preserve designator.
// Increment to the next token.
// Step through finding the next delimiter or EOS.
// Advance pointer.
// Check for delimiter.
// Replace the delimiter.
// Move the pointer up and return.
// A preserve designator is NESTED inside this token
// We can't strip such preserve designators, just skip
// over them so that delimiters nested within arn't seen.
// Skip starting preserve_designator
// Skip enclosed character
// Check for end of string.
// *************************************************************
/* ACE_TOKENIZER_T_CPP */
/* __ACE_INLINE__ */
// Check if the new_proxy is already in the list.
// One already exists, so fail.
// Clone the new token.
// Get the token from the collection.
// Save/restore errno.
// Get the token from the collection.
// did we find it?
// perform the operation
// Get the token from the collection.
// did we find it?
// perform the operation
// We will fail if _any_ token is not free.
// Get the token from the collection.
// Did we find it?
// perform the operation
// get the token from the collection
// did we find it?
// perform the operation
// The ext_id_'s delete themselves when the array of
// COLLECTION::ENTRYs goes away.
// This method doesn't mean anything for a collection.
// This method doesn't mean anything for a collection.
/* ACE_HAS_DUMP */
/* ACE_HAS_TOKENS_LIBRARY */
// Perform the Double-Check pattern...
// Register for destruction with ACE_Object_Manager.
// Reach into the proxy to find the token type.
// ACE_Tokens::RWLOCK.
// ACE_RW_Token::WRITER.
// Reach into the proxy to find the token type.
// ACE_Tokens::RWLOCK.
/* ACE_HAS_DUMP */
// We did not find one in the collection.
// We did not find one in the collection.
// We did not find one in the collection.
// We did not find one in the collection.
// **************************************************
// **************************************************
// **************************************************
/* ACE_HAS_DUMP */
// **************************************************
// **************************************************
// **************************************************
/* ACE_HAS_DUMP */
/* ACE_HAS_TOKENS_LIBRARY */
/* __ACE_INLINE__ */
// singleton token manager
// @ should I be doing an unbind here?
// The ext_id_'s delete themselves when the array of
// COLLECTION::ENTRYs goes away.
// This first check is to avoid acquiring the mutex in the common
// case.  Double-Check pattern rules.
/* ACE_MT_SAFE */
// Register for destruction with ACE_Object_Manager.
// Hmm.  I think this makes sense.  We perform our own locking here
// (see safe_acquire.)  We have to make sure that only one thread
// uses the collection at a time.
// We did not find one in the collection.
// Make one.
// Put it in the collection.
// We may be returning proxy->token_ == 0 if new failed, caller must
// check.
// 0. check_deadlock (TOKEN)
// 1. if TOKEN->visited (), return 0.
// 2. mark TOKEN visited.
// 3. get ALL_OWNERS
// 4. if CLIENT in ALL_OWNERS, return *DEADLOCK*.
// 5. for each OWNER in ALL_OWNERS,
// 6.    if OWNER is not waiting for a NEW_TOKEN, continue.
// 7.    else, if check_deadlock (NEW_TOKEN) == 1, return *DEADLOCK*
// 8. return 0.
// Start the recursive deadlock detection algorithm.
// Whether or not we detect deadlock, we have to unmark all tokens
// for the next time.
// Error.
// The caller is an owner, so we have a deadlock situation.
// Recurse on each owner.
// If the owner is waiting on another token, recurse.
// else, check the next owner.
// We've checked all the owners and found no deadlock.
// nothing was found, return NULL.
// Notify the token manager that a token is has been released.  If
// as a result, there is no owner of the token, the token is
// deleted.
// again, let's perform our own locking here.
// No one has the token, so we can delete it and remove it from
// our collection.  First, let's get it from the collection.
// we did not find one in the collection
// @@ bad
// we found it
// sanity pointer comparison.  The token referenced by the
// proxy better be the one we found in the list.
// or delete temp
// we set their token to zero.  if the calling proxy is
// still going to be used, it had better check it's token
// value before calling a method on it!
// else
// someone is still interested in the token, so keep it around.
/* ACE_HAS_DUMP */
/* ACE_HAS_TOKENS_LIBRARY */
/* __ACE_INLINE__ */
// Default "do nothing" constructor.
// Create a ACE_Token_Request message.
// to avoid Purify UMR
// to avoid Purify UMR
// to avoid Purify UMR
// to avoid Purify UMR
// Encode the transfer buffer into network byte order
// so that it can be sent to the server.
// Decode the transfer buffer into host byte byte order
// so that it can be used by the server.
// Decode the variable-sized portion.
// Check to make sure this->tokenName_ isn't too long!
// Skip this->tokenName_ + '\0' + ':'.
// Fixed size header
// token_name_ plus '\0'
// ':'
// client_id_ plus '\0'
// Make sure the message was correctly received and framed.
// Print out the current values of the ACE_Token_Request.
// == ACE_Tokens::RWLOCK
// == WRITER
/* ACE_HAS_DUMP */
// ************************************************************
// ************************************************************
// ************************************************************
// Create a ACE_Token_Reply message.
// Type of reply.
// Encode the transfer buffer into network byte order
// so that it can be sent to the client.
// Decode the transfer buffer into host byte order
// so that it can be used by the client.
// Print out current values of the ACE_Token_Reply object.
/* ACE_HAS_DUMP */
/* ACE_HAS_TOKENS_LIBRARY */
/* __ACE_INLINE__ */
// The order of these events is very subtle, modify with care.
// Try to grab the lock.  If someone if already there, don't wake
// them up, just queue up in the thread pool.
// Check for timeouts and errors.
// We got the token and so let us mark ourselves as owner
// Try to grab the lock.  If someone if already there, don't wake
// them up, just queue up in the thread pool.
// Check for timeouts and errors.
// We got the token and so let us mark ourselves as owner
// Stash the current time -- the destructor of this object will
// automatically compute how much time elapsed since this method was
// called.
//
// The order of these events is very subtle, modify with care.
//
// Instantiate the token guard which will try grabbing the token for
// this thread.
// If the guard is NOT the owner just return the retval
// After getting the lock just just for deactivation..
// Update the countdown to reflect time waiting for the token.
// We use this count to detect potential infinite loops as described
// in bug 2540.
// Note: We are passing the <event_count> around, to have record of
// how many events still need processing. May be this could be
// useful in future.
// @Ciju
// signal handling isn't in a production state yet.
// Commenting it out for now.
// Dispatch signals
// Looks like we dont do any upcalls in dispatch signals. If at
// a later point of time, we decide to handle signals we have to
// release the lock before we make any upcalls.. What is here
// now is not the right thing...
//
// @@ We need to do better..
// #if 0
// If there are no signals and if we had received a proper
// event_count then first look at dispatching timeouts. We need to
// handle timers early since they may have higher latency
// constraints than I/O handlers.  Ideally, the order of dispatching
// should be a strategy...
// NOTE: The event count does not have the number of timers that
// needs dispatching. But we are still passing this along. We dont
// need to do that. In the future we *may* have the timers also
// returned through the <event_count>. Just passing that along for
// that day.
// Else just go ahead fall through for further handling.
// Next dispatch the notification handlers (if there are any to
// dispatch).  These are required to handle multiple-threads
// that are trying to update the <Reactor>.
// Else just fall through for further handling
// Handle socket events
// @Ciju
// signal handling isn't in a production state yet.
// Commenting it out for now.
/*event_count*/,
/*guard*/)
/*
// First check for interrupts.
// Bail out -- we got here since <select> was interrupted.
// This piece of code comes from the old TP_Reactor. We did not
// handle signals at all then. If we happen to handle signals
// in the TP_Reactor, we should then start worryiung about this
// - Bala 21-Aug- 01
// Not sure if this should be done in the TP_Reactor
// case... leave it out for now.   -Steve Huston 22-Aug-00
// If any HANDLES in the <ready_set_> are activated as a
// result of signals they should be dispatched since
// they may be time critical...
// active_handle_count = 0;
// Record the fact that the Reactor has dispatched a
// handle_signal() method.  We need this to return the
// appropriate count.
// #if 0
/*event_count*/,
/*event_count*/,
// Get the handle on which notify calls could have occurred
// The notify was not in the list returned by
// wait_for_multiple_events ().
// Now just do a read on the pipe..
// Clear the handle of the read_mask of our <ready_set_>
// Keep reading notifies till we empty it or till we have a
// dispatchable buffer
// Just figure out whether we can read any buffer that has
// dispatchable info. If not we have just been unblocked by
// another thread trying to update the reactor. If we get any
// buffer that needs dispatching we will dispatch that after
// releasing the lock
// Release the token before dispatching notifies...
// Dispatch the upcall for the notify
// We had a successful dispatch.
// break out of the while loop
// If we did some work, then we just return 1 which will allow us
// to get out of here. If we return 0, then we will be asked to do
// some work ie. dispacth socket events
// We got the lock, lets handle some I/O events.
// If there is any event handler that is ready to be dispatched, the
// dispatch information is recorded in dispatch_info.
// Check for removed handlers.
// Suspend the handler so that other threads don't start dispatching
// it, if we can't suspend then return directly
//
// NOTE: This check was performed in older versions of the
// TP_Reactor. Looks like it is a waste..
// Call add_reference() if needed.
// Release the lock.  Others threads can start waiting.
// If there was an event handler ready, dispatch it.
// Decrement the event left
// Dispatched an event
// If the reactor handler state has changed, clear any remembered
// ready bits and re-scan from the master wait_set.
// This is a hack... somewhere, under certain conditions (which
// I don't understand...) the mask will have all of its bits clear,
// yet have a size_ > 0. This is an attempt to remedy the affect,
// without knowing why it happens.
// Check for dispatch in write, except, read. Only catch one, but if
// one is caught, be sure to clear the handle from each mask in case
// there is more than one mask set for it. This would cause problems
// if the handler is suspended for dispatching, but its set bit in
// another part of ready_set_ kept it from being dispatched.
// @@todo: We can do quite a bit of code reduction here. Let me get
// it to work before I do this.
// Remember this info
// Remember this info
// Remember this info
// Dispatches a single event handler
// Check for removed handlers.
// Upcall. If the handler returns positive value (requesting a
// reactor callback) don't set the ready-bit because it will be
// ignored if the reactor state has changed. Just call back
// as many times as the handler requests it. Other threads are off
// handling other things.
// Post process socket event
// First check if we really have to post process something, if not, then
// we don't acquire the token which saves us a lot of time.
// Get the reactor token and with this token acquired remove first the
// handler and resume it at the same time. This must be atomic, see also
// bugzilla 2395. When this is not atomic it can be that we resume the
// handle after it is reused by the OS.
// If the guard is NOT the owner just return the retval
// A different event handler may have been registered during the
// upcall if the handle was closed and then reopened, for
// example.  Make sure we're removing and/or resuming the event
// handler used during the upcall.
// Only remove or resume the event handler used during the
// upcall.
// Resume handler if required.
// Call remove_reference() if needed.
// Call the notify handler to get a handle on which we would have a
// notify waiting
// Check whether the rd_mask has been set on that handle. If so
// return the handle.
// None found..
// Turn off tracing for the duration of this file.
/* ACE_NTRACE */
/* ACE_HAS_ALLOC_HOOKS */
// = Static initialization.
// Keeps track of how far to indent per trace call.
// Is tracing enabled?
/* ACE_HAS_DUMP */
// Determine whether or not tracing is enabled
// Enable the tracing facility.
// Disable the tracing facility.
// Change the nesting indentation level.
// Get the nesting indentation level.
// Perform the first part of the trace, which prints out the string N,
// the LINE, and the ACE_FILE as the function is entered.
/* ACE_NLOGGING */
// If ACE has not yet been initialized, don't try to trace... there's
// too much stuff not yet initialized.
// Perform the second part of the trace, which prints out the NAME as
// the function is exited.
// If ACE has not yet been initialized, don't try to trace... there's
// too much stuff not yet initialized.
/**
/* ACE_HAS_ALLOC_HOOKS */
// call cleanup routine for ts_obj_
// Perform cleanup on the real TS object.
// Delete the adapter object.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_ALLOC_HOOKS */
/* ACE_HAS_THR_C_DEST */
/* ACE_HAS_THR_C_DEST */
/* defined (ACE_HAS_THREADS) && (defined (ACE_HAS_THREAD_SPECIFIC_STORAGE) || defined (ACE_HAS_TSS_EMULATION)) */
// A bug in LynxOS-178 causes pthread_setspecific (called from ts_value(0)
// above) to call the cleanup function, so we need to avoid calling it here.
/* ACE_HAS_THR_C_DEST */
// defined (ACE_HAS_THREADS) && (defined (ACE_HAS_THREAD_SPECIFIC_STORAGE) || defined (ACE_HAS_TSS_EMULATION))
// We own it, we need to delete it.
// defined (ACE_HAS_THREADS) && (defined (ACE_HAS_THREAD_SPECIFIC_STORAGE) || defined (ACE_HAS_TSS_EMULATION))
/* defined (ACE_HAS_THREADS) && (defined (ACE_HAS_THREAD_SPECIFIC_STORAGE) || defined (ACE_HAS_TSS_EMULATION)) */
/* ACE_HAS_DUMP */
// Cast this to the concrete TYPE * so the destructor gets called.
// Ensure that we are serialized!
// Use the Double-Check pattern to make sure we only create the key
// once!
/* ACE_HAS_THR_C_DEST */
// Major problems, this should *never* happen!
// This *must* come last to avoid race conditions!
// If caller has passed us a non-NULL TYPE *, then we'll just use
// this to initialize the thread-specific value.  Thus, subsequent
// calls to operator->() will return this value.  This is useful
// since it enables us to assign objects to thread-specific data
// that have arbitrarily complex constructors!
// Save/restore errno.
// What should we do if this call fails?!
/* ACE_HAS_WINCE */
// Encapsulate a ts_obj and it's destructor in an
// ACE_TSS_Adapter.
// Put the adapter in thread specific storage
/* ACE_HAS_THR_C_DEST */
// Create and initialize thread-specific ts_obj.
// Seriously wrong..
// If tss_adapter is not 0 but its ts_obj_ is 0 then we still need to create
// a proper ts_obj. That's the intent of this member function.
// Check to see if this is the first time in for this thread.
// Check to see if this is the first time in for this thread.
/* ACE_HAS_THR_C_DEST */
// Allocate memory off the heap and store it in a pointer in
// thread-specific storage (on the stack...).
// Encapsulate a ts_obj and it's destructor in an
// ACE_TSS_Adapter.
// Put the adapter in thread specific storage
// Major problems, this should *never* happen!
// Store the dynamically allocated pointer in thread-specific
// storage.
// Major problems, this should *never* happen!
/* ACE_HAS_THR_C_DEST */
// Delete the adapter that didn't actually have a real ts_obj.
// Return the underlying ts object.
/* ACE_HAS_THR_C_DEST */
// Get the thread-specific object for the key associated with this
// object.  Returns 0 if the ts_obj has never been initialized,
// otherwise returns a pointer to the ts_obj.
// Return 0 if we've never been initialized.
// Extract the real TS object.
/* ACE_HAS_THR_C_DEST */
// Note, we shouldn't hold the keylock at this point because
// <ts_init> does it for us and we'll end up with deadlock
// otherwise...
// Create and initialize thread-specific ts_obj.
// Don't delete tss_adapter yet. It can be double-deleted
// in case setspecific below fails.
// Now it's fine to delete the old tss_adapter.
/* ACE_HAS_THR_C_DEST */
/* ACE_HAS_DUMP */
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Make sure that this pointer is NULL when we shut down...
// Destructor releases lock.
// Destructor releases lock.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
/* ACE_HAS_DUMP */
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
// Need this temp to keep G++ from complaining.
// Need this temp to keep G++ from complaining.
/* ACE_HAS_THR_C_DEST */
/* ACE_HAS_DUMP */
/* defined (ACE_HAS_THREADS) && (defined (ACE_HAS_THREAD_SPECIFIC_STORAGE) || defined (ACE_HAS_TSS_EMULATION)) */
/* ACE_TSS_T_CPP */
/* ACE_WIN32 */
// Interface for reading/writing serial device parameters
/* ACE_HAS_TERMIOS */
/* B0 */
/* B50 */
/* B75 */
/* B110 */
/* B134 */
/* B150 */
/* B200 */
/* B300 */
/* B600 */
/* B1200 */
/* B1800 */
/* B2400 */
/* B4800 */
/* B9600 */
/* B19200 */
/* B38400 */
/* B56000 */
/* B57600 */
/* B76800 */
/* B115200 */
/* B128000 */
/* B153600 */
/* B230400 */
/* B307200 */
/* B256000 */
/* B460800 */
/* B500000 */
/* B576000 */
/* B921600 */
/* B1000000 */
/* B1152000 */
/* B1500000 */
/* B2000000 */
/* B2500000 */
/* B3000000 */
/* B3500000 */
/* B4000000 */
// Can you really have different input and output baud rates?!
/* CBAUDEX */
/* ACE_HAS_TERMIOS */
// Enable RTS/CTS protocol
// Enable RTS/CTS protocol
/* NEW_RTSCTS || CRTSCTS */
// Enable/disable receiver
/* CREAD */
// Cause DTR to drop after port close.
/* HUPCL */
// If device is not a modem set to local device.
/* CLOCAL */
// If device is not a modem set to ignore break points
/* IGNBRK */
// Enable/disable software flow control on input
/* IXOFF */
// Enable/disable software flow control on output
/* IXON */
// Enable noncanonical input processing mode
/* ICANON */
// Disable echoing of input characters
/* ECHO */
// Disable echoing erase chareacter as BS-SP-BS
/* ECHOE */
// Disable SIGINTR, SIGSUSP, SIGDSUSP and SIGQUIT signals
/* ISIG */
// Disable post-processing of output data
/* OPOST */
// Settings for infinite timeout.
// In case of infinite timeout [VMIN] must be at least 1.
/* definded (TIOCMGET) */
/* ACE_HAS_TERMIOS */
// Not yet implemented.
// Wrong cmd.
// Enable/disable RTS protocol.
// Enable/disable CTS protocol.
// Enable/disable DSR protocol.
// Disable/enable DTR protocol
// Enable/disable software flow control on input
// Enable/disable software flow control on output
// Always set limits unless set to negative to use default.
// Settings for infinite timeout.
// Return immediately if no data in the input buffer.
// Wait for specified timeout for char to arrive before returning.
// Enable/disable RTS protocol.
// Enable/disable CTS protocol.
// Enable/disable DSR protocol.
// Disable/enable DTR protocol
// Attention: DTR_CONTROL_HANDSHAKE is not supported.
// Enable/disable software flow control on input
// Enable/disable software flow control on output
// Wrong cmd.
// arg switch
/* ACE_HAS_TERMIOS || ACE_HAS_TERMIO */
/* ACE_NEEDS_DEV_IO_CONVERSION */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_TYPED_SV_MESSAGE_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* ACE_TYPED_SV_MESSAGE_QUEUE_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue (void)");
// Make the list circular by pointing it back to itself.
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue");
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::operator=");
// ACE_TRACE ("ACE_Unbounded_Queue<T>::begin");
// ACE_TRACE ("ACE_Unbounded_Queue<T>::end");
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::dump");
/* ! ACE_NLOGGING */
/* ACE_HAS_DUMP */
// @@ What's the right thing to do here?
// Keep looking until we've hit the dummy node.
// @@ Doesnt make sense to have this check since
// this will always be true.
//   ACE_ASSERT (this->cur_size_ >= 0);
// Reset the list to be a circular list with just a dummy node.
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::~ACE_Unbounded_Queue (void)");
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::enqueue_head");
// Create a new node that points to the original head.
// Link this pointer into the front of the list.  Note that the
// "real" head of the queue is <head_->next_>, whereas <head_> is
// just a pointer to the dummy node.
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::enqueue_tail");
// Insert <item> into the old dummy node location.  Note that this
// isn't actually the "head" item in the queue, it's a dummy node at
// the "tail" of the queue...
// Create a new dummy node.
// Link this dummy pointer into the list.
// Point the head to the new dummy node.
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::dequeue_head");
// Check for empty queue.
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::get");
//   ACE_TRACE ("ACE_Unbounded_Queue<T>::set");
// We're in range, so everything's cool.
// We need to expand the list.
// A common case will be increasing the set size by 1.
// Therefore, we'll optimize for this case.
// Try to expand the size of the set by 1.
// We need to expand the list by multiple (dummy) items.
// This head points to the existing dummy node, which is
// about to be overwritten when we add the new dummy
// node.
// Try to expand the size of the set by 1, but don't
// store anything in the dummy node (yet).
// ****************************************************************
// ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::ACE_Unbounded_Queue_Const_Iterator");
// ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::advance");
// ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::first");
// ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::next");
// ****************************************************************
// ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::ACE_Unbounded_Queue_Iterator");
// ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::advance");
// ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::first");
// ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::next");
/* ACE_UNBOUNDED_QUEUE_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
/* ACE_UNBOUNDED_SET_CPP */
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::size");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::insert_tail");
// Insert <item> into the old dummy node location.
// Create a new dummy node.
// Link this pointer into the list.
// Point the head to the new dummy node.
/* ! ACE_NLOGGING */
/* ACE_HAS_DUMP */
// Keep looking until we've hit the dummy node.
// Reset the list to be a circular list with just a dummy node.
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::~ACE_Unbounded_Set_Ex");
// Delete the dummy node.
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::ACE_Unbounded_Set_Ex");
// Make the list circular by pointing it back to itself.
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::ACE_Unbounded_Set_Ex");
// Make the list circular by pointing it back to itself.
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::find");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::insert");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::remove");
// Insert the item to be found into the dummy node.
// reset the dummy node. This ensures reference counted items are
// completely released. Without this, a reference can linger as
// the dummy long after it was removed from the list.
// Item was not found.
// Skip over the node that we're deleting.
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::begin");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::end");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::begin");
// ACE_TRACE ("ACE_Unbounded_Set_Ex<T, C>::end");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::ACE_Unbounded_Set_Ex_Iterator");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::advance");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::first");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::next");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::operator++ (int)");
// postfix operator
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::operator++ (void)");
// prefix operator
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::operator*");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::operator==");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Iterator<T, C>::operator!=");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::dump");
/* ACE_HAS_DUMP */
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::ACE_Unbounded_Set_Ex_Const_Iterator");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::advance");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::first");
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::next");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::operator++ (int)");
// postfix operator
// ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::operator++ (void)");
// prefix operator
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::operator*");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::operator==");
//ACE_TRACE ("ACE_Unbounded_Set_Ex_Const_Iterator<T, C>::operator!=");
/* ACE_UNBOUNDED_SET_EX_CPP */
/* ACE_HAS_ALLOC_HOOKS */
/* __ACE_INLINE__ */
// Set a pointer to the address.
// Return a pointer to the underlying address.
// Transform the string into the current addressing format.
// Transform the current address into string format.
/* ACE_HAS_DUMP */
// Do nothing constructor.
// Copy constructor.
// Create a ACE_Addr from a UNIX pathname.
/* ACE_LACKS_UNIX_DOMAIN_SOCKETS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* Do nothing routine for constructor. */
// General purpose routine for performing server ACE_UPIPE.
// General purpose routine for accepting new connections.
// Transfer address ownership.
// Now that we got the handle, we'll read the address of the
// connector-side ACE_UPIPE_Stream out of the pipe and link that
// ACE_UPIPE_Stream to our ACE_UPIPE_Stream.
// Send a message over the new streampipe to confirm acceptance.
// Close down the new_stream at this point in order to conserve
// handles.  Note that we don't need the SPIPE connection
// anymore since we're now linked via the <Message_Queue>.
/* ACE_HAS_THREADS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
/* local_sap */,
/* reuse_addr */,
// We're connected!
// class copy.
// Now send the address of our ACE_UPIPE_Stream over this pipe
// to our corresponding ACE_UPIPE_Acceptor, so he may link the
// two streams.
// Wait for confirmation of stream linking.
// Our part is done, wait for server to confirm connection.
// Do *not* coalesce the following two checks for result == -1.
// They perform different checks and cannot be merged.
// Close down the new_stream at this point in order to
// conserve handles.  Note that we don't need the SPIPE
// connection anymore since we're linked via the Message_Queue
// now.
/* ACE_HAS_THREADS */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Since the UPIPE should have been closed earlier we won't bother
// checking to see if closing it now fails.
// Close down the ACE_stream.
// Send a buffer.
// Receive a buffer.
// Index in buffer.
// We have remaining data in our last read Message_Buffer.
// The remaining data is not enough.
// mb_last_ now 0
// The remaining data is at least enough.  If there's
// more, we'll get it the next time through.
// Advance rd_ptr.
// Now the Message_Buffer is empty.
// We have to get a new Message_Buffer from our stream.
// Return the number of bytes read before we timed out.
/* ACE_HAS_THREADS */
// ======================================================================
//
// The actual conversion methods are covered by the copyright information
// below.  It is not the actual code provided by Unicode, Inc. but is an
// ACE-ified and only slightly modified version.
// Chad Elliott 4/28/2005
//
// Copyright 2001-2004 Unicode, Inc.
//
// Limitations on Rights to Redistribute This Code
//
// Unicode, Inc. hereby grants the right to freely use the information
// supplied in this file in the creation of products supporting the
// Unicode Standard, and to make copies of this file in any form
// for internal or external distribution as long as this notice
// remains attached.
//
// ======================================================================
/* __ACE_INLINE__ */
// Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
// into the first byte, depending on how many bytes follow.  There are
// as many entries in this table as there are UTF-8 sequence types.
// (I.e., one byte sequence, two byte... etc.). Remember that sequencs
// for *legal* UTF-8 will be 4 or fewer bytes total.
// Index into the table below with the first byte of a UTF-8 sequence to
// get the number of trailing bytes that are supposed to follow it.
// Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
// left as-is for anyone who may want to do such conversion, which was
// allowed in earlier algorithms.
// Magic values subtracted from a buffer value during UTF8 conversion.
// This table contains as many values as there might be trailing bytes
// in a UTF-8 sequence.
// If we have a surrogate pair, convert to ACE_UINT32 first.
// If the 16 bits following the high surrogate are in the
// sourceStart buffer...
// If it's a low surrogate, convert to ACE_UINT32.
// it's an unpaired high surrogate
// We don't have the 16 bits following the high surrogate.
// UTF-16 surrogate values are illegal in UTF-32
// Figure out how many bytes the result will require
// NOTE: Everything falls through for efficiency purposes.
// Do this check whether lenient or strict
// The cases all fall through. See "Note A" below.
// remember, illegal UTF-8
// remember, illegal UTF-8
// Target is a character <= 0xFFFF
// UTF-16 surrogate values are illegal in UTF-32
// targetStart is a character in range 0xFFFF - 0x10FFFF.
/* ACE_USES_WCHAR */
// ======================================================================
//
// The actual conversion methods are covered by the copyright information
// below.  It is not the actual code provided by Unicode, Inc. but is an
// ACE-ified and only slightly modified version.
//
// Chad Elliott 4/28/2005
//
// Copyright 2001-2004 Unicode, Inc.
//
// Limitations on Rights to Redistribute This Code
//
// Unicode, Inc. hereby grants the right to freely use the information
// supplied in this file in the creation of products supporting the
// Unicode Standard, and to make copies of this file in any form
// for internal or external distribution as long as this notice
// remains attached.
//
// ======================================================================
// UTF-16 surrogate values are illegal in UTF-32
// Figure out how many bytes the result will require. Turn any
// illegally large ACE_UINT32 things (> Plane 17) into replacement
// chars.
// NOTE: everything falls through.
// Do this check whether lenient or strict
// The cases all fall through. See "Note A" below.
// UTF-16 surrogate values are illegal in UTF-32, and anything
// over Plane 17 (> 0x10FFFF) is illegal.
/* ACE_USES_WCHAR */
// Choose a converter for the ASCII or UTF-8 string to a wide character
// string which we will use in from_utf8.  We have to make an
// assumption here about the encoding based on the size of ACE_TCHAR.
/*strict*/)
// All characters are "valid" ASCII
/* ACE_USES_WCHAR */
/* __ACE_INLINE__ */
// NIL version of the UUID
/* ACE_LACKS_SSCANF */
// Reset the string version of the UUID a string version
// exist, and the UUID is not equal to the old UUID.
// Copy the contents of the UUID.
/// @todo We should create an UUID_Ex class for UUIDs that
///       contain the thread id and process id.
// Compute the string representation only once.
// Get a buffer exactly the correct size. Use the nil UUID as a
// gauge.  Don't forget the trailing nul.
/* ACE_HAS_ALLOC_HOOKS */
// Let the auto array pointer manage the buffer.
//for '-'
/* ACE_HAS_ALLOC_HOOKS */
// Let the auto array pointer manage the buffer.
// Save the string.
/// Special case for the nil UUID.
// This might seem quite strange this being in ACE, but it
// seems to be a bit difficult to write a facade for ::sscanf
// because some compilers dont support vsscanf, including
// MSVC. It appears that most platforms support sscanf though
// so we need to use it directly.
/* ACE_HAS_TR24731_2005_CRT */
/* ACE_HAS_TR24731_2005_CRT */
// Support varient 10- only
/// Support versions 1, 3, and 4 only
// ACE_LACKS_SSCANF
// Construct a Version 1 UUID with the information in the arguements.
/// Obtain a new timestamp. If UUID's are being generated too quickly
/// the clock sequence will be incremented
// Account for the clock being set back. Increment the clock /
// sequence.
// If the system time ticked since the last UUID was
// generated. Set / the clock sequence back.
// Account for the clock being set back. Increment the clock /
// sequence.
// If the system time ticked since the last UUID was
// generated. Set / the clock sequence back.
/**
/// Get the time of day, convert to 100ns ticks then add the offset.
/* ACE_LACKS_PRAGMA_ONCE */
/* __ACE_INLINE__ */
// Compare this vector with <s> for equality.
// ****************************************************************
// ACE_TRACE ("ACE_Vector_Iterator<T>::next");
/* ACE_VECTOR_T_CPP */
/* __ACE_INLINE__ */
// Dynamic allocation
// Initialization
// Free up dynamically allocated space
// Find the old reactor masks.  This automatically does the work of
// the GET_MASK operation.
// For the CLR_MASK operation, clear only the specific masks.
// If the operation is a set, first reset any existing masks
/* FALLTHRU */
// For the ADD_MASK and the SET_MASK operation, add only the
// specific masks.
// The work for this operation is done in all cases at the
// beginning of the function.
// Remember this value; only if it changes do we need to wakeup
// the other threads
// Go through all the handles looking for <handle>.  Even if we find
// it, we continue through the rest of the list since <handle> could
// appear multiple times. All handles are checked.
// First check the current entries
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that it is not already marked for deleted
// Then check the suspended entries
// Since the handle can either be the event or the I/O handle, we
// have to check both
// Make sure that it is not already marked for deleted
// Then check the to_be_added entries
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that it is not already marked for deleted
// Only if the number of handlers to be deleted changes do we need
// to wakeup the other threads
// I/O entries
// See if there are other events that the <Event_Handler> is
// interested in
// Disassociate/Reassociate the event from/with the I/O handle.
// This will depend on the value of remaining set of network
// events that the <event_handler> is interested in. I don't
// think we can do anything about errors here, so I will not
// check this.
// Normal event entries.
// Preserve DONT_CALL
// Make sure that the <to_be_removed_masks> is the NULL_MASK
// If this event was marked for suspension, undo the suspension flag
// and reduce the to be suspended count.
// Undo suspension
// Decrement the handle count
// If there are no more events that the <Event_Handler> is
// interested in, or this is a non-I/O entry, schedule the
// <Event_Handler> for removal
// Mark to be deleted
// Remember the mask
// Increment the handle count
// Since it is not a complete removal, we'll call handle_close
// for all the masks that were removed.  This does not change
// the internal state of the reactor.
//
// Note: this condition only applies to I/O entries
// I/O entries
// See if there are other events that the <Event_Handler> is
// interested in
// Disassociate/Reassociate the event from/with the I/O handle.
// This will depend on the value of remaining set of network
// events that the <event_handler> is interested in. I don't
// think we can do anything about errors here, so I will not
// check this.
// Normal event entries.
// Preserve DONT_CALL
// Make sure that the <to_be_removed_masks> is the NULL_MASK
// If this event was marked for resumption, undo the resumption flag
// and reduce the to be resumed count.
// Undo resumption
// Decrement the handle count
// If there are no more events that the <Event_Handler> is
// interested in, or this is a non-I/O entry, schedule the
// <Event_Handler> for removal
// Mark to be deleted
// Remember the mask
// Increment the handle count
// Since it is not a complete removal, we'll call handle_close for
// all the masks that were removed.  This does not change the
// internal state of the reactor.
//
// Note: this condition only applies to I/O entries
// I/O entries
// See if there are other events that the <Event_Handler> is
// interested in
// Disassociate/Reassociate the event from/with the I/O handle.
// This will depend on the value of remaining set of network
// events that the <event_handler> is interested in. I don't
// think we can do anything about errors here, so I will not
// check this.
// Normal event entries.
// Preserve DONT_CALL
// Make sure that the <to_be_removed_masks> is the NULL_MASK
// If this event was marked for suspension, undo the suspension flag
// and reduce the to be suspended count.
// Undo suspension
// Decrement the handle count
// If there are no more events that the <Event_Handler> is
// interested in, or this is a non-I/O entry, schedule the
// <Event_Handler> for removal
// Mark to be deleted
// Remember the mask
// Increment the handle count
// Since it is not a complete removal, we'll call handle_close
// for all the masks that were removed.  This does not change
// the internal state of the reactor.
//
// Note: this condition only applies to I/O entries
// Go through all the handles looking for <handle>.  Even if we find
// it, we continue through the rest of the list since <handle> could
// appear multiple times. All handles are checked.
// Check the current entries first.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that it is not already marked for suspension
// Mark to be suspended
// Increment the handle count
// Changes will be required
// Then check the suspended entries.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that the resumption is not already undone
// Undo resumption
// Decrement the handle count
// Changes will be required
// Then check the to_be_added entries.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that it is not already marked for suspension
// Mark to be suspended
// Increment the handle count
// Changes will be required
// Go through all the handles looking for <handle>.  Even if we find
// it, we continue through the rest of the list since <handle> could
// appear multiple times. All handles are checked.
// Check the current entries first.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that the suspension is not already undone
// Undo suspension
// Decrement the handle count
// Changes will be required
// Then check the suspended entries.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that it is not already marked for resumption
// Mark to be resumed
// Increment the handle count
// Changes will be required
// Then check the to_be_added entries.
// Since the handle can either be the event or the I/O handle,
// we have to check both
// Make sure that the suspension is not already undone
// Undo suspension
// Decrement the handle count
// Changes will be required
// Remove all the current handlers
// Remove all the suspended handlers
// Remove all the to_be_added handlers
// The guard is released here
// Wake up all threads in WaitForMultipleObjects so that they can
// reconsult the handle set
// Make sure that the <handle> is valid
// Make sure that there's room in the table and that total pending
// additions should not exceed what the <to_be_added_info_> array
// can hold.
// Cache this set into the <to_be_added_info_>, till we come
// around to actually adding this to the <current_info_>
// Wake up all threads in WaitForMultipleObjects so that they can
// reconsult the handle set
// File descriptor table is full (better than nothing)
// Go through the entire valid array and check for all handles that
// have been schedule for deletion
// This stuff is necessary here, since we should not make
// the upcall until all the internal data structures have
// been updated.  This is to protect against upcalls that
// try to deregister again.
// See if this entry is scheduled for deletion
// Calling the <handle_close> method here will ensure that we
// will only call it once per deregistering <Event_Handler>.
// This is essential in the case when the <Event_Handler> will
// do something like delete itself and we have multiple
// threads in WFMO_Reactor.
//
// Make sure that the DONT_CALL mask is not set
// Grab the correct handle depending on the type entry
// Event handler
// If <WFMO_Reactor> created the event, we need to clean it up
// Reduce count by one
// See if this entry is scheduled for suspension
// Increase number of suspended handles
// Reduce count by one
// See if this entry is scheduled for deletion or suspension
// If so we need to clean up
// If this is the last handle in the set, no need to swap
// places. Simply remove it.
// Swap this handle with the last valid handle
// Struct copy
// Reset the info in this slot
// This current entry is not up for deletion or
// suspension.  Proceed to the next entry in the current
// handles.
// Now that all internal structures have been updated, make
// the upcall.
// Go through the <suspended_handle> array
// This stuff is necessary here, since we should not make
// the upcall until all the internal data structures have
// been updated.  This is to protect against upcalls that
// try to deregister again.
// See if this entry is scheduled for deletion
// Calling the <handle_close> method here will ensure that we
// will only call it once per deregistering <Event_Handler>.
// This is essential in the case when the <Event_Handler> will
// do something like delete itself and we have multiple
// threads in WFMO_Reactor.
//
// Make sure that the DONT_CALL mask is not set
// Grab the correct handle depending on the type entry
// Upcall
// If <WFMO_Reactor> created the event, we need to clean it up
// Reduce count by one
// Add to the end of the current handles set
// Struct copy
// Reduce count by one
// If an entry needs to be removed, either because it
// was deleted or resumed, remove it now before doing
// the upcall.
// Net effect is that we're removing an entry and
// compressing the list from the end.  So, if removing
// an entry from the middle, copy the last valid one to the
// removed slot.  Reset the end and decrement the number
// of suspended handles.
// Struct copy
// This current entry is not up for deletion or
// resumption.  Proceed to the next entry in the
// suspended handles.
// Now that all internal structures have been updated, make
// the upcall.
// Go through the <to_be_added_*> arrays
// This stuff is necessary here, since we should not make
// the upcall until all the internal data structures have
// been updated.  This is to protect against upcalls that
// try to deregister again.
// See if this entry is scheduled for deletion
// Calling the <handle_close> method here will ensure that we
// will only call it once per deregistering <Event_Handler>.
// This is essential in the case when the <Event_Handler> will
// do something like delete itself and we have multiple
// threads in WFMO_Reactor.
//
// Make sure that the DONT_CALL mask is not set
// Grab the correct handle depending on the type entry
// Upcall
// If <WFMO_Reactor> created the event, we need to clean it up
// Reduce count by one
// See if this entry is scheduled for suspension
// Increase number of suspended handles
// Reduce count by one
// If neither of the two flags are on, add to current
// Add to the end of the current handles set
// Struct copy
// Reset the <to_be_added_info_>
// Now that all internal structures have been updated, make the
// upcall.
// Since all to be added handles have been taken care of, reset the
// counter
/* ACE_HAS_DUMP */
/************************************************************/
/* Use of 'this' in initializer list */
// this event is initially signaled
// this event is initially unsignaled
// this event is initially unsignaled
// this event is initially signaled
// this event is initially unsignaled
// this event is initially unsignaled
// This GUARD is necessary since we are updating shared state.
// If we are already open, return -1
// Timer Queue
// Signal Handler
// Setup the atomic wait array (used later in <handle_events>)
// Prevent memory leaks when the ACE_WFMO_Reactor is reopened.
// Make necessary changes to the handler repository
// Turn off <wakeup_all_threads_> since all necessary changes
// have completed
// Open the handle repository.  Two additional handles for internal
// purposes
/* NOTE */
// The order of the following two registrations is very important
// Open the notification handler
// Register for <wakeup_all_threads> event
// Since we have added two handles into the handler repository,
// update the <handler_repository_>
// Make necessary changes to the handler repository
// Turn off <wakeup_all_threads_> since all necessary changes
// have completed
// We are open for business
// This GUARD is necessary since we are updating shared state.
// If we are already closed, return error
// We are now closed
// This will unregister all handles
// Make necessary changes to the handler repository that we caused
// by the above actions. Someone who called close() is expecting that
// things will be tidied up upon return.
// Assumption: No threads are left in the Reactor when this method
// is called (i.e., active_threads_ == 0)
// Close down
// If this is a Winsock 1 system, the underlying event assignment will
// not work, so don't try. Winsock 1 must use ACE_Select_Reactor for
// reacting to socket activity.
// Make sure that the <handle> is valid
/* ACE_HAS_CPP11 */
// Look up the repository to see if the <event_handler> is already
// there.
// Check to see if the user passed us a valid event; If not then we
// need to create one
// Note: don't change this since some C++ compilers have
// <auto_ptr>s that don't work properly...
/* ACE_HAS_CPP11 */
// If we had found the <Event_Handler> there is nothing more to do
// The <event_handler> was not found in the repository, add to
// the repository.
// Clear out the handle in the ACE_Auto_Event so that when
// it is destroyed, the handle isn't closed out from under
// the reactor. After setting it, running down the event
// (via auto_ptr<> event, above) at function return will
// cause an error because it'll try to close an invalid handle.
// To avoid that smashing the errno value, save the errno
// here, explicitly remove the event so the dtor won't do it
// again, then restore errno.
/* ACE_HAS_WINSOCK2 || ACE_HAS_WINSOCK2 == 0 */
// Make sure that the <handle> is valid
// Look up the repository to see if the <Event_Handler> is already
// there.
// First go through the current entries
//
// Look for all entries in the current handles for matching handle
// (except those that have been scheduled for deletion)
// Then pass through the suspended handles
//
// Look for all entries in the suspended handles for matching handle
// (except those that have been scheduled for deletion)
// Then check the to_be_added handles
//
// Look for all entries in the to_be_added handles for matching
// handle (except those that have been scheduled for deletion)
// Look for the handle first
// First go through the current entries
//
// Look for all entries in the current handles for matching handle
// (except those that have been scheduled for deletion)
// Then pass through the suspended handles
//
// Look for all entries in the suspended handles for matching handle
// (except those that have been scheduled for deletion)
// Then check the to_be_added handles
//
// Look for all entries in the to_be_added handles for matching
// handle (except those that have been scheduled for deletion)
// Otherwise, make sure that the masks that the user is looking for
// are on.
// Waits for and dispatches all events.  Returns -1 on error, 0 if
// max_wait_time expired, or the number of events that were dispatched.
// Make sure we are not closed
// Stash the current time -- the destructor of this object will
// automatically compute how much time elapsed since this method was
// called.
// Check to see if it is ok to enter ::WaitForMultipleObjects
// This will acquire <this->lock_> on success On failure, the
// lock will not be acquired
// Increment the number of active threads
// Release the <lock_>
// Update the countdown to reflect time waiting to play with the
// mut and event.
// Calculate timeout
// Wait for event to happen
// Upcall
// wait_for_multiple_events timed out without dispatching
// anything.  Because of rounding and conversion errors and
// such, it could be that the wait loop timed out, but
// the timer queue said it wasn't quite ready to expire a
// timer. In this case, max_wait_time won't have quite been
// reduced to 0, and we need to go around again. If max_wait_time
// is all the way to 0, just return, as the entire time the
// caller wanted to wait has been used up.
// Reflect time waiting for events
// Calculate the max time we should spend here
//
// Note: There is really no need to involve the <timer_queue_> here
// because even if a timeout in the <timer_queue_> does expire we
// will not be able to dispatch it
// We need to wait for both the <lock_> and <ok_to_wait_> event.
// If not on WinCE, use WaitForMultipleObjects() to wait for both atomically.
// On WinCE, the waitAll arg to WFMO must be false, so wait for the
// ok_to_wait_ event first (since that's likely to take the longest) then
// grab the lock and recheck the ok_to_wait_ event. When we can get them
// both, or there's an error/timeout, return.
// The event is signaled, so it's ok to wait; grab the lock and
// recheck the event. If something has changed, restart the wait.
// Have the lock_, now re-check the event. If it's not signaled,
// another thread changed something so go back and wait again.
// PharLap doesn't implement WaitForMultipleObjectsEx, and doesn't
// do async I/O, so it's not needed in this case anyway.
/* ACE_HAS_PHARLAP */
// It is ok to enter ::WaitForMultipleObjects
/* ACE_HAS_WINCE */
// Wait for any of handles_ to be active, or until timeout expires.
// If <alertable> is enabled allow asynchronous completion of
// ReadFile and WriteFile operations.
// PharLap doesn't do async I/O and doesn't implement
// WaitForMultipleObjectsEx, so use WaitForMultipleObjects.
/* ACE_HAS_PHARLAP */
// If "owner" thread
// expire all pending timers.
// Nothing to expire
// Expire timers
// Failure.
// Timeout.
// APC.
// ACE_HAS_WINCE
// Dispatch.
// We'll let dispatch worry about abandoned mutes.
// Dispatches any active handles from <handles_[slot]> to
// <handles_[max_handlep1_]>, polling through our handle set looking
// for active handles.
// dispatch_slot is the absolute slot.  Only += is used to
// increment it.
// Cache this value, this is the absolute value.
// nCount starts off at <max_handlep1>, this is a transient count of
// handles last waited on.
// wait_status is unsigned in Borland, Green Hills,
// mingw32 and MSVC++
// This >= is always true, with a warning.
// Otherwise, a handle was abandoned.
// Dispatch handler
// Increment slot
// We're done.
// Readjust nCount
// Check the remaining handles
// Failure.
/* FALLTHRU */
// There are no more handles ready, we can return.
// Check if there are window messages that need to be dispatched
// Dispatch the handler if it has not been scheduled for deletion.
// Note that this is a very week test if there are multiple threads
// dispatching this slot as no locks are held here. Generally, you
// do not want to do something like deleting the this pointer in
// handle_close() if you have registered multiple times and there is
// more than one thread in WFMO_Reactor->handle_events().
// The handle was scheduled for deletion, so we will skip it.
// This dispatch is used for non-I/O entires
// Assign the ``signaled'' HANDLE so that callers can get it.
// siginfo_t is an ACE - specific fabrication. Constructor exists.
// Upcall
// Call remove_reference() if needed.
// This dispatch is used for I/O entires.
// Prepare for upcalls. Clear the bits from <events> representing
// events the handler is not interested in. If there are any left,
// do the upcall(s). upcall will replace events.lNetworkEvents
// with bits representing any functions that requested a repeat
// callback before checking handles again. In this case, continue
// to call back unless the handler is unregistered as a result of
// one of the upcalls. The way this is written, the upcalls will
// keep being done even if one or more upcalls reported problems.
// In practice this may turn out not so good, but let's see. If any
// problems, please notify Steve Huston <shuston@riverace.com>
// before or after you change this code.
// Call add_reference() if needed.
// Upcall
// Call remove_reference() if needed.
// This method figures out what exactly has happened to the socket
// and then calls appropriate methods.
// Go through the events and do the indicated upcalls. If the handler
// doesn't want to be called back, clear the bit for that event.
// At the end, set the bits back to <events> to request a repeat call.
// Successful connect
// Unsuccessful connect
// This GUARD is necessary since we are updating shared state.
// Decrement active threads
// Check if the state of the handler repository has changed or new
// owner has to be set
// Try to become the thread which will be responsible for the
// changes
// Make sure no new threads are allowed to enter
// Check for other active threads
// Wake up all other threads
// Release <lock_>
// Go to sleep waiting for all other threads to get done
// Re-acquire <lock_> again
// Note that make_changes() calls into user code which can
// request other changes.  So keep looping until all
// requested changes are completed.
// Make necessary changes to the handler repository
// Update the owner
// Turn off <wakeup_all_threads_>
// Let everyone know that it is ok to go ahead
// Reset this flag
// This thread did not get a chance to become the change
// thread. If it is the last one out, it will wakeup the
// change thread
// This is if we were woken up explicitily by the user and there are
// no state changes required.
// Turn off <wakeup_all_threads_>
/* ACE_HAS_DUMP */
/*number_of_active_handles*/,
/*rd_mask*/)
/*buffer*/)
// Handle all pending notifications.
// Just check for sanity...
// This will get called when <WFMO_Reactor->wakeup_one_thread_> event
// is signaled.
//  ACELIB_DEBUG ((LM_DEBUG,
//             ACE_TEXT ("(%t) waking up to handle internal notifications\n")));
// Copy ACE_Time_Value::zero since dequeue_head will modify it.
// We've reached the end of the processing, return
// normally.
// Something weird happened...
// If eh == 0 then we've got major problems!  Otherwise, we
// need to dispatch the appropriate handle_* method on the
// ACE_Event_Handler pointer we've been passed.
// Make sure to delete the memory regardless of success or
// failure!
// Bail out if we've reached the <max_notify_iterations_>.
// Note that by default <max_notify_iterations_> is -1, so
// we'll loop until we're done.
// If there are still notification in the queue, we need
// to wake up again
// Break the loop as we have reached max_notify_iterations_
// Notify the WFMO_Reactor, potentially enqueueing the
// <ACE_Event_Handler> for subsequent processing in the WFMO_Reactor
// thread of control.
// Convert from relative time to absolute time by adding the
// current time of day.  This is what <ACE_Message_Queue>
// expects.
// Must always be > 0 or < 0 to optimize the loop exit condition.
// Go over message queue and take out all the matching event
// handlers.  If eh == 0, purge all. Note that reactor notifies (no
// handler specified) are never purged, as this may lose a needed
// notify the reactor queued for itself.
// Guard against new and/or delivered notifications while purging.
// WARNING!!! The use of the notification queue's lock object for
// this guard makes use of the knowledge that on Win32, the mutex
// protecting the queue is really a CriticalSection, which is
// recursive. This is how we can get away with locking it down here
// and still calling member functions on the queue object.
// first, copy all to our own local queue. Since we've locked everyone out
// of here, there's no need to use any synchronization on this queue.
// This shouldn't happen...
// If this is not a Reactor notify (it is for a particular handler),
// and it matches the specified handler (or purging all),
// and applying the mask would totally eliminate the notification, then
// release it and count the number purged.
// the existing notification mask
// is left with nothing when
// applying the mask
// To preserve it, move it to the local_queue.  But first, if
// this is not a Reactor notify (it is for a
// particularhandler), and it matches the specified handler
// (or purging all), then apply the mask
// Should be empty!
// Now copy back from the local queue to the class queue, taking
// care to preserve the original order...
/* ACE_HAS_DUMP */
// Must always be > 0 or < 0 to optimize the loop exit condition.
// No-op WinSOCK2 methods to help WFMO_Reactor compile
/* s */,
/* hEventObject */,
/* lNetworkEvents */)
/* s */,
/* hEventObject */,
/* lpNetworkEvents */)
/* !defined ACE_HAS_WINSOCK2 */
/* ACE_WIN32 */
// Get to the platform specific implementation.
// Post myself.
// Set the ACE_OVERLAPPED structure
// Grab the handle from the <handler> if <handle> is invalid
// update implementation.
// Register with the <proactor>.
// All I/O operations that are canceled will complete with the error
// ERROR_OPERATION_ABORTED. All completion notifications for the I/O
// operations will occur normally.
// @@ This API returns 0 on failure. So, I am returning -1 in that
//    case. Is that right? (Alex).
// Couldn't cancel the operations.
// result is non-zero. All the operations are cancelled then.
/* !ACE_HAS_WIN32_OVERLAPPED_IO */
/* ACE_HAS_AIO_CALLS */
// ************************************************************
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// Create the Asynch_Result.
// Shared read
// Upon errors
// We should not read more than user requested,
// but it is allowed to read less
// OS should correctly process zero length buffers
// if ( msg_space == 0 )
//   ACELIB_ERROR_RETURN ((LM_ERROR,
//                      ACE_TEXT ("ACE_WIN32_Asynch_Read_Stream::readv:")
//                      ACE_TEXT ("No space in the message block\n")),
//                     -1);
// Make as many iovec as needed to fit all of msg_space.
// Collect the data in the iovec.
// Increment iovec counter if there's more to do.
// Ran out of iovecs before msg_space exhausted
// Re-calculate number bytes to read
// Create the Asynch_Result.
// scatter read enabled
// do the scatter recv
// Clear error before starting IO.
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
/* ACE_HAS_WINSOCK2 && ACE_HAS_WINSOCK2 != 0 */
// ReadFile API limits us to DWORD range.
// Clear error before starting IO.
// Initiate the read
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
/* FALLTHRU */
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// Copy the data which was returned by <GetQueuedCompletionStatus>.
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// Clear error before starting IO.
// Initiate the write; Winsock 2 is required for the higher-performing
// WSASend() function. For Winsock 1, fall back to the slower WriteFile().
// flags
/* ACE_HAS_WINSOCK2 */
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// We should not write more than user requested,
// but it is allowed to write less
// Skip 0-length blocks.
// Make as many iovec as needed to fit all of msg_len.
// Collect the data in the iovec.
// Increment iovec counter if there's more to do.
// Ran out of iovecs before msg_space exhausted
// Re-calculate number bytes to write
// gather write enabled
// do the gather send
// flags
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
/* ACE_HAS_WINSOCK2 && ACE_HAS_WINSOCK2 != 0 */
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// Copy the data which was returned by GetQueuedCompletionStatus.
// Appropriately move the pointers in the message block.
// mb->space () is ought to be >= page_size.
// this is verified in the readv method
// ACE_ASSERT (mb->space () >= page_size);
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// The following methods belong to
// ACE_WIN32_Asynch_Read_Stream_Result. They are here to avoid VC++
// warnings. These methods route their call to the
// ACE_WIN32_Asynch_Read_Stream_Result base class.
// ************************************************************
// Shared read
// Upon errors
// Each buffer must be at least the size of a system memory page
// and must be aligned on a system memory page size boundary
// We should not read more than user requested,
// but it is allowed to read less
// not read more than buffers space
// ReadFileScatter API limits us to DWORD range.
// last one should be completely 0
// scatter read enabled
// do the scatter read
// Clear error before starting IO.
// reserved, must be NULL
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
/* ACE_WIN32_OVERLAPPED_IO */
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// mb->length () is ought to be >= page_size.
// this is verified in the writev method
// ACE_ASSERT (mb->length () >= page_size);
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// The following methods belong to
// ACE_WIN32_Asynch_Write_Stream_Result. They are here to avoid VC++
// warnings. These methods route their call to the
// ACE_WIN32_Asynch_Write_Stream_Result base class.
// Clear error before starting IO.
// Initiate the write
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Each buffer must be at least the size of a system memory page
// and must be aligned on a system memory page size boundary
// We should not read more than user requested,
// but it is allowed to read less
// Don't allow writing less than page_size, unless
// the size of the message block is big enough (so we don't write from
// memory which does not belong to the message block), and the message
// block is the last in the chain.
// message block too small
// NOT last chunk
// not write more than we have in buffers
// WriteFileGather API limits us to DWORD range.
// last one should be completely 0
// gather write enabled
// do the gather write
// reserved, must be NULL
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
/* ACE_HAS_WIN32_OVERLAPPED_IO */
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// Sanity check: make sure that enough space has been allocated by
// the caller.
/* ACE_HAS_IPV6 */
// AcceptEx requires address size + 16 (minimum)
// WIN Specific.
// AcceptEx API limits us to DWORD range.
// If the <accept_handle> is invalid, we will create a new socket.
// Remember to close the socket down if failures occur.
// Common code for both WIN and POSIX.
// Initiate the accept.
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Close the newly created socket
// Cleanup dynamically allocated Asynch_Result.
/* defined (ACE_HAS_WIN32_OVERLAPPED_IO) || (defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0)) */
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// *********************************************************************
// Copy the data.
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// *********************************************************************
// to avoid purge_pending_notifications
// if we are already opened,
// we could not create a new handler without closing the previous
//int result =
// Ignore result as we pass ACE_INVALID_HANDLE
//if (result == -1)
//  return result;
// Common code for both WIN and WIN32.
// Create future Asynch_Connect_Result
// update handle
//  Enqueue result we will wait for completion
// not to suspend after register
// NOTE: result is invalid after post_completion(). It's either deleted
// or will be shortly via the proactor dispatch, regardless of success
// or fail of the call.
// There was no call to post_completion() so manually delete result.
// connect_i
//  return code :
//   -1   errors  before  attempt to connect
//    0   connect started
//    1   connect finished ( may be unsuccessfully)
// save it
// Reuse the address
// set non blocking mode
// failure
// connect started
// connect finished
// cancel_uncompleted
// It performs cancellation of all pending requests
//
// Parameter flg_notify can be
//     0  - don't send notifications about canceled accepts
//    !0  - notify user about canceled accepts
//          according WIN32 standards we should receive notifications
//          on canceled AIO requests
//
//  Return value : number of cancelled requests
//
// ERRORS
// AIO_ALLDONE
// AIO_CANCELED
// not found
// This previously just did a "return -1" and let handle_close() clean
// things up. However, this entire object may be gone as a result of
// the application's completion handler, so don't count on 'this' being
// legitimate on return from post_result().
// remove_io_handler() contains flag DONT_CALL
// not found
// *********************************************************************
// Copy the data which was returned by GetQueuedCompletionStatus
// We will not do this because (a) the header and trailer blocks may
// be the same message_blocks and (b) in cases of failures we have
// no idea how much of what (header, data, trailer) was sent.
/*
// Create the interface result class.
// Call the application handler.
// Base class operations. These operations are here to kill dominance
// warnings. These methods call the base class methods.
// TransmitFile API limits us to DWORD range.
// Initiate the transmit file
// Immediate success: the OVERLAPPED will still get queued.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Cleanup dynamically allocated Asynch_Result
/* ACE_HAS_WIN32_OVERLAPPED_IO || ACE_HAS_WINSOCK2 */
// Methods belong to ACE_WIN32_Asynch_Operation base class. These
// methods are defined here to avoid VC++ warnings. They route the
// call to the ACE_WIN32_Asynch_Operation base class.
// failure
// make sure the addresses are of the same type
// copy the remote_address_ into addr
// success
// only supporting INET addresses
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// Adjust the address length
// Create the interface result class.
// Call the application handler.
//***************************************************************************
/***************************************************************************
// OS should correctly process zero length buffers
// if ( msg_space == 0 )
//   ACELIB_ERROR_RETURN ((LM_ERROR,
//                      ACE_TEXT ("ACE_WIN32_Asynch_Read_Dgram::recv:")
//                      ACE_TEXT ("No space in the message block\n")),
//                     -1);
// Make as many iovec as needed to fit all of msg_len.
// Collect the data in the iovec.
// Increment iovec counter if there's more to do.
// Ran out of iovecs before msg_space exhausted
// Create the Asynch_Result.
// do the scatter/gather recv
// NOTE! The flags value is in/out to recvfrom() - it's changed AFTER
// the call to WSARecvFrom returns and if it completes immediately, the
// result object may already be deleted. Since the changed value is not
// used, and not needed by result, pass a copy to avoid the race.
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Immediate success: the OVERLAPPED will still get queued.
// number_of_bytes_recvd contains the number of bytes recvd
// addr contains the peer address
// flags was updated
// number_of_bytes_recvd = bytes_recvd;
//***********************************************
/***********************************************
// Copy the data which was returned by GetQueuedCompletionStatus
// Appropriately move the pointers in the message block.
// Create the interface result class.
// Call the application handler.
//***********************************************
/***********************************************
// Make as many iovec as needed to fit all of msg_len.
//if (msg_len >= 0 && iovcnt < ACE_IOV_MAX)
// msg_len >= 0 is always true since msg_len is unsigned
// Collect the data in the iovec.
// Increment iovec counter if there's more to do.
// Ran out of iovecs before msg_space exhausted
// Create the Asynch_Result.
// do the scatter/gather send
// If initiate failed, check for a bad error.
// The IO will complete proactively: the OVERLAPPED will still
// get queued.
// Something else went wrong: the OVERLAPPED will not get
// queued.
// Immediate success: the OVERLAPPED will still get queued.
// number_of_bytes_recvd contains the number of bytes recvd
// addr contains the peer address
// flags was updated
// number_of_bytes_sent = bytes_sent;
/* ACE_HAS_WIN32_OVERLAPPED_IO && ACE_HAS_WINSOCK2 */
//
// WIN implemenatation of the Proactor.
/**
/// Constructor.
/// Destructor.
/// This method calls the <handler>'s <handle_wakeup> method.
// This *MUST* be 0, *NOT* ACE_INVALID_HANDLE !!!
// Create the completion port.
// Close the completion port
// To avoid memory leaks we should delete all results from queue.
// Get the next asynchronous operation that completes
// poll
// No locking is needed here as no state changes.
// If errno == ERROR_INVALID_PARAMETER, then this handle was
// already registered.
// Perform a non-blocking "poll" for all the I/O events that have
// completed in the I/O completion queue.
// If our handle_events failed, we'll report a failure to the
// Reactor.
// Decrement <wait_time> with the amount of time spent in the method
// Get the next asynchronous operation that completes
// Calling GetQueuedCompletionStatus with timeout value 0
// returns FALSE with extended errno "ERROR_SUCCESS" errno =
// ETIME; ?? I don't know if this has to be done !!
// Narrow the result.
// If errors happen, grab the error.
// if "result_err" is 0 than
//     It is normal OS/WIN32 AIO completion.
//     We have cleared asynch_result->error_
//     during shared_read/shared_write.
//     The real error code is already stored in "errno",
//     so copy "errno" value to the "result_err"
//     and pass this "result_err" code
//     to the application_specific_code ()
// else
//    "result_err" non zero
//     it means we have "post_completed" result
//     so pass this "result_err" code
//     to the application_specific_code ()
// Call completion hook
// This is crucial to prevent memory leaks
// Grab the event associated with the Proactor
// pass
//   bytes_transferred
//   completion_key
// to the ::PostQueuedCompletionStatus()
//   error will be extracted later in handle_events()
// This cast is ok since the original API calls restricted the transfer
// counts to DWORD range.
// Post a completion
// completion port
// xfer count
// completion key
// overlapped
// If Proactor event is valid, signal it
/* bytes_transferred */,
/* success */,
/* completion_key */,
/*  error */)
/* ACE_WIN32 */
/* ACE_USES_CLASSIC_SVC_CONF == 0 */
/* __ACE_INLINE__ */
/* ACE_HAS_DUMP */
// Add a leaf to the current connection (i.e., multicast).
// Check for asynchronous event
// If this doesn't work for asynchronous calls we need to call
// the XTI/ATM t_rcvleafchange() function to check for t_addleaf
// completion.
/* ACE_HAS_XTI_ATM */
/* __ACE_INLINE__ */
// Compress using Run Length Encoding (RLE)
// Save for stats
// BootStrap to 128
// Output Exhausted
// Switch off compressing
// Fall Through
// Fix problem where input exhaused but maybe compressing
// In Compression?
// Stay in Compression
// Xfering to Compression
// Output Exhausted
// We Are Now Compressing
// Are we in Compression?
// Finalise the Compression Run Length
// Reset for Uncmpressed
// Output Exhausted
// Now restart Uncompressed
// Output Exhausted
// return as our output length
// Decompress using Run Length Encoding (RLE)
// Output Exhausted
// compressed
// Output Exhausted
// Output Exhausted
// Close versioned namespace, if enabled by the user.
// -*- C++ -*-
/* __ACE_INLINE__ */
/* visitor */)
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// ****************************************************************
// -*- C++ -*-
//=============================================================================
/**
//=============================================================================
// -*- C++ -*-
// Routine to have Lex read its input from the constraint string.
/* A lexical scanner generated by flex */
/* Scanner skeleton version:
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
/* Use prototypes in function declarations. */
/* The "const" storage-class-modifier is valid. */
/* ! __cplusplus */
/* __STDC__ */
/* ! __cplusplus */
/* Returned upon end-of-file. */
/* Promotes a possibly negative, possibly signed char to an unsigned
/* Enter a start condition.  This macro really ought to take a parameter,
/* Translate the current start state into a value that can be later handed
/* Action number for EOF rule of a given start state. */
/* Special action meaning "start processing a new file". */
/* Size of default input buffer. */
/* The funky do-while in the following #define is used to turn the definition
/* Return all but the first 'n' matched characters back to the input stream. */
/* Undo effects of setting up yytext. */ \
/* set up yytext again */ \
/* The following is because we cannot portably get our hands on size_t
/* input buffer */
/* current position in input buffer */
/* Size of input buffer in bytes, not including room for EOB
/* Number of characters read into yy_ch_buf, not including EOB
/* Whether we "own" the buffer - i.e., we know we created it,
/* Whether this is an "interactive" input source; if so, and
/* Whether we're considered to be at the beginning of a line.
/* Whether to try to fill the input buffer when we reach the
/* When an EOF's been seen but there's still some text to process
/* We provide macros for accessing buffer states in case in the
/* yy_hold_char holds the character lost when yytext is formed. */
/* number of characters read into yy_ch_buf */
/* Points to current character in buffer. */
/* whether we need to initialize */
/* start state number */
/* Flag which is used to allow yywrap()'s to do buffer switches
/* Done after the current pattern has been matched and before the
/* The intent behind this definition is that it'll catch
//=============================================================================
/**
//=============================================================================
//static const char * extract_string(char*);
/* CONSTRAINT_DEBUG */
//#define YY_DECL int ETCL_yylex (ETCL_YYSTYPE *lvalp, void* state)
/* Macros after this point can all be overridden by user definitions in
/* Just try to get by without declaring the routines.  This will fail
/* Amount of stuff to slurp up with each read. */
/* Copy whatever the last rule matched to the standard output. */
//FUZZ: disable check_for_lack_ACE_OS
/* This used to be an fputs(), but since the string might contain NUL's,
//FUZZ: enable check_for_lack_ACE_OS
/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
/* No semi-colon after return; correct usage is to write "yyterminate();" -
/* Number of entries by which start-condition stack grows. */
/* Report a fatal error. */
/* Default declaration of generated scanner - a define so the user can
/* Code executed at the beginning of each rule, after yytext and yyleng
/* Code executed at the end of each rule. */
//#line 50 "ETCL/ETCL.ll"
/* first start state */
/* loops until end-of-file is reached */
/* Support of yytext. */
/* yy_bp points to the position in yy_ch_buf of the start of
/* have to back up */
/* This label is used only to access EOF actions. */
/* beginning of action switch */
/* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
//#line 52 "ETCL/ETCL.ll"
//#line 53 "ETCL/ETCL.ll"
//#line 54 "ETCL/ETCL.ll"
//#line 55 "ETCL/ETCL.ll"
//#line 56 "ETCL/ETCL.ll"
//#line 57 "ETCL/ETCL.ll"
//#line 58 "ETCL/ETCL.ll"
//#line 59 "ETCL/ETCL.ll"
//#line 60 "ETCL/ETCL.ll"
//#line 61 "ETCL/ETCL.ll"
//#line 62 "ETCL/ETCL.ll"
//#line 63 "ETCL/ETCL.ll"
//#line 64 "ETCL/ETCL.ll"
//#line 65 "ETCL/ETCL.ll"
//#line 66 "ETCL/ETCL.ll"
//#line 67 "ETCL/ETCL.ll"
//#line 68 "ETCL/ETCL.ll"
//#line 69 "ETCL/ETCL.ll"
//#line 70 "ETCL/ETCL.ll"
//#line 71 "ETCL/ETCL.ll"
//#line 72 "ETCL/ETCL.ll"
//#line 73 "ETCL/ETCL.ll"
//#line 74 "ETCL/ETCL.ll"
//#line 75 "ETCL/ETCL.ll"
//#line 76 "ETCL/ETCL.ll"
//#line 77 "ETCL/ETCL.ll"
//#line 78 "ETCL/ETCL.ll"
//#line 79 "ETCL/ETCL.ll"
//#line 80 "ETCL/ETCL.ll"
//#line 81 "ETCL/ETCL.ll"
//#line 82 "ETCL/ETCL.ll"
//#line 83 "ETCL/ETCL.ll"
//#line 84 "ETCL/ETCL.ll"
//#line 89 "ETCL/ETCL.ll"
//#line 94 "ETCL/ETCL.ll"
//#line 99 "ETCL/ETCL.ll"
//#line 106 "ETCL/ETCL.ll"
//#line 111 "ETCL/ETCL.ll"
//#line 116 "ETCL/ETCL.ll"
// Ignore
//#line 119 "ETCL/ETCL.ll"
// @@ TODO
//#line 122 "ETCL/ETCL.ll"
/* Amount of text matched not including the EOB char. */
/* Undo the effects of YY_DO_BEFORE_ACTION. */
/* We're scanning a new file or input source.  It's
/* Note that here we test for yy_c_buf_p "<=" to the position
/* This was really a NUL. */
/* Okay, we're now positioned to make the NUL
/* Consume the NUL. */
/* Note: because we've taken care in
/* end of action switch */
/* end of scanning one token */
/* end of yylex */
/* yy_get_next_buffer - try to read in a new buffer
/* Don't try to fill the buffer, so this is an EOF. */
/* We matched a single character, the EOB, so
/* We matched some text prior to the EOB, first
/* Try to read more data. */
/* First move last chars to start of buffer. */
/* don't do the read, it's not guaranteed to return an EOF,
/* Not enough room in the buffer - grow it. */
/* just a shorter name for the current buffer */
/* Include room in for 2 EOB chars. */
/* Can't grow it, we don't own it. */
/* Read in more data. */
/* yy_get_previous_state - get the state just before the EOB char was reached */
/* yy_try_NUL_trans - try to make a transition on the NUL character
/* undo effects of setting up yytext */
/* need to shift things up to make room */
/* +2 for EOB chars. */
/* ifndef YY_NO_UNPUT */
/* yy_c_buf_p now points to the character we want to return.
/* This was really a NUL. */
/* need more input */
/* This happens because yy_g_n_b()
/* Reset buffer status. */
/* fall through */
/* cast for 8-bit char's */
/* preserve yytext */
/* YY_NO_INPUT */
/* Flush out information for old buffer. */
/* We don't actually know whether we did this switch during
/* yy_ch_buf has to be 2 characters longer than the size given because
// Mimic the behavior as WinCE does not have isatty().
// ACE_HAS_WINCE
/* We always need two end-of-buffer characters.  The first causes
/* They forgot to leave room for the EOB's. */
/* "- 2" to take care of EOB's */
/* Get memory for full buffer, including space for trailing EOB's. */
/* It's okay to grow etc. this buffer, and we should throw it
/* Redefine yyless() so it works in section 3 code. */
/* Undo effects of setting up yytext. */ \
/* Internal utility routines. */
/* The cast to (char *) in the following accommodates both
//#line 122 "ETCL/ETCL.ll"
/*  A Bison parser, made from ETCL/ETCL.yy
/* Identify Bison output.  */
//=============================================================================
/**
//=============================================================================
// @@ TODO
// Ignore error messages
//#line' lines.  */
/* -*-C-*-  Note some compilers choke on comments on `//#line' lines.  */
//#line 3 "/pkg/gnu/share/bison.simple"
/* This file comes from bison-1.28.  */
/* Skeleton output parser for bison,
/* As a special exception, when this file is copied by Bison into a
/* This is the parser code that is written into each bison parser
/* alloca not defined */
/* not GNU C.  */
/* not sparc */
/* We think this test detects Watcom and Microsoft C.  */
/* This used to test MSDOS, but that is a bad idea
/* No need for malloc.h, which pollutes the namespace;
/* not MSDOS, or __TURBOC__ */
/* I don't know what this was needed for, but it pollutes the namespace.
/* #include <malloc.h>  */
/* not MSDOS, or __TURBOC__, or _AIX */
/* haible@ilog.fr says this works for HPUX 9.05 and up,
/* __hpux */
/* not _AIX */
/* not MSDOS, or __TURBOC__ */
/* not sparc */
/* not GNU C */
/* alloca not defined */
/* YYSTACK_USE_ALLOCA not defined */
/* Note: there must be only one dollar sign in this file.
/* Like YYERROR except do call yyerror.
/* not YYLSP_NEEDED */
/* not YYLSP_NEEDED */
/* If nonreentrant, generate the variables here */
/*  the lookahead symbol    */
/*  the semantic value of the   */
/*  lookahead symbol      */
/*  the variable used to return   */
/*  semantic values from the action */
/*  routines        */
/*  location data for the lookahead */
/*  symbol        */
/*  number of parse errors so far       */
/* not YYPURE */
/*  nonzero means print parse trace */
/* Since this is uninitialized, it does not stop multiple parsers
/*  YYINITDEPTH indicates the initial size of the parser's stacks  */
/*  YYMAXDEPTH is the maximum size the stacks can grow to
/* Define __yy_memcpy.  Note that the size argument
/* GNU C and GNU C++ define this.  */
/* not GNU C or C++ */
/* This is the most reliable way to avoid incompatibilities
/* __cplusplus */
/* This is the most reliable way to avoid incompatibilities
//#line 217 "/pkg/gnu/share/bison.simple"
/* The user can define YYPARSE_PARAM as the name of an argument to be passed
/* not __cplusplus */
/* not __cplusplus */
/* not YYPARSE_PARAM */
/* not YYPARSE_PARAM */
/* Prevent warning if -Wstrict-prototypes.  */
/*  number of tokens to shift before error messages enabled */
/*  lookahead token as an internal (translated) token number */
/*  the state stack     */
/*  the semantic value stack   */
/*  refer to the stacks thru separate pointers */
/*  to allow yyoverflow to reallocate them elsewhere */
/*  the location stack     */
/* Cause a token to be read.  */
/* Initialize stack pointers.
/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
/* Give user a chance to reallocate the stack */
/* Use copies of these so that the &'s don't force the real ones into memory. */
/* Get the current used size of the three stacks, in elements.  */
/* Each stack pointer address is followed by the size of
/* This used to be a conditional around just the two extra args,
/* no yyoverflow */
/* Extend the stack our own way.  */
/* no yyoverflow */
/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */
/* First try to decide what to do without reference to lookahead token.  */
/* Not known => get a lookahead token if don't already have one.  */
/* yychar is either YYEMPTY or YYEOF
/* Convert token to internal form (in yychar1) for indexing tables with */
/* This means end of input. */
/* Don't call YYLEX any more */
/* Give the individual parser a way to print the precise meaning
/* yyn is what to do for this token type in this state.
/* Shift the lookahead token.  */
/* Discard the token being shifted unless it is eof.  */
/* count tokens shifted since error; after three, turn off error status.  */
/* Do the default action for the current state.  */
/* Do a reduction.  yyn is the number of a rule to reduce with.  */
/* implement default value of the action */
/* Print the symbols being reduced, and their result.  */
//#line 97 "ETCL/ETCL.yy"
//#line 99 "ETCL/ETCL.yy"
//#line 101 "ETCL/ETCL.yy"
//#line 103 "ETCL/ETCL.yy"
//#line 105 "ETCL/ETCL.yy"
//#line 109 "ETCL/ETCL.yy"
//#line 114 "ETCL/ETCL.yy"
//#line 119 "ETCL/ETCL.yy"
//#line 121 "ETCL/ETCL.yy"
//#line 123 "ETCL/ETCL.yy"
//#line 125 "ETCL/ETCL.yy"
//#line 127 "ETCL/ETCL.yy"
//#line 129 "ETCL/ETCL.yy"
//#line 134 "ETCL/ETCL.yy"
//#line 136 "ETCL/ETCL.yy"
//#line 141 "ETCL/ETCL.yy"
//#line 146 "ETCL/ETCL.yy"
//#line 148 "ETCL/ETCL.yy"
//#line 153 "ETCL/ETCL.yy"
//#line 155 "ETCL/ETCL.yy"
//#line 160 "ETCL/ETCL.yy"
//#line 165 "ETCL/ETCL.yy"
//#line 167 "ETCL/ETCL.yy"
//#line 169 "ETCL/ETCL.yy"
//#line 171 "ETCL/ETCL.yy"
//#line 173 "ETCL/ETCL.yy"
//#line 175 "ETCL/ETCL.yy"
//#line 177 "ETCL/ETCL.yy"
//#line 179 "ETCL/ETCL.yy"
//#line 181 "ETCL/ETCL.yy"
//#line 183 "ETCL/ETCL.yy"
//#line 185 "ETCL/ETCL.yy"
//#line 187 "ETCL/ETCL.yy"
//#line 189 "ETCL/ETCL.yy"
//#line 191 "ETCL/ETCL.yy"
//#line 195 "ETCL/ETCL.yy"
//#line 197 "ETCL/ETCL.yy"
//#line 200 "ETCL/ETCL.yy"
//#line 207 "ETCL/ETCL.yy"
//#line 209 "ETCL/ETCL.yy"
//#line 216 "ETCL/ETCL.yy"
//#line 218 "ETCL/ETCL.yy"
//#line 220 "ETCL/ETCL.yy"
//#line 222 "ETCL/ETCL.yy"
//#line 224 "ETCL/ETCL.yy"
//#line 230 "ETCL/ETCL.yy"
//#line 234 "ETCL/ETCL.yy"
//#line 238 "ETCL/ETCL.yy"
//#line 242 "ETCL/ETCL.yy"
//#line 246 "ETCL/ETCL.yy"
//#line 248 "ETCL/ETCL.yy"
//#line 250 "ETCL/ETCL.yy"
//#line 252 "ETCL/ETCL.yy"
//#line 254 "ETCL/ETCL.yy"
/* the action file gets copied in in place of this dollarsign */
//#line 543 "/pkg/gnu/share/bison.simple"
/* Now "shift" the result of the reduction.
/* here on detecting error */
/* If not already recovering from an error, report this error.  */
/* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
/* YYERROR_VERBOSE */
/* here on error raised explicitly by an action */
/* if just tried and failed to reuse lookahead token after an error, discard it.  */
/* return failure if at end of input */
/* Else will try to reuse lookahead token
/* Each real token shifted decrements this */
/* current state does not do anything special for the error token. */
/* This is wrong; only states that explicitly want error tokens
/* If its default is to accept any token, ok.  Otherwise pop it.*/
/* pop the current state because it cannot handle the error token */
/* YYACCEPT comes here.  */
/* YYABORT comes here.  */
/* Flush out yy_current_buffer before next parse.  Since there is
//#line 257 "ETCL/ETCL.yy"
/**/ <FL/Fl.H>
// Must be called with lock held
// When the ACE_Select_Reactor is constructed it creates the notify
// pipe and registers it with the register_handler_i() method. The
// FlReactor overloads this method BUT because the
// register_handler_i occurs when constructing the base class
// ACE_Select_Reactor, the ACE_Select_Reactor register_handler_i()
// is called not the FlReactor register_handler_i().  This means
// that the notify pipe is registered with the ACE_Select_Reactor
// event handling code not the FlReactor and so notfications don't
// work.  To get around this we simply close and re-opened the
// notification handler in the constructor of the FlReactor.
/* ACE_MT_SAFE */
// This is just the <wait_for_multiple_events> from ace/Reactor.cpp
// but we use the Fl functions to wait for an event, not <select>
// Check to make sure our handle's are all usable.
// Bad file arguments...
// Instead of waiting using <select>, just use the Fl mechanism
// to wait for one or more events...
// Wait for something to happen.
// Reset the width, in case it changed during the upcalls.
// Now actually read the result needed by the <Select_Reactor>
// using <select>.
/* ACE_WIN32 */
// Timed out or input available
//reinterpret_cast<ACE_HANDLE> (fd);
// my copy isn't const.
// Deal with one file event.
// - read which kind of event
// - Use only that one file event (removes events for other files).
// Deal with any timer events
// connected, you may write
// connected, you have data/err
// reinterpret_cast<int> (handle),
// In the registration phase we registered first with
// ACE_Select_Reactor and then with X.  Now we are now doing things
// in reverse order.
// First clean up the corresponding X11Input.
// reinterpret_cast<int> (handle);
// Now let the reactor do its work.
// The following function ensures there's an Fl timeout for the first
// timeout in the Reactor's Timer_Queue.
// Must be called with lock held
// When the ACE_Select_Reactor is constructed it creates the notify
// pipe and registers it with the register_handler_i() method. The
// FoxReactor overloads this method BUT because the
// register_handler_i occurs when constructing the base class
// ACE_Select_Reactor, the ACE_Select_Reactor register_handler_i()
// is called not the FoxReactor register_handler_i().  This means
// that the notify pipe is registered with the ACE_Select_Reactor
// event handling code not the FoxReactor and so notfications don't
// work.  To get around this we simply close and re-opened the
// notification handler in the constructor of the FoxReactor.
/* ACE_MT_SAFE */
// This is just the <wait_for_multiple_events> from ace/Reactor.cpp
// but we use the Fox functions to wait for an event, not <select>
/* ACE_WIN32 */
// Timed out or input available
/*max_wait_time*/)
// Check to make sure our handle's are all usable.
// Bad file arguments...
// Qt processing.
// Reset the width, in case it changed during the upcalls.
// Now actually read the result needed by the <Select_Reactor> using
// <select>.
/* ob */, FXSelector se, void* handle){
/* ob */, FXSelector /* sel */, void* /* handle */)
// Deal with any timer events
// Set next timeout signal
// connected, you may write
// connected, you have data/err
// In the registration phase we registered first with
// ACE_Select_Reactor and then with X.  Now we are now doing things
// in reverse order.
// connected, you may write
// connected, you have data/err
// First clean up the corresponding X11Input.
// ACE_reinterpret_cast(int,handle));
// Now let the reactor do its work.
// The following function ensures there's an Fox timeout for the first
// timeout in the Reactor's Timer_Queue.
/// We want the thread in which the event loop is started to
/// own the reactor, otherwise the handle_timeout() calls
/// aren't triggerd.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* defined (__NetBSD__) || defined (__OpenBSD__) */
/// Scan format for /proc/net/dev
/// On some platforms, value_ is an ACE_UINT64.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// Scan format for /proc/net/dev
/// On some platforms, value_ is an ACE_UINT64.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// Root is deleted in the interpreter's destructor.
/// root_ is set in this base class call.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
// Evaluate the constraint in root_;
// If a property couldn't be evaluated we must return FALSE.
/// TODO - check for strings related to other identifiers
/// relevant in MonitorControl, for example the data timestamp.
/// Call to accept() puts the subexpression's evaluation on our queue.
/// The leading '-' was parsed separately, so we have to pull
/// the literal constraint off the queue, apply the class' own
/// unary minus operator, and put it back.
/// Leave the literal constraint on the queue. The leading
/// '+' was just syntactic sugar - no action is necessary.
/// The parser should never construct a ETCL_Unary_Constraint
/// behind any operators except the above three.
/// These last two are not supported in non_CORBA ETCL.
/// Call to accept() puts the lhs (or its evaluation) on our queue.
/// Short-circuiting OR.
/// Call to accept() puts the lhs (or its evaluation) on our queue.
/// Short-circuiting AND.
/// Perform an operation on the results of evaluating the left and
/// right branches of this subtree. The evaluations go on our queue.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// The system hasn't updated /proc/stat since the last call
/// to update(), we must avoid dividing by 0.
/// Stores value and timestamp with thread-safety.
/// All data in this file are stored as running 'jiffy' totals, so we
/// get values here in the constructor to subtract for the difference
/// in subsequent calls.
/// Stored similarly to Linux, in a system file.
/// Unlike Linux's "/proc/stat", there is no entry for total CPU
/// stats, so we have to sum them manually.
/// Because the kstat chain can change dynamically,
/// watch the chain ID and restart the walk if the ID
/// differs from what we saw during the walk. The restart
/// is done by breaking from the cycle with kstat_ not 0.
/// The ID changed underneath us, so get the new one and
/// start again.
/// Clean run, exit the WHILE loop.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
// for
/* defined (__FreeBSD__) || defined (__Lynx__) */
/// Ignore the first 2 lines of the file, which are file
/// and column headers.
/// If the monitor runs long enough, the system counters will
/// wrap around, the statement below is an attempt to correct
/// for that.
/// Read the file once to get a base value that we can subtract
/// from subsequent readings to get bytes sent since we started
/// monitoring.
/// Ignore the first 2 lines of the file, which are file
/// and column headers.
/* defined (ACE_LINUX) || defined (AIX) */
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* data */)
/// No-op, should always call update().
/* data */)
/// No-op, should always call update().
/* data */)
/// No-op, should always call update().
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/* current */,
//=========================================================
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// No-op.
/// No-op.
/// Stores value and timestamp with thread-safety.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// Scan format for /proc/net/dev
/// On some platforms, value_ is an ACE_UINT64.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// Scan format for /proc/net/dev
/// On some platforms, value_ is an ACE_UINT64.
/* ACE_HAS_MONITOR_FRAMEWORK==1 */
/// We have to sum the network interfaces manually.
/// Interfaces 'lo' have only packet counters.
/// Unrecoverable error, diagnostic already output.
/// The kstat_id changed underneath us, start over.
/// Unrecoverable error, diagnostic already output.
/// The kstat_id changed underneath us, start over.
/// Because the kstat chain can change dynamically,
/// watch the chain ID and restart the walk if the ID
/// differs from what we saw during the walk. The restart
/// is done by breaking from the cycle with kstat_ not 0.
/// This return value restarts the walk as described above.
/// Just return and let the calling FOR loop advance.
/// Guard against overflow.
/* defined (ACE_HAS_KSTAT) */
/// Create a query and a counter here so it doesn't have
/// to be done with each update.
/* defined (ACE_HAS_WIN32_PDH) */
/// Create a string which is a concatentation of the path
/// name of each 'instance' we need to monitor.
/// Create a regular Windows monitor for each path name.
/// Destroy the single instance monitors created in the constructor.
/// Sum the values of each single instance monitor.
/// Sum the values of each single instance monitor.
/* defined (ACE_HAS_WIN32_PDH) */
// QoS_Decorator.cpp
// Constructor.
// Constructor.
// Destructor.
// Forward the call to ACE_Event_Handler component.
// Forward the call to ACE_Event_Handler component.
// Forward the call to ACE_Event_Handler component.
// Constructor.
// Constructor.
// Destructor.
// Implements the undecorated functionality. This is sufficient for
// GQoS. RAPI needs additional QoS decoration. This is done by the
// ACE_QoS_Event_Handler class.
// Implements the undecorated functionality. This is sufficient for
// GQoS. RAPI needs additional QoS decoration. This is done by the
// ACE_QoS_Event_Handler class.
// Implements the undecorated functionality. This is sufficient for
// GQoS. RAPI needs additional QoS decoration. This is done by the
// ACE_QoS_Event_Handler class.
// This method registers the RAPI QoS event handler with the reactor
// if the application is using RAPI. Note that it is a no-op for GQoS
// because an extra socket for handling QoS events is not required.
// Pass the QoS session to QoS Event Handler.
// Register the QoS Event Handler with the Reactor.
// Constructor.
// Constructor.
// Destructor.
// Set the QoS session.
// Returns the RAPI file descriptor for listening to RAPI evnets.
// Note, here the handle_input () calls the handle_qos () of the
// Decorator Base which then calls handle_qos () of the
// ACE_Event_Handler component within it. This helps to translate the
// normal read events into qos events in case of RAPI so the
// application using the API is oblivious to the fact that in RAPI,
// QoS events are received on a different socket. This helps to
// maintain a uniform design for the application irrespective of
// whether it is using RAPI or GQoS.
// QoS_Manager.cpp
// Adds the given session to the list of session objects joined by
// this socket.
// Returns the QoS session set for this socket.
// QoS_Session_Factory.cpp
/* ACE_HAS_RAPI */
// Create a QoS session of the given type (RAPI or GQoS).
/* ACE_HAS_RAPI */
// Destroy the QoS Session.
// Add a session to the set of sessions created by this factory. This is a
// private method called by the create_session ().
// Remove a session from the set of sessions created by this factory. This is
// a private method called by the destroy_session ().
// QoS_Session_Impl.cpp
/* __ACE_INLINE__ */
// Call back function used by RAPI to report RSVP events. This
// function translates the RAPI QoS parameters into the more generic
// ACE_QoS parameters for the underlying RAPI session.
/* sid */,
/* style_id */,
/* errflags */,
/* filter_spec_no */,
/* filter_spec_list */,
/* ad_spec_no */,
/* ad_spec_list */,
// Extended Legacy format.
// Set the sending flowspec QoS of the given session.
// Choose based on the service type : [QOS_GUARANTEEDX/QOS_CNTR_LOAD].
// Slack term in MICROSECONDS
// @@How does the guaranteed rate parameter map to the ACE_Flow_Spec.
// Note there is no break !!
// qos_service_type.
// Token Bucket Average Rate (B/s)
// Token Bucket Rate (B)
// Peak Data Rate (B/s)
// Minimum Policed Unit (B)
// Max Packet Size (B)
// Set the updated ACE_QoS for the RSVP callback argument(QoS session).
// @@ what is the meaning of the return value. RAPI docs don't say anything!
// Constructor.
//this->source_port (DEFAULT_SOURCE_SENDER_PORT);
// Open a RAPI QoS session [dest IP, dest port, Protocol ID].
// Open a RAPI session. Note "this" is being passed as an argument to
// the callback function. The callback function uses this argument to
// update the QoS of this session based on the RSVP event it receives.
// Close the RAPI QoS Session.
//Get the most recent RSVP event that occurred
//Set the most recent RSVP event that occurred
/* socket */,
/* qos_manager */,
// If sender : call sending_qos ()
// If receiver : call receiving_qos ()
// If both : call sending_qos () and receiving_qos ()
// Set sending QoS for this RAPI session.
// This formats the t_spec in a visually intuitive char * that can
// be printed.
// Print out all the fields separately.
// This the source sender port.
//  ACE_INET_Addr sender_addr (this->source_port ());
// Set the Sender TSpec for this QoS session.
/*
// Set receiving QoS for this RAPI session.
// Setting the RAPI_REQ_CONFIRM flag requests confirmation
// of the resevation, by means of a confirmation upcall of
// type RAPI_RESV_CONFIRM.
//                   (sockaddr *)receiver_addr.get_addr (),
// This applies the flowspec to all the senders. Given this,
// @@I am passing the filter_spec to be null, hoping this will work.
// The filter spec is NULL. This should work since the RSTYLE is
// WILDCARD.
// This formats the flow_spec in a visually intuitive char * that can
// be printed.
// Print out all the fields separately.
// Set the Receiver FlowSpec for this QoS session.
// @@The filter style is hardcoded to WildCard. This can be changed later.
// Setting the RAPI_REQ_CONFIRM flag requests confirmation
// of the resevation, by means of a confirmation upcall of
// type RAPI_RESV_CONFIRM.
//                   (sockaddr *)receiver_addr.get_addr (),
// This applies the flowspec to all the senders. Given this,
// @@I am passing the filter_spec to be null, hoping this will work.
// The filter spec is NULL. This should work since the RSTYLE is
// WILDCARD.
// Update the session QoS Parameters based on the RSVP Event Received.
// Construct a simplified RAPI Sender TSpec object
// from an ACE_Flow_Spec. Note the form of the TSpec is
// simplified as against the full bodied IntServ version.
// There may be some type incompatibility here.
// Note the types of the LHS are float32_t, uint32_t etc.
//QOS_TSPEC;
// Token Rate (B/s)
// Token Bucket Depth (B)
// Peak Data Rate (B/s)
// Minimum policed unit.
// Maximum SDU size.
// Construct a simplified RAPI flowspec object from ACE_Flow_Spec.
// Note the form of the FlowSpec is simplified as against the
// full bodied IntServ version.
// Extended Legacy format.
// Choose based on the service type : [QOS_GUARANTEEDX/QOS_CNTR_LOAD].
// Guaranteed Rate B/s. @@How does this map to the
// ACE Flow Spec Parameters.
// Slack term in MICROSECONDS
// Note there is no break !!
// qos_service_type
// Token Bucket Average Rate (B/s)
// Token Bucket Rate (B)
// Peak Data Rate (B/s)
// Minimum Policed Unit (B)
// Max Packet Size (B)
/* ACE_HAS_RAPI */
// This is a GQoS session ID generator.
// Constructor.
// Open a GQoS session [dest IP, dest port, Protocol ID].
// Close the GQoS Session.
// TBD.
// Set the QoS for this GQoS session.
// Confirm if the current session is one of the QoS sessions
// subscribed to by the given socket.
// Set the QOS according to the supplied ACE_QoS. The I/O control
// code used under the hood is SIO_SET_QOS.
// WSAIoctl (GET_QOS) call goes here...
//Get the most recent RSVP event that occurred
//Set the most recent RSVP event that occurred
// needed for subscribe_ifs()
/* ACE_WIN32 */
/* __ACE_INLINE__ */
// This is a workaround for platforms with non-standard
// definitions of the ip_mreq structure
/* ! defined (IMR_MULTIADDR) */
// Dummy default constructor...
// Only perform the <open> initialization if we haven't been opened
// earlier.
// Windows NT's winsock has trouble with multicast subscribes in the
// presence of multiple network interfaces when the IP address is
// given as INADDR_ANY.  It will pick the first interface and only
// accept mcast there.  So, to work around this, cycle through all
// of the interfaces known and subscribe to all the non-loopback
// ones.
//
// Note that this only needs to be done on NT, but there's no way to
// tell at this point if the code will be running on NT - only if it
// is compiled for NT-only or for NT/95, and that doesn't really
// help us.  It doesn't hurt to do this on Win95, it's just a little
// slower than it normally would be.
//
// NOTE - <ACE_Sock_Connect::get_ip_interfaces> doesn't always get all
// of the interfaces.  In particular, it may not get a PPP interface.  This
// is a limitation of the way <ACE_Sock_Connect::get_ip_interfaces> works
// with MSVC.  The reliable way of getting the interface list is
// available only with MSVC 5.
// Iterate through all the interfaces, figure out which ones
// offer multicast service, and subscribe to them.
// Convert to 0-based for indexing, next loop check.
// 1 indicates a "short-circuit" return.  This handles the
// rather bizarre semantics of checking all the interfaces on
// NT.
/* ACE_WIN32 */
// Otherwise, do it like everyone else...
// Create multicast request.
// The following method call only applies to Win32 currently.
// Check for the "short-circuit" return value of 1 (for NT).
// Tell network device driver to read datagrams with a
// <mcast_request_if_> IP interface.
// Check if the mcast_addr passed into this method is the
// same as the QoS session address.
// Subscribe to the QoS session.
// XX This is windows stuff only. fredk
// Must be called with lock held
// Must be called with lock held
// When the ACE_Select_Reactor is constructed it creates the notify
// pipe and registers it with the register_handler_i() method. The
// QtReactor overloads this method BUT because the
// register_handler_i occurs when constructing the base class
// ACE_Select_Reactor, the ACE_Select_Reactor register_handler_i()
// is called not the QtReactor register_handler_i().  This means
// that the notify pipe is registered with the ACE_Select_Reactor
// event handling code not the QtReactor and so notfications don't
// work.  To get around this we simply close and re-opened the
// notification handler in the constructor of the QtReactor.
// Patch for MS Windows: close and open doesn't clear the read
// fd_set, so reset it manually
/* ACE_MT_SAFE */
// iterate over QSocketNotifiers for read and release them
// QOBject destructor notifies qapplication (hopefully) on delete
// iterate over QSocketNotifiers for write and release them
// QOBject destructor notifies qapplication (hopefully) on delete
// iterate over QSocketNotifiers for exceptions and release them
// QOBject destructor notifies qapplication (hopefully) on delete
// QOBject destructor notifies qapplication (hopefully) on delete
// reparent QSocketNotifiers and QTimer
// Deal with any timer events
// Set next timeout signal
// The argument passed to the Qt slot method is ignored due to this bug:
// https://bugreports.qt.io/browse/QTBUG-70441
// disable socket notifier to clear pending events
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// The core of read event handling
// enable socket notifier according to current mask
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// disable socket notifier to clear pending events
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// The core of write event handling
// enable socket notifier according to current mask
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// disable socket notifier to clear pending events
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// The core of exception event handling
// enable socket notifier according to current mask
/* ACE_QTREACTOR_CLEAR_PENDING_EVENTS  */
// Find the current notifier
// Call regular bit_ops
// disable or enable the notifiers based on handle_set and mask
// We have no work to do here, so just return
// Enable or disable notifiers based on the specified masks
// We can't just return -1 here because we'll have half-changed things.
// So, we need to restore the old handle_set, then return -1.
// we take no action for any other operations
// if there is already a read socket notifier for this handle, do nothing
// otherwise create read notifier
// disable; it will be enabled by the regular register_handler_i if
// necessary
// if there is already a write socket notifier for this handle, do nothing
// otherwise create read notifier
// disable; it will be enabled by the regular register_handler_i if
// necessary
// if there is already a write socket notifier for this handle, do nothing
// otherwise create read notifier
// disable; it will be enabled by the regular register_handler_i if
// necessary
// Looks for the handle in the maps and removes them.
// destroy notifiers only when there is no handler for handle
// destroy notifiers only when there is no handler for handle
// The following functions ensure that there is an Qt timeout for the
// first timeout in the Reactor's Timer_Queue.
// mbrudka: who needs QtWaitForMultipleEvents? It seems it's cargo load now!
/*max_wait_time*/)
// Keep a copy of the wait set in case the wait_set be changed
// between the two select calls in this function. It could happen
// while waiting for an event, another event is handled and dispatched
// which changes the dispatch_set_/wait_set.
// Check to make sure our handle's are all usable.
// Bad file arguments...
// Qt processing.
// Reset the width, in case it changed during the upcalls.
// Now actually read the result needed by the <Select_Reactor> using
// <select>.
// mbrudka: who needs wait_for_multiple_events? It seems it's cargo load now!
/* ACE_WIN32 */
// Timed out or input available
// -*- C++ -*-
/* ACE_HAS_VERSIONED_NAMESPACE == 1 */
/**
//@{
//@}
// BIO_TYPE_PROXY_SERVER,
/* ACE_ASYNCH_BIO_GETS_NAME, */
/* !BIO_set_flags */
/* OPENSSL_VERSION_NUMBER < 0x10100000L */
/**
// not initialized
// still zero ( we can use it )
// will be pointer to ACE_SSL_Asynch_Stream
/* OPENSSL_VERSION_NUMBER > 0x0090581fL && (ACE_WIN32 || ACE_HAS_AIO_CALLS) */
// This only works on platforms with Asynchronous IO support.
/* ACE_WIN32 */
/* __ACE_INLINE__ */
// act,
// Offset
// OffsetHigh
// Priority
//signal_number
/* bytes_transferred */,
/* success */,
/* completion_key */,
/* error */)
// ************************************************************
//  ACE_SSL_Asynch_Stream Constructor / Destructor
// ************************************************************
// was honestly copied from ACE_SSL_SOCK_Stream :)
// It is safe to delete stream if all notifications are received,
// i.e., state is SF_DELETE_ENABLE or if proactor event loop is
// done.
// open
// but ..
// Was honestly copied from ACE_SSL_SOCK_Stream :)
// @@ Question: should we reference count the Context object or
// leave that to the application developer? We do not reference
// count reactors (for example) and following some simple rules
// seems to work fine!
// ************************************************************
//  close ()
//  returns :
//  0  - Stream is in the state SF_DELETE_ENABLE,
//       so  it is safe to delete stream
//  -1 - Stream has pending AIO requests,
//       close should be repeated later one more
// ************************************************************
// not open
// ************************************************************
//  Asynch_Operation interface
//    cancel
// ************************************************************
// not open
//   AIO_ALLDONE
// attempt to cancel internal, i.e. user's read/write
// attempt to cancel external, i.e. bio_ssl read/write
// at least one error
// AIO_ALLDONE
// AIO_NOT_CANCELED , at least one not canceled
// AIO_CANCELED, at least will be one notification
// ************************************************************
//  Asynch_Operation interface
//    open
// ************************************************************
// Get a proactor for/from the user.
// Open internal input stream
// real callbacks to this
// Open internal output stream
// real callbacks to this
// ************************************************************
//  Asynch_Operation interface
//    read
// ************************************************************
// not open
// only one read operation is allowed now
// later it will be possible to make a queue
// create result for future notification
// ignore return code
// ************************************************************
//  Asynch_Operation interface
//    write
// ************************************************************
// not open
// only one read operation is allowed now
// later it will be possible to make a queue
// create result for future notification
// ************************************************************
//  Main SSL engine
// ************************************************************
// this protected member should be called
// with locked mutex_
// handshake in progress ?
// execute user read request
// execute user write request
// Do we have any errors
// ************************************************************
// do_SSL_shutdown
// return code:
// 1   SSL shutdown is finished already, success
// 0   SSL shutdown in progress
// -1  failure
// ************************************************************
// already done
// if we have any uncompleted user requests
// than cancel its
//   case SSL_ERROR_WANT_ACCEPT:
// ************************************************************
// Do SSL handshake if necessary
// return code:
// 1   SSL handshake is finished already, success
// 0   SSL handshake in progress
// -1  failure
// ************************************************************
//case SSL_ERROR_WANT_ACCEPT:
// ************************************************************
// Perform SSL_read call if necessary and notify user
// ************************************************************
// nothing to do
// If not an EOF, then fall through to "default" case.
// ************************************************************
// Perform SSL_write call if necessary  and notify user
// ************************************************************
// nothing to do
// ************************************************************
//  notify external user handler that
//  it is now to safe destroy stream
//  Return code  looks like cancel() return code
//  0  - notified               NOTIFIED
//  1  - nothing to notify      ALLDONE
//  2  - unable to notify       NOT NOTIFIED
// ************************************************************
// already sent
// only after shutdown
// too early , we will do later
// wait for all internal IO
// too early , we will do later
// create result for future notification
//@@ Not exception safe!
// ************************************************************
//  notify external user handler about user write completion
//  Return code  looks like cancel() return code
//  0  - notified               NOTIFIED/CANCELED
//  1  - nothing to notify      ALLDONE
//  2  - unable to notify       NOT NOTIFIED/CANCELED
// ************************************************************
//nothing to notify
// success
// unable to notify
// ************************************************************
//  notify external user handler about user write completion
//  Return code  looks like cancel() return code
//  0  - notified               NOTIFIED/CANCELED
//  1  - nothing to notify      ALLDONE
//  2  - unable to notify       NOT NOTIFIED/CANCELED
// ************************************************************
//nothing to notify
// success
// unable to notify
// ************************************************************
// Print SSL errors
// ************************************************************
// OpenSSL < 0.9.6a doesn't have ERR_error_string_n() function.
/* OPENSSL_VERSION_NUMBER */
// ************************************************************
//  BIO helper functions
//  SSL library will ask BIO to do raw I/O
//  BIO will call us to do this
// ************************************************************
// We do not have to acquire mutex
// as we called already with locked mutex
// from do_SSL_state_machine()
// there are more data buffered
// go ahead
// if was error - it is permanent !
// End of stream
// SSL will try later
// we are busy
// message block
// priority
// act
// priority
// default signal
// may be leave EINPROGRESS ??
// to try later
// AIO is active
// We do not have to acquire mutex
// as we called already with locked mutex
// from do_SSL_state_machine
// sorry, we are busy
// try later
// no recovery
// message block
// priority
// act
// priority
// default signal
// may be leave EINPROGRESS ??
// to try later
// AIO is active
// Ok, go ahead
// ************************************************************
//  Internal IO handlers
//  virtual from ACE_Service_Handler
// ************************************************************
// error ?
// save err code
// TCP/IP overloaded ?
// continue, rd_ptr at right place
// message block
// priority
// act
// priority
// default signal
// error ?
// save err code
// end of stream ?
// set flag EOS
/* OPENSSL_VERSION_NUMBER > 0x0090581fL && (ACE_WIN32 ||
/* __ACE_INLINE__ */
/* ACE_HAS_THREADS */
/// Reference count of the number of times the ACE_SSL_Context was
/// initialized.
// @@ This should also be done with a singleton, otherwise it is not
//    thread safe and/or portable to some weird platforms...
/// Array of mutexes used internally by OpenSSL when the SSL
/// application is multithreaded.
// @@ This should also be managed by a singleton.
/* ACE_HAS_THREADS && OPENSSL_VERSION_NUMBER < 0x10100000L */
/* ACE_HAS_VERSIONED_NAMESPACE == 1 */
/* file */,
/* line */)
// #ifdef undef
//   fprintf(stderr,"thread=%4d mode=%s lock=%s %s:%d\n",
//           CRYPTO_thread_id(),
//           (mode&CRYPTO_LOCK)?"l":"u",
//           (type&CRYPTO_READ)?"r":"w",file,line);
// #endif
//   /*
/*
//     fprintf(stderr,"(t,m,f,l) %ld %d %s %d\n",
//     CRYPTO_thread_id(),
//     mode,file,line);
//   */
// -------------------------------
// Return the current thread ID.  OpenSSL uses this on platforms
// that need it.
/* ACE_HAS_THREADS && (OPENSSL_VERSION_NUMBER < 0x10100000L) */
// ****************************************************************
/* ACE_HAS_THREADS  && (OPENSSL_VERSION_NUMBER < 0x10100000L) */
// Initialize the locking callbacks before initializing anything
// else.
// This call isn't necessary on some platforms.  See the CRYPTO
// library's threads(3) man page for details.
/* !WIN32 */
/* ACE_HAS_THREADS && OPENSSL_VERSION_NUMBER < 0x10100000L */
// Seed the random number generator.  Note that the random
// number generator can be seeded more than once to "stir" its
// state.
// Seed the random number generator by sampling the screen.
/* OPENSSL_VERSION_NUMBER < 0x10100000L */
/* WIN32 */
// OpenSSL < 0.9.5 doesn't have EGD support.
/* OPENSSL_VERSION_NUMBER */
// Initialize the mutexes that will be used by the SSL and
// crypto library.
// Clean up the locking callbacks after everything else has been
// cleaned up.
/* ACE_HAS_THREADS &&  */
/* OPENSSL_VERSION_NUMBER < 0x10100000L */
// Load the trusted certificate authority (default) certificate
// locations. But do not return -1 on error, doing so confuses CTX
// allocation (severe error) with the less important loading of CA
// certificate location error.  If it is important for your
// application then call ACE_SSL_Context::have_trusted_ca(),
// immediately following this call to set_mode().
/* SSL_OP_NO_SSLv2 */
/* SSL_OP_NO_SSLv3 */
/* SSL_OP_NO_TLSv1 */
/* SSL_OP_NO_TLSv1_1 */
/* SSL_OP_NO_TLSv1_2 */
/* OPENSSL_VERSION_NUMBER */
// Use the default environment settings.
// Use the default environment settings.
// NOTE: SSL_CTX_load_verify_locations() returns 0 on error.
// For TLS/SSL servers scan all certificates in ca_file and ca_dir and
// list them as acceptable CAs when requesting a client certificate.
// Note: The STACK_OF(X509_NAME) pointer is a copy of the pointer in
// the CTX; any changes to it by way of these function calls will
// change the CTX directly.
// Add CAs from both the file and dir, if specified. There should
// already be a STACK_OF(X509_NAME) in the CTX, but if not, we create
// one.
// Add new certificate names to the list.
// SSL_add_dir_cert_subjects_to_stack is defined at 0.9.8a (but not
// on OpenVMS or Mac Classic); it may be available earlier. Change
// this comparison if so. It's still (1.0.1g) broken on windows too.
/* !OPENSSL_SYS_WIN32 */
/* !OPENSSL_SYS_VMS && !OPENSSL_SYS_MACINTOSH_CLASSIC */
/* OPENSSL_VERSION_NUMBER >= 0.9.8a release */
// Is it really a good idea to return 0 if we're not setting the
// certificate?
// No file is associated with the certificate, set this to a fictional
// value so we don't reset it later.
// Setup the peer verififcation mode.
// set the default verify mode
// Set the max certificate depth but later let the verify_callback
// catch the depth error by adding one to the required depth.
// RAND_status() returns 1 if the PRNG has enough entropy.
// Ugly, but OpenSSL <= 0.9.4 doesn't have RAND_status().
/* OPENSSL_VERSION_NUMBER >= 0x00905100L */
// OpenSSL < 0.9.5 doesn't have EGD support. OpenSSL 1.1 and newer
// disable egd by default
// RAND_egd() returns the amount of entropy used to seed the random
// number generator.  The actual value should be greater than 16,
// i.e. 128 bits.
/* OPENSSL_VERSION_NUMBER < 0x00905100L */
// RAND_load_file() returns the number of bytes used to seed the
// random number generator. If the file reads ok, check RAND_status to
// see if it got enough entropy.
// RAND_status() returns 1 if the PRNG has enough entropy.
// Ugly, but OpenSSL <= 0.9.4 doesn't have RAND_status().
/* OPENSSL_VERSION_NUMBER >= 0x00905100L */
// OpenSSL < 0.9.6a doesn't have ERR_error_string_n() function.
/* OPENSSL_VERSION_NUMBER >= 0x0090601fL */
/* OPENSSL_VERSION_NUMBER >= 0x0090601fL */
// For now we only support PEM encodings
// Swiped from Rescorla's examples and the OpenSSL s_server.c app
// ****************************************************************
// Initialize ACE_SSL_Context singleton.
// Explicitly close the ACE_SSL_Context singleton.
/* __ACE_INLINE__ */
/* SIGURG */
/* SIGURG */
// -*- C++ -*-
/* __ACE_INLINE__ */
// We're going to call SSL_accept, optionally doing ACE::select and
// retrying the SSL_accept, until the SSL handshake is done or
// it fails.
// To get the timeout affect, set the socket to nonblocking mode
// before beginning if there is a timeout specified. If the timeout
// is 0 (wait as long as it takes) then don't worry about the blocking
// status; we'll block in SSL_accept if the socket is blocking, and
// block in ACE::select if not.
// Set the handle into non-blocking mode if it's not already
// in it.
// Take into account the time between each select() call below.
// These handle sets are used to set up for whatever SSL_accept
// says it wants next. They're reset on each pass around the loop.
// To tell caller about success
// Done
// Wait for more activity
// Wait for more activity
// The peer has notified us that it is shutting down via
// the SSL "close_notify" message so we need to
// shutdown, too.
// On some platforms (e.g. MS Windows) OpenSSL does not
// store the last error in errno so explicitly do so.
//
// Explicitly check for EWOULDBLOCK since it doesn't get
// converted to an SSL_ERROR_WANT_{READ,WRITE} on some
// platforms. If SSL_accept failed outright, though, don't
// bother checking more. This can happen if the socket gets
// closed during the handshake.
// Although the SSL_ERROR_WANT_READ/WRITE isn't getting
// set correctly, the read/write state should be valid.
// Use that to decide what to do.
// Wait for more activity
// Doesn't want anything - bail out
// Must have at least one handle to wait for at this point.
// 0 is timeout, so we're done.
// -1 is error, so we're done.
// Could be both handles set (same handle in both masks) so
// set to 1.
// Timeout or failure
// General purpose routine for accepting new connections.
// Since our underlying acceptor is of the plain old ACE_SOCK_Acceptor
// variety, get the basic socket setup done with it, then take care of
// the SSL handshake if the socket is accepted.
// Take into account the time to complete the basic TCP handshake
// and the SSL handshake.
// Take into account the time to complete the basic TCP handshake
// and the SSL handshake.
// -*- C++ -*-
/* __ACE_INLINE__ */
// Check if a connection is already pending for the given SSL
// structure.
// We're going to call SSL_connect, optionally doing ACE::select and
// retrying the SSL_connect, until the SSL handshake is done or
// it fails.
// To get the timeout affect, set the socket to nonblocking mode
// before beginning if there is a timeout specified. If the timeout
// is 0 (wait as long as it takes) then don't worry about the blocking
// status; we'll block in SSL_connect if the socket is blocking, and
// block in ACE::select if not.
// Set the handle into non-blocking mode if it's not already
// in it.
// Need a non-const copy.
// Take into account the time between each select() call below.
// These handle sets are used to set up for whatever SSL_connect
// says it wants next. They're reset on each pass around the loop.
// Start out with non-blocking disabled on the SSL stream.
// To tell caller about success
// Done
// Wait for more activity
// Wait for more activity
// The peer has notified us that it is shutting down via
// the SSL "close_notify" message so we need to
// shutdown, too.
// On some platforms (e.g. MS Windows) OpenSSL does not
// store the last error in errno so explicitly do so.
//
// Explicitly check for EWOULDBLOCK since it doesn't get
// converted to an SSL_ERROR_WANT_{READ,WRITE} on some
// platforms. If SSL_connect failed outright, though, don't
// bother checking more. This can happen if the socket gets
// closed during the handshake.
// Although the SSL_ERROR_WANT_READ/WRITE isn't getting
// set correctly, the read/write state should be valid.
// Use that to decide what to do.
// Wait for more activity
// Doesn't want anything - bail out
// Must have at least one handle to wait for at this point.
// Block indefinitely if timeout pointer is zero.
// 0 is timeout, so we're done.
// -1 is error, so we're done.
// Could be both handles set (same handle in both masks) so set to 1.
// Timeout or socket failure
// Take into account the time to complete the basic TCP handshake
// and the SSL handshake.
// Save us some TSS accesses.
// Obtain the handle from the underlying SOCK_Stream and set it in
// the SSL_SOCK_Stream.  Note that the case where a connection is in
// progress is also handled.  In that case, the handle must also be
// set in the SSL_SOCK_Stream so that the correct handle is returned
// when performing non-blocking connect()s.
// If using a timeout, update the countdown timer to reflect the time
// spent on the connect itself, then pass the remaining time to
// ssl_connect to bound the time on the handshake.
// Take into account the time to complete the basic TCP handshake
// and the SSL handshake.
// Save us some TSS accesses.
// Obtain the handle from the underlying SOCK_Stream and set it in
// the SSL_SOCK_Stream.  Note that the case where a connection is in
// progress is also handled.  In that case, the handle must also be
// set in the SSL_SOCK_Stream so that the correct handle is returned
// when performing non-blocking connect()s.
// If using a timeout, update the countdown timer to reflect the time
// spent on the connect itself, then pass the remaining time to
// ssl_connect to bound the time on the handshake.
// Try to complete a non-blocking connection.
// Take into account the time to complete the basic TCP handshake
// and the SSL handshake.
// Only attempt to complete the TCP connection if it that hasn't
// already been done.
// The handle in the SSL_SOCK_Stream should have already been set in
// the connect() method.
// If using a timeout, update the countdown timer to reflect the time
// spent on the connect itself, then pass the remaining time to
// ssl_connect to bound the time on the handshake.
/* __ACE_INLINE__ */
// @@ Question: should we reference count the Context object or
// leave that to the application developer? We do not reference
// count reactors (for example) and following some simple rules
// seems to work fine!
// There is subtle problem in this method that occurs when using
// non-blocking IO.  The semantics of a non-blocking scatter write
// (sendv()) are not possible to retain with the emulation in this
// method.
// Make a copy since ACE_Countdown_Time modifies the
// ACE_Time_Value.
// Take into account the time between each send.
// There is a subtle difference in behaviour depending on
// whether or not any data was sent.  If no data was sent,
// then always return -1.  Otherwise return bytes_sent.
// This gives the caller an opportunity to keep track of
// Do not continue on to the next loop iteration if the
// amount of data sent was less than the amount data given.
// This avoids a subtle problem where "holes" in the data
// stream would occur if partial sends of a given buffer in
// the iovec array occurred.
// From ACE_SOCK_IO::recvv().
// Check the status of the current socket.
/* NOTREACHED */
/* NOTREACHED */
// Goes fine, fallthrough to get data
/* FIONREAD */
// If SSL has data in the buffer, i.e. SSL_pending() returns a
// non-zero value, then don't block on select().
// NOTE: This method used to fill an IO vector (e.g. iovec) and then
//       send it using a scatter write (sendv()).  However, it is
//       not possible to emulate a non-blocking scatter write over
//       SSL.  As such, there is no point in attempting to use
//       scatter writes over SSL.
// There is a subtle difference in behaviour depending on
// whether or not any data was sent.  If no data was sent,
// then always return -1.  Otherwise return bytes_sent.
// This gives the caller an opportunity to keep track of
// which data was actually sent.
// Do not continue on to the next loop iteration if the
// amount of data sent was less than the amount of data
// given.  This avoids a subtle problem where "holes" in the
// data stream would occur if partial sends of a given
// buffer in the varargs occurred.
// There is a subtle difference in behaviour depending on
// whether or not any data was received.  If no data was
// received, then always return -1.  Otherwise return
// bytes_received.  This gives the caller an opportunity to
// keep track of which data was actually received.
// Do not continue on to the next loop iteration if the
// amount of data received was less than the amount of data
// desired.  This avoids a subtle problem where "holes" in
// the data stream would occur if partial receives of a
// given buffer in the varargs occurred.
// No support for send flags in SSL.
/* This code mimics ACE::send_n */
// Total number of bytes written.
// Actual number of bytes written in each <send> attempt
// If blocked, try again.
// Send flags are unsupported in SSL
/*  The following code mimics <ACE::send_n> */
// There is a subtle difference in behaviour depending on
// whether or not any data was sent.  If no data was sent,
// then always return -1.  Otherwise return bytes_sent.
// This gives the caller an opportunity to keep track of
// which data was actually sent.
// There is a subtle difference in behaviour depending on
// whether or not any data was read.  If no data was read,
// then always return -1.  Otherwise return bytes_read.
// This gives the caller an opportunity to keep track of
// which data was actually read.
// Some applications use get_remote_addr() as a way of determining
// whether or not a connection has been established.  In SSL's case,
// the remote addr will be available once the TCP handshake has been
// complete.  Despite that fact, the SSL connection may not have
// been completed.  In such a case, a successful return from
// get_remote_addr() would be misleading.
// Must be called with lock held
// When the ACE_Select_Reactor is constructed it creates the notify
// pipe and registers it with the register_handler_i() method. The
// TkReactor overloads this method BUT because the
// register_handler_i occurs when constructing the base class
// ACE_Select_Reactor, the ACE_Select_Reactor register_handler_i()
// is called not the TkReactor register_handler_i().  This means
// that the notify pipe is registered with the ACE_Select_Reactor
// event handling code not the TkReactor and so notfications don't
// work.  To get around this we simply close and re-opened the
// notification handler in the constructor of the TkReactor.
/* ACE_MT_SAFE */
// Delete the remaining items in the linked list.
// This is just the <wait_for_multiple_events> from ace/Reactor.cpp
// but we use the Tk functions to wait for an event, not <select>
/* ACE_WIN32 */
// Timed out or input available
// Deal with any timer events
/**
/* mask */)
// my copy isn't const.
// Deal with one file event.
// - read which kind of event
// - Use only that one file event (removes events for other files).
// Check to make sure our handle's are all usable.
// Bad file arguments...
// Instead of waiting using <select>, just use the Tk mechanism to
// wait for a single event.
// Wait for something to happen.
// Reset the width, in case it changed during the upcalls.
// Now actually read the result needed by the <Select_Reactor> using
// <select>.
// connected, you may write
// connected, you have data/err
// connected, you may write
// connected, you have data/err
/* !ACE_WIN32 */
// In the registration phase we registered first with
// ACE_Select_Reactor and then with X.  Now we are now doing things
// in reverse order.
// First clean up the corresponding X11Input.
// Now let the reactor do its work.
// The following functions ensure that there is an Tk timeout for the
// first timeout in the Reactor's Timer_Queue.
// On unicode windows, ACE_TCHAR == XMLCh
// idiots?
// Must be called with lock held
// When the ACE_Select_Reactor is constructed it creates the notify
// pipe and registers it with the register_handler_i() method. The
// XtReactor overloads this method BUT because the
// register_handler_i occurs when constructing the base class
// ACE_Select_Reactor, the ACE_Select_Reactor register_handler_i()
// is called not the XtReactor register_handler_i().  This means
// that the notify pipe is registered with the ACE_Select_Reactor
// event handling code not the XtReactor and so notfications don't
// work.  To get around this we simply close and re-opened the
// notification handler in the constructor of the XtReactor.
/* ACE_MT_SAFE */
// Delete the remaining items in the linked list.
// This is just the <wait_for_multiple_events> from ace/Reactor.cpp
// but we use the Xt functions to wait for an event, not <select>
/* ACE_WIN32 */
// Timed out or input available
/* id */)
// Deal with any timer events
// This could be made shorter if we know which *kind* of event we were
// about to get.  Here we use <select> to find out which one might be
// available.
// my copy isn't const.
// Deal with one file event.
// - read which kind of event
// - Use only that one file event (removes events for other files).
// Make sure we have a valid context
// Check to make sure our handle's are all usable.
// Bad file arguments...
// Instead of waiting using <select>, just use the Xt mechanism to
// wait for a single event.
// Wait for something to happen.
// Reset the width, in case it changed during the upcalls.
// Now actually read the result needed by the <Select_Reactor> using
// <select>.
// Make sure we have a valid context
// Let's handle this special case before we do any real work.
/* ACE_WIN32 */
// The idea here is to call this function after the base class has
// processed the register/remove/suspend/resume_handler request. The
// resulting mask is used to find out which XtInput mask we need.
// Find existing handler in linked list.
// Remove existing input handler.
// No input handler needed.
// Remove linked list entry.
// Create new node.
// Finally, add input handler.
// Retrieve current wait mask from base class.
// The returned value is either a combination of READ/WRITE/EXCEPT_MASK
// or -1.
// No active mask.
// EXCEPT_MASK is not supported for WIN32. As this was
// already handled in register_handler_i, no check here.
/* !ACE_WIN32 */
// The following functions ensure that there is an Xt timeout for the
// first timeout in the Reactor's Timer_Queue.
// Make sure we have a valid context
/**
//graphics.cs.williams.edu
// Low, medium, and high along the chosen axis
// Copy over this box.
// Now move the split points along the special axis
// Choose evenly between positive and negative face planes
// The probability of choosing a given face is proportional to
// its area.
// Must be overlap along all three axes.
// Try to find a separating axis.
//     |--------|
// |------|
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// We can early-out only if we have found one point on each
// side of the plane (i.e. if we are straddling).  That
// occurs when (numContained < v) && (numContained > 0)
// Unrolling these 3 if's into a switch decreases performance
// by about 2x
// this branch is highly predictable
// Plane p culled the box
// The caller should not recurse into the children,
// since the parent is culled.  If they do recurse,
// make them only test against this one plane, which
// will immediately cull the volume.
// The bounding volume straddled the plane; we have
// to keep testing against this plane
// Move on to the next bit.
// None of the planes could cull this box
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// Assume this plane culls all points.  See if there is a point
// not culled by the plane... early out when at least one point
// is in the positive half space.
// Unrolling these 3 if's into a switch decreases performance
// by about 2x
// this branch is highly predictable
// Plane p culled the box
// Move on to the next bit.
// None of the planes could cull this box
//find the square of the distance
//from the sphere to the box
// default constructor inits all components to 0
/**
// If std::string has a fast hash compare, use it first
// Walk through character-by-character
// Mismatch
// Make sure s ran out no later than n
// Tried to read from a placeholder--throw an exception as if
// the original operator[] had failed.
// No clone needed
// Note that placeholders may be copied; that is ok--they are still
// just placeholders.
// No extra space needed
// We need to allocate space for the worst-case
// If no separator and brackets were provided, substitute defaults
// If no separator and brackets were provided, substitute defaults
// If no separator and brackets were provided, substitute defaults
// Allocate the data object
// Create the (empty) value object at the end of the Data object
// No value
// Destruct but do not deallocate children
// All other types should have a NULL value pointer (i.e., they were used just for name and comment fields)
//////////////////////////////////////////////////////////////
//catches the case of an empty container, where value.t is null
// Don't return true for placeholder objects
// This was the last reference to the shared data
// Copy the data.  We must do this before dropping the reference
// to avoid a race condition
// This is no longer a placeholder
// Forget where this Any was included from...it no
// longer matches the contents there.
// All 3 cases intentionally fall through
// if empty, m_data->value.t will not be initialized as it is unknown whether this is supposed to be an array or a table
// The entry was created by this method; do not allow it to be
// read before it is written.
// Write source data for the value
// Key not found
// Different value
// peek character
// Identify separators
// Skip over this symbol
// This is an illegal character for an identifier, so we need quotes
// Silently fall through
// This value came from a #include...preserve it.  This includes the comment
// if any.
/* %s */\n", m_data->comment.c_str());
// Specials have no legal syntax in JSON, so insert values that will parse 
// to something close to what we want (there is no good solution for NaN, unfortunately)
// Don't put a separator after the last
// Skip an extra line between table entries that are longer than a line
// For arrays, leave no trailing space between the name and the paren
// Probably a long-form array
// Probably a short-form array
// Put the close paren on an array right behind the last element
// Leave no trailing space between the name and the paren
// Parse comments
// Allow comments to contain newlines.
/** True if \a c is an open paren of some form */
/** True if \a c is an open paren of some form */
// Skip newlines and comments
// Restore the last token
// Deallocate old data
// Skip leading newlines
// There should never be a comment without an Any following it; even
// if the file ends with some commented out stuff,
// that should not happen after a comma, so we'd never read that 
// far in a proper file.
// Do we need to read one more token after the end? 
// Pragma, Named Array, Named Table, Array, Table, or NIL
// Pragma
// Currently, "include" is the only pragma allowed
// The string typed into the file, which may be relative
// Find the include file
// Try and find the path, starting with the cwd
// Read the included file
// Update the source information
/* %s */\n", comment.c_str());
// Nothing left to do; we initialized to NIL originally
// Valid unquoted string
// Array or Table
// Parse the name
// s must have at least one element or this would not have
// been parsed as a symbol
// Array or table
// if NIL
// switch
// Array and table already consumed their last token
// Consume
// Update checks
/**
// consumes the open symbol
// consumes tokens and prepares to push them back onto the TextInput
// an '=' indicates a key = value pairing, and thus a table
// any non-comment, non-'=' token after any element indicates an array
// catches no previous element and a closing symbol (e.g [])
// consumes elements, indicating one has been seen, and prepares to push them back onto TextInput
// pushes everything back to the TextInput
// Chose the appropriate close symbol based on the open symbol
// We must set the type before we allocate m_data in ensureData().
// Allocate the underlying data structure
// Consume the open token
// Read any leading comment.  This must be done here (and not in the recursive deserialize
// call) in case the body contains only a comment.
// We're done; this catches the case where the container is empty
// Pointer the value being read
// Read the key
// Consume everything up to the = sign, returning the "=" sign.
// Read the next token, which is the value (don't consume comments--we want the value pointed to by a to get those).
// Prepend the comment we read earlier
// Read until the separator or close paren, discarding trailing comments and newlines
// Consume the separator
// Consume the close paren (to match other deserialize methods)
// namespace G3D
/** Verifies that \a is a TABLE with the given \a name. */
// If an exception is thrown, the destructors will not be 
// invoked automatically.
// If an exception is thrown, the destructors will not be 
// invoked automatically.
// Some entries were unread.  Find them.
// namespace G3D
/**
//graphics.cs.williams.edu
// Allocate space for a lot of buffers.
// This buffer is full
// Intentionally empty; we block deallocate
/**
//graphics.cs.williams.edu
/**
/* G3DFIX: Use ZIP-library only if defined */
/** Helper used by the constructors for decompression */
// Read the decompressed size from the first 4 bytes
// Decompress with zlib
/* G3DFIX: Use ZIP-library only if defined */
// Load from zipfile
// Zipfiles require Unix-style slashes
// TODO: Docs unclear if zip_stat_init is required.
// sets machines up to use MMX, if they want
// Figure out how big the file is and verify that it exists.
// Read the file into memory
// Read only a subset of the file so we don't consume
// all available memory.
// Either the length is fine or the file is compressed
// and requires us to read the whole thing for zlib.
// Try to allocate a small array; not much memory is available.
// Give up if we can't allocate even 1k.
// Ensure NULL termination
// Copy up to the first NULL
// Decompress
// Use the existing buffer as the source, allocate
// a new buffer to use as the destination.
// The file couldn't have better than 500:1 compression
// Load the next section of the file
// The current buffer isn't big enough to hold the chunk we want to read.
// This happens if there was little memory available during the initial constructor
// read but more memory has since been freed.
// Consume a new byte for reading.  We do this at the beginning
// of the loop so that we don't try to read past the end of the file.
// Slide the lowest bit of the bitString into
// the correct position.
// Shift over to the next bit
// Put back the last byte we read
// std::vector optimizes bool in a way that prevents fast reading
// Data structures that are one byte per element can be 
// directly copied, regardles of endian-ness.
// namespace G3D
/**
//graphics.cs.williams.edu
// Largest memory buffer that the system will use for writing to
// disk.  After this (or if the system runs out of memory)
// chunks of the file will be dumped to disk.
//
// Currently 400 MB
// Data structures that are one byte per element can be 
// directly copied, regardles of endian-ness.
//debugPrintf("reallocBuffer(%d, %d)\n", bytes, oldBufferLen);
// We're either writing to memory (in which case we *have* to
// try and allocate) or we've been asked to allocate a
// reasonable size buffer.
// debugPrintf("  realloc(%d)\n", newBufferLen); 
// Realloc failed; we're probably out of memory.  Back out
// the entire call and try to dump some data to disk.
// Realloc succeeded
// Dump the contents to disk.  In order to enable seeking backwards, 
// we keep the last 10 MB in memory.
// We're going to write less than 1/3 of the file;
// give up and just write the whole thing.
//debugPrintf("Writing %d bytes to disk\n", writeBytes);
// Record that we saved this data.
// Shift the unwritten data back appropriately in the buffer.
// *now* we allocate bytes (there should presumably be enough 
// space in the buffer; if not, we'll come back through this 
// code and dump the last 10MB to disk as well.  Note that the 
// bytes > maxBufferLen case above would already have triggered
// if this call couldn't succeed. 
/** Verify ability to write to disk */
// Do not reallocate, just clear the size of the buffer.
// This is the worst-case size, as mandated by zlib
// Save the old buffer and reallocate to the worst-case size
// add space for the 4-byte header
// Write the header containing the old buffer size, which is needed for decompression
// Compress and write after the header
// Free the old data
// Make sure the directory exists.
// +1 is because strlen doesn't count the null
// +1 is because strlen doesn't count the null
// Pad with another NULL
// Write the NULL and count it
// Extract the current bit of value and
// insert it into the current byte
// We've reached the end of this byte
/**
//graphics.cs.williams.edu, Michael Mara
// Single point
// Oriented box
// Aligned box
// Oriented box
// Other state can be reconstructed
// If the extent is infinite along an axis, make the center zero to avoid NaNs
// The corner forms a bit mask (xyz), where a one indicates we should
// add half of the corresponding edge vector from center, and a zero indicates 
// we should subtract it. Note:
// 1 = 001
// 2 = 010
// 4 = 100
// 
// The following bit-hacky code shows this directly:
// return _center + ((_edgeVector[0] * ((i&1) - 0.5) +
//                  _edgeVector[1] * (((i>>1)&1) - 0.5) +
//                  _edgeVector[2] * (((i>>2)&1) - 0.5)));
// This method is implemented as a swtich statement due to being marginally faster than the bit-hack method
// Also, the _center + 0.5f * (...) is repeated every time for similarly speed-based reasons.
//case 7
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// We can early-out only if we have found one point on each
// side of the plane (i.e. if we are straddling).  That
// occurs when (numContained < v) && (numContained > 0)
// Plane p culled the box
// The caller should not recurse into the children,
// since the parent is culled.  If they do recurse,
// make them only test against this one plane, which
// will immediately cull the volume.
// The bounding volume straddled the plane; we have
// to keep testing against this plane
// Move on to the next bit.
// None of the planes could cull this box
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// Assume this plane culls all points.  See if there is a point
// not culled by the plane... early out when at least one point
// is in the positive half space.
// Plane p culled the box
// Move on to the next bit.
// None of the planes could cull this box
// Form axes from three edges, transform the point into that
// space, and perform 3 interval tests
// TODO: Write in a more intuitive way. I left it as it was before after figuring it out, but
// this should make no sense to someone who is just starting to read this code.
// M^-1 * (point - _corner[0]) = point in unit cube's object space
// compute the inverse of M
// Choose evenly between positive and negative face planes
// The probability of choosing a given face is proportional to
// its area.
// namespace
/**
//graphics.cs.williams.edu
// Find the extent of box 2 on m_axisin a
// We have to subtract off the origin
// See if [tMin, tMax] intersects [0, 1]
// There was no intersection along this dimension;
// the boxes cannot possibly overlap.
// There was no dimension along which there is no intersection.
// Therefore the boxes overlap.
// Make the length of each m_axisin = 1/edge length so we know any
// dot product must be less than 1 to fall within the edge.
// w * h
// G3D
/**
//graphics.cs.williams.edu
/**
//graphics.cs.williams.edu
// Sphere volume
// Cylinder volume
// Sphere area
// Cylinder area
// Create a random point on a standard capsule and then rotate to the global frame.
// Relative areas
// Select a point uniformly at random on a sphere
// Side
// Transform to world space
// Create a random point in a standard capsule and then rotate to the global frame.
// Select a point uniformly at random on a disk
// Transform to world space
// namespace
/**
//graphics.cs.williams.edu
//ftp.3dmaileffects.com/pub/FluidStudios/CollisionDetection/Fluid_Studios_Generic_Collision_Detection_for_Games_Using_Ellipsoids.pdf and comments by Max McGuire.  Ray-sphere code by Eric Haines.
// Turn on fast floating-point optimizations
// A0
// A1
// A2
// B0
// B1
// B2
// A0 x B0
// A0 x B1
// A0 x B2
// A1 x B0
// A1 x B1
// A1 x B2
// A2 x B0
// A2 x B1
// A2 x B2
// length between center and each side of box1 and box2
// difference between centers of box1 and box2
// store the value of all possible dot products between the
// axes of box1 and box2, c_{row, col} in the Eberly paper
// corresponds to c[row * 3 + col] for this 9 element array.
//
// c[] holds signed values, ca[] hold absolute values
// store all possible dot products between the axes of box1 and D,
// as well as the axes of box2 and D
// do a quick bounding sphere test because it is relatively
// cheap, (three dot products, two sqrts, and a few others)
// for explanations of the variable please refer to the
// paper and fillSolidBoxSolidBoxInfo()
// check the separating axis from the last time step
// the separating axis from the last time step is still
// valid, the boxes do not intersect
// test if the boxes can be separated by a plane normal to
// any of the three axes of box1, any of the three axes of box2,
// or any of the 9 possible cross products of axes from box1
// and box2
// do not need to check edge-edge cases if any two of
// the axes are parallel
// found a separating axis, the boxes do not intersect
// TODO make accessors for Line that don't make a copy of data
// a = 1.0, c = 1.0
// lines are parallel, choose P0 as one point, find the point
// on line2 that is closest to P0
// lines are not parallel
// check the separating axis from the last time step
// the separating axis from the last time step is still
// valid, the boxes do not intersect
// test if the boxes can be separated by a plane normal to
// any of the three axes of box1, any of the three axes of box2,
// (test 9 possible cross products later)
// found a separating axis, the boxes do not intersect
// keep track of the axis that is least violated
// for each edge-edge case we have to adjust the magnitude of
// penetration since we did not include the dot(L, L) denominator
// that can be smaller than 1.0 for the edge-edge cases.
// run through edge-edge cases to see if we can find a separating axis
// found a separating axis, the boxes do not intersect,
// correct magnitude and return projected distance
// no separating axis found, the boxes do intersect,
// correct the magnitudes of the projectedDistance values
// find the negative penetration value with the smallest magnitude,
// the adjustment done for the edge-edge cases only increases
// magnitude by dividing by a number smaller than 1 and greater than 0
// get final separating axis vector
// set L to be the normal that faces away from box1
// vertex to face collision, find deepest colliding vertex
// L will be the outward facing normal for the faceBox
// find the vertex that is farthest away in the direction
// face normal direction
// return the point half way between the deepest point and the
// contacting face
// edge-edge case, find the two ege lines
// find edge line by finding the edge axis, and the
// other two axes that are closest to the other box
// make lines from the two closest edges, and find
// the points that on each line that are closest to the other
// take the average of the two closest edge points for the final
// contact point
// In its local coordinate frame, the box measures
// 2 * halfExtent[a] along dimesion a.
// Transform the sphere to the box's coordinate frame.
// Find the square of the distance from the sphere to the box
// Distance along each axis from the closest side of the box
// to the sphere center.  Negative values are *inside* the box.
// Divide space up into the 27 regions corresponding
// to {+|-|0}X, {+|-|0}Y, {+|-|0}Z and classify the
// sphere center into one of them.
// In the edge collision case, the edge is between vertices
// (constant + variable) and (constant - variable).
// Iterate over axes
// For each (box side), see which direction the sphere
// is outside the box (positive or negative).  Add the
// square of that distance to the total distance from 
// the box.
// Inside the box
// Off the high side
// Off the low side
// Squared distance between the outside of the box and the
// sphere center.
// There is no penetration because the distance is greater
// than the radius of the sphere.  This is the common case
// and we quickly exit.
// We know there is some penetration but need to classify it.
//
// Examine the region that contains the center of the sphere. If
// there is exactly one non-zero axis, the collision is with a 
// plane.  If there are exactly two non-zero axes, the collision
// is with an edge.  If all three axes are non-zero, the collision is
// with a vertex.  If there are no non-zero axes, the center is inside
// the box.
// Vertex collision
// The collision point is the vertex at constant, the normal
// is the vector from there to the sphere center.
// Edge collision
// TODO: unwrapping the edge constructor and closest point
// code will probably make it faster.
// Determine the edge
// Penetration depth:
// The contact point is the closes point to the sphere on the line 
// Plane collision
// The plane normal is the centerRegion vector,
// so the sphere normal is the negative.  Take
// it to world space from box-space.
// Center region doesn't need to be normalized because
// it is known to contain only one non-zero value
// and that value is +/- 1.
// Penetration depth:
// Compute the contact point from the penetration depth
// Volume collision
// The sphere center is inside the box.  This is an easy case
// to handle.  Note that all axes of distOutsideBox must
// be negative.  
// Arbitratily choose the sphere center as a contact point
// Find the least-negative penetration axis.
//
// We could have computed this during the loop over the axes,
// but since volume collisions are rare (they only occur with
// large time steps), this case will seldom be executed and
// should not be optimized at the expense of the others.
// Smallest penetration on x-axis
// Chose normal based on which side we're closest to.
// Keep in mind that this is a normal to the sphere,
// so it is the inverse of the box normal.
// Smallest penetration on z-axis
// Smallest penetration on y-axis
// Chose normal based on which side we're closest to.
// Keep in mind that this is a normal to the sphere,
// so it is the inverse of the box normal.
// Smallest on z-axis
// Chose normal based on which side we're closest to.
// Keep in mind that this is a normal to the sphere,
// so it is the inverse of the box normal.
// All vertices below the plane should be contact points.
// Depth should be a positive number
// Solve for the time at which normal.dot(point + velocity) + d == 0.
// The point is *in* the plane.
// no collision will occur
// Pre-emptive partial bounding sphere test
// Passing here does not mean that the ray hits the bounding sphere;
// we would still have to perform more expensive tests to determine
// that.
// Find candidate planes.
// Calculate T distances to candidate planes
// Calculate T distances to candidate planes
// Ray origin inside bounding box
// Get largest of the maxT's for final choice of intersection
// Check final candidate actually inside box
// Miss the box
// On this plane we're outside the box extents, so
// we miss the box
// length of the axis between the start and the sphere
// Interpenetrating
// Location is now the center of the moving sphere at the collision time.
// Adjust for the size of the moving sphere.  Two spheres always collide
// along a line between their centers.
/*
// No collision with the plane of the triangle.
// Collision occured inside the triangle
// Missed the triangle
/*
// Barycenteric coords
// find vectors for two edges sharing vert0
// begin calculating determinant - also used to calculate U parameter
// if determinant is near zero, ray lies in plane of triangle
// calculate distance from vert0 to ray origin
// calculate U parameter and test bounds
// Hit the plane outside the triangle
// prepare to test V parameter
// calculate V parameter and test bounds
// Hit the plane outside the triangle
// calculate t, scale parameters, ray intersects triangle
// If we want u,v, we can compute this
// double t = DOT(edge2, qvec);
//const double inv_det = 1.0 / det;
//t *= inv_det;
//u *= inv_det;
//v *= inv_det;
// return t;
// Case where we don't need correct (u, v):
// Note that det must be positive
// We had to travel backwards in time to intersect
// Prime the loop
// Check other faces
// Integer representation of a floating-point value.
// Find candidate planes.
// Calculate T distances to candidate planes
// Calculate T distances to candidate planes
// Ray origin inside bounding box
// Get largest of the maxT's for final choice of intersection
// Check final candidate actually inside box
// Miss the box
// On this plane we're outside the box extents, so
// we miss the box
// Choose the normal to be the plane normal facing into the ray
// No collision is ever going to happen
// The intersection point is inside the rectangle; that is the location where
// the point hits the rectangle.
/** Used by findRayCapsuleIntersection.
// set up quadratic Q(t) = a*t^2 + 2*b*t + c
// Is the velocity parallel to the capsule direction? (or zero)
// Velocity anti-parallel to the capsule direction
// Velocity parallel to the capsule direction
// sphere heading wrong direction, or no velocity at all
// test intersection with infinite cylinder
// line does not intersect infinite cylinder
// line intersects infinite cylinder in two places
// line intersects capsule wall in two places
// line is tangent to infinite cylinder
// test intersection with bottom hemisphere
// fA = 1
// test intersection with top hemisphere
// fA = 1
/** Used by collisionTimeForMovingPointFixedCapsule.
// Only return intersections that occur in the future
// A collision can only occur if there are two intersections.  If there is one
// intersection, that one is exiting the capsule.  
// Find the entering intersection (the first one that occurs).
// Compute the surface normal (if we aren't ignoring the result)
// No entering intersection discovered; return no intersection.
// Optimization for zero radius sphere
// The world-space collision point, which lies on the surface of the sphere, will be the point at
// center + velocity * time - (radius * planeNormal).  Collisions only occur when
// the sphere is travelling into the plane.
// Rate at which the sphere is approaching the plane
// No collision when the sphere is moving towards a backface.
// Initial distance from the sphere center to the plane
// Already interpenetrating
// The point on the sphere (in world space) that will eventually first contact the plane
// The problem is now reduced to finding when the point hits the plane
// No collision if moving towards a backface
// No collision is ever going to happen
// We will hit the plane of the triangle at *time*. See if
// the intersection point actually is within the triangle.
// The intersection point is inside the triangle; that is the location where
// the sphere hits the triangle.
// Internal consistency checks
// Call again so that we can debug the problem
// isPointInsideTriangle(triangle.vertex(0), triangle.vertex(1), triangle.vertex(2), triangle.normal(), 
// outLocation, b, triangle.primaryAxis());
// The collision (if it exists) is with a point on the triangle perimeter.
// Switch over to moving the triangle towards a fixed sphere and see at what time
// they will hit.
// Closest point on the triangle to the sphere intersection with the plane.
// The point is outside the sphere--see when it will hit
// Compute Barycentric coords
// Index of the next vertex
// Project along the edge in question.
// Avoid sqrt by taking advantage of the existing edgeDirection unit vector.
// Internal consistency checks
// Call again so that we can debug the problem
// Due to tiny roundoffs, these values might be slightly out of bounds.
// Ensure that they are legal.  Note that the above debugging code
// verifies that we are not clamping truly illegal values.
// The collision occured at the point, if it occured.  The normal
// was the plane normal, computed above.
// No collision is ever going to happen
// The intersection point is inside the rectangle; that is the location where
// the sphere hits the rectangle.
// Switch over to moving the rectangle towards a fixed sphere and see at what time
// they will hit.
// Normal is the plane normal, location is the original location of the point.
// TODO: Compute more useful location and normal?
// Location is now the position of the center of the sphere at the time of collision.
// We have to adjust the collision location for the size of the sphere.
// Location when the collision occurs
// Reflect direction about the normal
// subtract off the part in the direction away from the normal.
// The line segment is a point
// Vector towards the point
// Projected onto the edge itself
// Before the start
// After the end
// At distance t along the edge
// Closest point on segment from v[i] to v[i + 1]
// Distance squared from r[i] to point
// Index of the next point
// Between v0 and v1
// Between v2 and v0
// Between v1 and v2
// Between v2 and v0
// Check that the point is within the triangle using a Barycentric
// coordinate test on a two dimensional plane.
// This case is here to supress a warning on Linux
// See if all barycentric coordinates are non-negative
// 2D area via cross product
// Area of the polygon
// This triangle has zero area, so the point must not
// be in it unless the triangle point is the test point.
// (avoid normalization until absolutely necessary)
// Project the point into the plane
// If the center of the sphere is within the box, the whole
// sphere is within the box.
// Find the closest point on the surface of the box to the sphere.  If
// this point is within the sphere's radius, they intersect.
// If they intersect originally, they definitely pass through each other.
// See if the sphere hits the box during the time period.
// Extend the fixed sphere by the radius of the moving sphere
// If the sphere collides with the other sphere during the time limit, it passes through
// How far is the sphere from the plane of the triangle
// Does the closest point to the sphere center lie within the triangle?
// Is the closest point to the plane within the sphere?
// Is it also within the triangle?
// The closest point is inside the triangle
// ignored
// Is the closest point within the sphere?
////////////////////////////////////////////////////////////////////////////////
// AABB-triangle overlap test code based on Tomas Akenine-Mller's
// http://www.cs.lth.se/home/Tomas_Akenine_Moller/code/tribox3.txt
// Ported 2008-12-28
// for each axis
/*======================== X-tests ========================*/
/*======================== Y-tests ========================*/
/*======================== Z-tests ========================*/
//    use separating axis theorem to test overlap between triangle and box 
//    need to test for overlap in these directions: 
//    1) the {x,y,z}-directions (actually, since we use the AABB of the triangle 
//       we do not even need to test these) 
//    2) normal of the triangle 
//    3) crossproduct(edge from tri, {x,y,z}-direction) 
//       this gives 3x3=9 more tests 
// This is the fastest branch (on Sun).
// Move the triangle to the object space of the box
// Triangle vertices in box object space
// Compute triangle edges in object space
// Bullet 3: 
//  test the 9 tests first (this was faster) 
// Bullet 1: 
//  first test overlap in the {x,y,z}-directions 
//  find min, max of the triangle each direction, and test for overlap in 
//  that direction -- this is equivalent to testing a minimal AABB around
//  the triangle against the AABB 
// test in X-direction 
// test in Y-direction
// test in Z-direction 
// Bullet 2: 
//  test if the box intersects the plane of the triangle 
//  compute plane equation of triangle: normal*x+d=0 
// box and triangle overlap
////////////////////////////////////////////////////////////////////////////////
// namespace
// Turn off fast floating-point optimizations
/**
//graphics.cs.williams.edu
// namespace G3D
/**
//graphics.cs.williams.edu
// Intentionally falls through
// Create fairly bright, saturated colors
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// note from the max we know that it exactly equals one of the three.
//truncated triangles where sides have slope 4
//----------------------------------------------------------------------------
// namespace
/**
//graphics.cs.williams.edu
// This is a Color3 constructor--extend with alpha = 1
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// namespace
/**
//graphics.cs.williams.edu
// Sample uniformly on a sphere by rejection sampling and then normalizing
// Sample uniformly on a cube
// Compute 1 / ||v||, but
// if the vector is in the wrong hemisphere, flip the sign
// Cosine of the angle between v and the light's negative-z axis
// v was within the cone.  Normalize it and maybe flip the hemisphere.
/**
// Find the biggest angle
// If the bounding sphere contains the tip, then
// they definitely touch.
// Move the tip backwards, effectively making the cone bigger
// to account for the radius of the sphere.
// namespace
/**
//graphics.cs.williams.edu
// G3D
/**
//graphics.cs.williams.edu
// Intentionally empty
// Split into triangle fan, compute individual area
//debugPrintf("Empty\n");
// See if the polygon is *in* the plane.
// Polygon is parallel to the plane.  It must be either above,
// below, or in the plane.
// The polygon is entirely in the plane.
//debugPrintf("Entirely above\n");
//debugPrintf("Entirely below (1)\n");
// Number of edges crossing the plane.  Used for 
// debug assertions.
// True when the last _vertex we looked at was above the plane
// Switched sides.
// Create an interpolated point that lies
// in the plane, between the two points.
// Since the polygon is not in the plane (we checked above), 
// it must be the case that this edge (and only this edge)
// is in the plane.  This only happens when the polygon is
// entirely below the plane except for one edge.  This edge
// forms a degenerate polygon, so just treat the whole polygon
// as below the plane.
//debugPrintf("Entirely below\n");
// Loop back to the first point, seeing if an interpolated point is
// needed.
// Since the polygon is not in the plane (we checked above), 
// it must be the case that this edge (and only this edge)
// is in the plane.  This only happens when the polygon is
// entirely below the plane except for one edge.  This edge
// forms a degenerate polygon, so just treat the whole polygon
// as below the plane.
//debugPrintf("Entirely below\n");
// Any valid polygon should have 3 or more vertices, but why take chances?
// Remove duplicate vertices.
// Don't move forward.
// Check the last vertex against the first.
//////////////////////////////////////////////////////////////////////////////
// Intentionally empty
// The volume of any pyramid is 1/3 * h * base area.
// Discussion at: http://nrich.maths.org/mathsf/journalf/oct01/art1/
// Choose the first _vertex of the first face as the origin.
// This lets us skip one face, too, and avoids negative heights.
// See if the plane cuts this polyhedron at all.  Detect when
// the polyhedron is entirely to one side or the other.
//{
// This number has to be fairly large to prevent precision problems down
// the road.
//}
// Clip each polygon, collecting split edges.
//debugPrintf("\n");
//debugPrintf(" Above %f\n", a.getArea());
//debugPrintf(" Below %f\n", b.getArea());
//debugPrintf(" == Split\n");
// Might be the case that the polygon is entirely on 
// one side of the plane yet there is an edge we need
// because it touches the plane.
// 
// Extract the non-empty _vertex list and examine it.
// If we find exactly one edge in the plane, add that edge.
// Only one face above means that this entire 
// polyhedron is below the plane.  Move that face over.
// This shouldn't happen, but it arises in practice
// from numerical imprecision.
// The polyhedron was actually cut; create a cap polygon
// Collect the final polgyon by sorting the edges
/*debugPrintf("\n");
// Need at least three points to make a polygon
// Search for the next _vertex.  Because of accumulating
// numerical error, we have to find the closest match, not 
// just the one we expect.
// matching edge index
// This is the new closest one
// Don't tolerate ridiculous error.
//debugPrintf("\n");
//debugPrintf("Cap (both) %f\n", cap.getArea());
// Make sure we put enough faces on each polyhedra
///////////////////////////////////////////////
// Compute the signed area of each polygon from p to an edge.  
// If the area is non-negative for all polygons then p is inside 
// the polygon.  (To adapt this algorithm for a concave polygon,
// the *sum* of the areas must be non-negative).
// Area = (1/2) cross product, negated to be ccw in
// a 2D space; we neglect the 1/2
/**
//graphics.cs.williams.edu
//    } else if (beginsWith(n, "UPRIGHTFRAME") || beginsWith(n, "UFRAME")) {
//        *this = UprightFrame(any);
// TODO
// Since there is no scale factor, we don't have to 
// worry about the inverse transpose of the normal.
// When d is infinite, we can't multiply 0's by it without
// generating NaNs.
// We can't combine infinite elements under a matrix
// multiplication: if the computation performs inf-inf we'll
// get NaN.  So treat the box as infinite in all directions.
// namespace
/**
//graphics.cs.williams.edu
// From:
// http://primes.utm.edu/lists/small/1000.txt
// G3D
/**
//graphics.cs.williams.edu
/* 8-bit byte */
/* 32-bit word */
/* Define the state of the MD5 Algorithm. */
/* message length in bits, lsw first */
/* digest buffer */
/* accumulate block */
/* Initialize the algorithm. */
/* Append a string to the message. */
/* Finish the message and return the digest. */
/*
/*
//www.ietf.org/rfc/rfc1321.txt
/*
/* 0xd76aa478 */ (T_MASK ^ 0x28955b87)
/* 0xe8c7b756 */ (T_MASK ^ 0x173848a9)
/* 0xc1bdceee */ (T_MASK ^ 0x3e423111)
/* 0xf57c0faf */ (T_MASK ^ 0x0a83f050)
/* 0xa8304613 */ (T_MASK ^ 0x57cfb9ec)
/* 0xfd469501 */ (T_MASK ^ 0x02b96afe)
/* 0x8b44f7af */ (T_MASK ^ 0x74bb0850)
/* 0xffff5bb1 */ (T_MASK ^ 0x0000a44e)
/* 0x895cd7be */ (T_MASK ^ 0x76a32841)
/* 0xfd987193 */ (T_MASK ^ 0x02678e6c)
/* 0xa679438e */ (T_MASK ^ 0x5986bc71)
/* 0xf61e2562 */ (T_MASK ^ 0x09e1da9d)
/* 0xc040b340 */ (T_MASK ^ 0x3fbf4cbf)
/* 0xe9b6c7aa */ (T_MASK ^ 0x16493855)
/* 0xd62f105d */ (T_MASK ^ 0x29d0efa2)
/* 0xd8a1e681 */ (T_MASK ^ 0x275e197e)
/* 0xe7d3fbc8 */ (T_MASK ^ 0x182c0437)
/* 0xc33707d6 */ (T_MASK ^ 0x3cc8f829)
/* 0xf4d50d87 */ (T_MASK ^ 0x0b2af278)
/* 0xa9e3e905 */ (T_MASK ^ 0x561c16fa)
/* 0xfcefa3f8 */ (T_MASK ^ 0x03105c07)
/* 0x8d2a4c8a */ (T_MASK ^ 0x72d5b375)
/* 0xfffa3942 */ (T_MASK ^ 0x0005c6bd)
/* 0x8771f681 */ (T_MASK ^ 0x788e097e)
/* 0xfde5380c */ (T_MASK ^ 0x021ac7f3)
/* 0xa4beea44 */ (T_MASK ^ 0x5b4115bb)
/* 0xf6bb4b60 */ (T_MASK ^ 0x0944b49f)
/* 0xbebfbc70 */ (T_MASK ^ 0x4140438f)
/* 0xeaa127fa */ (T_MASK ^ 0x155ed805)
/* 0xd4ef3085 */ (T_MASK ^ 0x2b10cf7a)
/* 0xd9d4d039 */ (T_MASK ^ 0x262b2fc6)
/* 0xe6db99e5 */ (T_MASK ^ 0x1924661a)
/* 0xc4ac5665 */ (T_MASK ^ 0x3b53a99a)
/* 0xf4292244 */ (T_MASK ^ 0x0bd6ddbb)
/* 0xab9423a7 */ (T_MASK ^ 0x546bdc58)
/* 0xfc93a039 */ (T_MASK ^ 0x036c5fc6)
/* 0x8f0ccc92 */ (T_MASK ^ 0x70f3336d)
/* 0xffeff47d */ (T_MASK ^ 0x00100b82)
/* 0x85845dd1 */ (T_MASK ^ 0x7a7ba22e)
/* 0xfe2ce6e0 */ (T_MASK ^ 0x01d3191f)
/* 0xa3014314 */ (T_MASK ^ 0x5cfebceb)
/* 0xf7537e82 */ (T_MASK ^ 0x08ac817d)
/* 0xbd3af235 */ (T_MASK ^ 0x42c50dca)
/* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)
/*[64]*/)
/* Define storage only for big-endian CPUs. */
/* Define storage for little-endian or both types of CPUs. */
/*
/* dynamic little-endian */
/* little-endian */
/*
/* data are properly aligned */
/* not aligned */
/* dynamic big-endian */
/* big-endian */
/*
/* (dynamic only) */
/* (static only) */
/* Round 1. */
/* Let [abcd k s i] denote the operation
/* Do the following 16 operations. */
/* Round 2. */
/* Let [abcd k s i] denote the operation
/* Do the following 16 operations. */
/* Round 3. */
/* Let [abcd k s t] denote the operation
/* Do the following 16 operations. */
/* Round 4. */
/* Let [abcd k s t] denote the operation
/* Do the following 16 operations. */
/* Then perform the following additions. (That is increment each
/*0xefcdab89*/ T_MASK ^ 0x10325476;
/*0x98badcfe*/ T_MASK ^ 0x67452301;
/* Update the message length. */
/* Process an initial partial block. */
/* Process full blocks. */
/* Process a final partial block. */
/* Save the length before padding. */
/* Pad to 56 bytes mod 64. */
/* Append the length. */
/**
//graphics.cs.williams.edu
// Sides
// Caps
// Create a random point on a standard cylinder and then rotate to the global frame.
// Relative areas (factor of 2PI already taken out)
// Select a point uniformly at random on a disk
// @cite http://mathworld.wolfram.com/DiskPointPicking.html
// Top
// Bottom
// Side
// Transform to world space
// Create a random point in a standard cylinder and then rotate to the global frame.
// Select a point uniformly at random on a disk
// @cite http://mathworld.wolfram.com/DiskPointPicking.html
// Transform to world space
// namespace
/**
// disable: "C++ exception handler used"
/* G3DFIX: Disabled to avoid requirement for X11 libraries */
/**
// The last error value.  (Which is preserved across the call).
// The decoded message from FormatMessage
// Make sure the message got translated into something.
// Get rid of the allocated memory from FormatMessage.
// Build the message.
// Log the error
// Put the incoming last error back.
// -1 shouldn't actually occur because it means 
// that we're in release mode.
// Should never get here
// Log the error
// Stop hiding the cursor if the application hid it.
// Set the default cursor in case the application
// set the cursor to NULL.
// Allow the cursor full access to the screen
/* G3DFIX: Disabled to avoid requirement for X11 libraries */
//XUndefineCursor(x11Display, x11Window);
// TODO: Note that we leak this cursor; it should be
// freed in the restore code.
// TODO: OS X
// Restore the old clipping region
// Restore the old cursor
// Restore old visibility count
// TODO: Linux
// TODO: OS X
// internal namespace
// Windows can't handle really long strings sent to
// the console, so we break the string.
//    return debugPrint(consolePrint(s));
// namespace
/**
//graphics.cs.williams.edu
/* G3DFIX: Use ZIP-library only if defined */
// Needed for _getcwd
// Needed for _findfirst
/////////////////////////////////////////////////////////////
/* G3DFIX: Use ZIP-library only if defined */
// TODO: Docs unclear if zip_stat_init is required.
// Fully-qualified name of a file inside zipfile
// We found something inside the directory we were looking for,
// so the directory itself must exist
// For building the cached directory listing, extract only elements that do not contain 
// additional subdirectories.
// There are no more slashes; add this name
// There are more slashes, indicating that this is a directory
// Out of date: update
// On windows, we have to use GetFileAttributes (http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx) instead of 
// stat in order to work with network shares
// Does this path exist on the real filesystem?
// Is this path actually a directory?
// Update contents
// Not all POSIX systems support this field
// http://www.delorie.com/gnu/docs/glibc/libc_270.html
// This is a zipfile; get its root
// There is a zipfile somewhere in the path.  Does
// the rest of the path exist inside the zipfile?
// Reject trivial cases before parsing
// Look at all sub-paths containing periods.
// For each, ask if it is a zipfile.
// xxxxx/foo.zip/yyyyy
// Look forward for the next slash
// No more slashes
// Purge the cache entry for the parent of this directory
// Add a trailing / if there isn't one.
// If it already exists, do nothing
// Parse the name apart
// Begin with an extra period so "c:\" becomes "c:\.\" after
// appending a path and "c:" becomes "c:.\", not root: "c:\"
// Create any intermediate that doesn't exist
// Windows only requires one argument to mkdir,
// where as unix also requires the permissions.
// TODO: handle case where srcPath is in a zipfile
// Read it all in, then dump it out
// The directory didn't exist, so neither do its contents
// See if any element of entry matches the wild card
// Could not find a match
// TODO: work with zipfiles and cache
// Remove from cache
// Already resolved
// There is a drive spec on the front.
// Already fully qualified
// The drive spec is relative to the
// working directory on that drive.
// Prepend the working directory.
// TODO: work with cache and zipfiles
/* G3DFIX: Use ZIP-library only if defined */
// Docs unclear if zip_stat_init is required.
/* G3DFIX: Use ZIP-library only if defined */
// See if it matches the spec
// Update the type: it is unknown and we'll need to branch onit below
// match
// for
// See http://msdn.microsoft.com/en-us/library/aa364975(VS.85).aspx
// Drive list is a series of NULL-terminated strings, itself terminated with a NULL.
/////////////////////////////////////////////////////////////////////
// e.g.,   "x:"
// e.g.,   "x:\"
// Windows shares are considered roots, but only if this does not include a path inside the share
// e.g., "\\foo\", "\\foo"
// Ensure that the directory ends in a slash
// No extension
// Empty filename
// See if there is a root/drive spec.
// e.g.  c:\foo
// e.g.  c:foo
// e.g. //foo
// Pull the extension off
// Find the period
// Make sure it is after the last slash!
// Pull the basename off
// Find the last slash
// There is no slash; the basename is the whole thing
// Parse what remains into path.
// Allow either slash
// Search for pattern
// Pattern does not exist
// Search for close paren
// Search for slash or end of string
// If the varible goes to the end of the string, it is the rest of the string
// We just parsed an "empty" variable, which was probably a default share on Windows, e.g.,
// "\\mycomputer\c$", and not a variable name.
// Paste on the remainder of the source path
/** Generate a unique filename based on the provided hint */
/**
/* G3DFIX: Use ZIP-library only if defined */
// Needed for _getcwd
// Ensure that the directory ends in a slash
// Already resolved
// There is a drive spec on the front.
// Already fully qualified
// The drive spec is relative to the
// working directory on that drive.
// Prepend the working directory.
// Not in zipfile
// In zipfile
/* G3DFIX: Use ZIP-library only if defined */    
// Zipfiles require Unix-style slashes
// TODO: Docs unclear if zip_stat_init is required.
// Add NULL termination
// Copy the string
/* G3DFIX: Use ZIP-library only if defined */
// TODO: Docs unclear if zip_stat_init is required.
///////////////////////////////////////////////////////////////////////////////
// Make sure the directory exists.
///////////////////////////////////////////////////////////////////////////////
/**
// Add a trailing / if there isn't one.
// If it already exists, do nothing
// Parse the name apart
// Begin with an extra period so "c:\" becomes "c:\.\" after
// appending a path and "c:" becomes "c:.\", not root: "c:\"
// Create any intermediate that doesn't exist
// Windows only requires one argument to mkdir,
// where as unix also requires the permissions.
///////////////////////////////////////////////////////////////////////////////
/* G3DFIX: Use ZIP-library only if defined */
/* Helper methods for zipfileExists()*/
// Given a string (the drive) and an array (the path), computes the directory
// if the given length is longer than the array, we correct it
/** assumes that zipDir references a .zip file */
//the last parameter, an int, determines case sensitivity:
//1 is sensitive, 2 is not, 0 is default
/** If no zipfile exists, outZipfile and outInternalFile are unchanged */
/* G3DFIX: Use ZIP-library only if defined */
// Put the filename back together
// Remove all standalone single dots (".") from path
// Remove non-leading ".." from path
// Remove both i and i - 1
// Walk the path backwards, accumulating pieces onto the infile until
// we find a zipfile that contains it
// test if it actually is a zipfile
// if not, return false, a bad
// directory structure has been given,
// not a .zip
// the directory structure was valid but did not point to a .zip
// not a valid directory structure ever, 
// obviously no .zip was found within the path 
///////////////////////////////////////////////////////////////////////////////
// Note "template" is a reserved word in C++
// Remove extensions
///////////////////////////////////////////////////////////////////////////////
// TODO: don't use BinaryInput and BinaryOutput
// Read it all in, then dump it out
//////////////////////////////////////////////////////////////////////////////
// Empty filename
// See if there is a root/drive spec.
// e.g.  c:\foo
// e.g.  c:foo
// e.g. //foo
// Pull the extension off
// Find the period
// Make sure it is after the last slash!
// Pull the basename off
// Find the last slash
// There is no slash; the basename is the whole thing
// Parse what remains into path.
// Allow either slash
/**
// Find the place where the path ends and the file-spec begins
// Drive letters on Windows can separate a path
// If there is a path, pull it off
// Strip the trailing character
// Empty paths don't work on Unix
// Unix implementation
// Exclude '.' and '..'
// Form a name with a path
// See if this is a file or a directory
// Make sure it has the correct type
// Make sure it matches the wildcard
/* G3DFIX: Use ZIP-library only if defined */
/**
// Make certain we are within the desired parent folder (prefix)
// validityTest was prefix/file
// Extract everything to the right of the prefix
// This was the name of the prefix
// See if there are any slashes
// No slashes, so s must be a file
// Not all zipfiles list directories as explicit entries.
// Because of this, if we're looking for directories and see
// any path longer than prefix, we must add the subdirectory. 
// The Set will fix duplicates for us.
/* G3DFIX: Use ZIP-library only if defined */
// TODO: Docs unclear if zip_stat_init is required.
// if it is a .zip, prefix will specify the folder within
// whose contents we want to see
// Strip the trailing slash
// .zip should only work if * is specified as the Base + Ext
// Here, we have been asked for the root's contents
// It is a normal directory
// .zip should only work if * is specified as the Base + Ext
// Here, we have been asked for the contents of a folder within the .zip
/**
//graphics.cs.williams.edu
// namespace
/**
// disable: "C++ exception handler used"
// _MSC_VER
// If your platform does not have vsnprintf, you can find a
// implementation at http://www.ijs.si/software/snprintf/
// Both MSVC seems to use the non-standard vsnprintf
// so we are using vscprintf to determine buffer size, however
// only MSVC7 and up headers include vscprintf for some reason.
// We draw the line at a 1MB string.
// If the string is less than 161 characters,
// allocate it on the stack because this saves
// the malloc/free time.
// MSVC does not support va_copy
// Now use the heap.
// We draw the line at a 1MB string.
// If the string is less than 161 characters,
// allocate it on the stack because this saves
// the malloc/free time.
// MSVC6 doesn't support va_copy, however it also seems to compile
// correctly if we just pass our argument list along.  Note that 
// this whole code block is only compiled if we're on MSVC6 anyway
// Not a big enough buffer, bufSize characters written
// glibc 2.1 has been updated to the C99 standard
// If the string is less than 161 characters,
// allocate it on the stack because this saves
// the malloc/free time.  The number 161 is chosen
// to support two lines of text on an 80 character
// console (plus the null terminator).
// We didn't allocate a big enough string.
// namespace
/* $Id: g3dfnmatch.cpp,v 1.3 2010/03/15 05:01:23 morgan3d Exp $ */
/*    $OpenBSD: fnmatch.c,v 1.7 2000/03/23 19:13:51 millert Exp $    */
/*
/* Collapse multiple stars. */
/* Optimize for pattern with * at end or before /. */
/* General case, use recursion. */
/* not a good range, treat as normal text */
/* FALLTHROUGH */
/* NOTREACHED */
/*
/*
/**
// Using Box-Mueller method from http://www.taygeta.com/random/gaussian.html
// Modified to specify standard deviation and mean of distribution
// Loop until w is less than 1 so that log(w) is negative
// Transform to gassian distribution
// Multiply by sigma (stdev ^ 2) and add mean.
/** 
// --fast-math breaks other methods of testing for NaN on g++ 4.x,
// including isnan(x) and !(x == x)
// Wipe out the sign bit
// If the remaining number has all of the exponent bits set and atleast one
// fraction bit set, then it is NaN
// Wipe out the sign bit
// If the remaining number has all of the exponent bits set and atleast one
// fraction bit set, then it is NaN
/** 
/** This value should not be tested against directly, instead
// double is a standard type and should have quiet NaN
// double is a standard type and should have quiet NaN
// Binary search.
// There is a *very small* chance of generating
// a number larger than high.
/**
// namespace _internal
// system-independent clear of handle
// From http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
// Must be 0x1000.
// Pointer to name (in user addr space).
// Thread ID (-1=caller thread).
// Reserved for future use, must be zero.
// Run on this thread
// system-independent clear of handle
// system-independent clear of handle
// Must be done
//GMutex implementation
//TODO: Debug check for locked
// namespace G3D
/**
//graphics.cs.williams.edu
// Create a unique ID for this machine/program instance
// TODO: see ioctl(skfd, SIOCGIFHWADDR, &if_hwaddr)
// Ensure that the systemID is non-zero (vanishingly small probability)
// No need for modulo; we'll all be dead before this counter
// overflows 54 bits
// G3D 
/**
//graphics.cs.williams.edu
// Convert int8 -> float
// Strip alpha and convert
// Strip alpha
// To avoid saving as floating point image.  FreeImage cannot convert floating point to L8.
// G3D
/**
//graphics.cs.williams.edu
// Convert int8 -> float
// Strip alpha and convert
// Strip alpha
/** Saves in any of the formats supported by G3D::GImage. */
// To avoid saving as floating point image.  FreeImage cannot convert floating point to RGB8.
// G3D
/**
//graphics.cs.williams.edu
// Convert int8 -> float
// Add alpha and convert
// Add alpha
/** Saves in any of the formats supported by G3D::GImage. */
// To avoid saving as floating point image.  FreeImage cannot convert floating point to RGBA8.
// G3D
/**
//graphics.cs.williams.edu
// TODO
// TODO
// TODO
// TODO
// TODO
// TODO
// TODO
// TODO
// TODO
// TODO
// Helper variables for defining texture formats
// Is opaque format (no alpha)
// Is compressed format (not raw component data)
// The base format for integer formats must be *_INTEGER even though the spec doesn't state this
// The base format for integer formats must be *_INTEGER even though the spec doesn't state this
// The base format for integer formats must be *_INTEGER even though the spec doesn't state this
// These formats are for use with Renderbuffers only!
// TODO: Find out if these are acutally NFP, not integer, formats.
// this is the signature for all conversion routines (same parameters as ImageFormat::convert)
// this defines the conversion routines for converting between compatible formats
// forward declare the converters we can use them below
// this is the list of mappings between formats and the routines to perform them
// RGB -> RGB color space
// L8 ->
// L32F ->
// RGB8 ->
// BGR8 ->
// RGBA8 ->
// RGB32F ->
// RGBA32F ->
// RGB -> BAYER color space
// BAYER -> RGB color space
// RGB <-> YUV color space
// check for matching source
// now check for matching dest to see if the routine fits
// check if dest format matches and padding + invert rules match
// found compatible converter
// check if a conversion is available
// Handle direct copy of image to same format
// if no direct conversion routine exists,
// then look for conversion to intermediate
// and then from intermediate to dest.
// intermediate format is RGBA32F
// if we have a direct converter, use it, otherwise find intermdiate path
// *******************
// RGB -> RGB color space conversions
// *******************
// L8 ->
// L32F ->
// RGB8 ->
// BGR8 ->
// RGBA8 ->
// RGB32F ->
// RGBA32F ->
// *******************
// RGB <-> YUV color space conversions
// *******************
// Compute two color channels at a time.  Use >> 1 for fast division by two
// Using alternating color channels prevents overflow
// Shift first to avoid overflow in alpha channel
// convert 4-pixel block at a time
// convert 2-pixel horizontal block at a time
// convert 1-pixels at a time
// convert to two rgb pixels in a row
// convert to two rgb pixels in a row
// convert to one rgb pixels at a time
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Bayer conversions
//
// There are two kinds of rows (GR and BG).
// In each row, there are two kinds of pixels (G/R, B/G).
// We express the four kinds of INPUT pixels as:
//    GRG, GRG, BGB, BGG
//
// There are three kinds of OUTPUT pixels: R, G, B.
// Thus there are nominally 12 different I/O combinations, 
// but several are impulses because needed output at that 
// location *is* the input (e.g., G_GRG and G_BGG).
//
// The following 5x5 row-major filters are named as output_input.
// Green
// Red 
//(the caption in the paper is wrong for this case:
// "R row B column really means R row G column"
// Blue 
//(the caption in the paper is wrong for this case:
// "B row R column really means B row G column")
// =====================================================================
// Helper methods
// =====================================================================
/** Applies a 5x5 filter to monochrome image I (wrapping at the boundaries) */
/** Helper method for Bayer grbg and bggr --> rgb8 */
// RGB -> BAYER color space
// =====================================================================
// rgb8 --> bayer helpers
// =====================================================================
// Top row pixels
// Top left pixels
// Top right pixels
// Bottom row pixels
// Bottom left pixels
// Bottom right pixels
// Top row pixels
// Top left pixels
// Top right pixels
// Bottom row pixels
// Bottom left pixels
// Bottom right pixels
// Top row pixels
// Top left pixels
// Top right pixels
// Bottom row pixels
// Bottom left pixels
// Bottom right pixels
// Top row pixels
// Top left pixels
// Top right pixels
// Bottom row pixels
// Bottom left pixels
// Bottom right pixels
// =====================================================================
// rgba32f (-->rgb8) --> bayer converter implementations
// =====================================================================
// BAYER -> RGB color space
// =====================================================================
// bayer --> rgb8 helpers
// =====================================================================
// Row beginning in the input array.
// RG row
// R pixel
// G pixel
// GB row
// G pixel
// B pixel
// Row beginning in the input array.
// GB row
// G pixel
// B pixel
// Run the equivalent function for red
// Now swap red and blue
// Run the equivalent function for red
// Now swap red and blue
// =====================================================================
// bayer (--> rgb8) --> rgba32f converter implementations
// =====================================================================
// TODO: The following region is commented out because so far
// those conversions are not used anywhere else. Until it is
// decided that such conversions are not needed, this region
// remains commented out.
// // =====================================================================
// // bayer --> bgr8 
// // =====================================================================
// static void bayer_rggb8_to_bgr8_mhc(int w, int h, 
//                     const unorm8* in, unorm8* _out) {
//     debugAssert(in != _out);
//     Color3unorm8* out = (Color3unorm8*)_out;
//     for (int y = 0; y < h; ++y) {
//     // Row beginning in the input array.
//     int offset = y * w;
//     // RG row
//     for (int x = 0; x < w; ++x, ++out) {
//         // R pixel
//         {
//         out->b = in[x + offset];
//         out->g = applyFilter(in, x, y, w, h, G_GRR);
//         out->r = applyFilter(in, x, y, w, h, B_GRR);
//         }
//         ++x; ++out;
//         // G pixel
//         {
//         out->b = applyFilter(in, x, y, w, h, R_GRG);
//         out->g = in[x + offset];
//         out->r = applyFilter(in, x, y, w, h, B_GRG);
//         }
//     }
//     ++y;
//     offset += w;
//     // GB row
//     for (int x = 0; x < w; ++x, ++out) {
//         // G pixel
//         {
//         out->b = applyFilter(in, x, y, w, h, R_BGG);
//         out->g = in[x + offset];
//         out->r = applyFilter(in, x, y, w, h, B_BGG);
//         }
//         ++x; ++out;
//         // B pixel
//         {
//         out->b = applyFilter(in, x, y, w, h, R_BGB);
//         out->g = applyFilter(in, x, y, w, h, G_BGB);
//         out->r = in[x + offset];
//         }
//     }
//     }
// }
// static void bayer_gbrg8_to_bgr8_mhc(int w, int h, 
//                     const unorm8* in, unorm8* _out) {
//     debugAssert(in != _out);
//     Color3unorm8* out = (Color3unorm8*)_out;
//     for (int y = 0; y < h; ++y) {
//     // Row beginning in the input array.
//     int offset = y * w;
//     // GB row
//     for (int x = 0; x < srcWidth; ++x, ++out) {
//         // G pixel
//         {
//         out->b = applyFilter(in, x, y, w, h, R_BGG);
//         out->g = in[x + offset];
//         out->r = applyFilter(in, x, y, w, h, B_BGG);
//         }
//         ++x; ++out;
//         // B pixel
//         {
//         out->b = applyFilter(in, x, y, w, h, R_BGB);
//         out->g = applyFilter(in, x, y, w, h, G_BGB);
//         out->r = in[x + offset];
//         }
//     }
//     }
// }
// static void bayer_grbg8_to_bgr8_mhc(int w, int h, 
//                     const unorm8* in, unorm8* _out) {
//     // Run the equivalent function for red
//     bayer_gbrg8_to_bgr8_mhc(w, h, in, _out);
//     // Now swap red and blue
//     swapRedAndBlue(srcWidth * h, (Color3unorm8*)_out);
// }
// static void bayer_bggr8_to_bgr8_mhc(int w, int h, 
//                     const unorm8* in, unorm8* _out) {
//     // Run the equivalent function for red
//     bayer_rggb8_to_bgr8_mhc(w, h, in, _out);
//     // Now swap red and blue
//     swapRedAndBlue(srcWidth * h, (Color3unorm8*)_out);
// }
///////////////////////////////////////////////////
// namespace G3D
/**
//graphics.cs.williams.edu
//g3d.sf.net
// Turn on fast floating-point optimizations
// compute the intersection distance
// Turn off fast floating-point optimizations
/**
//ffmpeg.mplayerhq.hu), which are included under the terms of the\n" 
//www.gnu.org/copyleft/lesser.html).\n\n"
//g3d.sf.net), which\n"
// Win32 doesn't use SDL
//www.libsdl.org), which is included under the terms of the\n"
//www.gnu.org/copyleft/lesser.html).\n\n"
/**
/**
//graphics.cs.williams.edu
// The vector from the end of the capsule to the point in question.
// Projection of v onto the line segment scaled by 
// the length of direction.
// Avoid some square roots.  Derivation:
//    t/direction.length() <= direction.length()
//      t <= direction.squaredLength()
// The point falls within the segment.  Normalize direction,
// divide t by the length of direction.
// The point does not fall within the segment; see which end is closer.
// Distance from 0, squared
// Distance from 1, squared
// Point 0 is closer
// Point 1 is closer
/////////////////////////////////////////////////////////////////////////////////////
// Two constants that appear in the result
// This line segment has no length
// Time [0, 1] at which we hit the closest point travelling from p0 to p1.
// Derivation can be obtained by minimizing the expression
//     ||P0 + (P1 - P0)t - Q||.
// Clipped to low end point
// Clipped to high end point
// Subsitute into the line equation to find 
// the point on the segment.
// Note: Now that we've checked the endpoints, all other parallel lines can now be assumed
// to not intersect (within numerical precision)
// Avoid an upcoming divide by zero
// t1 = ((other.m_origin.x - m_origin.x) + other.m_direction.x * t2) / m_direction.x
//
// ((other.m_origin.x - m_origin.x) + other.m_direction.x * t2) * m_direction.y / m_direction.x = 
//        (other.m_origin.y - m_origin.y) + other.m_direction.y * t2
//
// m = m_direction.y / m_direction.x
// d = other.m_origin - m_origin
//
// (d.x + other.m_direction.x * t2) * m = d.y + other.m_direction.y * t2
//
// d.x * m + other.m_direction.x * m * t2 = d.y + other.m_direction.y * t2
//
// d.x * m - d.y  = (other.m_direction.y - other.m_direction.x * m) * t2
//
// (d.x * m - d.y) / (other.m_direction.y - other.m_direction.x * m)  = t2
//
// Parallel lines: no intersection
// Intersection occurs past the end of the line segments
// Intersection occurs past the end of the line segments
// Return the intersection point (computed from non-transposed 
// variables even if we flipped above)
/**
//graphics.cs.williams.edu
// Write time is greater than 1ms.  This may be a network drive.... try another file.
// Use a large buffer (although we flush in logPrintf)
// Make sure we don't leave a dangling pointer
/**
//graphics.cs.williams.edu
// Don't print "negative zero"
// Print integers nicely
// We can't optimize this one
// Copy the data before mutating; this object is shared
// Copy the data before mutating; this object is shared
// Copy the data before mutating; this object is shared
// Get a pointer to the first element in the column
// Skip around to the next row
// Implement an explicit-output unary method by trampolining to the impl
// In place
// Make sure we don't overwrite a shared matrix
// Make a copy of this for in-place SVD
// Sort the singular values from greatest to least
// Now permute U, d, and V appropriately
///////////////////////////////////////////////////////////
// Nothing to do
// Only allocate if we need more space
// or the size difference is ridiculous
// Construct the row pointers
//delete[] elt;
// new T*[R];
//delete[] elt;
// We're about to define several similar methods,
// so use a macro to share implementations.  This
// must be a macro because the difference between
// the macros is the operation in the inner loop.
// lsub is special because the argument order is reversed
// Inverse = adjoint / determinant
// Don't call the determinant method when we already have an
// adjoint matrix; there's a faster way of computing it: the dot
// product of the first row and the adjoint's first col.
// Square matrix in place
// Transpose is safe to perform in place
// Strang p. 217
// Compute using cofactors
// Determinant of a 1x1 is the element
// Determinant of a 2x2 is ad-bc
// Determinant of an nxn matrix is the dot product of the first
// row with the first row of cofactors.  The base cases of this
// method get called a lot, so we spell out the implementation
// for the 3x3 case.
// Determinant of an n x n matrix is the dot product of the first
// row with the first row of cofactors
/*
// See http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse
// Matrices from SVD
// Diagonal elements
// TODO: Should be eps(d[0]), which is the largest diagonal
// There were no non-zero elements
// Use the first r columns
// Test code (the rest is below)
/*
// We want to do this:
//
//   d.resize(r);
//   U = U.subMatrix(0, U.rows() - 1, 0, r - 1);
//   X = V * Matrix::fromDiagonal(d) * U.transpose();
//
// but creating a large diagonal matrix and then
// multiplying by it is wasteful.  So we instead
// explicitly perform A = (D * U')' = U * D, and 
// then multiply X = V * A'.
// A(i,j) = U(i,:) * D(:,j)
// This is non-zero only at j = i because D is diagonal
// A(i,j) = U(i,j) * D(j,j)
//
// Compute X = V.subMatrix(0, V.rows() - 1, 0, r - 1) * A.transpose()
// 
// Avoid the explicit subMatrix call, and by storing A' instead of A, avoid
// both the transpose and the memory incoherence of striding across memory
// in big steps.
/*
// Computes pseudoinverse for a vector
// If vector A has nonzero elements: transpose A, then divide each elt. by the squared norm
// If A is zero vector: transpose A
// B = A * A'
// B has size m x m
// TODO: Put each of the individual cases in its own helper function
// TODO: Push the B computation down into the individual cases
// B = A' * A
// B has size n x n
// Row-major 2x2 matrix
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// invert using formula at http://www.netsoc.tcd.ie/~jgilbert/maths_site/applets/algebra/matrix_inversion.html
// Multiply by Binv * A'
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// Multiply by Binv * A'
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// Multiply by Binv * A'
// Row-major 2x2 matrix
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// invert using formula at http://www.netsoc.tcd.ie/~jgilbert/maths_site/applets/algebra/matrix_inversion.html
// Multiply by Binv * A'
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// Multiply by Binv * A'
// Matrix was singular; the block matrix pseudo-inverse can't
// handle that, so fall back to the old case
// Multiply by Binv * A'
// Uses the block matrix pseudoinverse to compute the pseudoinverse of a full-rank mxn matrix with m >= n
// http://en.wikipedia.org/wiki/Block_matrix_pseudoinverse
// Logic:
// A^-1 = (A'A)^-1 A'
// A has few (n) columns, so A'A is small (n x n) and fast to invert
// TODO: optimize by pushing through the transpose
//return transpose().partitionPseudoInverse().transpose();
// Exchange to float elements
// The integer arrays pivot, rowIndex, and colIndex are
// used for bookkeeping on the pivoting
// Initialize the pivot array to default values.
// This is the main loop over the columns to be reduced
// Loop over the columns.
// Find the largest element and use that as a pivot
// This is the outer loop of the search for a pivot element
// Unless we've already found the pivot, keep going
// Find the largest pivot
// Interchange columns so that the pivot element is on the diagonal (we'll have to undo this
// at the end)
// The pivot is now at [row, col]
// Divide everything by the pivot (avoid computing the division
// multiple times).
// Reduce all rows
// Skip over the pivot row
// Put the columns back in the correct locations
/** Helper for svdCore */ 
// Temp row vector
// Householder reduction to bidiagonal form
// Left-hand reduction
// right-hand reduction
// accumulate the right-hand transformation
// double division to avoid underflow 
// accumulate the left-hand transformation
// diagonalize the bidiagonal form
// loop over singular values 
// loop over allowed iterations
// test for splitting 
// convergence
// make singular value nonnegative 
// shift from bottom 2 x 2 minor
// next QR transformation 
/**
//----------------------------------------------------------------------------
// Implementation from Watt and Watt, pg 362
// See also http://www.flipcode.com/documents/matrfaq.html#Q54
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Invert a 3x3 using cofactors.  This is about 8 times faster than
// the Numerical Recipes code which uses Gaussian elimination.
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// map first column to (*,0,0)
// map first row to (*,*,0)
// map second column to (*,*,0)
//----------------------------------------------------------------------------
// adjust right
// adjust left
// adjust right
// adjust left
//----------------------------------------------------------------------------
// 2x2 closed form factorization
// 2x2 closed form factorization
// positize diagonal
//----------------------------------------------------------------------------
// product S*R
// product L*S*R
//----------------------------------------------------------------------------
// Algorithm uses Gram-Schmidt orthogonalization.  If 'this' matrix is
// M = [m0|m1|m2], then orthonormal output matrix is Q = [q0|q1|q2],
//
//   q0 = m0/|m0|
//   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|
//   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|
//
// where |V| indicates length of vector V and A*B indicates dot
// product of vectors A and B.
// compute q0
// compute q1
// compute q2
//----------------------------------------------------------------------------
// Factor M = QR = QDU where Q is orthogonal, D is diagonal,
// and U is upper triangular with ones on its diagonal.  Algorithm uses
// Gram-Schmidt orthogonalization (the QR algorithm).
//
// If M = [ m0 | m1 | m2 ] and Q = [ q0 | q1 | q2 ], then
//
//   q0 = m0/|m0|
//   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|
//   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|
//
// where |V| indicates length of vector V and A*B indicates dot
// product of vectors A and B.  The matrix R has entries
//
//   r00 = q0*m0  r01 = q0*m1  r02 = q0*m2
//   r10 = 0      r11 = q1*m1  r12 = q1*m2
//   r20 = 0      r21 = 0      r22 = q2*m2
//
// so D = diag(r00,r11,r22) and U has entries u01 = r01/r00,
// u02 = r02/r00, and u12 = r12/r11.
// Q = rotation
// D = scaling
// U = shear
// D stores the three diagonal entries r00, r11, r22
// U stores the entries U[0] = u01, U[1] = u02, U[2] = u12
// build orthogonal matrix Q
// guarantee that orthogonal matrix has determinant 1 (no reflections)
// build "right" matrix R
// the scaling component
// the shear component
//----------------------------------------------------------------------------
/*
/* Higham suggests using OneNorm(Xit-X) < eps * OneNorm(X)
// close enough use simple iteration
// not close to convergence, compute acceleration factor
// S := (S + S^t)/2 one more time to make sure it is symmetric
// Check iter limit
// Check A = R*S
// Check R is orthogonal
// Check that S is symmetric
//----------------------------------------------------------------------------
// Spectral norm is for A^T*A, so characteristic polynomial
// P(x) = c[0]+c[1]*x+c[2]*x^2+x^3 has three positive float roots.
// This yields the assertions c[0] < 0 and c[2]*c[2] >= 3*c[1].
// quick out for uniform scale (triple root)
// Compute an upper bound on roots of P(x).  This assumes that A^T*A
// has been scaled by its largest entry.
// uses a matrix norm to find an upper bound on maximum root
// Newton's method to find root
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// The one norm of a matrix is the max column sum in absolute value.
//----------------------------------------------------------------------------
// The infinity norm of a matrix is the max row sum in absolute value.
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// 
// Let (x,y,z) be the unit-length axis and let A be an angle of rotation.
// The rotation matrix is R = I + sin(A)*P + (1-cos(A))*P^2 (Rodrigues' formula) where
// I is the identity and
//
//       +-        -+
//   P = |  0 -z +y |
//       | +z  0 -x |
//       | -y +x  0 |
//       +-        -+
//
// If A > 0, R represents a counterclockwise rotation about the axis in
// the sense of looking from the tip of the axis vector towards the
// origin.  Some algebra will show that
//
//   cos(A) = (trace(R)-1)/2  and  R - R^t = 2*sin(A)*P
//
// In the event that A = pi, R-R^t = 0 which prevents us from extracting
// the axis through P.  Instead note that R = I+2*P^2 when A = pi, so
// P^2 = (R-I)/2.  The diagonal entries of P^2 are x^2-1, y^2-1, and
// z^2-1.  We can solve these for axis (x,y,z).  Because the angle is pi,
// it does not matter which sign you choose on the square roots.
// in [0,PI]
// angle is PI
// r00 >= r11
// r00 is maximum diagonal term
// r22 is maximum diagonal term
// r11 > r00
// r11 is maximum diagonal term
// r22 is maximum diagonal term
// The angle is 0 and the matrix is the identity.  Any axis will
// work, so just use the x-axis.
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// rot =  cy*cz          -cy*sz           sy
//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
//----------------------------------------------------------------------------
// rot =  cy*cz          -sz              cz*sy
//        sx*sy+cx*cy*sz  cx*cz          -cy*sx+cx*sy*sz
//       -cx*sy+cy*sx*sz  cz*sx           cx*cy+sx*sy*sz
// WARNING.  Not unique.  XA - YA = atan2(r20,r22)
// WARNING.  Not unique.  XA + YA = atan2(-r20,r22)
//----------------------------------------------------------------------------
// rot =  cy*cz+sx*sy*sz  cz*sx*sy-cy*sz  cx*sy
//        cx*sz           cx*cz          -sx
//       -cz*sy+cy*sx*sz  cy*cz*sx+sy*sz  cx*cy
// WARNING.  Not unique.  YA - ZA = atan2(r01,r00)
// WARNING.  Not unique.  YA + ZA = atan2(-r01,r00)
//----------------------------------------------------------------------------
// rot =  cy*cz           sx*sy-cx*cy*sz  cx*sy+cy*sx*sz
//        sz              cx*cz          -cz*sx
//       -cz*sy           cy*sx+cx*sy*sz  cx*cy-sx*sy*sz
// WARNING.  Not unique.  YA - XA = -atan2(r21,r22);
// WARNING.  Not unique.  YA + XA = atan2(r21,r22)
//----------------------------------------------------------------------------
// rot =  cy*cz-sx*sy*sz -cx*sz           cz*sy+cy*sx*sz
//        cz*sx*sy+cy*sz  cx*cz          -cy*cz*sx+sy*sz
//       -cx*sy           sx              cx*cy
// WARNING.  Not unique.  ZA - YA = -atan(r02,r00)
// WARNING.  Not unique.  ZA + YA = atan2(r02,r00)
//----------------------------------------------------------------------------
// rot =  cy*cz           cz*sx*sy-cx*sz  cx*cz*sy+sx*sz
//        cy*sz           cx*cz+sx*sy*sz -cz*sx+cx*sy*sz
//       -sy              cy*sx           cx*cy
// WARNING.  Not unique.  ZA - XA = -atan2(r01,r02)
// WARNING.  Not unique.  ZA + XA = atan2(-r01,-r02)
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Householder reduction T = Q^t M Q
//   Input:
//     mat, symmetric 3x3 matrix M
//   Output:
//     mat, orthogonal matrix Q
//     diag, diagonal entries of T
//     subd, subdiagonal entries of T (T is symmetric)
//----------------------------------------------------------------------------
// QL iteration with implicit shifting to reduce matrix from tridiagonal
// to diagonal
// should not get here under normal circumstances
//----------------------------------------------------------------------------
// make eigenvectors form a right--handed system
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// Runs in 52 cycles on AMD, 76 cycles on Intel Centrino
//
// The loop unrolling is necessary for performance. 
// I was unable to improve performance further by flattening the matrices
// into float*'s instead of 2D arrays.  
//
// -morgan
//----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// namespace
/**
//graphics.cs.williams.edu
// Adapted from Mesa.  Note that Microsoft (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/opengl/glfunc03_8qnj.asp) 
// and Linux (http://www.xfree86.org/current/glOrtho.3.html) have different matrices shown in their documentation.
// Infinite view frustum
// Verify that this really is a projection matrix
/**
// If the bit patterns are identical, they must be
// the same matrix.  If not, they *might* still have
// equal elements due to floating point weirdness.
// Determinant is the dot product of the first row and the first row
// of cofactors (i.e. the first col of the adjoint matrix)
// Inverse = adjoint / determinant
// Determinant is the dot product of the first row and the first row
// of cofactors (i.e. the first col of the adjoint matrix)
// We'll use i to incrementally compute -1 ^ (r+c)
// Compute the determinant of the 3x3 submatrix
// Compute non-excluded row and column indices
// Compute the first row of cofactors 
// Product of the first row and the cofactors along the first row
// Ensure that the rotation matrix is orthonormal
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// If the bit patterns are identical, they must be
// the same matrix.  If not, they *might* still have
// equal elements due to floating point weirdness.
// Infinite view frustum
// namespace
/**
//graphics.cs.williams.edu
///////////////////////////////////////////////////
///////////////////////////////////////////////////
/**
//graphics.cs.williams.edu
// Generate vertices                  
// Generate indices
//  A       B
//   *-----*
//   | \   |
//   |   \ |
//   *-----*
//  C       D
// The index array needs to have reversed winding for the bottom
// and offset by the original number of vertices
// Duplicate the arrays
// Negative face indices are faces that don't exist
// Construct a fake vertex array for backwards compatibility
// We leave out the edges because they aren't used to compute normals
// Face normals (not unit length)
// Per-vertex normals, computed by averaging
// Infinite case
// Finite case
// Infinite case
// Finite case
// Make sure round-off hasn't pushed values less than zero
// Makes a copy so as to re-use the existing computebounds code
// FIRST PASS: find 6 minima/maxima points
// Set points dia1 & dia2 to the maximally separated pair
// Set xspan = distance between the 2 points xmin & xmax (squared)
// Same for y & z spans
// dia1, dia2 is a diameter of initial sphere
// calc initial center
// calculate initial radius^2 and radius 
// SECOND PASS: increment current sphere
// do r^2 test first 
// this point is outside of current sphere
// calc radius of new sphere
// for next r^2 compare
// calc center of new sphere
// Zero the output arrays.
// Iterate over faces, computing the tangent vectors for each 
// vertex.  Accumulate those into the tangent and binormal arrays
// and then orthonormalize at the end.
// See http://www.terathon.com/code/tangent.html for a derivation of the following code
// vertex edges
// texture edges
// degenerate case
// Normalize the basis vectors
// Remove the component parallel to the normal
// Normalize
// G3D namespace
/**
//graphics.cs.williams.edu
/** Two-level table mapping index 0 -> index 1 -> list of face indices */
/** We  expect 2 faces per edge. */
/** We expect at most 6 edges per vertex; that matches a typical regular grid mesh */
/**
/** Pair index */
// Skip over elements with no face array
/** @deprecated  Use isValid */
/**
// Convert the vertexArray into adjacentFaceArray
// Face normals
// This array has the same size as the vertex array
// Iterate through the triangle list
// Construct the face
// Store back pointers in the vertices
// We'll need these vertices to find the face normal
// Compute the face normal
// Add each edge to the edge table.
// The edge was directed in the same manner as in the face
// The edge was directed in the opposite manner as in the face
// For each edge in the edge table, create an edge in the edge array.
// Collapse every 2 edges from adjacent faces.
// Process this edge
// Remove the last index
// Find the normal to that face
// We try to find the matching face with the closest
// normal.  This ensures that we don't introduce a lot
// of artificial ridges into flat parts of a mesh.
// Try to find the face with the matching edge
// This face contains the oppositely oriented edge
// and has not been assigned too many edges
// We previously found a good face; see if this
// one is better.
// This face is better.
// This is the first face we've found
// Create the new edge
// The face indices above are two's complemented.
// this code restores them to regular indices.
// The edge index *does* need to be inverted, however.
// We found a matching face; remove both
// faces from the active list.
// Move boundary edges to the end of the list and then
// clean up the face references into them
// Map old edge indices to new edge indices
// Index of the start and end of the edge array
// Fix the faces
// Backwards edge; twiddle before and after conversion
// Regular edge; remap the index
// Now order the edge indices inside the faces correctly.
// e0 will always remain first.  The only 
// question is whether e1 and e2 should be swapped.
// See if e1 begins at the vertex where e1 ends.
// We must swap e1 and e2
// Fill out the edge adjacency information in the vertex array
// Copy over the original edge array
// newEdgeIndex[e] is the new index of the old edge with index e
// Note that newEdgeIndex[e] might be negative, indicating that
// the edge switched direction between the arrays.
// boundaryEdgeIndices[v_low] is an array of the indices of 
// all boundary edges whose lower vertex is v_low.
// Copy over non-boundary edges to the new array
// Add to the boundary table
// We'll fill out newEdgeIndex[e] later, when we find pairs
// Copy the edge to the new array
// Remove all edges from the table that have pairs.
// See if edge ei is the reverse (match) of edge ej.
// True if the edges match
// True if edgej's vertex indices are reversed from
// edgei's (usually true).
//        verts|faces
// edgei = [u v A /]
// This is the most common of the four cases
// edgej = [v u B /]
// edgej = [u v / B]
// edgei = [u v / A]
// edgej = [u v B /]
// edgej = [v u / B]
// ei and ej can be paired as a single edge
// Follow the direction of edgei.
// Insert the face index for edgej.
// The new edge is backwards of the old edge for ej
// Remove both ei and ej from being candidates for future pairing.
// Remove ej first since it comes later in the list (removing
// ei would decrease the index of ej to j - 1).
// Re-process element i, which is now a new edge index
// Jump out of the j for-loop
// Anything remaining in the table is a real boundary edge; just copy it to
// the end of the array.
// Finally, fix up edge indices in the face and vertex arrays
// Num vertices
// canonical[v] = first occurance of any vertex near oldVertexArray[v]
// Throw away the new vertex array
// Round-trip through the toNew/toOld process.  This will give
// us the original vertex.
// Destroy vertexArray (we reconstruct it below)
// Fix edge vertex indices
// Fix face vertex indices
// Add the back pointer
// As a result of the welding, some of the boundary edges at
// the end of the array may now have mates and no longer be
// boundaries.  Try to pair these up.
// Every face's edge must be on that face
// Make sure the edge is oriented appropriately 
// _DEBUG
// G3D namespace
/**
//graphics.cs.williams.edu
// Intentionally illegal
/** Indices of newVertexArray elements in <B>or near</B> a grid cell. */
/** Must be less than one grid cell, not checked */
/** (oldVertexArray[i] - offset) * scale is on the range [0, 1] */
/**
/** Gets the index of a vertex, adding it to 
// namespace _internal
// namespace G3D
// Compute a scale factor that moves the range
// of all ordinates to [0, 1]
// The model might have zero extent along some axis
// Check against all vertices within radius of this grid cube
// This is a new vertex
// Create a new vertex and store its index in the
// neighboring grid cells (usually, only 1 neighbor)
// Prime the vertex positions
// Now create the official remapping by snapping to 
// nearby vertices.
// internal namespace
// G3D namespace
/**
//graphics.cs.williams.edu
// Make the data fit in a unit cube
// Construct triangles
// Throw out zero size triangles
// Compute the range of the vertices
// Center and scale all vertices in the input list
//Matrix3 rot90 = Matrix3::fromAxisAngle(Vector3::UNIT_Y, toRadians(180)) * Matrix3::fromAxisAngle(Vector3::UNIT_X, toRadians(90));
//triList[v] = rot90 * triList[v];
// namespace
/**
//graphics.cs.williams.edu
// SOCKADDR_IN is supposed to be defined in NetAddress.h
// The address wasn't in numeric form, resolve it
// Get the IP address of the server and store it in host
/**
// Note: timeout = 0 means no timeout
/////////////////////////////////////////////////////////////////////////////
/** Invokes select on one socket.  Returns SOCKET_ERROR on error, 0 if
// 0 time timeout is specified to poll and return immediately
// Create a set that contains just this one socket
/** Returns true if the socket has a read pending */
// Return true so that we'll force an error on read and close
// the socket.
/** Invokes select on one socket.   */
// 0 time timeout is specified to poll and return immediately
// Create a set that contains just this one socket
///////////////////////////////////////////////////////////////////////////////
//    G3D now initializes winsock through ENet
//    WSADATA wsda;            
//    WSAStartup(MAKEWORD(G3D_WINSOCK_MAJOR_VERSION, G3D_WINSOCK_MINOR_VERSION), &wsda);
// TODO: Find subnet on Win32
// TODO: Find broadcast on Win32
// TODO: find MAC on Win32
/*
// TODO: WSAIoctl for subnet and broadcast addresses
// http://msdn.microsoft.com/en-us/library/ms741621(VS.85).aspx
// 
// TODO: SIO_GET_INTERFACE_LIST 
// An IPv4 address
// Not an IPv4 address
// Used for combining the MAC and ip information
// Head of a linked list of network interfaces on this machine
// Skip this adapter; it is offline or is a loopback
// This adapter must exist because it was created above
// Extract MAC address
// Linux
// The MAC address and the interfaceAddress come in as
// different interfaces with the same name.
// Posix/FreeBSD/Mac OS
// See if there was a MAC address
// Extract all interesting adapters from the table
// Only add adapters that have IP addresses
// Now handled through enet
//        WSACleanup();
///////////////////////////////////////////////////////////////////////////////
/**
// Increase the buffer size; the default (8192) is too easy to
// overflow when the network latency is high.
//////////////////////////////////////////////////////////////////////////////
// Setup socket options (both constructors should set the same options)
// Disable Nagle's algorithm (we send lots of small packets)
// Set the NO LINGER option so the socket doesn't hang around if
// there is unsent data in the queue when it closes.
// Set reuse address so that a new server can start up soon after
// an old one has closed.
// Ideally, we'd like to specify IPTOS_LOWDELAY as well.
// Non-blocking; we must wait until select returns non-zero
// TODO: check for failure on the select call
// Setup socket options (both constructors should set the same options)
// Disable Nagle's algorithm (we send lots of small packets)
// Set the NO LINGER option so the socket doesn't hang around if
// there is unsent data in the queue when it closes.
// Set reuse address so that a new server can start up soon after
// an old one has closed.
// Ideally, we'd like to specify IPTOS_LOWDELAY as well.
// We've already read the message and are waiting
// for a receive call.
// We're currently receiving the message.  Read a little more.
// We've read the whole mesage.  Switch to holding state 
// and return true.
// There are more bytes left to read.  We'll read them on
// the next call.  Because the *entire* message is not ready,
// return false.
// Message incoming.  Read the header.
// Loop back around now that we're in the receive state; we
// may be able to read the whole message before returning 
// to the caller.
// No message incoming.
// The messageWaiting call is what actually receives the message.
// Verify the packet was actually sent
// Conversion to unsigned is safe because -1 is caught earlier
/** Null serializer.  Used by reliable conduit::send(type) */
// Read the type
// The type is the first four bytes.  It is little endian.
// Swap the byte order
// Read the size
// Extend the size of the buffer.
// Read the data itself
// There's still more. Give the machine a chance to read
// more data, but don't wait forever.
// Something went wrong; our blocking read returned nothing.
///////////////////////////////////////////////////////////////////////////////
// Figuring out the MTU seems very complicated, so we just set it to 1000,
// which is likely to be safe.  See IP_MTU for more information.
// This both checks to ensure that a message was waiting and
// actively consumes the message from the network stream if
// it has not been read yet.
// Something went wrong
// We may have already pulled the message off the network stream
// The type is the first four bytes.  It is little endian.
// Swap the byte order
///////////////////////////////////////////////////////////////////////////////
// Start the listener socket
// Set reuse address so that a new server can start up soon after
// an old one has closed.
// listen is supposed to return 0 when there is no error.
// The 2nd argument is the number of connections to allow pending
// at any time.
// The address of the connecting host
////////////////////////////////////////////////////////////////////////////////////////////////
// namespace
/**
//graphics.cs.williams.edu
// Prefer to serialize as a CFrame, which is easier to read
// namespace
/**
//graphics.cs.williams.edu
// Must be a single control point
// Check actual values
// Going the long way, so change the order
/**
//graphics.cs.williams.edu
// Rotate the points around so that the finite points come first.
// 1 finite, 2 infinite points; the plane must contain
// the direction of the two direcitons
// 3 finite points, the plane must contain the directions
// betwseen the points.
// 2 finite, 1 infinite point; the plane must contain
// the direction between the first two points and the
// direction of the third point.
/**
//graphics.cs.williams.edu
// Computing a cosPowHemi costs 4 slow functions (pow, sqrt, sin,
// cos). We can do it with two, given a cosHemi sample, basically
// saving the cost of sin and cos and making a single 128-byte
// memory read (for a vector) instead of two (for adjacent uniform
// floats).
// cos^1 distribution sample
// Fix the distribution by adjusting the cosine:
// rnd(cos^k t) = (rnd(cos(t))^2)^(1/k)
// produces cos^k distribution sample
// Rescale x and y by sqrt(1.0f - square(z)) / sqrt(x*x + y*y).
// Add a very tiny offset to handle the (almost impossibly unlikely) case where
// z = 1 and x^2+y^2 = 0.
/**
//graphics.cs.williams.edu 
/* G3DFIX: exclude GUI prompt code */
/*#ifdef __LP64__
/*
/* G3DFIX: exclude GUI prompt code */
/* G3DFIX: exclude GUI prompt code */
/**
// The dialog box doesn't have a menu or a special class
// Add the dialog's caption to the template
// Increment the component count
/**
// DWORD align the beginning of the component data
// Increment the component count
/**
// Under SDL 1.2.6 we get a NCDESTROY message for no reason and the
// window is immediately closed.  This is here to debug the problem.
// namespace _internal
/**
// Convert all single \n characters to \r\n for proper printing
/*
// The last error value.  (Which is preserved across the call).
// The decoded message from FormatMessage
// Make sure the message got translated into something.
// Get rid of the allocated memory from FormatMessage.
/* G3DFIX: exclude GUI prompt code */
/**
/* G3DFIX: exclude GUI prompt code */
/* G3DFIX: exclude GUI prompt code */
/* G3DFIX: exclude GUI prompt code */
// Build the message box
//Will default to text prompt if numChoices > 4
/* G3DFIX: exclude GUI prompt code */
// namespace
/**
// Find the index of the largest diagonal component
// These ? operations hopefully compile to conditional
// move instructions instead of branches.
// Find the indices of the other elements
// Index the elements of the vector part of the quaternion as a float*
// If we attempted to pre-normalize and trusted the matrix to be
// perfectly orthonormal, the result would be:
//
//   double c = sqrt((rot[i][i] - (rot[j][j] + rot[k][k])) + 1.0)
//   v[i] = -c * 0.5
//   v[j] = -(rot[i][j] + rot[j][i]) * 0.5 / c
//   v[k] = -(rot[i][k] + rot[k][i]) * 0.5 / c
//   w    =  (rot[j][k] - rot[k][j]) * 0.5 / c
//
// Since we're going to pay the sqrt anyway, we perform a post normalization, which also
// fixes any poorly normalized input.  Multiply all elements by 2*c in the above, giving:
// nc2 = -c^2
// We now have the correct result with the wrong magnitude, so normalize it:
// The quaternion is nearly zero.  Make it 0 0 0 1
// Decompose the quaternion into an angle and an axis.
// Reduce the range of the angle.
// Make the angle positive.
// From: Game Physics -- David Eberly pg 538-540
// Modified to include lerp for small angles, which
// is a common practice.
// See also:
// http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/index.html
// angle between quaternion rotations
// Change the sign and fix the dot product; we need to
// loop the other way to get the shortest path
// Using G3D::aCos will clamp the angle to 0 and pi
// Back off alpha        
// For large angles, slerp
// For small angles, linear interpolate
// Following Watt & Watt, page 360
// From "Uniform Random Rotations", Ken Shoemake, Graphics Gems III.
// 2-char swizzles
// 3-char swizzles
// 4-char swizzles
/**
//graphics.cs.williams.edu
// See http://en.wikipedia.org/wiki/Mersenne_twister
// Make a local copy of the index variable to ensure that it
// is not out of bounds
// Automatically checks for index < 0 if corrupted
// by unsynchronized threads.
// Increment the global index.  It may go out of bounds on
// multiple threads, but the above check ensures that the
// array index actually used never goes out of bounds.
// It doesn't matter if we grab the same array index twice
// on two threads, since the distribution of random numbers
// will still be uniform.
// Return the next random in the sequence
// Temper the result
/** Generate the next N ints, and store them for readback later */
// Lower R bits
// Upper (32 - R) bits
// Another thread just generated a set of numbers; no need for
// this thread to do it too
// First N - M
// Rest
// There is a *very small* chance of generating
// a number larger than high.
// Using Box-Mueller method from http://www.taygeta.com/random/gaussian.html
// Modified to specify standard deviation and mean of distribution
// Loop until w is less than 1 so that log(w) is negative
// Transform to gassian distribution
// Multiply by sigma (stdev ^ 2) and add mean.
// Choose the axis direction uniformly at random
// Jensen's method 
// We could also use Malley's method (pbrt p.657), since they are the same cost:
//
//  r = sqrt(e1);
//  t = 2*pi*e2;
//  x = cos(t)*r;
//  y = sin(t)*r;
//  z = sqrt(1.0 - x*x + y*y);
// Squared magnitude
// Rejection sample
// Divide by magnitude to produce a unit vector
// G3D
/**
//graphics.cs.williams.edu
// ray slope
// precomputed terms
//ray slope classification
//(m_direction.z >= 0)
//(m_direction.y >= 0)
//(m_direction.z >= 0)
//(m_direction.x >= 0)
//(m_direction.z >= 0)
//(m_direction.y >= 0)
//(m_direction.z > 0)
/**
//graphics.cs.williams.edu
/** \param any Must either Rect2D::xywh(#, #, #, #) or Rect2D::xyxy(#, #, #, #)*/
/** Converts the Rect2D to an Any. */
/**
// This file is only used on Windows
// static helpers
// increment datasize to allow for non null-terminated strings in registry
// static helpers
// namespace G3D
// G3D_WINDOWS
/**
//graphics.cs.williams.edu
// The farthest distance is along the axis between the centers, which
// must not be colocated since neither contains the other.
// Get a point on the axis from each
// Now just bound the A->B segment
// (if this contains other, we're done)
// No plane can cull the infinite box
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// Plane p culled the sphere
// The caller should not recurse into the children,
// since the parent is culled.  If they do recurse,
// make them only test against this one plane, which
// will immediately cull the volume.
// The bounding volume straddled the plane; we have
// to keep testing against this plane
// Move on to the next bit.
// None of the planes could cull this box
// Don't cull if the sphere has infinite radius
// See if there is one plane for which all of the
// vertices are in the negative half space.
// Only test planes that are not masked
// Plane p culled the sphere
// Move on to the next bit.
// None of the planes could cull this box
// namespace
// The standard Catmull-Rom spline basis (e.g., Watt & Watt p108)
// is for [u^3 u^2 u^1 u^0] * B * [p[0] p[1] p[2] p[3]]^T.
// We need a basis formed for:
//
//     U * C * [2*p'[1] p[1] p[2] 2*p'[2]]^T 
//
//     U * C * [p2-p0 p1 p2 p3-p1]^T 
//
// To make this transformation, compute the differences of columns in C:
// For [p0 p1 p2 p3]
// For [-p0 p1 p2 p3]^T 
// For [-p0 p1 p2 p3-p1]^T 
// For [p2-p0 p1 p2 p3-p1]^T 
// Inclusive bounds for binary search
// too big
// too small
// Having exited the above loop, i must be correct, so compute u.
// No control points to work with
// Cyclic spline
// Cyclic, off the bottom or top
// Compute offset and reduce to the in-bounds case
// Number of times we wrapped around the cyclic array
// Cyclic, off the top but before the end of the last interval
// Cyclic, in bounds
// Non-cyclic
// Non-cyclic, off the bottom.  Assume points are spaced
// following the first time interval.
// Non-cyclic, off the top.  Assume points are spaced following
// the last time interval.
// In bounds, non-cyclic.  Assume a regular
// distribution (which gives O(1) for uniform spacing)
// and then binary search to handle the general case
// efficiently.
// if in bounds
// extrapolation Mode
/**
//graphics.cs.williams.edu
// This is 'alwaysAssert' instead of 'debugAssert'
// since people rarely profile in debug mode.
// We read RDTSC twice here, but it is more abstract to implement this
// way and at least we're reading the cycle count last.
// Off by more than 50%
// The difference between emwa and m_fps is way off, so
// update emwa directly.
// Update m_smoothFPS only when the value varies significantly.
// We round so as to not mislead the user as to the accuracy of 
// the number.        
// Small number and display is off by more than 0.75; round to the nearest 0.1
// Large number and display is off by more than 1.25; round to the nearest 1.0
/**
//graphics.cs.williams.edu
// Define functions for ffmpeg since we don't link in gcc's c library
// disable: "C++ exception handler used"
// Find the next comma, or the end of the string
// Skip over the superquote
// Triple-quote
// Double-quote
// Don't make lines less than this length
// The end
// Look at character c + numCols, see if it is a space.
// Just crop
// Collapse multiple spaces.
// Pointers to the beginning and end of the substring
// Append the last one
// Trim from left
// Trim from right
// namespace
/** 
//graphics.cs.williams.edu
// Uncomment the following line to turn off G3D::System memory
// allocation and use the operating system's malloc.
//#define NO_BUFFERPOOL
// SIMM include
/** Checks if the CPUID command is available on the processor (called from init) */
/** Called from init */
/** Called from init */
// NOTE: Cannot use most G3D data structures or utility functions
// in here because they are not initialized.
// Process the CPUID information
// We read the standard CPUID level 0x00000000 which should
// be available on every x86 processor.  This fills out
// a string with the processor vendor tag.
// Then we connect the single register values to the vendor string
// GenuineIntel
// AuthenticAMD
// Number of cores is in (eax>>26) + 1
// Get the operating system name (also happens to read some other information)
// Note that this overrides some of the values computed above
// Find the operating system using the 'uname' command
// Remove trailing newline
// Operating System:
// Clock Cycle Timing Information:
// System Architecture:
// Places where specific files were most recently found.  This is
// used to cache seeking of common files.
// Places to look in findDataFile
//#define MARK_LOG() logPrintf("%s(%d)\n", __FILE__, __LINE__)
// First check if the file exists as requested.  This will go
// through the FileSystemCache, so most calls do not touch disk.
// Now check where we previously found this file.
// Even if cwd has changed the file is still present.
// We won't notice if it has been deleted, however.
// Remove this from the cache it is invalid
// Initialize the directory array
// If running the demos under visual studio from the G3D.sln file,
// this will locate the data directory.
//logPrintf("%s", d.c_str());
//logPrintf(" exists\n");
//logPrintf(" does not exist\n");
// Generate an error message.  Delay this operation until we know that we need it;
// otherwise all of the string concatenation would run on each successful find.
// Not found
// Wipe the findDataFile cache
// all known supported architectures have cpuid
// add cases for incompatible architectures if they are added
// e.g., if we ever support __powerpc__ being defined again
// Bit 28 is HTT; not checked by G3D
// Only on AMD
// Only on AMD
// Only on AMD
/* G3DFIX: Don't check if on 64-bit Windows platforms or using MinGW */
// 32-bit
/** Michael Herf's fast memcpy.  Assumes 16-byte alignment */
// 64 bytes per iteration 
// Read in source data 
// Non-temporal stores 
// Memcpy the rest
/* G3DFIX: Don't check if on 64-bit Windows platforms or using MinGW */
// The overhead of our memcpy seems to only be worthwhile on large arrays
/** Michael Herf's fastest memset. n32 must be filled with the same
/* G3DFIX: Don't check if on 64-bit Windows platforms or using MinGW */
// On x86 processors, use MMX
/* G3DFIX: Don't check if on 64-bit Windows platforms or using MinGW */
/** Removes the 'd' that icompile / Morgan's VC convention appends. */
// Maybe remove the 'd'; see if ../ or ../../ has the same name
// Run the 'ps' program to extract the program name
// from the process ID.
// filename will contain a newline.  Overwrite it:
// In case of an error, leave the handling up to the caller
// Ensure proper NULL termination
// Overhead of calling this function, measured from a previous run.
// On Windows, a "time slice" is measured in quanta of 3-5 ms (http://support.microsoft.com/kb/259025)
// Sleep(0) yields the remainder of the time slice, which could be a long time.
// A 1 ms minimum time experimentally kept the "Empty GApp" at nearly no CPU load at 100 fps,
// yet nailed the frame timing perfectly.
// Safe to use Sleep with a time... sleep for half the remaining time
// Safe to use Sleep with a zero time;
// causes the program to yield only
// the current time slice, and then return.
// Not safe to use Sleep; busy wait
// Translate to milliseconds
// Translate to microseconds
// Use termios to turn off line buffering
// "sse" = "seconds since epoch".  The time
// function returns the seconds since the epoch
// GMT (perhaps more correctly called UTC). 
// No call to free or delete is needed, but subsequent
// calls to asctime, ctime, mktime, etc. might overwrite
// local_time_vals. 
// tm_gmtoff is already corrected for daylight savings.
// Linux resolution defaults to 100Hz.
// There is no need to do a separate RDTSC call as gettimeofday
// actually uses RDTSC when on systems that support it, otherwise
// it uses the system clock.
////////////////////////////////////////////////////////////////
/** Only store buffers up to these sizes (in bytes) in each pool->
// 64-bit machines have larger pointers...and probably have more memory as well
/** 
/** Pointer given to the program.  Unless in the tiny heap, the user size of the block is stored right in front of the pointer as a uint32.*/
/** Actual block allocated on the heap */
/** The tiny pool is a single block of storage into which all tiny
/** Pointer to the data in the tiny pool */
/** 
// Note that we ignore the actual byte size
// and create a constant size block.
// Return the old last pointer from the freelist
//   "System::malloc heap corruption detected: "
//   "the last two pointers on the freelist are identical (during tinyMalloc).");
// NULL out the entry to help detect corruption
/** Returns true if this is a pointer into the tiny heap. */
//           "Tried to free a tiny pool buffer when the tiny pool freelist is full.");
//                    "System::malloc heap corruption detected: "
//                    "the last two pointers on the freelist are identical (during tinyFree).");
// Put the pointer back into the free list
/** Allocate out of a specific pool.  Return NULL if no suitable 
// OPT: find the smallest block that satisfies the request.
// See if there's something we can use in the buffer pool.
// Search backwards since usually we'll re-use the last one.
// We found a suitable entry in the pool.
// No need to offset the pointer; it is already offset
// Remove this element from the pool, replacing it with
// the one from the end (same as Array::fastRemove)
/** Count of memory allocations that have occurred. */
/** Amount of memory currently allocated (according to the application). 
// TODO: make me an atomic int!
// Initialize the tiny heap as a bunch of pointers into one
// pre-allocated buffer.
///---------------------------------- old mutex
///---------------------------------- old mutex
//-------------------------------- old mutex
// No destruction on pthreads
//--------------------------------old mutex
// The old pointer actually had enough space.
// Free the old pointer and malloc
// In one of our heaps.
// See how big the block really was
// The old block was big enough.
// Need to reallocate and move
// Failure to allocate a tiny buffer is allowed to flow
// through to a small buffer
// Note that a small allocation failure does *not* fall
// through into a medium allocation because that would
// waste the medium buffer's resources.
// Heap allocate
// Allocate 4 extra bytes for our size header (unfortunate,
// since malloc already added its own header).
// Check for memory corruption
// Flush memory pools to try and recover space
// Re-attempt the malloc
// Notify the application
// Free does nothing on null pointers
// Free; the buffer pools are full or this is too big to store.
// Dynamically allocated because we need to ensure that
// the buffer pool is still around when the last global variable 
// is deallocated.
// Putting the test here ensures that the system is always
// initialized, even when globals are being allocated.
// We must align to at least a word boundary.
// Pad the allocation size with the alignment size and the size of
// the redirect pointer.  This is the worst-case size we'll need.
// Since the alignment size is at least teh word size, we don't
// need to allocate space for the redirect pointer.  We repeat the max here
// for clarity.
// malloc returned NULL
// The blocks we return will not be valid Win32 debug heap
// pointers because they are offset 
//  debugAssert(_CrtIsValidPointer((void*)truePtr, totalBytes, TRUE) );
// We want alignedPtr % alignment == 0, which we'll compute with a
// binary AND because 2^n - 1 has the form 1111... in binary.
// The return pointer will be the next aligned location that is at
// least sizeof(void*) after the true pointer. We need the padding
// to have a place to write the redirect pointer.
// Add what we need to make it to the next alignment boundary, but
// if the remainder was zero, let it wrap to zero and don't add
// anything.
// Immediately before the aligned location, write the true array location
// so that we can free it correctly.
// Back up one word from the pointer the user passed in.
// We now have a pointer to a pointer to the true start
// of the memory block.
// Dereference that pointer so that ptr = true start
// Many linux implementations of putenv expect char*
// Windows 64-bit
// See http://sam.zoy.org/blog/2007-04-13-shlib-with-non-pic-code-have-inline-assembly-and-pic-mix-well
// for a discussion of why the second version saves ebx; it allows 32-bit code to compile with the -fPIC option.
// On 64-bit x86, PIC code has a dedicated rip register for PIC so there is no ebx conflict.
// AT&T assembler syntax
/* Wipe ecx */
// AT&T assembler syntax
/* save ebx */
/* Wipe ecx */
/* save what cpuid just put in %ebx */
/* restore the old ebx */
// namespace
/**
//graphics.cs.williams.edu
// Hex
/*
// End of file
// Need to back up.  This only works if the stack is actually
// in proper order reflecting the real file, and doesn't
// contain incorrectly pushed elements.
// Read until delimiter or eof
// Done
// Convert true and false symbols to all uppercase for fast comparisons
// Don't go off the end
// update lineNumber and charNumber to reflect the location of the *next*
// character which will be read.
// increment line number for \r, \n and \r\n which matches Token::NEWLINE parsing
// check for \r\n
// Don't go off the end
// loop through white space, newlines and comments
// found before other tokens
// generate newlines tokens for '\n' and '\r' and '\r\n'
// Consume the single whitespace
// update line and character number to include discarded whitespace
// This is an unsigned number.  Jump ahead for fast number reading.
// This is a simple number.  Jump ahead for fast number reading.
// We treat this case specially because large (i.e., slow) files
// are usually large because they are full of numbers.
// Consume the minus sign
// parse comments and generate tokens if enabled
// check for line comments first
// set start of line comment and eat markers
// set start of line comment and eat markers
// set start of line comment and eat markers
// consume line comment to newline or EOF
// build comment string for token
// There is whitespace after the comment (in particular, the
// newline that terminates the comment).  There might also be
// whitespace at the start of the next line.
// consume block comment to end-marker or EOF
// consume both start-comment chars, can't let the trailing one
// help close the comment.
// c is the next character we'll read, c2 is the one after *that*
// Eat input char may consume more than one character if there is a newline
// eat closing '*'
// eat closing '/'
// There is whitespace after the comment (in particular, the
// newline that terminates the comment).  There might also be
// whitespace at the start of the next line.
// while (! whitespaceDone)
// handle EOF
// Extended ASCII parses as itself, except for EOF
// Perform appropriate setup for a symbol (including setting up the token
// string to start with c), eat the input character, and overwrite
// 'c' with the peeked next input character.
// Simple symbols -> just themselves.
// negative number, -, --, -=, or ->
// ->
// --
// -=
// Negative number.  'c' is still the first digit, and is
// the next input char.
// negative infinity
// i
// n
// f
// plain -
// positive number, +, ++, or +=
// ++
// +=
// Positive number.  'c' is still the first digit, and is
// the next input char.
// positive infinity
// i
// n
// f
// : or :: or ::> or ::= or := or :>
// = or == or =>
// * or *=
// / or /=
// ! or !=
// ~ or ~=
// ^ or ^=
// >, >>,or >=
// <<, <<, or <= or <- or <:
// ||, ||, or |= or |-
// &, &&, or &=
// backslash or escaped comment char.
// escaped comment character.  Return the raw comment
// char (no backslash).
// number, ., .., or ...
// We're parsing a float that began without a leading zero
// .. or ...
// ...
// switch (c)
// A number.  Note-- single dots have been
// parsed already, so a . indicates a number
// less than 1 in floating point form.
// [0-9]*(\.[0-9][f]) or [0-9]+ or 0x[0-9,A-F]+
// If we picked up a leading "-" sign above, keep it,
// otherwise drop the string parsed thus far
// Hex number
// skip the 0x
// Non-hex number
// Read the part before the decimal.
// True if we are reading a floating-point special type
// Read the decimal, if one exists
// The '.' character was a decimal point, not the start of a
// method or range operator
// Floating point specials (msvc format only)
// We are reading a floating point special value
// of the form -1.#IND00, -1.#INF00, or 1.#INF00
// (with or without the trailing 00
// On older systems, there may be an extra 00 tacked on.
// Read the part after the decimal
// Read exponent
// Trailing f on a float
// Identifier or keyword
// [A-Za-z_][A-Za-z_0-9]*
// See if this symbol is actually a boolean
// Discard the double-quote.
// Double quoted string
// Discard the single-quote.
// Single quoted string
// end of special case tokens
// Some unknown token
// We're definitely going to consume the next input char, so we get
// it right now.  This makes the condition handling below a bit easier.
// END inside a quoted string.  (We finish the string.)
// An escaped character.  We're definitely going to consume it,
// so we get it (and consume it) now.
// otherwise, some illegal escape sequence; skip it.
// switch
// End of the string.  Already consumed the character.
// All other chars, go on to the string.  Already consumed the
// character.
// Push initial token back, and throw an error.  We intentionally
// indicate that the wrong type is the type of the initial token.
// Logically, the number started there.
// common case
// Even if signedNumbers is disabled, readInteger attempts to
// read a signed number, so we handle that case here.
// push back the second token.
// Push initial token back, and throw an error.  We intentionally
// indicate that the wrong type is the type of the initial token.
// Logically, the number started there.
// common case
// Even if signedNumbers is disabled, readNumber attempts to
// read a signed number, so we handle that case here.
// push back the second token.
// Push initial token back, and throw an error.  We intentionally
// indicate that the wrong type is the type of the initial token.
// Logically, the number started there.
// fast path
// fast path
// fast path
// fast path
// fast path
// fast path
// fast path
// fast path
// TODO: this could be faster if we directly read the zipfile
// Read directly into the array
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
// namespace
/**
//graphics.cs.williams.edu
// If there were more pops than pushes, don't let that take us below 0 indent.
// Don't ever indent more than the number of columns.
// Never break a line in a string
// Convert special characters to escape sequences
// TODO: can be significantly optimized in cases where
// single characters are copied in order by walking through
// the array and copying substrings as needed.
// Unix newline
// Windows newline
// TODO: keep track of the last space character we saw so we don't
// have to always search.
// No word-wrapping is needed
// Add one character at a time.
// TODO: optimize for strings without newlines to add multiple
// characters.
// Number of columns to wrap against
// Copy forward until we exceed the column size, 
// and then back up and try to insert newlines as needed.
// \r\n, we need to hit the \n to enter word wrapping.
// True when we're allowed to treat a space as a space.
// Cases:
//
// 1. Currently in a series of spaces that ends with a newline
//     strip all spaces and let the newline
//     flow through.
//
// 2. Currently in a series of spaces that does not end with a newline
//     strip all spaces and replace them with single newline
//
// 3. Not in a series of spaces
//     search backwards for a space, then execute case 2.
// Index of most recent space
// How far back we had to look for a space
// Search backwards (from current character), looking for a space.
// We couldn't find a series of spaces
// Strip the last character we wrote, force a newline,
// and replace the last character;
// Must be Settings::WRAP_WITHOUT_BREAKING
//
// Don't write the newline; we'll come back to
// the word wrap code after writing another character
// We found a series of spaces.  If they continue 
// to the new string, strip spaces off both.  Otherwise
// strip spaces from data only and insert a newline.                
// Find the start of the spaces.  firstSpace is the index of the
// first non-space, looking backwards from lastSpace.
// Spaces continued up to the new string
// Delete the spaces from the new string
// Spaces were somewhere in the middle of the old string.
// replace them with a newline.
// Copy over the characters that should be saved
// Undo changes to quoting (they will be re-done
// when we paste these characters back on).
// Remove those characters and replace with a newline.
// Write them back
// We are now free to continue adding from the
// new string, which may or may not begin with spaces.
// if spaces included new string
// if hit indent
// if line exceeded
// iterate over str
// Don't increment the column count on return character
// newline is taken care of below.
// Null terminate
/////////////////////////////////////////////////////////////////////
// Find the unstarted threads
// Save the last unstarted for the current thread
// Start all threads
// Start the last one on my thread
// namespace G3D
/**
//graphics.cs.williams.edu
//0.5f * (_vertex[1] - _vertex[0]).cross(_vertex[2] - _vertex[0]).dot(_plane.normal());
// Choose a random point in the parallelogram
// Outside the triangle; reflect about the
// diagonal of the parallelogram
// See RTR2 ch. 13.7 for the algorithm.
// Determinant is ill-conditioned; abort early
// We hit the plane of the m_geometry, but outside the m_geometry
// We hit the plane of the triangle, but outside the triangle
// This is a new hit, closer than the previous one
// This hit is after the previous hit, so ignore it
// G3D
/**
//graphics.cs.williams.edu
/** Adds two 64-bit integers, placing the result and the overflow into 64-bit integers.*/
// Break each number into 4 32-bit chunks. Since we are using uints, right-shifting will fill with zeros.
// This eliminates the need to and with 0xFFFFFFFF.
/** Multiplies two unsigned 64-bit integers, placing the result into one 64-bit int and the overflow into another.*/
// Break each number into 4 32-bit chunks. Since we are using uints, right-shifting will fill with zeros.
// This eliminates the need to and with 0xFFFFFFFF.
// The product of the low bits of a and b will always fit into the result
// The product of the high bits of a and b will never fit into the result
// The high 32 bits of prod[0][1] and prod[1][0] will never fit into the result
// Adding the carry will change hi. Save the old hi bits in case this == x.
// The low bits will get overwritten when doing the multiply, so back up both (in case &x == this)
// Overflow doesn't matter here because the result is going into hi - any overflow will exceed the capacity of a 128-bit number
// Note: hi * x.hi will always overflow, since (x * 2^64) * (y * 2^64) = x*y*(2^128). The largest number expressable in 128 bits is
// 2^128 - 1.
//Before shifting, mask out the bits that will be shifted out of hi.
//Put a 1 in the first bit that will not be lost in the shift, then subtract 1 to get the mask.
//Shift lo and add the bits shifted down from hi
//Before shifting, mask out the bits that will be shifted out of lo.
//Put a 1 in the last bit that will be lost in the shift, then subtract 1 to get the logical inverse of the mask.
//A bitwise NOT will then produce the correct mask.
//Shift hi and add the bits shifted up from lo
/**
//graphics.cs.williams.edu
// Use the first point to establish the wrapping convention
// No two angles should be more than pi (i.e., 180-degrees) apart.  
// These angles must have wrapped at zero, causing them
// to be interpolated the long way.
// Find canonical [0, 2pi] versions of these numbers
// Find the difference -pi < diff < pi between the current and previous values
// Offset the current from the previous by the difference
// between them.
///////////////////////////////////////////////////////////////////////////////////////////
// Import legacy path
/**
//graphics.cs.williams.edu
//www.magic-software.com
// Table
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// 2-char swizzles
// 3-char swizzles
// 4-char swizzles
// namespace
/**
//graphics.cs.williams.edu
// Table
/**
//graphics.cs.williams.edu
//www.magic-software.com
// Apply clamped translation
// Table
//----------------------------------------------------------------------------
// 2 * normal.dot(this) * normal - this
// Make a coordinate system
// Make a coordinate system
// Make a coordinate system
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// From pg. 24 of Henrik Wann Jensen. Realistic Image Synthesis
// Using Photon Mapping.  AK Peters. ISBN: 1568811470. July 2001.
// Invert the directions from Wann Jensen's formulation
// and normalize the vectors.
// Total internal reflection
//----------------------------------------------------------------------------
// If the input vectors are v0, v1, and v2, then the Gram-Schmidt
// orthonormalization produces vectors u0, u1, and u2 as follows,
//
//   u0 = v0/|v0|
//   u1 = (v1-(u0*v1)u0)/|v1-(u0*v1)u0|
//   u2 = (v2-(u0*v2)u0-(u1*v2)u1)/|v2-(u0*v2)u0-(u1*v2)u1|
//
// where |A| indicates length of vector A and A*B indicates dot
// product of vectors A and B.
// compute u0
// compute u1
// compute u2
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// 2-char swizzles
// 3-char swizzles
// 4-char swizzles
// namespace
/**
//graphics.cs.williams.edu
/**
//graphics.cs.williams.edu
//----------------------------------------------------------------------------
// 2-char swizzles
/**
//graphics.cs.williams.edu
// Table
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// 2-char swizzles
// 3-char swizzles
// 4-char swizzles
// namespace
/**
//graphics.cs.williams.edu
// Intentionally write individual bytes to avoid endian issues
// namespace G3D
/**
// for profiling
// Uncomment to print information that can help with performance
// profiling.
//#define VERBOSE
/** Used by WeldHelper2::smoothNormals. */
/** Used by WeldHelper::getIndex to maintain a list of vertices by location. */
// G3D
/** Used by getIndex and updateTriLists. Deallocating this is slow. */
/** Squared radius allowed for welding similar normals. */
/**
// Don't bother trying to match the surface normal, since this vertex has no surface normal.
// This is the vertex
// This is the vertex
// Note that a sliver triangle processed before its neighbors may reach here
// with a zero length normal.
// The vertex does not exist. Create it.
// Store in the grid so that it will be remembered.
/**
// Compute a hash grid so that we can find neighbors quickly.
// It begins empty and is extended as the tri lists are iterated
// through.
// Process all triLists
// For all vertices in this list
// This vertex mapped to u in the flatVertexArray
/*
/** Expands the indexed triangle lists into a triangle list.
/** For every three vertices, compute the face normal and store it three times.
// Note that the length may be zero in the case of sliver polygons, e.g.,
// those correcting a T-junction.  Scale up by 256 to avoid underflow when
// multiplying very small edges
// Append the normal once per vertex.
/**
// Create an area memory manager for fast deallocation
// Look for vertices with the exactly identical normal only
// Maximum expected faces that meet at a vertex
// Maps vertices to the indices of normals at that vertex
// This normal is close enough to consider.  Avoid underflow by scaling up
// Never "smooth" a normal so far that it points backwards
// Revert to the face normal
// Average available normals
// Non-zero vertex normal welding
// Compute a hash grid so that we can find neighbors quickly.
// OPT: this step could be done on multiple threads
// Compute the sum of all nearby normals within the cutoff angle.
// Search within the vertexWeldRadius, since those are the vertices
// that will collapse to the same point.
// This normal is close enough to consider.  Avoid underflow by scaling up
// Never "smooth" a normal so far that it points backwards
// Revert to the face normal
// Average available normals
/**
// Create an area memory manager for fast deallocation
// Generate all zero texture coordinates
// Generate a flat (unrolled) triangle list with texture coordinates.
// Put the output back into the input slots. 
// For every three vertices, generate their face normal and store it at 
// each vertex. The output array has the same length as the input.
// Compute smooth normals at vertices.
// Regenerate the triangle lists
// Throw away the generated texCoords
// Internal
// G3D
/*
/* _WIN32_WCE_EMULATION */
/* main */
/* seems to be undefined in Win CE although in online help */
/* _WIN32_WCE < 300 */
// Turn off the G3D for loop scoping for C++
/* Parse a command line buffer into arguments */
/* Skip leading whitespace */
/* Skip over argument */
/* Skip over word */
/* Skip over word */
/* Show an error message */
/* If USE_MESSAGEBOX is defined, you need to link with user32.lib */
/* Pop up an out of memory message, returns to Windows */
/*
/* Grab the command line */
/* Parse it into argv and argc */
/* Run the main program */
// if Win32
/**
// Raw string; no quotes
// Only tags know to append a newline
/** True if the next token begins the close tag */
// Need to keep looking ahead
// Check the name on the close tag.  It *must* match if
// this is a well-formed document, but there might be a
// tag error.
// Put the tokens back
// Put the read token back
// Beginning a tag
// Read name
// ignored tag:        <?xml> or <!xml>
// comment tag:        <!--   ... -->
// Ignore this tag
// Ignore until "-->"
// Keep reading until no colon
//  tag with namespace: <x:y>
// Read end of tag/close
// empty-element tag:  <foo/>
// Consume the close tag
// End of open tag: read children until close tag
// Read close tag (we wouldn't be here unless it parses correctly)
// Attribute pair
// Advance to next
// Beginning embedded content.  Read until the end of file or the next tag.
/* soapC.cpp
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* appease -Wall -Werror */
/* End of soapC.cpp */
/* soapServer.cpp
/* End of soapServer.cpp */
/*
//www.cs.fsu.edu/~engelen/soaplicense.html
/* EBCDIC to ASCII */
/* WinCE */
/* disable deprecation warnings */
/* 8bit character representing unknown/nonrepresentable character data (e.g. not supported by current locale with multibyte support enabled) */
/*      EOF=-1 */
/* XML-specific '<' */
/* XML-specific '</' */
/* XML-specific '>' */
/* XML-specific '"' */
/* XML-specific ''' */
/* make GNUTLS thread safe with pthreads */
/* make GNUTLS thread safe with PTH */
/*FIONBIO*/, &blocking); \
/*FIONBIO*/, &nonblocking); \
//schemas.xmlsoap.org/soap/envelope/";
//schemas.xmlsoap.org/soap/encoding/";
//www.w3.org/2003/05/soap-envelope";
//www.w3.org/2003/05/soap-encoding";
//www.w3.org/2003/05/soap-rpc";
/* Alternative indentation form for SOAP_XML_INDENT:
/* entities for XHTML parsing */
/******************************************************************************/
/* retry and back-off algorithm */
/* TODO: this is not very clear from specs so verify and limit conditions under which we should loop (e.g. ENOBUFS) */
/* SOAP-over-UDP MULTICAST_UDP_REPEAT - 1 */
/* SOAP-over-UDP UNICAST_UDP_REPEAT - 1 */
/* UDP_MIN_DELAY .. UDP_MAX_DELAY */
/* UDP_UPPER_DELAY */
/* and call write() again */
/* and call write() again */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* max 100 retries with non-blocking sockets */
/* SSL: sockets are nonblocking */
/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */
/* CycleSyncDisplay(curStatusMsg); */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* read HTTP chunked transfer */
/******************************************************************************/
/* do not call again after EOF */
/******************************************************************************/
/******************************************************************************/
/* case sensitive */
/******************************************************************************/
/* case insensitive */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* use this to represent unknown code */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* This is a quick way to parse XML PI and we could use a callback instead to
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* doesn't look like this is UTF8 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* must be multiple of 3 */
/******************************************************************************/
/* Check MTOM xop:Include element (within hex/base64Binary) */
/* TODO: this code to be obsoleted with new import/xop.h conventions */
/* should save type too? */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* find default namespace, if present */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************\
/******************************************************************************/
/******************************************************************************/
/* if dhfile is numeric, treat it as a key length to generate DH params which can take a while */
/******************************************************************************/
/******************************************************************************/
/* Note: for MT systems, the main program MUST call soap_ssl_init() before any threads are started */
/* 2.8.1 change (wsseapi.c) */
/* libgcrypt init done */
/******************************************************************************/
/******************************************************************************/
/* The following alters the behavior of SSL read/write: */
/* This code assumes a typical scenario, see alternative code below */
/* Suggested alternative approach to check the key file for certs (cafile=NULL):*/
/* if dhfile is numeric, treat it as a key length to generate DH params which can take a while */
/*or 5*/, NULL, NULL);
/* disable SSL v2 */
/* TLS extension is enabled by default in OPENSSL v0.9.8k
/* TODO: GNUTLS need to concat cert and key in single key file */
/******************************************************************************/
/******************************************************************************/
/* accept self signed certificates and certificates out of date */
/* Note: return 1 to continue, but unsafe progress will be terminated by OpenSSL */
/******************************************************************************/
/* accept self signed certificates and certificates out of date */
/* Note: return 1 to continue, but unsafe progress will be terminated by SSL */
/******************************************************************************/
/******************************************************************************/
/* Set SSL sockets to non-blocking */
/* timeout: 10 sec retries, 100 times 0.1 sec */
/* Set SSL sockets to non-blocking */
/* timeout: 10 sec retries, 100 times 0.1 sec */
/* GNUTLS repeat handhake when GNUTLS_E_AGAIN */
/******************************************************************************\
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* inet_addr(), and hostGetByName() expect "char *"; addr is a "const char *". */
/* If the DNS resolver library resolvLib has been configured in the vxWorks
/******************************************************************************/
/* speeds up windows xfer */
/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */
/* IPv6: already connected so use send() */
/* preserve settings */
/* make sure we only parse HTTP */
/* save the content length */
/* save the current status/command */
/* save the KA status */
/* mask IO and ENC */
/* mask IO and ENC */
/* preserve */
/* preserve */
/* restore */
/* restore */
/* restore */
/* restore */
/* restore */
/* restore */
/* Connect timeout: set SSL sockets to non-blocking */
/* timeout: 10 sec retries, 100 times 0.1 sec */
/* Try connecting until success or timeout (when nonblocking) */
/* Set SSL sockets to nonblocking */
/* Check server credentials when required */
/* OpenSSL not perfectly portable at this point (?):
/* wildcard domain */
/* Set SSL sockets to non-blocking */
/* timeout: 10 sec retries, 100 times 0.1 sec */
/* GNUTLS repeat handhake when GNUTLS_E_AGAIN */
/******************************************************************************/
/* no FD_SETSIZE or select() is not MT safe on some QNX: always poll */
/* if fd max set size exceeded, use poll() */
/* -usec -> ms */
/* avoid overflow */
/* sec -> ms */
/******************************************************************************/
/* portability note: see SOAP_SOCKLEN_T definition in stdsoap2.h */
/******************************************************************************/
/* SSL shutdown does not work when reads are pending, non-blocking */
/*
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* speeds up windows xfer */
/******************************************************************************/
/* OK when no socket! */
/******************************************************************************/
/* speeds up windows xfer */
/* does not return port number on some systems */
/******************************************************************************/
/* close on error: attachment state is not to be trusted */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* to force close the socket */
/* to force close the socket */
/******************************************************************************\
/******************************************************************************/
/* soap->status == 0 for HTTP request */
/* prevents further processing */
/* Status OK (HTTP 200) */
/* Status 201 (Created), 202 (Accepted), ... and HTTP 400 and 500 errors
/* force close afterwards in soap_closesock() */
/* read HTTP body for error details */
/******************************************************************************/
//");
//");
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* prevent overrun */
/* RFC 2732 */
/******************************************************************************/
/* disallow \n in HTTP headers */
/******************************************************************************/
/******************************************************************************/
/* RPM behaves as if standalone */
/* standalone application (socket) or CGI (stdin/out)? */
/* CGI header */
/* RPM behaves as if standalone */
/* standalone application */
/* CGI */
/******************************************************************************/
/* this tests for chunking too */))
/******************************************************************************\
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* already URL encoded? */
/******************************************************************************/
/* domain-level cookies, cannot compile when WITH_NOIO set */
/* HTTP header size overflow */
/******************************************************************************/
/* cookie size is up to 4096 bytes [RFC2109] */
/******************************************************************************/
/* cookie size is up to 4096 bytes [RFC2109] */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* WITH_COOKIES */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* keep track of last DIME attachment */
/* count # of attachments */
/* accumulate total size of attachments */
/******************************************************************************/
/******************************************************************************/
/* Set win32 stdout or soap->sendfd to BINARY, e.g. to support DIME */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* Add MTOM xop:Include element when necessary */
/* TODO: this code to be obsoleted with new import/xop.h conventions */
//www.w3.org/2004/08/xop/include\" href", aid)
/* RFC 2111 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* align at 4-, 8- or 16-byte boundary */
/* set the canary to detect corruption */
/* keep chain of alloced cells for destruction */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* we must assume these were deallocated: */
/******************************************************************************/
/* this was possibly deallocated */
/* this was possibly deallocated */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* found and removed from dealloc chain */
/* found and removed from dealloc chain */
/******************************************************************************/
/******************************************************************************/
/* lookup pointer to hash table entry for string id */
/* new hash table entry for string id */
/******************************************************************************/
/* lookup pointer to hash table entry for string id */
/* new hash table entry for string id */
/******************************************************************************/
/* lookup pointer to hash table entry for string id */
/* new hash table entry for string id */
/******************************************************************************/
/******************************************************************************/
/* SOAP body referenced attachments must appear first */
/* need to flush the remaining data in buffer */
/* Send TCP FIN */
/* Send TCP FIN */
/******************************************************************************/
/* reset before next send */
/* reset before next send */
/* Check if MIME attachments and mime-post-check flag is set, if so call soap_resolve() and return */
/* Make sure end of compressed content is reached */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* copy XML parser state */
/* copy reversed nlist */
/* preserve element nesting level */
/* copy attributes */
/******************************************************************************/
/******************************************************************************/
/* 0: use default */
/* Alternative: use "%G" */
/* Alternative: use "%lG" */
/* default DIME id format */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* reverse the namespace list */
/* then push on new stack */
/* preserve element nesting level */
/* restore level */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* non-nested wsu:Id found: clear xmlns, re-emit them for exc-c14n */
/* only produce the first four required entries */
/* namespace table control: ns = 0 or 2 to start, then 1 to stop dumping the table  */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* assume b == 16 and value is always positive */
/******************************************************************************/
/* b == 16 */
/******************************************************************************/
/******************************************************************************/
/* decrement level just before /> */
/******************************************************************************/
/* decrement level just before > */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* just ignore content for compliance reasons, but should compare tag to element's QName value? */
/******************************************************************************/
/* push namespace */
/******************************************************************************/
/******************************************************************************/
/* this whitespace or mixed content is significant for DOM */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* UTF-8 BOM? */
/* UTF-8 */
/* UTF-16 BE */
/* UTF-16 LE */
/* whitespace leading to tag is not insignificant for DOM */
/* skip space */
/* whitespace leading to end tag is significant for DOM */
/* add attribute name to dom */
/* if attribute name is qualified, append it to the end of the list */
/* blank delimiter */
/* seen this attribute w/ value */
/* seen this attribute w/o value */
//schemas.xmlsoap.org/soap/actor/next"))
//www.w3.org/2003/05/soap-envelope/role/next"))
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* too many or large attribute values */
/* use look-aside buffer */
/* allocate more space in look-aside buffer if necessary */
/* space to populate */
/* number of bytes available */
/* claim this space */
/* copy multibyte characters */
/* CDATA */
/* comment */
/* PI */
/* use look-aside buffer */
/* allocate more space in look-aside buffer if necessary */
/* space to populate */
/* number of bytes available */
/* claim this space */
/* copy multibyte characters */
/******************************************************************************/
/* check UTF16 encoding when wchar_t is too small to hold UCS */
//unicode.org/faq/utf_bom.html#utf16-2 */
/* http://unicode.org/faq/utf_bom.html#utf16-2 */
/* Malformed */
/******************************************************************************/
//unicode.org/faq/utf_bom.html#utf16-2 */
/* http://unicode.org/faq/utf_bom.html#utf16-2 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* convert decimal comma to DP */
/******************************************************************************/
/******************************************************************************/
/* On some systems strtof requires -std=c99 or does not even link: so we try to use strtod first */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* convert decimal comma to DP */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* remove non-ASCII chars */
/******************************************************************************/
/* convert (by prefix normalize prefix) all QNames in s */
/* skip blanks */
/* find next QName */
/* if there is no namespace stack, or prefix is "xml" then copy string */
/* we normalize the QName by replacing its prefix */
/* replace prefix */
/* no namespace, part of string */
/* no namespace: assume "" namespace */
/* advance to next and add spacing */
/******************************************************************************/
/* skip blanks */
/* find next QName */
/* normal prefix: pass string as is */
/* URL-based string prefix */
/* URL is in the namespace table? */
/* not in namespace table: create xmlns binding */
/* advance to next and add spacing */
/******************************************************************************/
/* Convert UTF8 to wchar */
/******************************************************************************/
/* Convert wchar to UTF8 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* parse non-XSD-standard alternative ISO 8601 format */
/* +hh:mm */
/* +hhmm */
/* put hour and min in range */
/* note: day of the month may be out of range, timegm() handles it */
/* no UTC or timezone, so assume we got a localtime */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* return non-null pointer */
/******************************************************************************/
/* got \r or something else, now get \n */
/* empty line: end of HTTP/MIME header */
/* HTTP line continuation? */
/******************************************************************************/
/* count \r\n--boundary\r\n */
/* count Content-Type: ...\r\n */
/* count Content-Transfer-Encoding: ...\r\n */
/* count Content-ID: ...\r\n */
/* count Content-Location: ...\r\n */
/* count Content-Description: ...\r\n */
/* count \r\n...content */
/* count \r\n--boundary-- */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* skip padding and get hdr */
/******************************************************************************/
/* allocate one more for '\0' */
/* force 0-terminated */
/******************************************************************************/
/* remove white space */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* force 0-terminated */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* FEXTRA */
/* skip FNAME */
/* skip FCOMMENT */
/* skip FHCRC (CRC32 is used) */
/******************************************************************************/
/******************************************************************************/
/* don't assume we're parsing SOAP content by default */
/* Set win32 stdout or soap->sendfd to BINARY, e.g. to support DIME */
/* should not chunk over plain transport, so why bother to check? */
/* if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK) */
/*   soap->z_buflen = soap->bufidx; */
/* else */
/* skip BOM */
/* UTF-8 */
/* UTF-16 BE */
/* UTF-16 LE */
/* skip space */
/* if not XML or MIME/DIME/ZLIB, assume HTTP header */
/* force close later */
/* prevents further processing */
/* if imode is changed, effectuate */
/* restore imode */
/* Note: fparse should not use soap_unget to push back last char */
/* HTTP OK: always expect data */
/* prevents further processing */
/* skip preamble */
/******************************************************************************/
/* DIME in MIME correction */
/******************************************************************************/
/* 2.8: always emit \r\n */
/* DIME in MIME correction */
/******************************************************************************/
/* get HTML body of HTTP error content */
/* use look-aside buffer */
/* allocate more space in look-aside buffer if necessary */
/* space to populate */
/* number of bytes available */
/* claim this space */
/******************************************************************************/
/* make sure we use SOAP 1.1 */
/* make sure we use SOAP 1.2 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* save previous host name: if != then reconnect */
/* save previous port to compare */
/* to force close */
/* to force close */
/******************************************************************************/
//www.nongnu.org/libntlm/ */
/* requires libntlm from http://www.nongnu.org/libntlm/ */
/* S -> C   401 Unauthorized
/* C -> S   GET ...
/* S -> C   401 Unauthorized
/* C -> S   GET ...
/******************************************************************************/
/******************************************************************************/
/* make sure enough space for \0 */
/******************************************************************************/
/******************************************************************************/
/* make sure enough space for \0 */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* to terminate connection */
/******************************************************************************/
/* try getfault when no tag or tag mismatched at level 2, otherwise ret */
/* check flag set: check if SOAP Fault is present, if not just return */
/******************************************************************************/
/* stops the server's processing of request */
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************\
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
//////////////////////////////////////////////////////////////////////////////////////////
// Check if P in vertex region outside A
// barycentric coordinates (1,0,0)
// Check if P in vertex region outside B
// barycentric coordinates (0,1,0)
// Check if P in edge region of AB, if so return projection of P onto AB
// barycentric coordinates (1-v,v,0)
// Check if P in vertex region outside C
// barycentric coordinates (0,0,1)
// Check if P in edge region of AC, if so return projection of P onto AC
// barycentric coordinates (1-w,0,w)
// Check if P in edge region of BC, if so return projection of P onto BC
// barycentric coordinates (0,1-w,w)
// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
// S is nearly parallel to this edge
// segment S is entering across this edge
// S enters after leaving polygon
// segment S is leaving across this edge
// S leaves before entering polygon
// Compute barycentric coordinates
// The (sloppy) epsilon is needed to allow to get height of points which
// are interpolated along the edges of the triangles.
// If point lies inside the triangle, return interpolated ycoord.
/// @par
///
/// All points are projected onto the xz-plane, so the y-values are ignored.
// TODO: Replace pnpoly with triArea2D tests?
// TODO: Replace pnpoly with triArea2D tests?
/// @par
///
/// All vertices are projected onto the xz-plane, so the y-values are ignored.
// Found separating axis
// Found separating axis
// Returns a random point in a convex polygon.
// Adapted from Graphics Gems article.
// Calc triangle araes
// Find sub triangle weighted by area.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Check for horizontal overlap.
// The segment is shrunken a little so that slabs which touch
// at end points are not connected.
// Check vertical overlap.
// Crossing segments always overlap.
// Check for overlap at endpoints.
// Large multiplicative constants;
// here arbitrarily chosen primes
/// @par
///
/// This function will only free the memory for tiles with the #DT_TILE_FREE_DATA
/// flag set.
//////////////////////////////////////////////////////////////////////////////////////////
/**
// Init tiles
// Edited by TC
// Make sure the data is in right format.
/// @par
///
/// @note The parameters are created automatically when the single tile
/// initialization is performed.
//////////////////////////////////////////////////////////////////////////////////////////
// Remove links pointing to 'side' and compact the links array. 
// Skip edges which do not point to the right side.
// Segments are not close enough.
// Check if the segments touch.
// Add return value.
// Revove link.
// Advance
// Connect border links.
// Create new links.
//		unsigned short m = DT_EXT_LINK | (unsigned short)side;
// Skip non-portal edges.
// Create new links
// Compress portal limits to a byte value.
// Connect off-mesh links.
// We are interested on links which land from target tile to this tile.
// Skip off-mesh connections which start location could not be connected at all.
// Find polygon to connect to.
// findNearestPoly may return too optimistic results, further check to make sure. 
// Make sure the location is on current mesh.
// Link off-mesh connection to target poly.
// Add to linked list.
// Link target poly to off-mesh connection.
// Add to linked list.
// Build edge links backwards so that the links will be
// in the linked list from lowest index to highest.
// Skip hard and non-internal edges.
// Add to linked list.
// Base off-mesh connection start points.
// Find polygon to connect to.
// First vertex
// findNearestPoly may return too optimistic results, further check to make sure. 
// Make sure the location is on current mesh.
// Link off-mesh connection to target poly.
// Add to linked list.
// Start end-point is always connect back to off-mesh connection. 
// Add to linked list.
// Off-mesh connections don't have detail polygons.
// Clamp point to be inside the polygon.
// Point is outside the polygon, dtClamp to nearest edge.
// Find height at the location.
// Get nearby polygons from proximity grid.
// Find nearest polygon amongst the nearby polygons.
// Calculate quantized box
// dtClamp query box to world box.
// Quantize
// Traverse tree
// Do not return off-mesh connection polygons.
// Calc polygon bounds.
/// @par
///
/// The add operation will fail if the data is in the wrong format, the allocated tile
/// space is full, or there is a tile already at the specified reference.
///
/// The lastRef parameter is used to restore a tile with the same tile
/// reference it had previously used.  In this case the #dtPolyRef's for the
/// tile will be restored to the same values they were before the tile was 
/// removed.
///
/// @see dtCreateNavMeshData, #removeTile
// Make sure the data is in right format.
// Make sure the location is free.
// Allocate a tile.
// Try to relocate the tile to specific index with same salt.
// Try to find the specific tile id from the free list.
// Could not find the correct location.
// Remove from freelist
// Restore salt.
// Make sure we could allocate a tile.
// Insert tile into the position lut.
// Patch header pointers.
// If there are no items in the bvtree, reset the tree pointer.
// Build links freelist
// Init tile.
// Create connections with neighbour tiles.
// Connect with layers in current tile.
// Connect with neighbour tiles.
// Find tile based on hash.
// Find tile based on hash.
/// @par
///
/// This function will not fail if the tiles array is too small to hold the
/// entire result set.  It will simply fill the array to capacity.
// Find tile based on hash.
// Find tile based on hash.
/// @par
///
/// @warning Only use this function if it is known that the provided polygon
/// reference is valid. This function is faster than #getTileAndPolyByRef, but
/// it does not validate the reference.
/// @par
///
/// This function returns the data for the tile so that, if desired,
/// it can be added back to the navigation mesh at a later point.
///
/// @see #addTile
// Remove tile from hash lookup.
// Remove connections to neighbour tiles.
// Create connections with neighbour tiles.
// Connect with layers in current tile.
// Connect with neighbour tiles.
// Reset tile.
// Owns data
// Update salt, salt should never be zero.
// Add to free list.
/// @par
///
/// Example use case:
/// @code
///
/// const dtPolyRef base = navmesh->getPolyRefBase(tile);
/// for (int i = 0; i < tile->header->polyCount; ++i)
/// {
///     const dtPoly* p = &tile->polys[i];
///     const dtPolyRef ref = base | (dtPolyRef)i;
///     
///     // Use the reference to access the polygon data.
/// }
/// @endcode
// Magic number, used to identify the data.
// Data version number.
// Tile ref at the time of storing the data.
// Flags (see dtPolyFlags).
// Area ID of the polygon.
///  @see #storeTileState
/// @par
///
/// Tile state includes non-structural data such as polygon flags, area ids, etc.
/// @note The state data is only valid until the tile reference changes.
/// @see #getTileStateSize, #restoreTileState
// Make sure there is enough space to store the state.
// Store tile state.
// Store per poly state.
/// @par
///
/// Tile state includes non-structural data such as polygon flags, area ids, etc.
/// @note This function does not impact the tile's #dtTileRef and #dtPolyRef's.
/// @see #storeTileState
// Make sure there is enough space to store the state.
// Check that the restore is possible.
// Restore per poly state.
/// @par
///
/// Off-mesh connections are stored in the navigation mesh as special 2-vertex 
/// polygons with a single edge. At least one of the vertices is expected to be 
/// inside a normal polygon. So an off-mesh connection is "entered" from a 
/// normal polygon at one of its endpoints. This is the polygon identified by 
/// the prevRef parameter.
// Get current polygon
// Make sure that the current poly is indeed off-mesh link.
// Figure out which way to hand out the vertices.
// Find link that points to first vertex.
// Get current polygon
// Make sure that the current poly is indeed off-mesh link.
// Change flags.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/*nitems*/, const int imin, const int imax,
// Leaf
// Split
// Sort along x-axis
// Sort along y-axis
// Sort along z-axis
// Left
// Right
// Negative index means escape.
/*nverts*/,
/*nnodes*/, dtBVNode* nodes)
// Build tree
// Calc polygon bounds.
// Remap y
// TODO: Better error handling.
/// @par
/// 
/// The output data array is allocated using the detour allocator (dtAlloc()).  The method
/// used to free the memory will be determined by how the tile is added to the navigation
/// mesh.
///
/// @see dtNavMesh, dtNavMesh::addTile()
// Classify off-mesh connection points. We store only the connections
// whose start point is inside the tile.
// Find tight heigh bounds, used for culling out off-mesh start locations.
// Zero out off-mesh start positions which are not even potentially touching the mesh.
// Cound how many links should be allocated for off-mesh connections.
// Off-mesh connectionss are stored as polygons, adjust values.
// Find portal edges which are at tile borders.
// Find unique detail vertices.
// Has detail mesh, count unique detail vertex count and use input detail tri count.
// No input detail mesh, build detail mesh from nav polys.
// No extra detail verts.
// Calculate data size
// Store header
// Store vertices
// Mesh vertices
// Off-mesh link vertices.
// Only store connections which start from this tile.
// Store polygons
// Mesh polys
// Border or portal edge.
// Border
// Portal x-
// Portal z+
// Portal x+
// Portal z-
// Normal connection
// Off-mesh connection vertices.
// Only store connections which start from this tile.
// Store detail meshes and vertices.
// The nav polygon vertices are stored as the first vertices on each mesh.
// We compress the mesh data by skipping them and using the navmesh coordinates.
// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
// Store triangles.
// Create dummy detail mesh by triangulating polys.
// Triangulate polygon (local indices).
// Bit for each edge that belongs to poly boundary.
// Store and create BVtree.
// TODO: take detail mesh into account! use byte per bbox extent?
// Store Off-Mesh connections.
// Only store connections which start from this tile.
// Copy connection end-points.
/*dataSize*/)
// Freelist index and pointers are updated when tile is added, no need to swap.
/// @par
///
/// @warning This function assumes that the header is in the correct endianess already. 
/// Call #dtNavMeshHeaderSwapEndian() first on the data if the data is expected to be in wrong endianess 
/// to start with. Call #dtNavMeshHeaderSwapEndian() after the data has been swapped if converting from 
/// native to foreign endianess.
/*dataSize*/)
// Make sure the data is in right format.
// Patch header pointers.
/*dtLink* links = (dtLink*)d;*/ d += linksSize;
/*unsigned char* detailTris = (unsigned char*)d;*/ d += detailTrisSize;
// Vertices
// Polys
// poly->firstLink is update when tile is added, no need to swap.
// Links are rebuild when tile is added, no need to swap.
// Detail meshes
// Detail verts
// BV-tree
// Off-mesh Connections.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/// @class dtQueryFilter
///
/// <b>The Default Implementation</b>
/// 
/// At construction: All area costs default to 1.0.  All flags are included
/// and none are excluded.
/// 
/// If a polygon has both an include and an exclude flag, it will be excluded.
/// 
/// The way filtering works, a navigation mesh polygon must have at least one flag 
/// set to ever be considered by a query. So a polygon with no flags will never
/// be considered.
///
/// Setting the include flags to 0 will result in all polygons being excluded.
///
/// <b>Custom Implementations</b>
/// 
/// DT_VIRTUAL_QUERYFILTER must be defined in order to extend this class.
/// 
/// Implement a custom query filter by overriding the virtual passFilter() 
/// and getCost() functions. If this is done, both functions should be as 
/// fast as possible. Use cached local copies of data rather than accessing 
/// your own objects where possible.
/// 
/// Custom implementations do not need to adhere to the flags or cost logic 
/// used by the default implementation.  
/// 
/// In order for A* searches to work properly, the cost should be proportional to
/// the travel distance. Implementing a cost modifier less than 1.0 is likely 
/// to lead to problems during pathfinding.
///
/// @see dtNavMeshQuery
/*ref*/,
/*tile*/,
/*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,
/*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,
/*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const
/*ref*/,
/*tile*/,
/*prevRef*/, const dtMeshTile* /*prevTile*/, const dtPoly* /*prevPoly*/,
/*curRef*/, const dtMeshTile* /*curTile*/, const dtPoly* curPoly,
/*nextRef*/, const dtMeshTile* /*nextTile*/, const dtPoly* /*nextPoly*/) const
// Edited by TC
// Search heuristic scale. 
//////////////////////////////////////////////////////////////////////////////////////////
/// @class dtNavMeshQuery
///
/// For methods that support undersized buffers, if the buffer is too small 
/// to hold the entire result set the return status of the method will include 
/// the #DT_BUFFER_TOO_SMALL flag.
///
/// Constant member functions can be used by multiple clients without side
/// effects. (E.g. No change to the closed list. No impact on an in-progress
/// sliced path query. Etc.)
/// 
/// Walls and portals: A @e wall is a polygon segment that is 
/// considered impassable. A @e portal is a passable segment between polygons.
/// A portal may be treated as a wall based on the dtQueryFilter used for a query.
///
/// @see dtNavMesh, dtQueryFilter, #dtAllocNavMeshQuery(), #dtAllocNavMeshQuery()
/// @par 
///
/// Must be the first function called after construction, before other
/// functions are used.
///
/// This function can be used multiple times.
// TODO: check the open list size too.
// Randomly pick one tile. Assume that all tiles cover roughly the same area.
// Choose random tile using reservoi sampling.
// Could be tile area too.
// Randomly pick one polygon weighted by polygon area.
// Do not return off-mesh connection polygons.
// Must pass filter
// Calc area of the polygon.
// Choose random polygon weighted by area, using reservoi sampling.
// Randomly pick point on polygon.
// Validate input
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Place random locations on on ground.
// Calc area of the polygon.
// Choose random polygon weighted by area, using reservoi sampling.
// Get parent poly and tile.
// Skip invalid neighbours and do not follow back to parent.
// Expand to neighbour
// Do not advance if the polygon is excluded by the filter.
// Find edge and calc distance to the edge.
// If the circle is not touching the next polygon, skip it.
// Cost
// The node is already in open list and the new result is worse, skip.
// Randomly pick point on polygon.
//////////////////////////////////////////////////////////////////////////////////////////
/// @par
///
/// Uses the detail polygons to find the surface height. (Most accurate.)
///
/// @p pos does not have to be within the bounds of the polygon or navigation mesh.
///
/// See closestPointOnPolyBoundary() for a limited but faster option.
///
// Edited by TC
// Off-mesh connections don't have detail polygons.
// Clamp point to be inside the polygon.
// Point is outside the polygon, dtClamp to nearest edge.
// Find height at the location.
/*	float closestDistSqr = FLT_MAX;
/// @par
///
/// Much faster than closestPointOnPoly().
///
/// If the provided position lies within the polygon's xz-bounds (above or below), 
/// then @p pos and @p closest will be equal.
///
/// The height of @p closest will be the polygon boundary.  The height detail is not used.
/// 
/// @p pos does not have to be within the bounds of the polybon or the navigation mesh.
/// 
// Collect vertices.
// Point is inside the polygon, return the point.
// Point is outside the polygon, dtClamp to nearest edge.
/// @par
///
/// Will return #DT_FAILURE if the provided position is outside the xz-bounds 
/// of the polygon.
/// 
/// @par 
///
/// @note If the search box does not intersect any polygons the search will 
/// return #DT_SUCCESS, but @p nearestRef will be zero. So if in doubt, check 
/// @p nearestRef before using @p nearestPt.
///
/// @warning This function is not suitable for large area searches.  If the search
/// extents overlaps more than 128 polygons it may return an invalid result.
///
// Get nearby polygons from proximity grid.
// Find nearest polygon amongst the nearby polygons.
// Get nearby polygons from proximity grid.
// Find nearest polygon amongst the nearby polygons.
// Calculate quantized box
// dtClamp query box to world box.
// Quantize
// Traverse tree
// Do not return off-mesh connection polygons.
// Must pass filter
// Calc polygon bounds.
/// @par 
///
/// If no polygons are found, the function will return #DT_SUCCESS with a
/// @p polyCount of zero.
///
/// If @p polys is too small to hold the entire result set, then the array will 
/// be filled to capacity. The method of choosing which polygons from the 
/// full set are included in the partial result set is undefined.
///
// Find tiles the query touches.
/// @par
///
/// If the end polygon cannot be reached through the navigation graph,
/// the last polygon in the path will be the nearest the end polygon.
///
/// If the path array is to small to hold the full result, it will be filled as 
/// far as possible from the start polygon toward the end polygon.
///
/// The start and end positions are used to calculate traversal costs. 
/// (The y-values impact the result.)
///
// Validate input
// Remove node from open list and put it in closed list.
// Reached the goal, stop searching.
// Get current poly and tile.
// The API input has been cheked already, skip checking internal data.
// Get parent poly and tile.
// Skip invalid ids and do not expand back to where we came from.
// Get neighbour poly and tile.
// The API input has been cheked already, skip checking internal data.
// If the node is visited the first time, calculate node position.
// Calculate cost and heuristic.
// Special case for last node.
// Cost
// Cost
// The node is already in open list and the new result is worse, skip.
// The node is already visited and process, and the new result is worse, skip.
// Add or update the node.
// Already in open, update node location.
// Put the node in open list.
// Update nearest node to target so far.
// Reverse the path.
// Store path
/// @par
///
/// @warning Calling any non-slice methods before calling finalizeSlicedFindPath() 
/// or finalizeSlicedFindPathPartial() may result in corrupted data!
///
/// The @p filter pointer is stored and used for the duration of the sliced
/// path query.
///
// Init path state.
// Validate input
// Make sure the request is still valid.
// Remove node from open list and put it in closed list.
// Reached the goal, stop searching.
// Get current poly and tile.
// The API input has been cheked already, skip checking internal data.
// The polygon has disappeared during the sliced query, fail.
// Get parent poly and tile.
// The polygon has disappeared during the sliced query, fail.
// Skip invalid ids and do not expand back to where we came from.
// Get neighbour poly and tile.
// The API input has been cheked already, skip checking internal data.
// If the node is visited the first time, calculate node position.
// Calculate cost and heuristic.
// Special case for last node.
// Cost
// Cost
// The node is already in open list and the new result is worse, skip.
// The node is already visited and process, and the new result is worse, skip.
// Add or update the node.
// Already in open, update node location.
// Put the node in open list.
// Update nearest node to target so far.
// Exhausted all nodes, but could not find path.
// Reset query.
// Special case: the search starts and ends at same poly.
// Reverse the path.
// Store path
// Reset query.
// Reset query.
// Special case: the search starts and ends at same poly.
// Find furthest existing node that was visited.
// Reverse the path.
// Store path
// Reset query.
// The vertices are equal, update flags and poly.
// Append new vertex.
// If reached end of path or there is no space to append more vertices, return.
// Append or update last vertex
// Calculate portal
// Skip intersection if only area crossings are requested.
// Append intersection
/// @par
/// 
/// This method peforms what is often called 'string pulling'.
///
/// The start position is clamped to the first polygon in the path, and the 
/// end position is clamped to the last. So the start and end positions should 
/// normally be within or very near the first and last polygons respectively.
///
/// The returned polygon references represent the reference id of the polygon 
/// that is entered at the associated path position. The reference id associated 
/// with the end point will always be zero.  This allows, for example, matching 
/// off-mesh link points to their representative polygons.
///
/// If the provided result buffers are too small for the entire result set, 
/// they will be filled as far as possible from the start toward the end 
/// position.
///
// TODO: Should this be callers responsibility?
// Add start point.
// Next portal.
// Failed to get portal points, in practice this means that path[i+1] is invalid polygon.
// Clamp the end point to path[i], and return the path so far.
// This should only happen when the first polygon is invalid.
// Apeend portals along the current straight path segment.
// If starting really close the portal, advance.
// End of the path.
// Right vertex.
// Append portals along the current straight path segment.
// Append or update vertex
// Restart
// Left vertex.
// Append portals along the current straight path segment.
// Append or update vertex
// Restart
// Append portals along the current straight path segment.
/// @par
///
/// This method is optimized for small delta movement and a small number of 
/// polygons. If used for too great a distance, the result set will form an 
/// incomplete path.
///
/// @p resultPos will equal the @p endPos if the end is reached. 
/// Otherwise the closest reachable position will be returned.
/// 
/// @p resultPos is not projected onto the surface of the navigation 
/// mesh. Use #getPolyHeight if this is needed.
///
/// This method treats the end position in the same manner as 
/// the #raycast method. (As a 2D point.) See that method's documentation 
/// for details.
/// 
/// If the @p visited array is too small to hold the entire result set, it will 
/// be filled as far as possible from the start position toward the end 
/// position.
///
// Validate input
// Search constraints
// Pop front.
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Collect vertices.
// If target is inside the poly, stop search.
// Find wall edges and find nearest point inside the walls.
// Find links to neighbours.
// Tile border.
// Internal edge, encode id.
// Wall edge, calc distance.
// Update nearest distance.
// Skip if no node can be allocated.
// Skip if already visited.
// Skip the link if it is too far from search constraint.
// TODO: Maybe should use getPortalPoints(), but this one is way faster.
// Mark as the node as visited and push to queue.
// Reverse the path.
// Store result
// Returns portal points between two polygons.
// Find the link that points to the 'to' polygon.
// Handle off-mesh connections.
// Find link that points to first vertex.
// Find portal vertices.
// If the link is at tile boundary, dtClamp the vertices to
// the link width.
// Unpack portal limits.
// Returns edge mid point between two polygons.
/// @par
///
/// This method is meant to be used for quick, short distance checks.
///
/// If the path array is too small to hold the result, it will be filled as 
/// far as possible from the start postion toward the end position.
///
/// <b>Using the Hit Parameter (t)</b>
/// 
/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
/// the end position. In this case the path represents a valid corridor to the 
/// end position and the value of @p hitNormal is undefined.
///
/// If the hit parameter is zero, then the start position is on the wall that 
/// was hit and the value of @p hitNormal is undefined.
///
/// If 0 < t < 1.0 then the following applies:
///
/// @code
/// distanceToHitBorder = distanceToEndPosition * t
/// hitPoint = startPos + (endPos - startPos) * t
/// @endcode
///
/// <b>Use Case Restriction</b>
///
/// The raycast ignores the y-value of the end position. (2D check.) This 
/// places significant limits on how it can be used. For example:
///
/// Consider a scene where there is a main floor with a second floor balcony 
/// that hangs over the main floor. So the first floor mesh extends below the 
/// balcony mesh. The start position is somewhere on the first floor. The end 
/// position is on the balcony.
///
/// The raycast will search toward the end position along the first floor mesh. 
/// If it reaches the end position's xz-coordinates it will indicate FLT_MAX
/// (no wall hit), meaning it reached the end position. This is one example of why
/// this method is meant for short distance checks.
///
// Validate input
// Cast ray against current polygon.
// The API input has been cheked already, skip checking internal data.
// Collect vertices.
// Could not hit the polygon, keep the old t and report hit.
// Keep track of furthest t so far.
// Store visited polygons.
// Ray end is completely inside the polygon.
// Follow neighbours.
// Find link which contains this edge.
// Get pointer to the next polygon.
// Skip off-mesh connections.
// Skip links based on filter.
// If the link is internal, just return the ref.
// If the link is at tile boundary,
// Check if the link spans the whole edge, and accept.
// Check for partial edge links.
// Check that the intersection lies inside the link portal.
// Calculate link size.
// Find Z intersection.
// Calculate link size.
// Find X intersection.
// No neighbour, we hit a wall.
// Calculate hit normal.
// No hit, advance to neighbour polygon.
/// @par
///
/// At least one result array must be provided.
///
/// The order of the result set is from least to highest cost to reach the polygon.
///
/// A common use case for this method is to perform Dijkstra searches. 
/// Candidate polygons are found by searching the graph beginning at the start polygon.
///
/// If a polygon is not found via the graph search, even if it intersects the 
/// search circle, it will not be included in the result set. For example:
///
/// polyA is the start polygon.
/// polyB shares an edge with polyA. (Is adjacent.)
/// polyC shares an edge with polyB, but not with polyA
/// Even if the search circle overlaps polyC, it will not be included in the 
/// result set unless polyB is also in the set.
/// 
/// The value of the center point is used as the start position for cost 
/// calculations. It is not projected onto the surface of the mesh, so its 
/// y-value will effect the costs.
///
/// Intersection tests occur in 2D. All polygons and the search circle are 
/// projected onto the xz-plane. So the y-value of the center point does not 
/// effect intersection tests.
///
/// If the result arrays are to small to hold the entire result set, they will be 
/// filled to capacity.
/// 
// Validate input
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Get parent poly and tile.
// Skip invalid neighbours and do not follow back to parent.
// Expand to neighbour
// Do not advance if the polygon is excluded by the filter.
// Find edge and calc distance to the edge.
// If the circle is not touching the next polygon, skip it.
// Cost
// The node is already in open list and the new result is worse, skip.
/// @par
///
/// The order of the result set is from least to highest cost.
/// 
/// At least one result array must be provided.
///
/// A common use case for this method is to perform Dijkstra searches. 
/// Candidate polygons are found by searching the graph beginning at the start 
/// polygon.
/// 
/// The same intersection test restrictions that apply to findPolysAroundCircle()
/// method apply to this method.
/// 
/// The 3D centroid of the search polygon is used as the start position for cost 
/// calculations.
/// 
/// Intersection tests occur in 2D. All polygons are projected onto the 
/// xz-plane. So the y-values of the vertices do not effect intersection tests.
/// 
/// If the result arrays are is too small to hold the entire result set, they will 
/// be filled to capacity.
///
// Validate input
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Get parent poly and tile.
// Skip invalid neighbours and do not follow back to parent.
// Expand to neighbour
// Do not advance if the polygon is excluded by the filter.
// Find edge and calc distance to the edge.
// If the poly is not touching the edge to the next polygon, skip the connection it.
// Cost
// The node is already in open list and the new result is worse, skip.
/// @par
///
/// This method is optimized for a small search radius and small number of result 
/// polygons.
///
/// Candidate polygons are found by searching the navigation graph beginning at 
/// the start polygon.
///
/// The same intersection test restrictions that apply to the findPolysAroundCircle 
/// mehtod applies to this method.
///
/// The value of the center point is used as the start point for cost calculations. 
/// It is not projected onto the surface of the mesh, so its y-value will effect 
/// the costs.
/// 
/// Intersection tests occur in 2D. All polygons and the search circle are 
/// projected onto the xz-plane. So the y-value of the center point does not 
/// effect intersection tests.
/// 
/// If the result arrays are is too small to hold the entire result set, they will 
/// be filled to capacity.
/// 
// Validate input
// Pop front.
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Skip invalid neighbours.
// Skip if cannot alloca more nodes.
// Skip visited.
// Expand to neighbour
// Skip off-mesh connections.
// Do not advance if the polygon is excluded by the filter.
// Find edge and calc distance to the edge.
// If the circle is not touching the next polygon, skip it.
// Mark node visited, this is done before the overlap test so that
// we will not visit the poly again if the test fails.
// Check that the polygon does not collide with existing polygons.
// Collect vertices of the neighbour poly.
// Connected polys do not overlap.
// Potentially overlapping.
// Get vertices and test overlap
// This poly is fine, store and advance to the poly.
// Find insertion point.
// Move current results.
// Store
/// @par
///
/// If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
/// Otherwise only the wall segments are returned.
/// 
/// A segment that is normally a portal will be included in the result set as a 
/// wall if the @p filter results in the neighbor polygon becoomming impassable.
/// 
/// The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
/// maximum segments per polygon of the source navigation mesh.
/// 
// Skip non-solid edges.
// Tile border.
// Internal edge
// If the edge leads to another polygon and portals are not stored, skip.
// Add sentinels
// Store segments.
// Portal segment.
// Wall segment.
/// @par
///
/// @p hitPos is not adjusted using the height detail data.
///
/// @p hitDist will equal the search radius if there is no wall within the 
/// radius. In this case the values of @p hitPos and @p hitNormal are
/// undefined.
///
/// The normal will become unpredicable if @p hitDist is a very small number.
///
// Validate input
// Get poly and tile.
// The API input has been cheked already, skip checking internal data.
// Get parent poly and tile.
// Hit test walls.
// Skip non-solid edges.
// Tile border.
// Internal edge
// Calc distance to the edge.
// Edge is too far, skip.
// Hit wall, update radius.
// Calculate hit pos.
// Skip invalid neighbours and do not follow back to parent.
// Expand to neighbour.
// Skip off-mesh connections.
// Calc distance to the edge.
// If the circle is not touching the next polygon, skip it.
// Cost
// The node is already in open list and the new result is worse, skip.
// Calc hit normal.
// If cannot get polygon, assume it does not exists and boundary is invalid.
// If cannot pass filter, assume flags has changed and boundary is invalid.
/// @par
///
/// The closed list is the list of polygons that were fully evaluated during 
/// the last navigation graph search. (A* or Dijkstra)
/// 
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Edited by TC
//////////////////////////////////////////////////////////////////////////////////////////
// Init node
//////////////////////////////////////////////////////////////////////////////////////////
// note: (index > 0) means there is a parent
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// not moving
// Overlap, calc time to exit.
// no intersection.
// Normalize penaly range.
// Prepare obstacles
// Side
// Precalc if the agent is really close to the segment.
// Find min time of impact and exit amongst all obstacles.
// RVO
// Side
// Handle overlapping obstacles.
// Avoid more when overlapped.
// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.
// Special case when the agent is very close to the segment.
// If the velocity is pointing towards the segment, no collision.
// Else immediate collision.
// Avoid less when facing walls.
// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.
// Normalize side bias, to prevent it dominating too much.
// Store different penalties for debug viewing
// Build sampling pattern aligned to desired velocity.
// Always add sample at zero
// Start sampling.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/// @class rcContext
/// @par
///
/// This class does not provide logging or timer functionality on its 
/// own.  Both must be provided by a concrete implementation 
/// by overriding the protected member functions.  Also, this class does not 
/// provide an interface for extracting log messages. (Only adding them.) 
/// So concrete implementations must provide one.
///
/// If no logging or timers are required, just pass an instance of this 
/// class through the Recast build process.
///
/// @par
///
/// Example:
/// @code
/// // Where ctx is an instance of rcContext and filepath is a char array.
/// ctx->log(RC_LOG_ERROR, "buildTiledNavigation: Could not load '%s'", filepath);
/// @endcode
// Delete span array.
// Delete span pools.
// Calculate bounding box.
/// @par
///
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// @see rcAllocHeightfield, rcHeightfield 
/*ctx*/, rcHeightfield& hf, int width, int height,
// TODO: VC complains about unref formal variable, figure out a way to handle this better.
//	rcAssert(ctx);
/// @par
///
/// Only sets the aread id's for the walkable triangles.  Does not alter the
/// area id's for unwalkable triangles.
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
/*ctx*/, const float walkableSlopeAngle,
/*nv*/,
// TODO: VC complains about unref formal variable, figure out a way to handle this better.
//	rcAssert(ctx);
// Check if the face is walkable.
/// @par
///
/// Only sets the aread id's for the unwalkable triangles.  Does not alter the
/// area id's for walkable triangles.
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
/*ctx*/, const float walkableSlopeAngle,
/*nv*/,
// TODO: VC complains about unref formal variable, figure out a way to handle this better.
//	rcAssert(ctx);
// Check if the face is walkable.
/*ctx*/, rcHeightfield& hf)
// TODO: VC complains about unref formal variable, figure out a way to handle this better.
//	rcAssert(ctx);
/// @par
///
/// This is just the beginning of the process of fully building a compact heightfield.
/// Various filters may be applied applied, then the distance field and regions built.
/// E.g: #rcBuildDistanceField and #rcBuildRegions
///
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcAllocCompactHeightfield, rcHeightfield, rcCompactHeightfield, rcConfig
// Fill in header.
// Fill in cells and spans.
// If there are no spans at this cell, just leave the data to index=0, count=0.
// Find neighbour connections.
// First check that the neighbour cell is in bounds.
// Iterate over all neighbour spans and check if any of the is
// accessible from current cell.
// Check that the gap between the spans is walkable,
// and that the climb height between the gaps is not too high.
// Mark direction as walkable.
/*
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/// @see rcAlloc, rcFree
/// @see rcAllocSetCustom
/// @par
///
/// @warning This function leaves the value of @p ptr unchanged.  So it still
/// points to the same (now invalid) location, and not to null.
/// 
/// @see rcAllocSetCustom
/// @class rcIntArray
///
/// While it is possible to pre-allocate a specific array size during 
/// construction or by using the #resize method, certain methods will 
/// automatically resize the array as needed.
///
/// @warning The array memory is not initialized to zero when the size is 
/// manually set during construction or when using #resize.
/// @par
///
/// Using this method ensures the array is at least large enough to hold
/// the specified number of elements.  This can improve performance by
/// avoiding auto-resizing during use.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/// @par 
/// 
/// Basically, any spans that are closer to a boundary or obstruction than the specified radius 
/// are marked as unwalkable.
///
/// This method is usually called immediately after the heightfield has been built.
///
/// @see rcCompactHeightfield, rcBuildCompactHeightfield, rcConfig::walkableRadius
// Init distance.
// Mark boundary cells.
// At least one missing neighbour.
// Pass 1
// (-1,0)
// (-1,-1)
// (0,-1)
// (1,-1)
// Pass 2
// (1,0)
// (1,1)
// (0,1)
// (-1,1)
/// @par
///
/// This filter is usually applied after applying area id's using functions
/// such as #rcMarkBoxArea, #rcMarkConvexPolyArea, and #rcMarkCylinderArea.
/// 
/// @see rcCompactHeightfield
// Init distance.
/// @par
///
/// The value of spacial parameters are in world units.
/// 
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
/// @par
///
/// The value of spacial parameters are in world units.
/// 
/// The y-values of the polygon vertices are ignored. So the polygon is effectively 
/// projected onto the xz-plane at @p hmin, then extruded to @p hmax.
/// 
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
// TODO: Optimize.
/// @par
///
/// The value of spacial parameters are in world units.
/// 
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Combine region and area codes in order to prevent
// border vertices which are in between two areas to be removed. 
// Check if the vertex is special edge vertex, these vertices will be removed later.
// The vertex is a border vertex there are two same exterior cells in a row,
// followed by two interior cells and none of the regions are out of bounds.
// Choose the first non-connected edge
// Choose the edge corner
// Remove visited edges
// Rotate CW
// Should not happen.
// Rotate CCW
/*	float pqx = (float)(qx - px);
// Add initial points.
// The contour has some portals to other regions.
// Add a new point to every location where the region changes.
// If there is no connections at all,
// create some initial points for the simplification process. 
// Find lower-left and upper-right vertices of the contour.
// Add points until all raw points are within
// error tolerance to the simplified shape.
// Find maximum deviation from the segment.
// Traverse the segment in lexilogical order so that the
// max deviation is calculated similarly when traversing
// opposite segments.
// Tessellate only outer edges or edges between areas.
// If the max deviation is larger than accepted error,
// add new point, else continue to next segment.
// Add space for the new point.
// Add the point.
// Split too long edges.
// Find maximum deviation from the segment.
// Tessellate only outer edges or edges between areas.
// Wall edges.
// Edges between areas.
// Round based on the segments in lexilogical order so that the
// max tesselation is consistent regardles in which direction
// segments are traversed.
// If the max deviation is larger than accepted error,
// add new point, else continue to next segment.
// Add space for the new point.
// Add the point.
// The edge vertex flag is take from the current raw point,
// and the neighbour region is take from the next raw point.
// Remove adjacent vertices which are equal on xz-plane,
// or else the triangulator will get confused.
// Degenerate segment, remove.
// vb must be "infront" of va.
// Copy contour A.
// Copy contour B
/// @par
///
/// The raw contours will match the region outlines exactly. The @p maxError and @p maxEdgeLen
/// parameters control how closely the simplified contours will match the raw contours.
///
/// Simplified contours are generated such that the vertices for portals between areas match up. 
/// (They are considered mandatory vertices.)
///
/// Setting @p maxEdgeLength to zero will disabled the edge length feature.
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// @see rcAllocContourSet, rcCompactHeightfield, rcContourSet, rcConfig
// If the heightfield was build with bordersize, remove the offset.
// Mark boundaries.
// Inverse, mark non connected edges.
// Store region->contour remap info.
// Create contour.
// Allocate more contours.
// This can happen when there are tiny holes in the heightfield.
// Reset source pointers to prevent data deletion.
// If the heightfield was build with bordersize, remove the offset.
// If the heightfield was build with bordersize, remove the offset.
/*					cont->cx = cont->cy = cont->cz = 0;
// Check and merge droppings.
// Sometimes the previous algorithms can fail and create several contours
// per area. This pass will try to merge the holes into the main region.
// Check if the contour is would backwards.
// Find another contour which has the same region ID.
// Make sure the polygon is correctly oriented.
// Merge by closest points.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
/// @par
///
/// Allows the formation of walkable regions that will flow over low lying 
/// objects such as curbs, and up structures such as stairways. 
/// 
/// Two neighboring spans are walkable if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) < waklableClimb</tt>
/// 
/// @warning Will override the effect of #rcFilterLedgeSpans.  So if both filters are used, call
/// #rcFilterLedgeSpans after calling this filter. 
///
/// @see rcHeightfield, rcConfig
// If current span is not walkable, but there is walkable
// span just below it, mark the span above it walkable too.
// Copy walkable flag so that it cannot propagate
// past multiple non-walkable objects.
/// @par
///
/// A ledge is a span with one or more neighbors whose maximum is further away than @p walkableClimb
/// from the current span's maximum.
/// This method removes the impact of the overestimation of conservative voxelization 
/// so the resulting mesh will not have regions hanging in the air over ledges.
/// 
/// A span is a ledge if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) > walkableClimb</tt>
/// 
/// @see rcHeightfield, rcConfig
// Mark border spans.
// Skip non walkable spans.
// Find neighbours minimum height.
// Min and max height of accessible neighbours.
// Skip neighbours which are out of bounds.
// From minus infinity to the first span.
// Skip neightbour if the gap between the spans is too small.
// Rest of the spans.
// Skip neightbour if the gap between the spans is too small.
// Find min/max accessible neighbour height. 
// The current span is close to a ledge if the drop to any
// neighbour span is less than the walkableClimb.
// If the difference between all neighbours is too large,
// we are at steep slope, mark the span as ledge.
/// @par
///
/// For this filter, the clearance above the span is the distance from the span's 
/// maximum to the next higher span's minimum. (Same grid column.)
/// 
/// @see rcHeightfield, rcConfig
// Remove walkable flag from spans which do not have enough
// space above them for the agent to stand there.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Layer ID
// Layer count
// Neighbour count
// Flag indicating if the region is hte base of merged regions.
// number samples
// region id
// neighbour id
/// @par
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// @see rcAllocHeightfieldLayerSet, rcCompactHeightfield, rcHeightfieldLayerSet, rcConfig
// Partition walkable area into monotone regions.
// -x
// -y
// Set neighbour when first valid neighbour is encoutered.
// Update existing neighbour
// This is hit if there is nore than one neighbour.
// Invalidate the neighbour.
// Create unique ID.
// If the neighbour is set and there is only one continuous connection to it,
// the sweep will be merged with the previous one, else new region is created.
// Remap local sweep ids to region ids.
// Allocate and init layer regions.
// Find region neighbours and overlapping regions.
// Collect all region layers.
// Update neighbours
// Update overlapping regions.
// Create 2D layers from regions.
// Skip alreadu visited.
// Start search.
// Pop front
// Skip already visited.
// Skip if the neighbour is overlapping root region.
// Skip if the height range would become too large.
// Edited by TC
// Deepen
// Mark layer id
// Merge current layers to root.
// Merge non-overlapping regions that are close in height.
// Skip if teh regions are not close to each other.
// Skip if the height range would become too large.
// Edited by TC
// Make sure that there is no overlap when mergin 'ri' and 'rj'.
// Iterate over all regions which have the same layerId as 'rj'
// Check if region 'k' is overlapping region 'ri'
// Index to 'regs' is the same as region id.
// Cannot merge of regions overlap.
// Can merge i and j.
// Could not find anything to merge with, stop.
// Merge
// Remap layerIds.
// Add overlaid layers from 'rj' to 'ri'.
// Update heigh bounds.
// Compact layerIds
// Find number of unique layers.
// Remap ids.
// No layers, return empty.
// Create layers.
// Build contracted bbox for layers.
// Store layers.
// Allocate memory for the current layer.
// Find layer height bounds.
// Adjust the bbox to fit the heighfield.
// Update usable data region.
// Copy height and area from compact heighfield. 
// Skip unassigned regions.
// Skip of does nto belong to current layer.
// Update data bounds.
// Store height and area type.
// Check connection.
// Portal mask
// Update height so that it matches on both sides of the portal.
// Valid connection mask
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Based on code by Eric Lengyel from:
// http://www.terathon.com/code/edges.php
// Insert edge
// Store adjacency
// Large multiplicative constants;
// here arbitrarily chosen primes
// next
// Could not find, create new.
//	Exclusive or: true iff exactly one argument is true.
//	The arguments are negated to ensure that they are 0/1
//	values.  Then the bitwise Xor operator may apply.
//	(This idea is due to Michael Baldwin.)
// Returns true iff c is strictly to the left of the directed
// line through a to b.
//	Returns true iff ab properly intersects cd: they share
//	a point interior to both segments.  The properness of the
//	intersection is ensured by using strict leftness.
// Eliminate improper cases.
// Returns T iff (a,b,c) are collinear and point c lies 
// on the closed segement ab.
// If ab not vertical, check betweenness on x; else on y.
// Returns true iff segments ab and cd intersect, properly or improperly.
// Returns T iff (v_i, v_j) is a proper internal *or* external
// diagonal of P, *ignoring edges incident to v_i and v_j*.
// For each edge (k,k+1) of P
// Skip edges incident to i or j
// Returns true iff the diagonal (i,j) is strictly internal to the 
// polygon P in the neighborhood of the i endpoint.
// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].
// Assume (i-1,i,i+1) not collinear.
// else P[i] is reflex.
// Returns T iff (v_i, v_j) is a proper internal
// diagonal of P.
// The last bit of the index is used to indicate if the vertex can be removed.
// Should not happen.
/*			printf("mini == -1 ntris=%d n=%d\n", ntris, n);
// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
// Update diagonal flags.
// Append the remaining triangle.
// If the merged polygon would be too big, do not merge.
// Check if the polygons share an edge.
// No common edge, cannot merge.
// Check to see if the merged polygon would be convex.
// Merge polygons.
// Add pa
// Add pb
// Count number of polygons to remove.
// There would be too few edges remaining to create a polygon.
// This can happen for example when a tip of a triangle is marked
// as deletion, but there are no other polys that share the vertex.
// In this case, the vertex should not be removed.
// Find edges which share the removed vertex.
// Collect edges which touches the removed vertex.
// Arrange edge so that a=rem.
// Check if the edge exists
// Exists, increment vertex share count.
// Add new edge.
// There should be no more than 2 open edges.
// This catches the case that two non-adjacent polygons
// share the removed vertex. In that case, do not remove the vertex.
// Count number of polygons to remove.
// Collect edges which does not touch the removed vertex.
// Remove the polygon.
// Remove vertex.
// Adjust indices to match the removed vertex layout.
// Start with one vertex, keep appending connected
// segments to the start and end of the hole.
// The segment matches the beginning of the hole boundary.
// The segment matches the end of the hole boundary.
// The edge segment was added, remove it.
// Generate temp vertex array for triangulation.
// Triangulate the hole.
// Merge the hole triangles back to polygons.
// Build initial polygons.
// Merge polygons.
// Find best polygons to merge.
// Found best, merge.
// Could not merge any polygons, stop.
// Store polygons.
/// @par
///
/// @note If the mesh data is to be used to construct a Detour navigation mesh, then the upper 
/// limit must be retricted to <= #DT_VERTS_PER_POLYGON.
///
/// @see rcAllocPolyMesh, rcContourSet, rcPolyMesh, rcConfig
// Skip null contours.
// Skip null contours.
// Triangulate contour
// Bad triangulation, should not happen.
/*			printf("\tconst float bmin[3] = {%ff,%ff,%ff};\n", cset.bmin[0], cset.bmin[1], cset.bmin[2]);
// Add and merge vertices.
// This vertex should be removed.
// Build initial polygons.
// Merge polygons.
// Find best polygons to merge.
// Found best, merge.
// Could not merge any polygons, stop.
// Store polygons.
// Remove edge vertices.
// Failed to remove vertex
// Remove vertex
// Note: mesh.nverts is already decremented inside removeVertex()!
// Fixup vertex flags
// Calculate adjacency.
// Find portal edges
// Skip connected edges.
// Just allocate the mesh flags array. The user is resposible to fill it.
/// @see rcAllocPolyMesh, rcPolyMesh
// Calculate adjacency.
// Destination must be empty.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Compute barycentric coordinates
// If point lies inside the triangle, return interpolated y-coord.
/*nverts*/, const int* tris, const int ntris)
/*cs*/, const float ics, const float ch,
// Special case when data might be bad.
// Find nearest neighbour pixel which has valid height.
/*			const float dx = (nx+0.5f)*cs - fx; 
// Add edge if not already in the triangulation. 
// Same or connected edges do not overlap.
// Cache s and t.
// Edge already completed. 
// Find best point on left of edge. 
// The circle is not updated yet, do it now.
// Outside current circumcircle, skip.
// Inside safe circumcircle, update circle.
// Inside epsilon circum circle, do extra tests to make sure the edge is valid.
// s-u and t-u cannot overlap with s-pt nor t-pt if they exists.
// Edge is valid.
// Add new triangle or update edge info if s-t is on hull. 
// Update face information of edge being completed. 
// Add new edge or update face info of old edge. 
// Add new edge or update face info of old edge. 
// Create tris
// Left face
// Right
// Max tris for delaunay is 2n-2-k (n=num verts, k=num hull verts).
// Tessellate outlines.
// This is done in separate pass in order to ensure
// seamless height values across the ply boundaries.
// Make sure the segments are always handled in same order
// using lexological sort or else there will be seams.
// Create samples along the edge.
// Simplify samples.
// Find maximum deviation along the segment.
// If the max deviation is larger than accepted error,
// add new point, else continue to next segment.
// Add new vertices.
// Tessellate the base mesh.
// Could not triangulate the poly, make sure there is some valid data there.
// Create sample locations in a grid.
// Make sure the samples are not too close to the edges.
// Not added
// Add the samples starting from the one that has the most
// error. The procedure stops when all samples are added
// or when the max error is within treshold.
// Find sample with most error.
// skip added.
// The sample location is jittered to get rid of some bad triangulations
// which are cause by symmetrical data from the grid structure.
// did not hit the mesh.
// If the max error is within accepted threshold, stop tesselating.
// Mark sample as added.
// Add the new sample point.
// Create new triangulation.
// TODO: Incremental add instead of full rebuild.
// Floodfill the heightfield to get 2D height data,
// starting at vertex locations as seeds.
// Note: Reads to the compact heightfield are offset by border size (bs)
// since border size offset is already removed from the polymesh vertices.
// Use poly vertices as seed points for the flood fill.
// Find center of the polygon using flood fill.
// Check if close to center of the polygon.
// Mark start locations.
// Return true if edge (va,vb) is part of the polygon.
/// @par
///
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcAllocPolyMeshDetail, rcPolyMesh, rcCompactHeightfield, rcPolyMeshDetail, rcConfig
// Find max size for a polygon area.
// Store polygon vertices for processing.
// Get the height data from the area of the polygon.
// Build detail mesh.
// Move detail verts to world space.
// Is this offset necessary?
// Offset poly too, will be used to flag checking.
// Store detail submesh.
// Store vertices, allocate more memory if necessary.
// Store triangles, allocate more memory if necessary.
/// @see rcAllocPolyMeshDetail, rcPolyMeshDetail
// Merge datas.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// If running out of memory, allocate new page and update the freelist.
// Create new page.
// Allocate memory for the new pool.
// Add the pool into the list of pools.
// Add new items to the free list.
// Pop item from in front of the free list.
// Add the node in front of the free list.
// Empty cell, add he first span.
// Insert and merge spans.
// Current span is further than the new span, break.
// Current span is before the new span advance.
// Merge spans.
// Merge flags.
// Remove current span.
// Insert new span.
/// @par
///
/// The span addition can be set to favor flags. If the span is merged to
/// another span and the new @p smax is within @p flagMergeThr units
/// from the existing span, the span flags are merged.
///
/// @see rcHeightfield, rcSpan.
/*ctx*/, rcHeightfield& hf, const int x, const int y,
//	rcAssert(ctx);
// Calculate the bounding box of the triangle.
// If the triangle does not touch the bbox of the heightfield, skip the triagle.
// Calculate the footpring of the triangle on the grid.
// Clip the triangle into all grid cells it touches.
// Clip polygon to row.
// Clip polygon to column.
// Calculate min and max of the span.
// Skip the span if it is outside the heightfield bbox
// Clamp the span to the heightfield bbox.
// Snap the span to the heightfield height grid.
/// @par
///
/// No spans will be added if the triangle does not overlap the heightfield grid.
///
/// @see rcHeightfield
/// @par
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
/*nv*/,
// Rasterize triangles.
// Rasterize.
/// @par
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
/*nv*/,
// Rasterize triangles.
// Rasterize.
/// @par
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
// Rasterize triangles.
// Rasterize.
//
// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
//
// Init distance and points.
// Mark boundary cells.
// Pass 1
// (-1,0)
// (-1,-1)
// (0,-1)
// (1,-1)
// Pass 2
// (1,0)
// (1,1)
// (0,1)
// (-1,1)
// Flood fill mark region.
// Check if any of the neighbours already have a valid region set.
// 8 connected
// Do not take borders into account.
// Expand neighbours.
// Find cells revealed by the raised level.
// mark as used
// rcSwap source and dest.
// Number of spans belonging to this region
// ID of the region
// Are type.
// Remove adjacent duplicates.
// Remove duplicate
// Duplicate current neighbourhood.
// Find insertion point on A.
// Find insertion point on B.
// Merge neighbours.
// Region is connected to border if
// one of the neighbours is null id.
// Choose the edge corner
// Rotate CW
// Should not happen.
// Rotate CCW
// Remove adjacent duplicates.
// Construct regions
// Find edge of a region and find connections around the contour.
// Update floors.
// Have found contour
// Check if this cell is next to a border.
// The cell is at border.
// Walk around the contour to find all the neighbours.
// Remove too small regions.
// Count the total size of all the connected regions.
// Also keep track of the regions connects to a tile border.
// Pop
// Visit
// If the accumulated regions size is too small, remove it.
// Do not remove areas which connect to tile borders
// as their size cannot be estimated correctly and removing them
// can potentially remove necessary areas.
// Kill all visited regions.
// Merge too small regions to neighbour regions.
// Check to see if the region should be merged.
// Small region with more than 1 connection.
// Or region which is not connected to a border at all.
// Find smallest neighbour region that connects to this one.
// Found new id.
// Merge neighbours.
// Fixup regions pointing to current region.
// If another region was already merged into current region
// change the nid of the previous region too.
// Replace the current region with the new one if the
// current regions is neighbour.
// Compress region Ids.
// Skip nil regions.
// Skip external regions.
// Remap regions.
/// @par
/// 
/// This is usually the second to the last step in creating a fully built
/// compact heightfield.  This step is required before regions are built
/// using #rcBuildRegions or #rcBuildRegionsMonotone.
/// 
/// After this step, the distance data is available via the rcCompactHeightfield::maxDistance
/// and rcCompactHeightfield::dist fields.
///
/// @see rcCompactHeightfield, rcBuildRegions, rcBuildRegionsMonotone
// Blur
// Store distance.
// row id
// region id
// number samples
// neighbour id
/// @par
/// 
/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
/// Contours will form simple polygons.
/// 
/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
/// re-assigned to the zero (null) region.
/// 
/// Partitioning can result in smaller than necessary regions. @p mergeRegionArea helps 
/// reduce unecessarily small regions.
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// The region data will be available via the rcCompactHeightfield::maxRegions
/// and rcCompactSpan::reg fields.
/// 
/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
/// 
/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
// Mark border regions.
// Make sure border will not overflow.
// Paint regions
// Sweep one line at a time.
// Collect spans from this row.
// -x
// -y
// Create unique ID.
// Remap IDs
// Filter out small regions.
// Store the result out.
/// @par
/// 
/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
/// Contours will form simple polygons.
/// 
/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
/// re-assigned to the zero (null) region.
/// 
/// Watershed partitioning can result in smaller than necessary regions, especially in diagonal corridors. 
/// @p mergeRegionArea helps reduce unecessarily small regions.
/// 
/// See the #rcConfig documentation for more information on the configuration parameters.
/// 
/// The region data will be available via the rcCompactHeightfield::maxRegions
/// and rcCompactSpan::reg fields.
/// 
/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
/// 
/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
// TODO: Figure better formula, expandIters defines how much the 
// watershed "overflows" and simplifies the regions. Tying it to
// agent radius was usually good indication how greedy it could be.
//	const int expandIters = 4 + walkableRadius * 2;
// Make sure border will not overflow.
// Paint regions
// Expand current regions until no empty connected cells found.
// Mark new regions with IDs.
// Expand current regions until no empty connected cells found.
// Filter out small regions.
// Write the result out.
/*****************************************************************************/
/* FileStream.cpp                         Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* File stream support for StormLib                                          */
/*                                                                           */
/* Windows support: Written by Ladislav Zezula                               */
/* Mac support:     Written by Sam Wilkins                                   */
/* Linux support:   Written by Sam Wilkins and Ivan Komissarov               */
/* Big-endian:      Written & debugged by Sam Wilkins                        */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.06.10  1.00  Lad  Derived from StormPortMac.cpp and StormPortLinux.cpp */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local defines
// 'BOOL' : forcing value to bool 'true' or 'false' (performance warning)
//-----------------------------------------------------------------------------
// Local functions - platform-specific functions
//-----------------------------------------------------------------------------
// Preparing file bitmap for a complete file of a given size
// Get file size and calculate bitmap length
// Calculate and give the total length
// Has the caller given enough space for storing the structure?
// Do we have enough space to fill the bitmap as well?
// Fill the full blocks
// Supply the last block
//-----------------------------------------------------------------------------
// Local functions - base file support
// Pointer to an open stream
// Pointer to file byte offset. If NULL, it reads from the current position
// Pointer to data to be read
// Number of bytes to read from the file
// Must be set by platform-specific code
// Note: StormLib no longer supports Windows 9x.
// Thus, we can use the OVERLAPPED structure to specify
// file offset to read from file. This allows us to skip
// one system call to SetFilePointer
// Update the byte offset
// Read the data
/*
// we have to update the file position
// Read the data
// If the byte offset is different from the current file position,
// we have to update the file position
// Perform the read operation
// Increment the current file position by number of bytes read
// If the number of bytes read doesn't match to required amount, return false
/**
// Must be set by platform-specific code
// Note: StormLib no longer supports Windows 9x.
// Thus, we can use the OVERLAPPED structure to specify
// file offset to read from file. This allows us to skip
// one system call to SetFilePointer
// Update the byte offset
// Read the data
/*
// we have to update the file position
// Read the data
// If the byte offset is different from the current file position,
// we have to update the file position
// Perform the read operation
// Increment the current file position by number of bytes read
// Also modify the file size, if needed
// Pointer to an open stream
// Pointer to file byte offset
// Pointer to an open stream
// Pointer where to store file size
/**
// Set the position at the new file size
// Set the current file pointer as the end of the file
// Restore the file position
// Renames the file pointed by pStream so that it contains data from pNewStream
// Delete the original stream file. Don't check the result value,
// because if the file doesn't exist, it would fail
// Rename the new file to the old stream's file
// "rename" on Linux also works if the target file exists
// Also invalidate the handle
// Fill-in the entry points
// Reset the file position
// Open the file
// Query the file size
// Query last write time
// Open the file
// Get the file size
// time_t is number of seconds since 1.1.1970, UTC.
// 1 second = 10000000 (decimal) in FILETIME
// Set the start to 1.1.1970 00:00:00
// Fill-in the entry points
// Reset the file position
//-----------------------------------------------------------------------------
// Local functions - base memory-mapped file support
// Pointer to an open stream
// Pointer to file byte offset. If NULL, it reads from the current position
// Pointer to data to be read
// Number of bytes to read from the file
// Do we have to read anything at all?
// Don't allow reading past file size
// Copy the required data
// Move the current file position
// Pointer to an open stream
// Pointer to file byte offset
// Pointer to an open stream
// Pointer where to store file size
// Open the file for read access
// Retrieve file size. Don't allow mapping file of a zero size.
// Retrieve file time
// Now create mapping object
// Map the entire view into memory
// Note that this operation will fail if the file can't fit
// into usermode address space
// Close the map handle
// Close the file handle
// If the file is not there and is not available for random access,
// report error
// Open the file
// Get the file size
// time_t is number of seconds since 1.1.1970, UTC.
// 1 second = 10000000 (decimal) in FILETIME
// Set the start to 1.1.1970 00:00:00
// Did the mapping fail?
// Fill-in entry points
//-----------------------------------------------------------------------------
// Local functions - base HTTP file support
// Check for HTTP
//"), 7))
// Cut off the server name
// Return the remainder
// Pointer to an open stream
// Pointer to file byte offset. If NULL, it reads from the current position
// Pointer to data to be read
// Number of bytes to read from the file
// Do we have to read anything at all?
// Open HTTP request to the file
// Add range request to the HTTP headers
// http://www.clevercomponents.com/articles/article015/resuming.asp
// Send the request to the server
// Read the block from the file
// Check for end
// Move buffers
// Increment the current file position by number of bytes read
// If the number of bytes read doesn't match the required amount, return false
// Not supported
// Pointer to an open stream
// Pointer to file byte offset
// Pointer to an open stream
// Pointer where to store file size
// Don't connect to the internet
// Initiate the connection to the internet
// Connect to the server
// Initiate connection with the server
// Now try to query the file size
// Open HTTP request to the file
// Check if the MPQ has Last Modified field
// Verify if the server supports random access
// If the file is not there and is not available for random access,
// report error
// Fill-in entry points
// Not supported
//-----------------------------------------------------------------------------
// Local functions - linear stream support
// Pointer to an open stream
// Pointer to file byte offset. If NULL, it reads from the current position
// Pointer to data to be read
// Number of bytes to read from the file
// At this point, we must have a bitmap set
// If we have data map, we must check if the data block is present in the MPQ
// Get the offset where we read it from
// If the start of the area is within the region
// protected by data map, check each block
// Cut the end of the stream protected by the data map
// Calculate the initial block index
// Parse each block
// Prepare byte index and bit mask
// If that bit is not set, it means that the block is not present
// Move to tne next block
// Now if all tests passed, we can call the base read function
// Sanity checks
// Close the new stream
// Close the source stream
// Rename the new data source file to the existing file
// Now we have to open the "pStream" again
// We need to cleanup the new data stream
// Assumed that we have bitmap now
// Give the bitmap length
// Do we have enough space to fill at least the bitmap structure?
// Enough space for complete bitmap?
// Free the data map, if any
// Call the base class for closing the stream
// No extra work here really; just set entry points
//-----------------------------------------------------------------------------
// Local functions - partial stream support
// Version number must be 2
// GameBuildNumber must be an ASCII number
// Block size must be power of 2
// Why it failed if not enough bytes was read
// If the byte offset is not entered, use the current position
// Check if the file position is not at or beyond end of the file
// Get the part index where the read offset is
// Note that the part index should now be within the range,
// as read requests beyond-EOF are handled by the previous test
// If the number of bytes remaining goes past
// the end of the file, cut them
// Calculate the offset in the current part
// Read all data, one part at a time
// If the part is not present in the file, we fail the read
// If we are in the last part, we have to cut the number of bytes in the last part
// Get the number of bytes reamining in the current part
// Compute the raw file offset of the file part
// If the number of bytes in part is too big, cut it
// Append the offset within the part
// Increment the file position
// Move to the next file part
// Move the file position by the number of bytes read
// Pointer to an open stream
// Pointer where to store file size
// Do we have stream bitmap?
// Give the bitmap length
// Do we have enough to fill at least the header?
// Fill the bitmap header
// Is there at least one incomplete block?
// Do we have enough space for supplying the bitmap?
// Fill the file bitmap
// Is the block there?
// Free the part map
// Clear variables
// Close the base stream
// Size of the file stored in part file
// Sanity check
// Attempt to read PART file header
// We need to swap PART file header on big-endian platforms
// Verify the PART file header
// Calculate the number of parts in the file
// Allocate the map entry array
// Load the block map
// Swap the array of file map entries
// Fill the members of PART file stream
// Set new function pointers
// Free the part map
//-----------------------------------------------------------------------------
// Local functions - encrypted stream support
// Note: Starcraft II - Installer.exe (4.1.1.4219):                    Suffix derived from battle.net auth. code
// Address of decryption routine: 0053A3D0                             http://us.battle.net/static/mediakey/sc2-authenticationcode-enUS.txt
// Pointer to decryptor object: ECX                                    Numbers mean offset of 4-char group of auth code (follows in comment)
// Pointer to key: ECX+0x5C                                            -0C-    -1C--08-    -18--04-    -14--00-    -10-
// Y45MD3CAK4KXSSXHYD9VY64Z8EKJ4XFX
// G8MN8UDG6NA2ANGY6A3DNY82HRGF29ZH
// W9RRHLB2FDU9WW5B3ECEBLRSFWZSF7HW
// 3DH5RE5NVM5GTFD85LXGWT6FK859ETR5
// 8WLKUAXE94PFQU4Y249PAZ24N4R4XKTQ
// A34DXX3VHGGXSQBRFE5UFFDXMF9G4G54
// ZG7J9K938HJEFWPQUA768MA2PFER6EAJ
// NE7CUNNNTVAPXV7E3G2BSVBWGVMW8BL2
// 3V9E2FTMBM9QQWK7U6MAMWAZWQDB838F
// 2NSFB8MELULJ83U6YHA3UP6K4MQD48L6
// QA2TZ9EWZ4CUU8BMB5WXCTY65F9CSW4E
// VHB378W64BAT9SH7D68VV9NLQDK9YEGT
// U3NFQJV4M6GC7KBN9XQJ3BRDN3PLD9NE
// Note: Diablo III: Agent.exe (1.0.0.954):                            Suffix derived from battle.net auth. code
// Address of decryption routine: 00502b00                             http://dist.blizzard.com/mediakey/d3-authenticationcode-enGB.txt
// Pointer to decryptor object: ECX                                    Numbers mean offset of 4-char group of auth code (follows in comment)
// Pointer to key: ECX+0x5C                                            -0C-    -1C--08-    -18--04-    -14--00-    -10-
// UCMXF6EJY352EFH4XFRXCFH2XC9MQRZK
// MMKVHY48RP7WXP4GHYBQ7SL9J9UNPHBP
// 8MXLWHQ7VGGLTZ9MQZQSFDCLJYET3CPP
// EJ2R5TM6XFE2GUNG5QDGHKQ9UAKPWZSZ
// PBGFBE42Z6LNK65UGJQ3WZVMCLP4HQQT
// X7SEJJS9TSGCW5P28EBSC47AJPEY8VU2
// 5KVBQA8VYE6XRY3DLGC5ZDE4XS4P7YA2
// 478JD2K56EVNVVY4XX8TDWYT5B8KB254
// 8TS4VNFQRZTN6YWHE9CHVDH9NVWD474A
// LJ52Z32DF4LZ4ZJJXVKK3AZQA6GABLJB
// K6BDHY2ECUE2545YKNLBJPVYWHE7XYAG
// 
// 6VWCQTN8V3ZZMRUCZXV8A8CGUX2TAA8H
// 
//  MpqeKey_Diablo3_Install_ruRU,
//  MpqeKey_Diablo3_Install_zhCN,
// Prepare the key
// Shuffle the key - part 1
// Shuffle the key - part 2
// Decrypt one data chunk
// Update byte offset in the key
// Move pointers and decrease number of bytes to decrypt
// We just try all known keys one by one
// Copy the key there
// Try to decrypt with the given key 
// We check the decrypted data
// All known encrypted MPQs have header at the begin of the file,
// so we check for MPQ signature there.
// Key not found, sorry
// Pointer to an open stream
// Pointer to file byte offset. If NULL, it reads from the current position
// Pointer to data to be read
// Number of bytes to read from the file
// Offset of the first byte to be read from the file
// Offset that the caller wants
// End offset that is to be read from the file
// Get the byte offset
// Cut it down to MPQE chunk size
// Calculate number of bytes to decrypt
// Allocate buffers for encrypted and decrypted data
// Get the offset of the desired data in the cache
// Read the file from the stream as-is
// Decrypt the data
// Copy the decrypted data
// Free decryption buffer        
// Free buffers and exit
// Sanity check
// Load one MPQE chunk and try to detect the file key
// Attempt to decrypt the MPQ header with all known keys
// Copy the key for the file
// Assign functions
// We need to reset the position back to the begin of the file
// An unknown key
//-----------------------------------------------------------------------------
// Public functions
/**
// We only support creation of linear, local file
// Allocate file stream structure for linear stream
// Reset entire structure to zero
// Attempt to create the disk file
// Fill the stream provider functions
// File create failed, delete the stream
// Return the stream
/**
// Allocate file stream for each stream provider
// Allocate structure for linear stream 
// Allocate the stream for each type
// Fill the stream structure with zeros
// Now initialize the respective base provider
// If we failed to open the base storage, fail the operation
// Now initialize the stream provider
// If the operation failed, free the stream and set it to NULL
// Only close the base stream
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// It must be a linear stream.
// Two bitmaps are not allowed
// We need to change some entry points
// Using data bitmap renders the stream to be read only.
/**
/**
// Check if the stream structure is allocated at all
// Close the stream provider.
// This will also close the base stream
// Free the stream itself
//-----------------------------------------------------------------------------
// main - for testing purposes
// Read the MPQ header
// Read the hash table
// Read the block table
/*
//
// Test 1: Write to a stream
//
//
// Test2: Read from the stream
//
// This call must end with an error
//
// Test3: Open the temp stream, write some data and switch it to the original stream
//
// Copy the original stream to the temp
// Switch the streams
// Note that the pTempStream is closed by the operation
//
// Test4: Read from the stream again
//
/*****************************************************************************/
/* SBaseCommon.cpp                        Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Common functions for StormLib, used by all SFile*** modules               */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 24.03.03  1.00  Lad  The first version of SFileCommon.cpp                 */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 12.06.04  1.01  Lad  Renamed to SCommon.cpp                               */
/* 06.09.10  1.01  Lad  Renamed to SBaseCommon.cpp                           */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// The buffer for decryption engine.
// File locale
// File platform
//-----------------------------------------------------------------------------
// Storm buffer functions
// Buffer for the decryption engine
// Initialize the decryption buffer.
// Do nothing if already done.
// Also register both MD5 and SHA1 hash algorithms
// Use LibTomMath as support math library for LibTomCrypt
// Don't do that again
//-----------------------------------------------------------------------------
// Calculates the hash table size for a given amount of files
// Round the hash table size up to the nearest power of two
// Don't allow the hash table size go over allowed maximum
//-----------------------------------------------------------------------------
// Calculates a Jenkin's Encrypting and decrypting MPQ file data
// This is required to produce defined results
// Normalize the file name - convert to uppercase, and convert "/" to "\\".
// Thanks Quantam for finding out what the algorithm is.
// I am really getting old for reversing large chunks of assembly
// that does hashing :-)
// Combine those 2 together
//-----------------------------------------------------------------------------
// This function converts the MPQ header so it always looks like version 4
// If version 1.0 is forced, then the format version is forced to be 1.0
// Reason: Storm.dll in Warcraft III ignores format version value
// Format-specific fixes
// Check for malformed MPQ header version 1.0
//
// The value of "dwArchiveSize" member in the MPQ header
// is ignored by Storm.dll and can contain garbage value
// ("w3xmaster" protector).
//
// Note: dwExpectedArchiveSize might be incorrect at this point.
// MPQs version 1.0 can have strong digital signature appended at the end,
// or they might just have arbitrary data there.
// In either case, we recalculate the archive size later when
// block table is loaded and positions of all files is known.
// Zero the fields in 2.0 part of the MPQ header
// No break here !!!
// In MPQ format 3.0, the entire header is optional
// and the size of the header can actually be identical
// to size of header 2.0
// In format 2.0, the archive size is obsolete and is calculated
// as the highest offset of hash table, block table or hi-block table.
// However, we can still rely on it, if the size of the archive is under 4 GB
// Only if we actually have a hi-block table
// We need to recalculate archive size later,
// when block table is loaded and the position of files is known
// Initialize the rest of the 3.0 header
//
// Calculate compressed size of each table. We assume the following order:
// 1) HET table
// 2) BET table
// 3) Classic hash table
// 4) Classic block table
// 5) Hi-block table
//
// Set all sizes to zero
// Either both HET and BET table exist or none of them does.
// Compressed size of the HET and BET tables
// Compressed size of hash and block table
// Compressed size of the hash table
// Block and hi-block table
// No known MPQ in format 1.0 has any of the tables compressed
// Set the data chunk size for MD5 to zero
// Fill the MD5's
// No break here !!!!
// Verify header MD5. Header MD5 is calculated from the MPQ header since the 'MPQ\x1A'
// signature until the position of header MD5 at offset 0xC0
//-----------------------------------------------------------------------------
// Default flags for (attributes) and (listfile)
// Fixed for format 1.0
// Size-dependent for formats 2.0-4.0
//-----------------------------------------------------------------------------
// Encrypting and decrypting MPQ file data
// Round to DWORDs
// Round to DWORDs
/*
/**
// temp = seed1 + seed2
// temp = seed1 + StormBuffer[0x400 + (seed1 & 0xFF)]
// Try all 255 possibilities
// Try the first DWORD (We exactly know the value)
// Add 1 because we are decrypting sector positions
// If OK, continue and test the second value. We don't know exactly the value,
// but we know that the second one has lower 16 bits set to zero
// (no compressed sector is larger than 0xFFFF bytes)
// Function tries to detect file encryption key. It expectes at least two uncompressed bytes
// We need at least two DWORDS to detect the file key
// Try all 256 possibilities
// Try the first DWORD
// If OK, continue and test all bytes.
// Try to break the file encryption key as if it was a WAVE file
// Try to break the encryption key as if it was an EXE file
// Try to break the encryption key as if it was a XML file
// Not detected, sorry
// File key is calculated from plain name
// Fix the key, if needed
// Return the key
//-----------------------------------------------------------------------------
// Handle validation functions
//-----------------------------------------------------------------------------
// Hash table and block table manipulation
// Retrieves the first hash entry for the given file.
// Every locale version of a file has its own hash entry
// File hash entry (start)
// File hash entry (current)
// Get the first possible has entry that might be the one
// There might be deleted entries in the hash table prior to our desired entry.
// If the entry agrees, we found it.
// Move to the next hash entry. Stop searching
// if we got reached the original hash entry
// The apropriate hash entry was not found
// Now go for any next entry that follows the pPrevHash,
// until either free hash entry was found, or the start entry was reached
// Move to the next hash entry. Stop searching
// if we got reached the original hash entry
// If the entry is a free entry, stop search
// If the entry is not free and the name agrees, we found it
// No next entry
// Allocates an entry in the hash table
// File hash entry (start)
// File hash entry (current)
// Get the first possible has entry that might be the one
// There might be deleted entries in the hash table prior to our desired entry.
// If there already is an existing entry, reuse it.
// Move to the next hash entry.
// If we reached the starting entry, it's failure.
// Fill the free hash entry
// Fill the hash index in the file entry
// Finds a free space in the MPQ where to store next data
// The free space begins beyond the file that is stored at the fuhrtest
// position in the MPQ.
// Parse the entire block table
// Only take existing files
// If the end of the file is bigger than current MPQ table pos, update it
// Get the end of the file data
// Add the MD5 chunks, if present
// Give the free space position to the caller
//-----------------------------------------------------------------------------
// Common functions - MPQ File
// Allocate space for TMPQFile
// Fill the file structure
// Loads a table from MPQ.
// Can be used for hash table, block table, sector offset table or sector checksum table
// "interface.MPQ.part" in trial version of World of Warcraft
// has block table and hash table compressed.
// Allocate temporary buffer for holding compressed data
// Assign the temporary buffer as target for read operation
// Read the table
// First of all, decrypt the table
// If the table is compressed, decompress it
// Free the temporary buffer
//
// Some MPQ protectors place the sector offset table after the actual file data.
// Sector offsets in the sector offset table are negative. When added
// to MPQ file offset from the block table entry, the result is a correct
// position of the file data in the MPQ.
//
// The position of sector table must be always within the MPQ, however.
// When a negative sector offset is found, we make sure that we make the addition
// just in 32-bits, and then add the MPQ offset.
//
// We also have to add patch header size, if patch header is present
// Sanity check
// Calculate how many MD5's we will calculate
// Allocate space for array or MD5s
// Give the size of the MD5 array
// Allocates sector buffer and sector offset table
// Caller of AllocateSectorBuffer must ensure these
// Don't allocate anything if the file has zero size
// Determine the file sector size and allocate buffer for it
// Return result
// Allocates sector offset table
// The following conditions must be true
// Allocate space for patch header. Start with default size,
// and if its size if bigger, then we reload them
// Do we have to load the patch header from the file ?
// Load the patch header
// Free the patch info
// Perform necessary swapping
// Verify the size of the patch header
// If it's not default size, we have to reload them
// Free the patch info
// If the length is out of all possible ranges, fail the operation
// Patch file data size according to the patch header
// Save the final length to the patch header
// Allocates sector offset table
// Caller of AllocateSectorOffsets must ensure these
// If the file is stored as single unit, just set number of sectors to 1
// Calculate the number of data sectors
// Note that this doesn't work if the file size is zero
// Calculate the number of file sectors
// If MPQ_FILE_SECTOR_CRC flag is set, there will either be extra DWORD
// or an array of MD5's. Either way, we read at least 4 bytes more
// in order to save additional read from the file.
// Only allocate and load the table if the file is compressed
// Allocate the sector offset table
// Only read from the file if we are supposed to do so
// Load the sector offsets from the file
// Free the sector offsets
// Swap the sector positions
// Decrypt loaded sector positions if necessary
// If we don't know the file key, try to find it.
// Decrypt sector positions
//
// Validate the sector offset table
//
// Note: Some MPQ protectors put the actual file data before the sector offset table.
// In this case, the sector offsets are negative (> 0x80000000).
//
// Every following sector offset must be bigger than the previous one
// The sector size must not be bigger than compressed file size
// If data corruption detected, free the sector offset table
//
// There may be various extra DWORDs loaded after the sector offset table.
// They are mostly empty on WoW release MPQs, but on MPQs from PTR,
// they contain random non-zero data. Their meaning is unknown.
//
// These extra values are, however, include in the dwCmpSize in the file
// table. We cannot ignore them, because compacting archive would fail
// 
// Offset of the CRC table, relative to file offset in the MPQ
// Caller of AllocateSectorChecksums must ensure these
// Single unit files don't have sector checksums
// Caller must ensure that we are only called when we have sector checksums
// 
// Older MPQs store an array of CRC32's after
// the raw file data in the MPQ.
//
// In newer MPQs, the (since Cataclysm BETA) the (attributes) file
// contains additional 32-bit values beyond the sector table.
// Their number depends on size of the (attributes), but their
// meaning is unknown. They are usually zeroed in retail game files,
// but contain some sort of checksum in BETA MPQs
//
// Does the size of the file table match with the CRC32-based checksums?
// Is there valid size of the sector checksums?
// Ignore cases when the length is too small or too big.
// Allocate the array for the sector checksums
// If we are not supposed to load it from the file, allocate empty buffer
// Calculate offset of the CRC table
// Now read the table from the MPQ
// If the size doesn't match, we ignore sector checksums
//  assert(false);
// The caller must make sure that this function is only called
// when the following is true.
// The caller must make sure that this function is only called
// when the following is true.
// If file is encrypted, sector positions are also encrypted
// Adjust sector offset table position, if we also have patch info
// Write sector offsets to the archive
// Not necessary, as the sector checksums
// are going to be freed when this is done.
//  BSWAP_ARRAY32_UNSIGNED(hf->SectorOffsets, dwSectorOffsLen);
// The caller must make sure that this function is only called
// when the following is true.
// If the MPQ has MD5 of each raw data chunk,
// we leave sector offsets empty
// Calculate size of the checksum array
// Allocate buffer for compressed sector CRCs.
// Perform the compression
// Write the sector CRCs to the archive
// Not necessary, as the sector checksums
// are going to be freed when this is done.
//  BSWAP_ARRAY32_UNSIGNED(hf->SectorChksums, dwCrcSize);
// Store the sector CRCs 
// Allocate buffer for array of MD5
// For every file chunk, calculate MD5
// Get the remaining number of bytes to read
// Calculate MD5
// Move offset and size
// Write the array od MD5's to the file
// Give the caller the size of the MD5 array
// Free buffers and exit
// Writes the MD5 for each chunk of the raw file data
// Allocate buffer for array of MD5
// Allocate space for file chunk
// For every file chunk, calculate MD5
// Get the remaining number of bytes to read
// Read the chunk
// Calculate MD5
// Move offset and size
// Write the array od MD5's to the file
// Free buffers and exit
// Frees the structure for MPQ file
// If we have patch file attached to this one, free it first
// Then free all buffers allocated in the file structure
// Frees the MPQ archive
// First of all, free the patch archive, if any
// Close the file stream
// Free the file names from the file table
// Then free all buffers allocated in the archive structure
// Verifies if the file name is a pseudo-name
// Must be "File########.ext"
// Check 8 digits
// An extension must follow
// Not a pseudo-name
//-----------------------------------------------------------------------------
// Functions calculating and verifying the MD5 signature
// The MD5 is considered invalid of it is zeroed
// Don't verify the block if the MD5 is not valid.
// Calculate the MD5 of the data block
// Does the MD5's match?
//-----------------------------------------------------------------------------
// Swapping functions
//
// Note that those functions are implemented for Mac operating system,
// as this is the only supported platform that uses big endian.
//
// Swaps a signed 16-bit integer
// Swaps an unsigned 16-bit integer
// Swaps signed 32-bit integer
// Swaps an unsigned 32-bit integer
// Swaps signed 64-bit integer
// Swaps an unsigned 64-bit integer
// Swaps array of unsigned 16-bit integers
// Swaps array of unsigned 32-bit integers
// Swaps array of unsigned 64-bit integers
// Swaps the TMPQUserData structure
// Swaps the TMPQHeader structure
// Swap the hi-block table position
// PLATFORM_LITTLE_ENDIAN
/*****************************************************************************/
/* SBaseDumpData.cpp                      Copyright (c) Ladislav Zezula 2011 */
/*---------------------------------------------------------------------------*/
/* Description :                                                             */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 26.01.11  1.00  Lad  The first version of SBaseDumpData.cpp               */
/*****************************************************************************/
// __STORMLIB_DUMP_DATA__
/*****************************************************************************/
/* SBaseFileTable.cpp                     Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* Description: Common handler for classic and new hash&block tables         */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 06.09.10  1.00  Lad  The first version of SBaseFileTable.cpp              */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local defines
//-----------------------------------------------------------------------------
// Local structures
// Structure for HET table header
// Size of the entire HET table, including HET_TABLE_HEADER (in bytes)
// Maximum number of files in the MPQ
// Size of the hash table (in bytes)
// Effective size of the hash entry (in bits)
// Total size of file index (in bits)
// Extra bits in the file index
// Effective size of the file index (in bits)
// Size of the block index subtable (in bytes)
// Structure for BET table header
// Size of the entire BET table, including the header (in bytes)
// Number of files in the BET table
// Size of one table entry (in bits)
// Bit index of the file position (within the entry record)
// Bit index of the file size (within the entry record)
// Bit index of the compressed size (within the entry record)
// Bit index of the flag index (within the entry record)
// Bit index of the ??? (within the entry record)
// Bit size of file position (in the entry record)
// Bit size of file size (in the entry record)
// Bit size of compressed file size (in the entry record)
// Bit size of flags index (in the entry record)
// Bit size of ??? (in the entry record)
// Total size of the BET hash
// Extra bits in the BET hash
// Effective size of BET hash (in bits)
// Size of BET hashes array, in bytes
// Number of flags in the following array
//-----------------------------------------------------------------------------
// Support for calculating bit sizes
// Find free or equal entry in the flag array
// This should never happen
//-----------------------------------------------------------------------------
// Support functions for BIT_ARRAY
// Allocate the bit array
// Keep compiler happy for platforms where nResultByteSize is not used
// Check if the target is properly zeroed
// Adjust the buffer pointer for big endian platforms
// Copy whole bytes, if any
// Is the current position in the Elements byte-aligned?
// Move byte positions and lengths
// Get the rest of the bits
// Keep compiler happy for platforms where nResultByteSize is not used
// Adjust the buffer pointer for big endian platforms
// Copy whole bytes, if any
// Reload the bit buffer
// Update the BitBuffer and AndMask for the bit array
// Update the byte in the array
// Move byte positions and lengths
// Reload the bit buffer
// Update the AND mask for the last bit
// Update the byte in the array
// Update the next byte, if needed
//-----------------------------------------------------------------------------
// Support for hash table
// Returns a hash table entry in the following order:
// 1) A hash table entry with the neutral locale
// 2) A hash table entry with any other locale
// 3) NULL
// Parse the found hashes
// If we found neutral hash, remember it
// Get the next hash entry for that file
// At the end, return neutral hash (if found), otherwise NULL
// Returns a hash table entry in the following order:
// 1) A hash table entry with the preferred locale
// 2) A hash table entry with the neutral locale
// 3) NULL
// Parse the found hashes
// If the locales match, return it
// If we found neutral hash, remember it
// Get the next hash entry for that file
// At the end, return neutral hash (if found), otherwise NULL
// Returns a hash table entry in the following order:
// 1) A hash table entry with the preferred locale
// 2) NULL
// Parse the found hashes
// If the locales match, return it
// Get the next hash entry for that file
// Not found
// Allocate copy of the hash table
// Copy the hash table
// Give the size to the caller
// Allocate copy of the hash table
// Copy the block table
// Give the size to the caller
// Allocate copy of the hash table
// Copy the block table
// Give the size to the caller
//-----------------------------------------------------------------------------
// General EXT table functions
// Compressed table
// Uncompressed table
// Do nothing if the size is zero
// Allocate size for the compressed table
// Load the table from the MPQ
// Swap the ext table header
// Decrypt the block
// If the table is compressed, decompress it
// Decompress the extended table
// Free the compressed block
// Return the decompressed table to the caller
// Used in MPQ Editor
// Do we have to compress the table?
// Allocate extra space for compressed table
// Compress the table
// If the compression failed, revert it. Otherwise, swap the tables
// Encrypt the table
// Calculate the MD5
// Save the table to the MPQ
// Free the compressed table, if any
// Do we have to compress the table?
// Allocate extra space for compressed table
// Compress the table
// If the compression failed, revert it. Otherwise, swap the tables
// Encrypt the table
// Calculate the MD5 of the table after
// Save the table to the MPQ
// We have to write raw data MD5
// Give the total written size, if needed
// Free the compressed table, if any
//-----------------------------------------------------------------------------
// Support for HET table
// Fill the BET header
// Calculate the total size needed for holding HET table
// Size of one index is calculated from max file count
// Allocate hash table
// If we shall create empty HET table, we have to allocate empty block index table as well
// Calculate masks
// Sanity check
// Verify size of the HET table
// Copy the table header in order to have it aligned and swapped
// Verify the size of the table in the header
// Create translated table
// Copy the hash table size, index size and extra bits from the HET header
// Fill the hash table
// Copy the block index table
// Prepare header of the HET table
// Calculate the total size needed for holding the encrypted HET table
// Allocate space for the linear table
// Create the common ext table header
// Copy the HET table header
// Copy the array of HET hashes
// Copy the bit array of BET indexes
// Calculate the total size of the table, including the TMPQExtTable
// Upper 8 bits of the masked file name hash
// Do nothing if the MPQ has no HET table
// Calculate 64-bit hash of the file name
// Split the file name hash into two parts:
// Part 1: The highest 8 bits of the name hash
// Part 2: The rest of the name hash (without the highest 8 bits)
// Calculate the starting index to the hash table
// Go through HET table until we find a terminator
// Did we find match ?
// Get the index of the BetHash
//
// TODO: This condition only happens when we are opening a MPQ
// where some files were deleted by StormLib. Perhaps 
// we should not allow shrinking of the file table in MPQs v 4.0?
// assert(dwFileIndex <= ha->dwFileTableSize);
//
// Verify the BetHash against the entry in the table of BET hashes
// Move to the next entry in the primary search table
// If we came to the start index again, we are done
// File not found
// Upper 8 bits of the masked file name hash
// Do nothing if the MPQ has no HET table
// Calculate 64-bit hash of the file name
// Calculate the starting index to the hash table
// Split the file name hash into two parts:
// Part 1: The highest 8 bits of the name hash
// Part 2: The rest of the name hash (without the highest 8 bits)
// Go through HET table until we find a terminator
// Check for entries that might have been deleted
// Verify the BET index. If it's really free, we can use it
// Is that entry free ?
// Move to the next entry in the primary search table
// If we came to the start index again, we are done
// Fill the HET table entry
// Fill the file entry
//-----------------------------------------------------------------------------
// Support for BET table
// Initialize array of flag combinations
// Get the maximum values for the BET table
// Highest file position in the MPQ
// Biggest file size
// Biggest compressed size
// Check if this flag was there before
// Now save bit count for every piece of file information
// Calculate the total size of one entry
// Save the file count and flag count
// Save the total size of the BET hash
// Save the total table size
// Allocate BET table
// Sanity check
// Verify size of the HET table
// Copy the table header in order to have it aligned and swapped
// Some MPQs affected by a bug in StormLib have pBetTable->dwFileCount
// greater than ha->dwMaxFileCount
// Verify the size of the table in the header
// Create translated table
// Copy the variables from the header to the BetTable
// Since we don't know what the "unknown" is, we'll assert when it's nonzero
// Allocate array for flags
// Allocate array for file flags and load it
// Save the number of flags
// Load the bit-based file table
// Fill the sizes of BET hash
// Create and load the array of BET hashes
// Dump both tables
//              DumpHetAndBetTable(ha->pHetTable, pBetTable);
// Calculate the bit sizes of various entries
// Calculate the size of the BET table
// Allocate space
// Create the common ext table header
// Copy the BET table header
// Save the bit-based block table
// Construct the array of flag values and bit-based file table
//
// Note: Blizzard MPQs contain valid values even for non-existant files
// (FilePos, FileSize, CmpSize and FlagIndex)
// Note: If flags is zero, it must be in the flag table too !!!
//
// Save the byte offset
// Save the flag index
// Move the bit offset
// Write the array of flags
// Write the bit-based block table
// Free the bit array
// Create bit array for BET hashes
// Calculate 64-bit hash of the file name
// Insert the name hash to the bit array
// Move to the next file entry
// Write the array of BET hashes
// Free the bit array
// Write the size of the BET table in the MPQ
//-----------------------------------------------------------------------------
// Support for file table
// If we have HET table in the MPQ, try to find the file in HET table
// Otherwise, perform the file search in the classic hash table
// Not found
// If we have HET table in the MPQ, try to find the file in HET table
// Otherwise, perform the file search in the classic hash table
// Not found
// If we have HET table in the MPQ, try to find the file in HET table
// Otherwise, perform the file search in the classic hash table
// Not found
// For MPQs with classic hash table
// Sanity check
// If the file name is pseudo file name, free it at this point
// Only allocate new file name if it's not there yet
// Finds a free file entry. Does NOT increment table size.
// Try to find a free entry
// If that entry is free, we reuse it
//
// Note: Files with "delete marker" are not deleted.
// Don't consider them free entries
//
// Do we have a deleted entry?
// If no file entry within the existing file table is free,
// we try the reserve space after current file table
// If we reached maximum file count, we cannot add more files to the MPQ
// If the archive has classic hash table, we try to
// find the file in the hash table
// If the hash entry is already there, we reuse the file entry
// If the archive has HET table, try to use it for
// finding the file
// If still haven't found the file entry, we allocate new one
// Fill the rest of the file entry
// Allocate space for file name, if it's not there yet
// If the free file entry is at the end of the file table,
// we have to increment file table size
// If the MPQ has hash table, we have to insert the new entry into the hash table
// If the MPQ has HET table, we have to insert it to the HET table as well
// TODO: Does HET table even support locales?
// Most probably, Blizzard gave up that silly idea long ago.
// Return the file entry
// If the MPQ has classic hash table, clear the entry there
// If the MPQ has HET table, clear the entry there as well
// Clear the entry in the HET hash array
// Set the BET index to invalid index
// Free the old file name
// Allocate new file name
// Now find a hash entry for the new file name
// Try to find the hash table entry for the new file name
// Note: If this fails, we leave the MPQ in a corrupt state
// If the archive has HET table, we have to allocate HET table for the file as well
// finding the file
// Invalidate the entries for (listfile) and (attributes)
// After we are done with MPQ changes, we need to re-create them
// If the MPQ has classic hash table, clear the entry there
// If the MPQ has HET table, clear the entry there as well
// Clear the entry in the HET hash array
// Set the BET index to invalid index
// Free the file name, and set the file entry as deleted
// Invalidate the file entry
//
// If we have HET table, we cannot just get rid of the file
// Doing so would lead to empty gaps in the HET table
// We have to keep BET hash, hash index, HET index, locale, platform and file name
//
// Zero the file entry
// Now there is a chance that we created a chunk of free
// file entries at the end of the file table. We check this
// and eventually free all deleted file entries at the end
// Is that an occupied file entry?
// Can we free some entries at the end?                 
// Fix the size of the file table entry
// Note: Deleted entries in Blizzard MPQs version 4.0
// normally contain valid byte offset and length
// Invalidate the (listfile), if not done yet
// Invalidate the (attributes), if not done yet
// Remember that the MPQ has been changed and it will be necessary
// to update the tables
//-----------------------------------------------------------------------------
// Functions that loads and verify MPQ data bitmap
// Is there enough space for a MPQ bitmap?
// Try to load the data bitmap from the end of the file
// Is it a valid data bitmap?
// We assume that MPQs with data bitmap begin at position 0
// Calculate the number of extra bytes for data bitmap
// Verify the data block size
// Allocate space for the data bitmap
// Copy the bitmap header
// Read the remaining part
// If the caller asks for file completeness, check it
// Calculate the number of whole bytes and extra bits of the bitmap
// Verify the whole bytes - their value must be 0xFF
// If there are extra bits, calculate the mask
// Give the result to the caller
//-----------------------------------------------------------------------------
// Support for file tables - hash table, block table, hi-block table
// Sanity checks
// Create the hash table
// Fill it
// Set the max file count, if needed
// If the MPQ has no hash table, do nothing
// If the hash table size is zero, do nothing
// Allocate buffer for the hash table
// Compressed size of the hash table
// 
// Load the table from the MPQ, with decompression
//
// Note: We will NOT check if the hash table is properly decrypted.
// Some MPQ protectors corrupt the hash table by rewriting part of it.
// Hash table, the way how it works, allows arbitrary values for unused entries.
// 
// Return the hash table
// Only perform this check on MPQs version 1.0
// Calculate claimed block table begin and end
// If the block table end goes into that file, fix the block table end
// Fix the block table size
// Do nothing if the block table position is zero
// Do nothing if the block table size is zero
// Sanity check, enforced by LoadAnyHashTable
// Calculate sizes of both tables
// Allocate space for the block table
// Note: pHeader->dwBlockTableSize can be zero !!!
// Fill the block table with zeros
// I found a MPQ which claimed 0x200 entries in the block table,
// but the file was cut and there was only 0x1A0 entries.
// We will handle this case properly.
//
// One of the first cracked versions of Diablo I had block table unencrypted 
// StormLib does NOT support such MPQs anymore, as they are incompatible
// with compressed block table feature
//
// Load the block table
// Failed, sorry
// Defense against MPQs that claim block table to be bigger than it really is
// If the HET table position is not NULL, we expect
// both HET and BET tables to be present.
// Attempt to load the HET table (Hash Extended Table)
// If succeeded, we have to limit the maximum file count
// to the values saved in the HET table
// If loading HET table fails, we ignore the result.
// If the HET hable failed to load, it's corrupt.
// If the HET table position is not NULL, we expect
// both HET and BET tables to be present.
// Attempt to load the HET table (Hash Extended Table)
// If succeeded, we translate the BET table
// to more readable form
// If the MPQ archive is empty, don't bother trying to load anything
// Try to load HET and/or classic hash table
// Load the HASH table
// Set the maximum file count to the size of the hash table
// In case there is HET table, we have to keep the file limit
// Did at least one succeed?
// In theory, a MPQ could have bigger block table than hash table
// Sanity checks
// Load the block table
// If we don't have HET table, we build the file entries from the hash&block tables
//
// Yet another silly map protector: For each valid file,
// there are 4 items in the hash table, that appears to be valid:
//
//   a6d79af0 e61a0932 001e0000 0000770b <== Fake valid
//   a6d79af0 e61a0932 0000d761 0000dacb <== Fake valid
//   a6d79af0 e61a0932 00000000 0000002f <== Real file entry
//   a6d79af0 e61a0932 00005a4f 000093bc <== Fake valid
// 
// Fill the entry
// If the hash table entry doesn't point to the valid file item,
// we invalidate the entire hash table entry
// Free the block table
// Load the hi-block table
// Allocate space for the hi-block table
// Note: pHeader->dwBlockTableSize can be zero !!!
// Load the hi-block table. It is not encrypted, nor compressed
// Now merge the hi-block table to the file table
// Add the high file offset to the base file offset.
// We also need to swap it during the process.
// Free the hi-block table
// Set the current size of the file table
// Load the BET table from the MPQ
// Step one: Fill the indexes to the HET table
// Is the entry in the HET table occupied?
// Load the index to the BET table
// Overflow test
// Get the file entry and save HET index
// Load the BET hash
// Go through the entire BET table and convert it to the file table.
// Read the file position
// Read the file size
// Read the compressed size
// Read the flag index
//
// TODO: Locale (?)
//
// Move the current bit position
// Set the current size of the file table
// Sanity checks
// Allocate the file table with size determined before
// Fill the table with zeros
// If we have HET table, we load file table from the BET table
// Note: If BET table is corrupt or missing, we set the archive as read only
// If we have hash table, we load the file table from the block table
// Note: If block table is corrupt or missing, we set the archive as read only
// If something failed, we free the file table entry
// Assign it to the archive structure
// Saves MPQ header, hash table, block table and hi-block table.
// A table position, relative to the begin of the MPQ
// We expect this function to be called only when tables have been changed
// Find the space where the MPQ tables will be saved 
// If the MPQ has HET table, we prepare a ready-to-save version
// If the MPQ has HET table, we also must create BET table to be saved
// Now create hash table
// Create block table
// Create hi-block table, if needed
// Write the HET table, if any
// Write the BET table, if any
// Write the hash table, if we have any
// Write the block table, if we have any
// Write the hi-block table, if we have any
// Cut the MPQ
// Write the MPQ header
// Update the size of the archive
// Update the MD5 of the archive header
// Write the MPQ header to the file
// Clear the changed flag
// Cleanup and exit
/*****************************************************************************/
/* SCompression.cpp                       Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* This module serves as a bridge between StormLib code and (de)compression  */
/* functions. All (de)compression calls go (and should only go) through this */   
/* module. No system headers should be included in this module to prevent    */
/* compile-time problems.                                                    */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 01.04.03  1.00  Lad  The first version of SCompression.cpp                */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local structures
// Information about the input and output buffers for pklib
// Pointer to input data buffer
// End of the input buffer
// Pointer to output data buffer
// Pointer to output data buffer
// Prototype of the compression function
// Function doesn't return an error. A success means that the size of compressed buffer
// is lower than size of uncompressed buffer.
// [out] Pointer to the buffer where the compressed data will be stored
// [in]  Pointer to length of the buffer pointed by pbOutBuffer
// [out] Contains length of the compressed data
// [in]  Pointer to the buffer with data to compress
// [in]  Length of the buffer pointer by pbInBuffer
// [in]  Compression-method specific value. ADPCM Setups this for the following Huffman compression
// [in]  Compression specific value. ADPCM uses this. Should be set to zero.
// Prototype of the decompression function
// Returns 1 if success, 0 if failure
// [out] Pointer to the buffer where to store decompressed data
// [in]  Pointer to total size of the buffer pointed by pbOutBuffer
// [out] Contains length of the decompressed data
// [in]  Pointer to data to be decompressed  
// [in]  Length of the data to be decompressed
// Table of compression functions
// Compression mask
// Compression function
// Table of decompression functions
// Decompression bit
// Decompression function
/*****************************************************************************/
/*                                                                           */
/*  Support for Huffman compression (0x01)                                   */
/*                                                                           */
/*****************************************************************************/
// 1500F4C0
/* nCmpLevel */)
// Huffmann tree for compression
// Output stream
// Initialize output stream
// Initialize the Huffmann tree for compression
// The following code is not necessary to run, because it has no
// effect on the output data. It only clears the huffmann tree, but when
// the tree is on the stack, who cares ?
//  ht.UninitTree();
// 1500F5F0
// Initialize input stream
// Initialize the Huffmann tree for compression
// The following code is not necessary to run, because it has no
// effect on the output data. It only clears the huffmann tree, but when
// the tree is on the stack, who cares ?
//  ht.UninitTree();
/******************************************************************************/
/*                                                                            */
/*  Support for ZLIB compression (0x02)                                       */
/*                                                                            */
/******************************************************************************/
/* pCmpType */,
/* nCmpLevel */)
// Stream information for zlib
// Fill the stream structure for zlib
// Determine the proper window bits (WoW.exe build 12694)
// Initialize the compression.
// Storm.dll uses zlib version 1.1.3
// Wow.exe uses zlib version 1.2.3
// Compression level used by WoW MPQs
// Call zlib to compress the data
// Stream information for zlib
// Fill the stream structure for zlib
// Initialize the decompression structure. Storm.dll uses zlib version 1.1.3
// Call zlib to decompress the data
/******************************************************************************/
/*                                                                            */
/*  Support functions for PKWARE Data Compression Library compression (0x08)  */
/*                                                                            */
/******************************************************************************/
// Function loads data from the input buffer. Used by Pklib's "implode"
// and "explode" function as user-defined callback
// Returns number of bytes loaded
//    
//   char * buf          - Pointer to a buffer where to store loaded data
//   unsigned int * size - Max. number of bytes to read
//   void * param        - Custom pointer, parameter of implode/explode
// Check the case when not enough data available
// Load data and increment offsets
// Function for store output data. Used by Pklib's "implode" and "explode"
// as user-defined callback
//    
//   char * buf          - Pointer to data to be written
//   unsigned int * size - Number of bytes to write
//   void * param        - Custom pointer, parameter of implode/explode
// Check the case when not enough space in the output buffer
// Write output data and increments offsets
/* pCmpType */,
/* nCmpLevel */)
// Data information
// Pklib's work buffer
// Dictionary size
// Compression type
// Fill data information structure
//
// Set the dictionary size
//
// Diablo I ues fixed dictionary size of CMP_IMPLODE_DICT_SIZE3
// Starcraft uses the variable dictionary size based on algorithm below
//
// Do the compression
// Data information
// Pklib's work buffer
// Fill data information structure
// Do the decompression
// If PKLIB is unable to decompress the data, return 0;
// Give away the number of decompressed bytes
/******************************************************************************/
/*                                                                            */
/*  Support for Bzip2 compression (0x10)                                      */
/*                                                                            */
/******************************************************************************/
/* pCmpType */,
/* nCmpLevel */)
// Initialize the BZIP2 compression
// Blizzard uses 9 as blockSize100k, (0x30 as workFactor)
// Last checked on Starcraft II
// Perform the compression
// Put the stream into idle state
// Initialize the BZIP2 decompression
// Perform the decompression
// If any error there, break the loop 
// Put the stream into idle state
// If all succeeded, set the number of output bytes
// Something failed, so set number of output bytes to zero
/******************************************************************************/
/*                                                                            */
/*  Support functions for LZMA compression (0x12)                             */
/*                                                                            */
/******************************************************************************/
/* p */, UInt64 /* inSize */, UInt64 /* outSize */)
/* address can be 0 */
//
// Note: So far, I haven't seen any files compressed by LZMA.
// This code haven't been verified against code ripped from Starcraft II Beta,
// but we know that Starcraft LZMA decompression code is able to decompress
// the data compressed by StormLib.
//
/*static */ void Compress_LZMA(
/* pCmpType */,
/* nCmpLevel */)
// Fill the callbacks in structures
// Initialize properties
// Perform compression
// If we failed to compress the data
// Write "useFilter" variable. Blizzard MPQ must not use filter.
// Copy the encoded properties to the output buffer
// Copy the size of the data
// Give the size of the data to the caller
// There must be at least 0x0E bytes in the buffer
// We only accept blocks that have no filter used
// Fill the callbacks in structures
// Perform compression
/******************************************************************************/
/*                                                                            */
/*  Support functions for SPARSE compression (0x20)                           */
/*                                                                            */
/******************************************************************************/
/* pCmpType */,
/* nCmpLevel */)
/******************************************************************************/
/*                                                                            */
/*  Support for ADPCM mono compression (0x40)                                 */
/*                                                                            */
/******************************************************************************/
// Prepare the compression level for Huffmann compression,
// which will be called as next step
/******************************************************************************/
/*                                                                            */
/*  Support for ADPCM stereo compression (0x80)                               */
/*                                                                            */
/******************************************************************************/
// Prepare the compression level for Huffmann compression,
// which will be called as next step
/*****************************************************************************/
/*                                                                           */
/*   SCompImplode                                                            */
/*                                                                           */
/*****************************************************************************/
// Check for valid parameters
// Perform the compression
// If the compression was unsuccessful, copy the data as-is
/*****************************************************************************/
/*                                                                           */
/*   SCompExplode                                                            */
/*                                                                           */
/*****************************************************************************/
// Check for valid parameters
// If the input length is the same as output length, do nothing.
// If the buffers are equal, don't copy anything.
// Perform decompression
/*****************************************************************************/
/*                                                                           */
/*   SCompCompress                                                           */
/*                                                                           */
/*****************************************************************************/
// This table contains compress functions which can be applied to
// uncompressed data. Each bit means the corresponding
// compression method/function must be applied.
//
//   WAVes compression            Data compression
//   ------------------           -------------------
//   1st sector   - 0x08          0x08 (D, HF, W2, SC, D2)
//   Next sectors - 0x81          0x02 (W3)
// Sparse compression
// IMA ADPCM mono compression
// IMA ADPCM stereo compression
// Huffmann compression
// Compression with the "zlib" library
// Compression with Pkware DCL
// Compression Bzip2 library
// Array of compression functions, applied sequentially
// CompressByte for each method in the CompressFuncArray array
// Temporary storage for decompressed data
// Current output buffer
// Current input buffer
// Check for valid parameters
// Zero input length brings zero output length
// Setup the compression function array
// Fill the compressions array
// If the mask agrees, insert the compression function to the array
// If at least one of the compressions remaing unknown, return an error
// If there is at least one compression, do it
// If we need to do more than 1 compression, allocate intermediate buffer
// Get the current compression index
// Perform all compressions in the array
// Choose the proper output buffer
// Perform the (next) compression
// Note that if the compression method is unable to compress the input data block
// by at least 2 bytes, we consider it as failure and will use source data instead
// If the compression failed, we copy the input buffer as-is.
// Note that there is one extra byte at the end of the intermediate buffer, so it should be OK
// Remember that we have done at least one compression
// Now point input buffer to the output buffer
// If at least one compression succeeded, put the compression
// mask to the begin of the output buffer
// Cleanup and return
/*****************************************************************************/
/*                                                                           */
/*   SCompDecompress                                                         */
/*                                                                           */
/*****************************************************************************/
// This table contains decompress functions which can be applied to
// uncompressed data. The compression mask is stored in the first byte
// of compressed data
// Decompression with Bzip2 library
// Decompression with Pkware Data Compression Library
// Decompression with the "zlib" library
// Huffmann decompression
// IMA ADPCM stereo decompression
// IMA ADPCM mono decompression
// Sparse decompression
// Temporary storage for decompressed data
// Where to store decompressed data
// Where to store decompressed data
// Decompressions applied to the data
// Decompressions applied to the data
// Current size of the output buffer
// Current size of the input buffer
// Number of compressions to be applied
// Verify buffer sizes
// If the input length is the same as output length, do nothing.
// If the buffers are equal, don't copy anything.
// Get applied compression types and decrement data length
// Get current compressed data and length of it
// This compression function doesn't support LZMA
// Parse the compression mask
// If the mask agrees, insert the compression function to the array
// If at least one of the compressions remaing unknown, return an error
// If there is more than one compression, we have to allocate extra buffer
// Get the current compression index
// Apply all decompressions
// Perform the (next) decompression
// Get the correct output buffer
// Perform the decompression
// Switch buffers
// Put the length of the decompressed data to the output buffer
// Cleanup and return
// Verify buffer sizes
// If the outputbuffer is as big as input buffer, just copy the block
// Get the compression methods
// We only recognize a fixed set of compression methods
//
// Note: Any combination including MPQ_COMPRESSION_ADPCM_MONO,
// MPQ_COMPRESSION_ADPCM_STEREO or MPQ_COMPRESSION_HUFFMANN
// is not supported by newer MPQs.
//
// If we have to use two decompressions, allocate temporary buffer
// Apply the first decompression method
// Apply the second decompression method, if any
// Supply the output buffer size
// Free temporary buffer
/*****************************************************************************/
/* SFileAddFile.cpp                       Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* MPQ Editing functions                                                     */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 27.03.10  1.00  Lad  Splitted from SFileCreateArchiveEx.cpp               */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local structures
// 0x52494646 ("RIFF")
// Size of that chunk, in bytes
// Must be 0x57415645 ("WAVE")
// Format sub-chunk 
// 0x666d7420 ("fmt ")
// 0x16 for PCM
// 1 = PCM. Other value means some sort of compression
// Number of channels
// 8000, 44100, etc.
// SampleRate * NumChannels * BitsPerSample/8
// NumChannels * BitsPerSample/8
// 8 bits = 8, 16 bits = 16, etc.
// Followed by "data" sub-chunk (we don't care)
//-----------------------------------------------------------------------------
// Local variables
// Data compression for SFileAddFile
// Kept here for compatibility with code that was created with StormLib version < 6.50
//-----------------------------------------------------------------------------
// MPQ write data functions
// Compressed (target) data
// Data to write to the file
// ADPCM compression level (only used for wave files)
// If the caller wants ADPCM compression, we will set wave compression level to 4,
// which corresponds to medium quality
// Make sure that the caller won't overrun the previously initiated file size
// Now write all data to the file sector buffer
// Process all data. 
// Check for sector overflow
// Copy the data to the file sector
// Update the file position
// If the current sector is full, or if the file is already full,
// then write the data to the MPQ
// Set the position in the file
// Update CRC32 and MD5 of the file
// Compress the file sector, if needed
// If the file is compressed, allocate buffer for the compressed data.
// Note that we allocate buffer that is a bit longer than sector size,
// for case if the compression method performs a buffer overrun
//
// Note that both SCompImplode and SCompCompress give original buffer,
// if they are unable to comperss the data.
//
// Update sector positions
// We have to calculate sector CRC, if enabled
// Encrypt the sector, if necessary
// Write the file sector
// Call the compact callback, if any
// Update the compressed file size
// Cleanup
//-----------------------------------------------------------------------------
// Recrypts file data for file renaming
// The file must be encrypted
// File decryption key is calculated from the plain name
// Calculate both file keys
// Incase the keys are equal, don't recrypt the file
// Calculate the raw position of the file in the archive
// Allocate buffer for file transfer
// Also allocate buffer for sector offsets
// Note: Don't load sector checksums, we don't need to recrypt them
// If we have sector offsets, recrypt these as well
// Allocate secondary buffer for sectors copy
// Recrypt the array of sector offsets
// Write the recrypted array back
// Now we have to recrypt all file sectors. We do it without
// recompression, because recompression is not necessary in this case
// Last sector: If there is not enough bytes remaining in the file, cut the raw size
// Fix the raw data length if the file is compressed
// Calculate the raw file offset of the file sector
// Read the file sector
// If necessary, re-encrypt the sector
// Note: Recompression is not necessary here. Unlike encryption, 
// the compression does not depend on the position of the file in MPQ.
// Write the sector back
// Decrement number of bytes remaining
//-----------------------------------------------------------------------------
// Support functions for adding files to the MPQ
// For various file offset calculations
// File structure for newly added file
//
// Note: This is an internal function so no validity checks are done.
// It is the caller's responsibility to make sure that no invalid
// flags get to this point
//
// Sestor CRC is not allowed with single unit files
// Sector CRC is not allowed if the file is not compressed
// Fix Key is not allowed if the file is not enrypted
// If the MPQ is of version 3.0 or higher, we ignore file locale.
// This is because HET and BET tables have no known support for it
// Allocate the TMPQFile entry for newly added file
// Find a free space in the MPQ, as well as free block table entry
// Find the position where the file will be stored
// Sanity check: The MPQ must be marked as changed at this point
// When format V1, the size of the archive cannot exceed 4 GB
// Allocate file entry in the MPQ
// Check if the file already exists in the archive
// If the file exists and "replace existing" is not set, fail it
// If the file entry already contains a file
// and it is a pseudo-name, replace it
//
// At this point, the file name in file entry must be non-NULL
//
// Create key for file encryption
// Initialize the hash entry for the file
// Initialize the block table entry for the file
// Initialize the file time, CRC32 and MD5
// If the caller gave us a file time, use it.
// Call the callback, if needed
// If an error occured, remember it
// Don't bother if the caller gave us zero size
// Get pointer to the MPQ archive
// Allocate file buffers
// Allocate buffer for file sector
// Allocate patch info, if the data is patch
// Set the MPQ_FILE_PATCH_FILE flag
// Allocate the patch info
// Allocate sector offsets
// Create array of sector checksums
// Pre-save the patch info, if any
// Pre-save the sector offset table, just to reserve space in the file.
// Note that we dont need to swap the sector positions, nor encrypt the table
// at the moment, as it will be written again after writing all file sectors.
// Write the MPQ data to the file
// If it succeeded and we wrote all the file data,
// we need to re-save sector offset table
// Finish calculating CRC32
// Finish calculating MD5
// If we also have sector checksums, write them to the file
// Now write patch info
// Now write sector offsets to the file
// Write the MD5 hashes of each file chunk, if required
// If all previous operations succeeded, we can update the MPQ
// Verify if the caller wrote the file properly
// Call the user callback, if any
// Update the size of the block table
// Free the file entry in MPQ tables
// Clear the add file callback
//-----------------------------------------------------------------------------
// Adds data as file to the archive 
// Check valid parameters
// Don't allow to add file if the MPQ is open for read only
// Don't allow to add a file under pseudo-file name
// Don't allow to add any of the internal files
// Perform validity check of the MPQ flags
// Mask all unsupported flags out
// Check for valid flag combinations
// Create the file in MPQ
// Invalidate the entries for (listfile) and (attributes)
// After we are done with MPQ changes, we need to re-create them anyway
// Initiate the add file operation
// Deal with the errors
// Check the proper parameters
// Special checks for single unit files
//
// Note: Blizzard doesn't support single unit files
// that are stored as encrypted or imploded. We will allow them here,
// the calling application must ensure that such flag combination doesn't get here
//
//      if(dwFlags & MPQ_FILE_IMPLODE)
//          nError = ERROR_INVALID_PARAMETER;
//
//      if(dwFlags & MPQ_FILE_ENCRYPTED)
//          nError = ERROR_INVALID_PARAMETER;
// Lossy compression is not allowed on single unit files
// Write the data to the file
// Deal with errors
// Check the proper parameters
// Finish the file
// Deal with errors
//-----------------------------------------------------------------------------
// Adds a file to the archive 
// Compression of the first sector
// Compression of next sectors
// Check parameters
// Open added file
// Get the file size and file time
// Files bigger than 4GB cannot be added to MPQ
// Allocate data buffer for reading from the source file
// Deal with various combination of compressions
// When the compression for next blocks is set to default,
// we will copy the compression for the first sector
// If the caller wants ADPCM compression, we make sure
// that the first sector is not compressed with lossy compression
// The first compression must not be WAVE
// Initiate adding file to the MPQ
// Write the file data to the MPQ
// Get the number of bytes remaining in the source file
// Read data from the local file
// If the file being added is a WAVE file, we check number of channels
// The file must really be a wave file, otherwise it's data corruption
// Setup the compression according to number of channels
// Add the file sectors to the MPQ
// Set the next data compression
// Finish the file writing
// Cleanup and exit
// Adds a data file into the archive
// Adds a WAVE file into the archive
//
// Note to wave compression level:
// The following conversion table applied:
// High quality:   WaveCompressionLevel = -1
// Medium quality: WaveCompressionLevel = 4
// Low quality:    WaveCompressionLevel = 2
//
// Starcraft files are packed as Mono (0x41) on medium quality.
// Because this compression is not used anymore, our compression functions
// will default to WaveCompressionLevel = 4 when using ADPCM compression
// 
// Convert quality to data compression
//          WaveCompressionLevel = -1;
//          WaveCompressionLevel = 4;
//          WaveCompressionLevel = 2;
// First sector should be compressed as data
// Next sectors should be compressed as WAVE
//-----------------------------------------------------------------------------
// bool SFileRemoveFile(HANDLE hMpq, char * szFileName)
//
// This function removes a file from the archive. The file content
// remains there, only the entries in the hash table and in the block
// table are updated. 
// File entry of the file to be deleted
// Keep compiler happy
// Check the parameters
// Do not allow to remove files from MPQ open for read only
// Get hash entry belonging to this file
// Test if the file is not already deleted
// Invalidate the entries for (listfile) and (attributes)
// After we are done with MPQ changes, we need to re-create them anyway
// Mark the file entry as free
// Resolve error and exit
// Renames the file within the archive.
// Test the valid parameters
// Do not allow to rename files in MPQ open for read only
// Do not allow renaming anything to a pseudo-file name
// Do not allow to rename any of the internal files
// Also do not allow to rename any of files to an internal file
// Find the current file entry.
// Get the file entry
// Also try to find file entry for the new file.
// This verifies if we are not overwriting an existing file
// (whose name we perhaps don't know)
// Now we rename the existing file entry.
// Rename the file entry
// Now we copy the existing file entry to the new one
// If the file is encrypted, we have to re-crypt the file content
// with the new decryption key
// Recrypt the file data in the MPQ
// Update the MD5
//
// Note: MPQ_FLAG_CHANGED is set by RenameFileEntry
//
// Resolve error and return
//-----------------------------------------------------------------------------
// Sets default data compression for SFileAddFile
//-----------------------------------------------------------------------------
// Changes locale ID of a file
// Invalid handle => do nothing
// Do not allow unnamed access
// Do not allow to change locale of any internal file
// Do not allow changing file locales in MPQs version 3 or higher
// Do not allow to rename files in MPQ open for read only
// If the file already has that locale, return OK
// We have to check if the file+locale is not already there
// Set the locale and return success
// Save the new locale to the hash table, if any
// Remember that the MPQ tables have been changed
//-----------------------------------------------------------------------------
// Sets add file callback
/* hMpq */, SFILE_ADDFILE_CALLBACK aAddFileCB, void * pvData)
/*****************************************************************************/
/* SAttrFile.cpp                          Copyright (c) Ladislav Zezula 2007 */
/*---------------------------------------------------------------------------*/
/* Description:                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 12.06.04  1.00  Lad  The first version of SAttrFile.cpp                   */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local structures
// Version of the (attributes) file. Must be 100 (0x64)
// See MPQ_ATTRIBUTE_XXXX
// Followed by an array of CRC32
// Followed by an array of file times
// Followed by an array of MD5
// Followed by an array of patch bits
//-----------------------------------------------------------------------------
// Public functions (internal use by StormLib)
// File table must be initialized
// Attempt to open the "(attributes)" file.
// If it's not there, then the archive doesn't support attributes
// Remember the flags for (attributes)
// Load the content of the attributes file
// Verify the header of the (attributes) file
// Verify format of the attributes
// Load the CRC32 (if any)
// Read the array of file times
// Read the MD5 (if any)
// Note: MD5 array can be incomplete, if it's the last array in the (attributes)
// Read the patch bit for each file
// Is the appropriate bit set?
// At the moment, we assume that the patch bit is present
// in both file table and (attributes)
// 
// Note: Version 7.00 of StormLib saved the (attributes) incorrectly. 
// Sometimes, number of entries in the (attributes) was 1 item less
// than block table size. 
// If we encounter such table, we will zero all three arrays
//
// Cleanup & exit
// Now we have to check if we need patch bits in the (attributes)
// If the (attributes) is not in the file table yet,
// we have to increase the final block table size
// If "(attributes)" file exists, and it's set to 0, then remove it
// If we don't want to create file atributes, do nothing
// Check where the file entry is going to be allocated.
// If at the end of the file table, we have to increment
// the expected size of the (attributes) file.
// Calculate the size of the attributes file
// Header
// Determine the flags for (attributes)
// Create the attributes file in the MPQ
// Write all parts of the (attributes) file
// Note that we don't know what the new bit (0x08) means.
// Write the array of CRC32
// Copy from file table
// Write the array of file time
// Copy from file table
// Write the array of MD5s
// Copy from file table
// Write the array of patch bits
// Finalize the file in the archive
//-----------------------------------------------------------------------------
// Public functions
// Verify the parameters
// Verify the parameters
// Not allowed when the archive is read-only
// Set the attributes
// Verify the parameters
// Not allowed when the archive is read-only
// Attempt to open the file
// Get the file size
// Initialize the CRC32 and MD5 contexts
// Go through entire file and calculate both CRC32 and MD5
// Read data from file
// Update CRC32 and MD5
// Decrement the total size
// Update both CRC32 and MD5
// Remember that we need to save the MPQ tables
/*****************************************************************************/
/* SFileCompactArchive.cpp                Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Archive compacting function                                               */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 14.04.03  1.00  Lad  Splitted from SFileCreateArchiveEx.cpp               */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/*****************************************************************************/
/*****************************************************************************/
/* Local variables                                                           */
/*****************************************************************************/
/*****************************************************************************/
/* Local functions                                                           */
/*****************************************************************************/
// Add the listfile to the MPQ
// Notify the user
// Verify the file table
// Resolve the file key. Use plain file name for it
// Give the key to the caller
// Copy the data
// Get the proper size of data
// Read from the source stream
// Write to the target stream
// Update the progress
// Decrement the number of data to be copied
// Copies all file sectors into another archive.
// Used for calculating sector offset in the old MPQ archive
// MPQ file position in the new archive
// Size of patch header
// File key used for decryption
// File key used for encryption
// Compressed file size, including patch header
// Remember the position in the destination file
// Resolve decryption keys. Note that the file key given 
// in the TMPQFile structure also includes the key adjustment
// If we have to save patch header, do it
// Save the size of the patch info
// If we have to save sector offset table, do it.
// Encrypt the secondary sector offset table and write it to the target file
// Update compact progress
// Now we have to copy all file sectors. We do it without
// recompression, because recompression is not necessary in this case
// Fix the raw data length if the file is compressed
// Last sector: If there is not enough bytes remaining in the file, cut the raw size
// Calculate the raw file offset of the file sector
// Read the file sector
// If necessary, re-encrypt the sector
// Note: Recompression is not necessary here. Unlike encryption, 
// the compression does not depend on the position of the file in MPQ.
// Now write the sector back to the file
// Update compact progress
// Adjust byte counts
// Copy the sector CRCs, if any
// Sector CRCs are always compressed (not imploded) and unencrypted
// Update compact progress
// Size of the CRC block is also included in the compressed file size
// There might be extra data beyond sector checksum table
// Sometimes, these data are even part of sector offset table
// Examples:
// 2012 - WoW\15354\locale-enGB.MPQ:DBFilesClient\SpellLevels.dbc
// 2012 - WoW\15354\locale-enGB.MPQ:Interface\AddOns\Blizzard_AuctionUI\Blizzard_AuctionUI.xml
// Allocate space for the extra data
// Include these extra data in the compressed size
// Write the MD5's of the raw file data, if needed
// Update file position in the block table
// At this point, number of bytes written should be exactly
// the same like the compressed file size. If it isn't,
// there's something wrong (an unknown archive version, MPQ protection, ...)
// 
// Note: Diablo savegames have very weird layout, and the file "hero"
// seems to have improper compressed size. Instead of real compressed size,
// the "dwCmpSize" member of the block table entry contains
// uncompressed size of file data + size of the sector table.
// If we compact the archive, Diablo will refuse to load the game
// Seems like some sort of protection to me.
//
// Note: Some patch files in WOW patches don't count the patch header
// into compressed size
//
// Note: DO NOT update the compressed size in the file entry, no matter how bad it is.
// Walk through all files and write them to the destination MPQ archive
// Copy all the file sectors
// Only do that when the file has nonzero size
// Allocate structure for the MPQ file
// Store file entry
// Set the raw file position
// Set the file decryption key
// If the file is a patch file, load the patch header
// Allocate buffers for file sector and sector offset table
// Also allocate sector offset table and sector checksum table
// Also load sector checksums, if any
// Copy all file sectors
// Free buffers. This also sets "hf" to NULL.
// Cleanup and exit
/*****************************************************************************/
/* Public functions                                                          */
/*****************************************************************************/
/* hMpq */, SFILE_COMPACT_CALLBACK aCompactCB, void * pvData)
//-----------------------------------------------------------------------------
// Archive compacting
/* bReserved */)
// Test the valid parameters
// If the MPQ is changed at this moment, we have to flush the archive
// Create the table with file keys
// First of all, we have to check of we are able to decrypt all files.
// If not, sorry, but the archive cannot be compacted.
// Initialize the progress variables for compact callback
// Get the temporary file name and create it
// Write the data before MPQ user data (if any)
// Inform the application about the progress
// Write the MPQ user data (if any)
// At this point, we assume that the user data size is equal
// to pUserData->dwHeaderOffs.
// If this assumption doesn't work, then we have an unknown version of MPQ
// Write the MPQ header
// Remember the header size before swapping
// Update the progress
// Now copy all files
// If succeeded, switch the streams
// If all succeeded, save the MPQ tables
//
// Note: We don't recalculate position of the MPQ tables at this point.
// SaveMPQTables does it automatically.
// 
// Invalidate the compact callback
// Cleanup and return
//-----------------------------------------------------------------------------
// Changing hash table size
// Test the valid parameters
// The new limit must not be lower than the index of the last file entry in the table
// ALL file names must be known in order to be able
// to rebuild hash table size
// If the MPQ has a hash table, then we relocate the hash table
// Save parameters for the current hash table
// Allocate new hash table
// If the MPQ has HET table, allocate new one as well
// Save the original HET table
// Create new one
// Now reallocate the file table
// Save the current file table
// Create new one
// Now we have to build both classic hash table and HET table.
// Create new hash and HET entry for each file
// Copy the old file entry to the new one
// Create new entry in the hash table
// Create new entry in the HET table, if needed
// Move to the next file entry in the new table
// Mark the archive as changed
// Note: We always have to rebuild the (attributes) file due to file table change
// Revert the hash table
// Revert the HET table
// Revert the file table
// Return the result
/*****************************************************************************/
/* SFileCreateArchive.cpp                 Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* MPQ Editing functions                                                     */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 24.03.03  1.00  Lad  Splitted from SFileOpenArchive.cpp                   */
/* 08.06.10  1.00  Lad  Renamed to SFileCreateArchive.cpp                    */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local variables
//-----------------------------------------------------------------------------
// Local functions
// Prepare the naked MPQ header
// Write it to the file
//-----------------------------------------------------------------------------
// Creates a new MPQ archive.
// Fill the create structure
// File stream
// MPQ archive handle
// Position of MPQ header in the file
// Initial block table size
// Check the parameters, if they are valid
// Verify if all variables in SFILE_CREATE_MPQ are correct
// One time initialization of MPQ cryptography
// We verify if the file already exists and if it's a MPQ archive.
// If yes, we won't allow to overwrite it.
//
// At this point, we have to create the archive.
// - If the file exists, convert it to MPQ archive.
// - If the file doesn't exist, create new empty file
//
// Increment the maximum amount of files to have space
// for listfile and attributes file
// If file count is not zero, initialize the hash table size
// Retrieve the file size and round it up to 0x200 bytes
// Debug code, used for testing StormLib
//  dwBlockTableSize = dwHashTableSize * 2;
// Create the archive handle
// Fill the MPQ archive handle structure
// Setup the attributes
// Fill the MPQ header
// Fill the MPQ header
// For MPQs version 4 and higher, we set the size of raw data block
// for calculating MD5
// Write the naked MPQ header
// Remember that the (listfile) and (attributes) need to be saved
// Create initial HET table, if the caller required an MPQ format 3.0 or newer
// Create initial hash table
// Create initial file table
// Cleanup : If an error, delete all buffers and return
// Return the values
/*****************************************************************************/
/* SFileExtractFile.cpp                   Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Simple extracting utility                                                 */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 20.06.03  1.00  Lad  The first version of SFileExtractFile.cpp            */
/*****************************************************************************/
// Open the MPQ file
// Create the local file
// Copy the file's content
// dwTransferred is only set to nonzero if something has been read.
// nError can be ERROR_SUCCESS or ERROR_HANDLE_EOF
// If something has been actually read, write it
// Close the files
/*****************************************************************************/
/* SFileFindFile.cpp                      Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* A module for file searching within MPQs                                   */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 25.03.03  1.00  Lad  The first version of SFileFindFile.cpp               */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Defines
//-----------------------------------------------------------------------------
// Private structure used for file search (search handle)
// Used by searching in MPQ archives
// Handle to MPQ, where the search runs
// Table for files that have been already found
// Number of items in the search table
// Next file index to be checked
// For checking flag mask
// Search mask (variable length)
//-----------------------------------------------------------------------------
// Local functions
// When the mask is empty, it never matches
// If the wildcard contains just "*", then it always matches
// Do normal test
// If there is '?' in the wildcard, we skip one char
// If there is '*', means zero or more chars. We have to 
// find the sequence after '*'
// More stars is equal to one star
// If we found end of the wildcard, it's a match
// Determine the length of the substring in szWildCard
// Now we have to find a substring in szString,
// that matches the substring in szWildCard
// Calculate match count
// If the match count has reached substring length, we found a match
// No match, move to the next char in szString
// If we came to the end of the string, compare it to the wildcard
// If we arrived to the end of the string, it's a match
// Otherwise, continue in comparing
// Loop over all patches
// Append the number of files
// Move to the patched archive
// Return the double size of number of items
// If we are in patch MPQ, we check if patch prefix matches
// and then trim the patch prefix
// If the patch prefix doesn't fit, we pretend that the file
// was there before and it will be skipped
// Calculate the hash to the table
// The file might have been found before
// only if this is not the first MPQ being searched
// Enumerate all entries in the search table
// Get the file entry at that position
// Does the name match?
// Move to the next entry
// Put the entry to the table for later use
// Go while there are patches
// Move to the patch archive
// Prepare the prefix for the file name
// Try to find the file there
// Return the found patch entry
// Performs one MPQ search
// Start searching with base MPQ
// Now parse the file entry table in order to get all files.
// Get the length of the patch prefix (0 if none)
// Parse the file table
// Increment the next index for subsequent search
// Is it a file and not a patch file?
// Now we have to check if this file was not enumerated before
// Find a patch to this file
// Prepare the block index
// Get the file name. If it's not known, we will create pseudo-name
// Open the file by its pseudo-name.
// This also generates the file name with a proper extension
// Check the file name against the wildcard
// Fill the found entry
// Fill the filetime
// Fill the file name and plain file name
// Move to the next patch in the patch chain
// No more files found, return error
//-----------------------------------------------------------------------------
// Public functions
// Check for the valid parameters
// Include the listfile into the MPQ's internal listfile
// Note that if the listfile name is NULL, do nothing because the
// internal listfile is always included.
// Allocate the structure for MPQ search
// Perform the first search
// If the archive is patched archive, we have to create a merge table
// to prevent files being repeated
// Perform first item searching
// Cleanup
// Return the result value
// Check the parameters
// Check the parameters
/*****************************************************************************/
/* SListFile.cpp                          Copyright (c) Ladislav Zezula 2004 */
/*---------------------------------------------------------------------------*/
/* Description:                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 12.06.04  1.00  Lad  The first version of SListFile.cpp                   */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Listfile entry structure
// Size of the cache buffer
// Stormlib file handle
// File mask
// Total size of the cached file
// Position of the cache in the file
// The begin of the listfile cache
// The last character in the file cache
// Listfile cache itself
//-----------------------------------------------------------------------------
// Local functions (cache)
// If the szListFile is NULL, it means we have to open internal listfile
// Use SFILE_OPEN_ANY_LOCALE for listfile. This will allow us to load
// the listfile even if there is only non-neutral version of the listfile in the MPQ
// Open the local/internal listfile
// Remember flags for (listfile)
// Allocate cache for one file block
// Initialize the file cache
// Fill the cache
// Initialize the pointers
// Return the cache
// Reloads the cache. Returns number of characters
// that has been loaded into the cache.
// Only do something if the cache is empty
//      __TryReadBlock:
// Move the file position forward
// Get the number of bytes remaining
// Load the next data chunk to the cache
// If we didn't read anything, it might mean that the block
// of the file is not available (in case of partial MPQs).
// We stop reading the file at this point, because the rest
// of the listfile is unreliable
// Set the buffer pointers
// Skip newlines, spaces, tabs and another non-printable stuff
// If we need to reload the cache, do it
// If we found a non-whitespace character, stop
// Skip the character
// Copy the remaining characters
// If we need to reload the cache, do it now and resume copying
// If we have found a newline, stop loading
// Blizzard listfiles can also contain information about patch:
// Pass1\Files\MacOS\unconditional\user\Background Downloader.app\Contents\Info.plist~Patch(Data#frFR#base-frFR,1326)
// Copy the character
// Terminate line with zero
// If there was extra string after the file name, clear it
// Return the length of the line
//-----------------------------------------------------------------------------
// Local functions (listfile nodes)
// Adds a name into the list of all names. For each locale in the MPQ,
// one entry will be created
// If the file name is already there, does nothing.
// If we have HET table, use that one
// Allocate file name for the file entry
// If we have hash table, we use it
// Look for the first hash table entry for the file
// Go while we found something
// Is it a valid file table index ?
// Allocate file name for the file entry
// Now find the next language version of the file
// Saves the whole listfile into the MPQ.
// Allocate the table for sorting listfile
// Construct the sort table
// Note: in MPQs with multiple locale versions of the same file,
// this code causes adding multiple listfile entries.
// Since those MPQs were last time used in Starcraft,
// we leave it as it is.
// Only take existing items
// Ignore pseudo-names
// Sort the table
// Now parse the table of file names again - remove duplicates
// and count file size.
// Count the 0-th item
// Count all next items
// If the item is the same like the last one, skip it
// Determine the flags for (listfile)
// Create the listfile in the MPQ
// Add all file names
// Each name is followed by newline ("\x0D\x0A")
// Count all next items
// If the item is the same like the last one, skip it
// Create the listfile in the MPQ
// Just add "(listfile)" there
// Finalize the file in the MPQ
// Free buffers
//-----------------------------------------------------------------------------
// File functions
// Adds a listfile into the MPQ archive.
// Note that the function does not remove the 
// Add the listfile for each MPQ in the patch chain
// Load the listfile to cache
// Load the node list. Add the node for every locale in the archive
// Also, add three special files to the listfile:
// (listfile) itself, (attributes) and (signature)
// Delete the cache
// Move to the next archive in the chain
//-----------------------------------------------------------------------------
// Passing through the listfile
// Initialize the structure with zeros
// Load the listfile to cache
// Allocate file mask
// Perform file search
// Read the (next) line
// If some mask entered, check it
// Cleanup & exit
// Read the (next) line
// If some mask entered, check it
/*****************************************************************************/
/* SFileOpenArchive.cpp                       Copyright Ladislav Zezula 1999 */
/*                                                                           */
/* Author : Ladislav Zezula                                                  */
/* E-mail : ladik@zezula.net                                                 */
/* WWW    : www.zezula.net                                                   */
/*---------------------------------------------------------------------------*/
/*                       Archive functions of Storm.dll                      */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of SFileOpenArchive.cpp            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/*****************************************************************************/
/*****************************************************************************/
/* Local functions                                                           */
/*****************************************************************************/
// Test for 'RIFF', 'AVI ' or 'LIST'
// Calculate the length of the bitmap in blocks and in bytes
// Allocate the file bitmap
// Fill the structure
// Copy the file bitmap
// This function gets the right positions of the hash table and the block table.
// Check the begin of HET table
// Check the begin of BET table
// Check the begin of hash table
// Check the begin of block table
// Check the begin of hi-block table
// All OK.
/*****************************************************************************/
/* Public functions                                                          */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// SFileGetLocale and SFileSetLocale
// Set the locale for all newly opened files
//-----------------------------------------------------------------------------
// SFileOpenArchive
//
//   szFileName - MPQ archive file name to open
//   dwPriority - When SFileOpenFileEx called, this contains the search priority for searched archives
//   dwFlags    - See MPQ_OPEN_XXX in StormLib.h
//   phMpq      - Pointer to store open archive handle
// Open file stream
// Archive handle
// Size of the file
// Verify the parameters
// One time initialization of MPQ cryptography
// Open the MPQ archive file
// Initialize the stream
// Allocate the MPQhandle
// Initialize handle structure and allocate structure for MPQ header
// Remember if the archive is open for write
// Also remember if we shall check sector CRCs when reading file
// Find the offset of MPQ header within the file
// Cut the bytes available, if needed
// Read the eventual MPQ header
// There are AVI files from Warcraft III with 'MPQ' extension.
// If there is the MPQ user data signature, process it
// Ignore the MPQ user data completely if the caller wants to open the MPQ as V1.0
// Fill the user data header
// Remember the position of the user data and continue search
// There must be MPQ header signature
// Save the position where the MPQ header has been found
// Now convert the header to version 4
// Move to the next possible offset
// If we haven't found MPQ header in the file, it's an error
// Fix table positions according to format
// Dump the header
//      DumpMpqHeader(ha->pHeader);
// W3x Map Protectors use the fact that War3's Storm.dll ignores the MPQ user data,
// and probably ignores the MPQ format version as well. The trick is to
// fake MPQ format 2, with an improper hi-word position of hash table and block table
// We can overcome such protectors by forcing opening the archive as MPQ v 1.0
// Both MPQ_OPEN_NO_LISTFILE or MPQ_OPEN_NO_ATTRIBUTES trigger read only mode
// Set the size of file sector
// Verify if any of the tables doesn't start beyond the end of the file
// Check if the MPQ has data bitmap. If yes, we can verify if the MPQ is complete
// Convert the MPQ bitmap to the file bitmap
// Set the data bitmap into the file stream for additional checks
// Read the hash table. Ignore the result, as hash table is no longer required
// Read HET table. Ignore the result, as HET table is no longer required
// Now, build the file table. It will be built by combining
// the block table, BET table, hi-block table, (attributes) and (listfile).
// Verify the file table, if no kind of protection was detected
//      ULONGLONG ArchiveSize = 0;
// Parse all file entries
// If that file entry is valid, check the file position
// Get the 64-bit file position,
// relative to the begin of the file
// Begin of the file must be within range
// End of the file must be within range
// Also, we remember end of the file
//              if(RawFilePos > ArchiveSize)
//                  ArchiveSize = RawFilePos;
// Load the internal listfile and include it to the file table
// Ignore result of the operation. (listfile) is optional.
// Load the "(attributes)" file and merge it to the file table
// Ignore result of the operation. (attributes) is optional.
// Cleanup and exit
//-----------------------------------------------------------------------------
// SFileGetArchiveBitmap
//-----------------------------------------------------------------------------
// bool SFileFlushArchive(HANDLE hMpq)
//
// Saves all dirty data into MPQ archive.
// Has similar effect like SFileCloseArchive, but the archive is not closed.
// Use on clients who keep MPQ archive open even for write operations,
// and terminating without calling SFileCloseArchive might corrupt the archive.
//
// Do nothing if 'hMpq' is bad parameter
// If the (listfile) has been invalidated, save it
// If the (attributes) has been invalidated, save it
// Save HET table, BET table, hash table, block table, hi-block table
// Return the error
//-----------------------------------------------------------------------------
// bool SFileCloseArchive(HANDLE hMpq);
//
// Flush all unsaved data to the storage
// Free all memory used by MPQ archive
/*****************************************************************************/
/* SFileOpenFileEx.cpp                    Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Description :                                                             */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.99  1.00  Lad  The first version of SFileOpenFileEx.cpp             */
/*****************************************************************************/
/*****************************************************************************/
/* Local functions                                                           */
/*****************************************************************************/
// We have to convert the local file name to UNICODE, if needed
// Allocate and initialize file handle
// Pointer to patch file
// Pointer to base open file
// The highest file in the chain that is not patch file
// Keep this flag here for future updates
// First of all, try to open the original version of the file in any of the patch chain
// Construct the name of the patch file
// The file must be a base file, i.e. without MPQ_FILE_PATCH_FILE
// Move to the next file in the patch chain
// If we couldn't find the file in any of the patches, it doesn't exist
// Now keep going in the patch chain and open every patch file that is there
// Construct patch file name
// Remember the new version
// If we encountered a full replacement of the file, 
// we have to remember the highest full file
// Set current patch to base file and move on
// Now we need to free all files that are below the highest unpatched version
// Free the file below
// Move the base to the next file
// Give the updated base MPQ
/*****************************************************************************/
/* Public functions                                                          */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// SFileEnumLocales enums all locale versions within MPQ. 
// Functions fills all available language identifiers on a file into the buffer
// pointed by plcLocales. There must be enough entries to copy the localed,
// otherwise the function returns ERROR_INSUFFICIENT_BUFFER.
// Test the parameters
// Keep compiler happy
// Parse hash table entries for all locales
// Calculate the number of locales
// Test if there is enough space to copy the locales
// Enum the locales
// There must be space for 1 locale
// For nameless access, always return 1 locale
// Give the caller the total number of found locales
//-----------------------------------------------------------------------------
// SFileHasFile
//
//   hMpq          - Handle of opened MPQ archive
//   szFileName    - Name of file to look for
// Prepare the file opening
// Different processing for pseudo-names
// Walk through the MPQ and all patches
// Verify presence of the file
// Verify the file flags
// If this is patched archive, go to the patch
// Prepare the patched file name
// Not found, sorry
// Cleanup
//-----------------------------------------------------------------------------
// SFileOpenFileEx
//
//   hMpq          - Handle of opened MPQ archive
//   szFileName    - Name of file to open
//   dwSearchScope - Where to search
//   phFile        - Pointer to store opened file handle
// Don't accept NULL pointer to file handle
// Prepare the file opening
// We want to open the updated version of the file
// First of all, check the name as-is
// This open option is reserved for opening MPQ internal listfile.
// No argument validation. Tries to open file with neutral locale first,
// then any other available.
// Don't accept any other value
// Quick return if something failed
// Test if the file was not already deleted.
// Allocate file handle
// Initialize file handle
// If the MPQ has sector CRC enabled, enable if for the file
// If we know the real file name, copy it to the file entry
// If there is no file name yet, allocate it
// If the file is encrypted, we should detect the file key
// Try to auto-detect the file name
// If the file is actually a patch file, we have to load the patch file header
// Cleanup
//-----------------------------------------------------------------------------
// bool WINAPI SFileCloseFile(HANDLE hFile);
// Free the structure
/*****************************************************************************/
/* SFilePatchArchives.cpp                 Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* Description:                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 18.08.10  1.00  Lad  The first version of SFilePatchArchives.cpp          */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local structures
//-----------------------------------------------------------------------------
// Local functions
// Ensure that both names are plain names
// Patch prefix is for the Cataclysm MPQs, whose names
// are like "locale-enGB.MPQ" or "speech-enGB.MPQ"
// If the length of the prefix doesn't match, use default one
// Copy the prefix
// Cut the initial DWORD from the compressed chunk
// Pre-fill decompressed buffer with zeros
// Unpack
// Is it a repetition byte ?
// Allocate space for patch header and compressed data
// Load the patch data and decide if they are compressed or not
// Copy the patch header itself
// Load the rest of the patch
// Allocate space for compressed data
// Read the compressed patch data
// Load the rest of the header
// Get the uncompressed size of the patch
// Now decompress the patch data
// Copy the patch header
// Uncompress or copy the patch data
// Free buffers and exit
// Allocate space for new file data
// Copy the patch data as-is
// Free the old file data
// Put the new file data there
// Current position to patch
// Current source position
// Patched file size
// File size before patch
// Get pointer to the patch header
// Format of BSDIFF header corresponds to original BSDIFF, which is:
// 0000   8 bytes   signature "BSDIFF40"
// 0008   8 bytes   size of the control block
// 0010   8 bytes   size of the data block
// 0018   8 bytes   new size of the patched file
// Get pointer to the 32-bit BSDIFF control block
// The control block follows immediately after the BSDIFF header
// and consists of three 32-bit integers
// 0000   4 bytes   Length to copy from the BSDIFF data block the new file
// 0004   4 bytes   Length to copy from the BSDIFF extra block
// 0008   4 bytes   Size to increment source file offset
// Get the pointer to the data block
// Get the pointer to the extra block
// Allocate new buffer
// Now patch the file
// Sanity check
// Read the diff string to the target buffer
// Now combine the patch data with the original file
// Sanity check
// Copy the data from the extra block in BSDIFF patch
// Move the old offset
// Free the old file data
// Put the new data to the fil structure
// Read the patch header
// Verify the signatures in the patch header
// BSWAP the entire header, if needed
// Read the patch, depending on patch type
// 'COPY'
// 'BSD0'
// Verify the original file before patching
// Apply the patch
// 'COPY'
// 'BSD0'
// Verify MD5 after patch
// Verify the patched file
//-----------------------------------------------------------------------------
// Public functions (StormLib internals)
// Give the caller the patch file size
// Move to the first patch
// Now go through all patches and patch the original data
// This must be true
// Make sure that the patch data is loaded
// Apply the patch
// Move to the next patch
//-----------------------------------------------------------------------------
// Public functions
//
// Patch prefix is the path subdirectory where the patched files are within MPQ.
//
// Example 1:
// Main MPQ:  locale-enGB.MPQ
// Patch MPQ: wow-update-12694.MPQ
// File in main MPQ: DBFilesClient\Achievement.dbc
// File in patch MPQ: enGB\DBFilesClient\Achievement.dbc
// Path prefix: enGB
//
// Example 2:
// Main MPQ:  expansion1.MPQ
// Patch MPQ: wow-update-12694.MPQ
// File in main MPQ: DBFilesClient\Achievement.dbc
// File in patch MPQ: Base\DBFilesClient\Achievement.dbc
// Path prefix: Base
//
// Keep compiler happy
// Verify input parameters
// If the user didn't give the patch prefix, get default one
// Save length of the patch prefix
//
// We don't allow adding patches to archives that have been open for write
//
// Error scenario:
//
// 1) Open archive for writing
// 2) Modify or replace a file
// 3) Add patch archive to the opened MPQ
// 4) Read patched file
// 5) Now what ?
//
// Open the archive like it is normal archive
// Older WoW patches (build 13914) used to have
// several language versions in one patch file
// Those patches needed to have a path prefix
// We can distinguish such patches by not having the (patch_metadata) file
// Save the prefix for patch file names.
// Make sure that there is backslash after it
// Now add the patch archive to the list of patches to the original MPQ
// Move to the next archive
// Should never happen
// Verify input parameters
/*****************************************************************************/
/* SFileReadFile.cpp                      Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Description :                                                             */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.99  1.00  Lad  The first version of SFileReadFile.cpp               */
/* 24.03.99  1.00  Lad  Added the SFileGetFileInfo function                  */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local structures
// Required data at offset 00 (32-bits)
// Mask for data at offset 00 (32 bits). 0 = data are ignored
// Required data at offset 04 (32-bits)
// Mask for data at offset 04 (32 bits). 0 = data are ignored
// Supplied extension, if the condition is true
//-----------------------------------------------------------------------------
// Local functions
// Go through all open MPQs, including patches
// Only count files that are not patch files
// If the file is patch file and this is not primary archive, skip it
// BUGBUG: This errorneously counts non-patch files that are in both
// base MPQ and in patches, and increases the number of files by cca 50%
// Move to the next patch archive
// Check if the "hf" is a MPQ file
// Calculate the length needed
// If we have enough space, copy the file name
// Terminate the multi-string
// Calculate number of characters needed
// If we have enough space, the copy the patch chain
// Terminate the multi-string
// Give result length, terminate multi-string and return
//  hf            - MPQ File handle.
//  pbBuffer      - Pointer to target buffer to store sectors.
//  dwByteOffset  - Position of sector in the file (relative to file begin)
//  dwBytesToRead - Number of bytes to read. Must be multiplier of sector size.
//  pdwBytesRead  - Stored number of bytes loaded
// Note that dwByteOffset must be aligned to size of one sector
// Note that dwBytesToRead must be a multiplier of one sector size
// This is local function, so we won't check if that's true.
// Note that files stored in single units are processed by a separate function
// If there is not enough bytes remaining, cut dwBytesToRead
// Perform all necessary work to do with compressed files
// If the sector positions are not loaded yet, do it
// If the sector checksums are not loaded yet, load them now.
//
// Sector CRCs is plain crap feature. It is almost never present,
// often it's empty, or the end offset of sector CRCs is zero.
// We only try to load sector CRCs once, and regardless if it fails
// or not, we won't try that again for the given file.
//
// TODO: If the raw data MD5s are not loaded yet, load them now
// Only do it if the MPQ is of format 4.0
//      if(ha->pHeader->wFormatVersion >= MPQ_FORMAT_VERSION_4 && ha->pHeader->dwRawChunkSize != 0)
//      {
//          nError = AllocateRawMD5s(hf, true);
//          if(nError != ERROR_SUCCESS)
//              return nError;
//      }
// If the file is compressed, also allocate secondary buffer
// Assign the temporary buffer as target for read operation
// Calculate raw file offset where the sector(s) are stored.
// Set file pointer and read all required sectors
// Now we have to decrypt and decompress all file sectors that have been loaded
// If there is not enough bytes in the last sector,
// cut the number of bytes in this sector
// If the file is compressed, we have to adjust the raw sector size
// If the file is encrypted, we have to decrypt the sector
// If we don't know the key, try to detect it by file content
// If the file has sector CRC check turned on, perform it
// We can only check sector CRC when it's not zero
// Neither can we check it if it's 0xFFFFFFFF.
// If the sector is really compressed, decompress it.
// WARNING : Some sectors may not be compressed, it can be determined only
// by comparing uncompressed and compressed size !!!
// Is the file compressed by Blizzard's multiple compression ?
// Is the file compressed by PKWARE Data Compression Library ?
// Did the decompression fail ?
// Move pointers
// Free all used buffers
// Give the caller thenumber of bytes read
// If the file buffer is not allocated yet, do it.
// If the file is a patch file, adjust raw data offset
// If the file sector is not loaded yet, do it
// Is the file compressed?
// Allocate space for compressed data
// Load the raw (compressed, encrypted) data
// If the file is encrypted, we have to decrypt the data first
// If the file is compressed, we have to decompress it now
//
// If the file is an incremental patch, the size of compressed data
// is determined as pFileEntry->dwCmpSize - sizeof(TPatchInfo)
//
// In "wow-update-12694.MPQ" from Wow-Cataclysm BETA:
//
// File                                    CmprSize   DcmpSize DataSize Compressed?
// --------------------------------------  ---------- -------- -------- ---------------
// esES\DBFilesClient\LightSkyBox.dbc      0xBE->0xA2  0xBC     0xBC     Yes
// deDE\DBFilesClient\MountCapability.dbc  0x93->0x77  0x77     0x77     No
// 
// Is the file compressed by Blizzard's multiple compression ?
// Is the file compressed by PKWARE Data Compression Library ?
// Note: Single unit files compressed with IMPLODE are not supported by Blizzard
// Free the decompression buffer.
// The file sector is now properly loaded
// At this moment, we have the file loaded into the file buffer.
// Copy as much as the caller wants
// File position is greater or equal to file size ?
// If not enough bytes remaining in the file, cut them
// Copy the bytes
// Give the number of bytes read
// An error, sorry
// Total bytes read in all three parts
// Mask for block size, usually 0x0FFF
// File offset of the loaded sector
// Number of bytes read (temporary variable)
// If the file position is at or beyond end of file, do nothing
// If not enough bytes in the file remaining, cut them
// Compute sector position in the file
// Position in the block
// If the file sector buffer is not allocated yet, do it now
// Load the first (incomplete) file sector
// Is the file sector already loaded ?
// Load one MPQ sector into archive buffer
// Remember that the data loaded to the sector have new file offset
// Copy the data from the offset in the loaded sector to the end of the sector
// Copy data from sector buffer into target buffer
// Update pointers and byte counts
// Load the whole ("middle") sectors only if there is at least one full sector to be read
// Load all sectors to the output buffer
// Update pointers
// Read the terminating sector
// Is the file sector already loaded ?
// Load one MPQ sector into archive buffer
// Remember that the data loaded to the sector have new file offset
// Check number of bytes read
// Copy the data from the cached last sector to the caller's buffer
// Update pointers
// Store total number of bytes read to the caller
// Make sure that the patch file is loaded completely
// Load the original file and store its content to "pbOldData"
// Read the file data
// Fix error code
// Patch the file data
// Reset number of bytes read to zero
// If there is something to read, do it
// Make sure we don't copy more than file size
// Copy the appropriate amount of the file data to the caller's buffer
// Set the proper error code
// Give the result to the caller
//-----------------------------------------------------------------------------
// SFileReadFile
// Number of bytes read
// Keep compilers happy
// Check valid parameters
// If the file is local file, read the data directly from the stream
// Because stream I/O functions are designed to read
// "all or nothing", we compare file position before and after,
// and if they differ, we assume that number of bytes read
// is the difference between them
// If not all bytes have been read, then return the number
// of bytes read
// If the file is a patch file, we have to read it special way
// If the file is single unit file, redirect it to read file 
// Otherwise read it as sector based MPQ file
// Increment the file position
// Give the caller the number of bytes read
// If the read operation succeeded, but not full number of bytes was read,
// set the last error to ERROR_HANDLE_EOF
// If something failed, set the last error value
//-----------------------------------------------------------------------------
// SFileGetFileSize
// Validate the file handle before we go on
// Make sure that the variable is initialized
// If the file is patched file, we have to get the size of the last version
// Walk through the entire patch chain, take the last version
// Get the size of the currently pointed version
// Move to the next patch file in the hierarchy
// Is it a local file ?
// If opened from archive, return file size
// If the hFile is not a valid file handle, return an error.
// Get the relative point where to move from
// Now get the move offset. Note that both values form
// a signed 64-bit value (a file pointer can be moved backwards)
// Now calculate the new file pointer
// Do not allow the file pointer to go before the begin of the file
// Now apply the file pointer to the file
// Apply the new file position
// Return the new file position
// Files in MPQ can't be bigger than 4 GB.
// We don't allow to go past 4 GB
// Change the file position
// Return the new file position
//-----------------------------------------------------------------------------
// Tries to retrieve the file name
// EXE files
// EXE files
// MPQ archive header ID ('MPQ\x1A')
// WAVE header 'RIFF'
// Old "Smacker Video" files 'SMK2'
// Bink video files (new)
// PCX images used in Diablo I
// Font files used in Diablo II
// HTML '<htm'
// HTML '<HTM
// Table files
// BLP textures
// BLP textures (v2)
// MDX files
// Warcraft II maps
// GIF images 'GIF8'
// WoW ??? .m2
// ??? .dbc
// WoW pixel shaders
// JPEG image
// Default extension
// Terminator 
// MPQ File handle
// The first 4 bytes of the file
// Saved file position
// Pre-zero the output buffer
// Check valid parameters
// Only do something if the file name is not filled
// Read the first 2 DWORDs bytes from the file
// Try to guess file extension from those 2 DWORDs
// Put the file name to the file table
// Now put the file name to the file structure
//-----------------------------------------------------------------------------
// Retrieves an information about an archive or about a file within the archive
//
//  hMpqOrFile - Handle to an MPQ archive or to a file
//  dwInfoType - Information to obtain
// pvFileInfo receives the name of the archive, terminated by 0
// Size of the archive
// Max. number of files in the MPQ
// Size of the hash table
// Size of the block table
// Construct block table from file table size
// Deprecated
// If everything is OK so far, copy the information
// Is the output buffer large enough?
// Copy the data
// Give the size to the caller
// Set the last error value, if needed
/*****************************************************************************/
/* SFileVerify.cpp                        Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* MPQ files and MPQ archives verification.                                  */
/*                                                                           */
/* The MPQ signature verification has been written by Jean-Francois Roy      */
/* <bahamut@macstorm.org> and Justin Olbrantz (Quantam).                     */
/* The MPQ public keys have been created by MPQKit, using OpenSSL library.   */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 04.05.10  1.00  Lad  The first version of SFileVerify.cpp                 */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Local defines
// File offset where the hashing starts
// Begin of the excluded area (used for (signature) file)
// End of the excluded area (used for (signature) file)
// File offset where the hashing ends
// Size of the entire file
// Length of the signature
// See SIGNATURE_TYPE_XXX
//-----------------------------------------------------------------------------
// Known Blizzard public keys
// Created by Jean-Francois Roy using OpenSSL
//-----------------------------------------------------------------------------
// Local functions
// Find out the begin of the BASE64 data
// decode the base64 string
// Create RSA key
// Convert the plain name to ANSI
// Calculate begin and end of the MPQ archive
// Get the MPQ begin
// Warcraft III maps are signed from the map header to the end
// Is it a map header ?
// We will have to hash since the map header
// Get the MPQ data end. This is stored in our MPQ header,
// and it's been already prepared by SFileOpenArchive,
// Get the size of the entire file
// Calculate the range of the MPQ
// If there is "(signature)" file in the MPQ, it has a weak signature
// Get the content of the signature
// Verify the size of the signature
// We have to exclude the signature file from the digest
// Close the file
// If there is extra bytes beyond the end of the archive,
// it's the strong signature
// Read the strong signature
// Check the signature header "NGIS"
// Succeeded, but no known signature found
// Allocate buffer for creating the MPQ digest.
// Initialize the MD5 hash state
// Set the byte offset of begin of the data
// Create the digest
// Check the number of bytes remaining
// Read the next chunk 
// Move the current byte offset
// Check if the signature is within the loaded digest
// Zero the part that belongs to the signature
// Pass the buffer to the hashing function
// Move pointers
// Finalize the MD5 hash
// Convert the tail to uppercase
// Note that we don't need to terminate the string with zero
// Append the tail to the SHA1
// Allocate buffer for creating the MPQ digest.
// Initialize SHA1 state structure
// Calculate begin of data to be hashed
// Create the digest
// Check the number of bytes remaining
// Read the next chunk 
// Pass the buffer to the hashing function
// Move pointers
// Add all three known tails and generate three hashes
// Finalize the MD5 hash
// Calculated MD5 array
// MD5 array loaded from the MPQ
// Don't verify zero-sized blocks
// Get the number of data chunks to calculate MD5
// Allocate space for data chunk and for the MD5 array
// Allocate space for MD5 array
// Calculate MD5 of each data chunk
// Get the number of bytes in the chunk
// Read the data chunk
// Calculate MD5
// Move pointers and offsets
// Read the MD5 array
// Read the array of MD5
// Compare the array of MD5
// Compare the MD5
// Free memory and return result
// Calculate hash of the entire archive, skipping the (signature) file
// Import the Blizzard key in OpenSSL format
// Verify the signature
// Return the result
// Import the Blizzard key in OpenSSL format
// Verify the signature
// Free the key and return result
// Calculate SHA1 hash of the archive
// Prepare the signature for decryption
// Prepare the padded digest for comparison
// Try Blizzard Strong public key with no SHA1 tail
// Try War 3 map public key with plain file name as SHA1 tail
// Try WoW-TBC public key with "ARCHIVE" as SHA1 tail
// Try Survey public key with no SHA1 tail
// Try Starcraft II public key with no SHA1 tail
// Fix the open type for patched archives
// If we have to verify raw data MD5, do it before file open
// Parse the base MPQ and all patches
// Does the archive have support for raw MD5?
// The file has raw MD5 if the archive supports it
// Find file entry for the file
// If the file's raw MD5 doesn't match, don't bother with more checks
// Move to the next patch
// Attempt to open the file
// Get the file size
// Initialize the CRC32 and MD5 contexts
// Also turn on sector checksum verification
// Go through entire file and update both CRC32 and MD5
// Read data from file
// Update CRC32 value
// Update MD5 value
// Decrement the total size
// If the file has sector checksums, indicate it in the flags
// Check if the entire file has been read
// No point in checking CRC32 and MD5 if not
// Skip checksum checks if the file has patches
// Check CRC32 and MD5 only if there is no patches
// Check if the CRC32 matches.
// Only check the CRC32 if it is valid
// Check if MD5 matches
// Patch files have their MD5 saved in the patch info
// Only check the MD5 if it is valid
// Patched files are MD5-checked automatically
// Remember that the file couldn't be open
// If the caller required CRC32 and/or MD5, give it to him
//-----------------------------------------------------------------------------
// Public (exported) functions
// If verification failed, return zero
// Verifies raw data of the archive Only works for MPQs version 4 or newer
// Verify input parameters
// If the archive doesn't have raw data MD5, report it as OK
// If we have to verify MPQ header, do it
// Only if the header is of version 4 or newer
// Only if we have HET table
// Only if we have BET table
// Hash table is not protected by MD5
// Block table is not protected by MD5
// It is unknown if the hi-block table is protected my MD5 or not.
// Verify parameters
// Get the offset of a file
// Verifies the archive against the signature
// Verify input parameters
// Get the MPQ signature and signature type
// Verify the signature
/*****************************************************************************/
/* adpcm.cpp                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* This module contains implementation of adpcm decompression method used by */
/* Storm.dll to decompress WAVE files. Thanks to Tom Amigo for releasing     */
/* his sources.                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.03.03  1.00  Lad  Splitted from Pkware.cpp                             */
/* 20.05.03  2.00  Lad  Added compression                                    */
/* 19.11.03  2.01  Dan  Big endian handling                                  */
/*****************************************************************************/
//------------------------------------------------------------------------------
// Structures
//-----------------------------------------------------------------------------
// Tables necessary dor decompression
//----------------------------------------------------------------------------
// CompressWave
// 1500EF70
//                ECX                          EDX
// Pointer to the output buffer
// Number of bytes remaining
// Number of words remaining
//  unsigned char * pbSaveOutBuffer;        // Copy of output buffer (actually not used)
// If less than 2 bytes remain, don't decompress anything
//  pbSaveOutBuffer = pbOutBuffer;
// Weird. But it's there
// mov eax, dwInLength; cdq; sub eax, edx;
// edi
// eax
// ebx - nChannels
// ecx - pwOutPos
// 1500F030
// Switch index
// Load one word from the input stream
// ecx - nOneWord
// esi - SInt32Array2[nIndex]
// eax - nValue
// esi - SInt32Array2[nIndex]
// edx - step_table[SInt32Array2[nIndex]]
// edi - (step_table[SInt32Array1[nIndex]] >> nCmpLevel)
// edi - nIndex;
//              esi = var_1C + nTableValue;
//----------------------------------------------------------------------------
// DecompressADPCM
// 1500F230
// Output buffer
// Fill the Uint32Array2 array by channel values.
// Get the initial index
// Perform the decompression
// Switch index
// 1500F2A2: Get one byte from input buffer
// 1500F315
// 1500F2E8
// 1500F41E
// 1500F2C4
// 1500F349
// EDI
// ESI
// ECX
// EBX = nOneByte
// Store the output 16-bit value
/*****************************************************************************/
/* huffman.cpp                       Copyright (c) Ladislav Zezula 1998-2003 */
/*---------------------------------------------------------------------------*/
/* This module contains Huffmann (de)compression methods                     */
/*                                                                           */
/* Authors : Ladislav Zezula (ladik@zezula.net)                              */
/*           ShadowFlare     (BlakFlare@hotmail.com)                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of dcmp.cpp                        */
/* 03.05.03  1.00  Lad  Added compression methods                            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/*****************************************************************************/
// Special for Mac - we have to know if normal pointer greater or less
// than 0x80000000. This variable is used in the PTR_VALID and PTR_INVALID
// macros
//-----------------------------------------------------------------------------
// Methods of the THTreeItem struct
// 1501DB70
// Gets previous Huffman tree item (?)
// OLD VERSION
//  if(PTR_INT(value) < 0)
//      value = PTR_INT((item - item->next->prev));
//  return (THTreeItem *)((char *)prev + value);
// 1500F5E0
// 1500BC90
// EDX
/*
// ESI
// EDX
// ??? usually item == next->prev, so what is it ?
// Remove HTree item from the chain
// Sets the 'first' pointer
// Invalidate pointers
//-----------------------------------------------------------------------------
// TOutputStream functions
// Flush completed bytes
//-----------------------------------------------------------------------------
// TInputStream functions
// Gets one bit from input stream
// Ensure that the input stream is reloaded, if there are no bits left
// Refill the bit buffer
// Copy the bit from bit buffer to the variable
// Gets 7 bits from the stream. DOES NOT remove the bits from input stream
// If there is not enough bits to get the value,
// we have to add 8 more bits from the input buffer
// Return the first available 7 bits. DO NOT remove them from the input stream
// Gets the whole byte from the input stream.
// If there is not enough bits to get the value,
// we have to add 8 more bits from the input buffer
// Return the lowest 8 its
// If there is not enough bits in the buffer,
// we have to add 8 more bits from the input buffer
// Skip the remaining bits
//-----------------------------------------------------------------------------
// Functions for huffmann tree items
// Inserts item into the tree (?)
// EDI - next to the first item
// ESI - prev to the first item
// Pointer to previous item
// Pointer to the next item
// The same code like in RemoveItem(item);
// If the first item already has next one
// 150083C1
// Remove the item from the tree
// Invalidate 'prev' and 'next' pointer
// EDX - If the second item is not entered,
// take the first tree item
// Switch the two items
// item2->next (Pointer to pointer to first)
// Set the first item
// Insert as the last item
// Set next item (or pointer to pointer to first item)
// Set prev item (or last item in the tree)
// Usually NULL
// Prev item to the second (or last tree item)
// Next after last item
//              next2 = (THTreeItem *)(unsigned long)((unsigned char *)item2 - (unsigned char *)(item2->next->prev));
//          prev2 = (THTreeItem *)((char *)prev2 + (unsigned long)next2);// ???
// Set the next/last item
//-----------------------------------------------------------------------------
// THuffmannTree class functions
// We have to check if the "this" pointer is less than zero
// Clear links for all the items in the tree
// Clear all TQDecompress items. Do this only if preparing for decompression
// Builds Huffman tree. Called with the first 8 bits loaded from input stream
// [ESP+10] - The greatest character found in table
// [ESP+14] - Pointer to Huffman tree item pointer array
// [ESP+1C] - Pointer to unsigned char in Table1502A630
// egcs in linux doesn't like multiple for loops without an explicit i
// Loop while pointer has a valid value
// ESI - Last entry
// EAX
// ESI->next
// EDI = &offs3054
// [EDI+4]
// EAX
// Clear all pointers in HTree item array
// Greatest character found init to zero.
// Pointer to current entry in HTree item pointer array
// Ensure we have low 8 bits only
// EDI also
// Item to be created
// Skip all the bytes which are zero.
// If not valid pointer, take the first available item in the array
// Insert this item as the top of the tree
// Invalidate child and parent
// Store pointer into pointer array
// Store counter
// Store byte value
// Find the first item which has byte value greater than current one byte
// EDI - Pointer to the last item
// 15006AF7
// 15006AFB
// 15006B09
// 15006B15
// 15006B1F
// 15006B4A
// EDI
// 15006B59
// ESI
// 15006B89
// 15006BAA
// EDI - last item (first child to item
// EBP
// ESI
// 15006BB8
// 15006BE3
// 15006BF3
//EDX = child2->byteValue + child1->byteValue;
//EAX = child1->byteValue;
//ECX = maxByte;                        // The greatest character (0xFF usually)
// 0x02
// Prev item in the
// EAX = item->byteValue;
// EDI
// 15006C2D
// The first item changed
// First->prev changed to negative value
// 15006C62
// Set item with 0x100 byte value
// Set item with 0x17 byte value
// Changed prev of item with
// 15006C7B
// 15006C88
/*
// ESI
// EBX
// EAX
// Prepare the first item to insert to the tree
// If item has any next item, remove it from the chain
// EAX
// 150068E9
// 150068F6
// Copy item index
// Copy item byte value
// Set parent to last item
// Insert item into item pointer array
// Prepare the second item to insert into the tree
// 1500692E
// EAX
// 1500694C
// 15006968
// 1500696E
// 15006993
// Pass through all previous which have its value greater than byteValue
// EBX
// 150069AC
// 150069B2
// Switch pItem2 with item
// 150069D0
// Switch parents of pItem1 and pItem2
// 150069ED
// Switch parents of pItem1 and pItem3
// EDX
// EAX
// esi
// ecx = pFirst->next;
// edi = pItem305C;
// ecx
// edi
// eax
// edx
// ebx
// 1500E920
// Store the compression type into output buffer
// Flush completed bytes
// ecx
// eax
// Store the loaded byte into output stream
// Flush the whole byte(s)
// 1500EB62
// 1500EB98
// 1500EB9D
// 1500EBAF
// for(; nInLength != 0; nInLength--)
// 1500EBB8
// 1500EBE6
// 1500EBEF
// Flush the remaining bits
// Decompression using Huffman tree (1500E450)
// 8 bits loaded from input stream
// 7 bits loaded from input stream
// Test the output length. Must not be NULL.
// Get the compression type from the input stream
// Build the Huffman tree
// Security check: If we are at the end of the input buffer,
// it means that the data is corrupt
// Get 7 bits from input stream
// Try to use quick decompression. Check TQDecompress array for corresponding item.
// If found, ise the result byte instead.
// If there is a quick-pass possible (ebx)
// If we can use quick decompress, use it.
// Move down by one level
// If current bit is set, move to previous
// If we are at 7th bit, save current HTree item.
// Walk until tree has no deeper level
// Huffman tree needs to be modified
// Table for (de)compression. Every compression type has 258 entries
// Data for compression type 0x00
// Data for compression type 0x01
// Data for compression type 0x02
// Data for compression type 0x03
// Data for compression type 0x04
// Data for compression type 0x05
// Data for compression type 0x06
// Data for compression type 0x07
// Data for compression type 0x08
/*****************************************************************************/
/* huffman.cpp                       Copyright (c) Ladislav Zezula 1998-2003 */
/*---------------------------------------------------------------------------*/
/* This module contains Huffmann (de)compression methods                     */
/*                                                                           */
/* Authors : Ladislav Zezula (ladik@zezula.net)                              */
/*           ShadowFlare     (BlakFlare@hotmail.com)                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of dcmp.cpp                        */
/* 03.05.03  1.00  Lad  Added compression methods                            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Methods of the THTreeItem struct
// 1501DB70
// Gets previous Huffman tree item (?)
// 1500F5E0
// 1500BC90
// EDX
//-----------------------------------------------------------------------------
// TOutputStream functions
// Flush completed bytes
//-----------------------------------------------------------------------------
// TInputStream functions
// Gets one bit from input stream
// Ensure that the input stream is reloaded, if there are no bits left
// Refill the bit buffer
// Copy the bit from bit buffer to the variable
// Gets 7 bits from the stream. DOES NOT remove the bits from input stream
// If there is not enough bits to get the value,
// we have to add 8 more bits from the input buffer
// Return the first available 7 bits. DO NOT remove them from the input stream
// Gets the whole byte from the input stream.
// If there is not enough bits to get the value,
// we have to add 8 more bits from the input buffer
// Return the lowest 8 its
// If there is not enough bits in the buffer,
// we have to add 8 more bits from the input buffer
// Skip the remaining bits
//-----------------------------------------------------------------------------
// Functions for huffmann tree items
// Inserts item into the tree (?)
// EDI - next to the first item
// ESI - prev to the first item
// Pointer to previous item
// Pointer to the next item
// The same code like in RemoveItem(item);
// If the first item already has next one
// 150083C1
// Remove the item from the tree
// Invalidate 'prev' and 'next' pointer
// EDX - If the second item is not entered,
// take the first tree item
// Switch the two items
// item2->next (Pointer to pointer to first)
// Set the first item
// Insert as the last item
// Set next item (or pointer to pointer to first item)
// Set prev item (or last item in the tree)
// Usually NULL
// Prev item to the second (or last tree item)
// Next after last item
// Set the next/last item
//-----------------------------------------------------------------------------
// THuffmannTree class functions
// Clear links for all the items in the tree
// Clear all TQDecompress items. Do this only if preparing for decompression
// Builds Huffman tree. Called with the first 8 bits loaded from input stream
// [ESP+10] - The greatest character found in table
// [ESP+14] - Pointer to Huffman tree item pointer array
// [ESP+1C] - Pointer to unsigned char in Table1502A630
// egcs in linux doesn't like multiple for loops without an explicit i
// Loop while pointer has a valid value
// ESI - Last entry
// EAX
// ESI->next
// EDI = &offs3054
// [EDI+4]
// EAX
// Clear all pointers in HTree item array
// Greatest character found init to zero.
// Pointer to current entry in HTree item pointer array
// Ensure we have low 8 bits only
// EDI also
// Item to be created
// Skip all the bytes which are zero.
// If not valid pointer, take the first available item in the array
// Insert this item as the top of the tree
// Invalidate child and parent
// Store pointer into pointer array
// Store counter
// Store byte value
// Find the first item which has byte value greater than current one byte
// EDI - Pointer to the last item
// 15006AF7
// 15006AFB
// 15006B09
// 15006B15
// 15006B1F
// 15006B4A
// EDI
// 15006B59
// ESI
// 15006B89
// 15006BAA
// EDI - last item (first child to item
// EBP
// ESI
// 15006BB8
// 15006BE3
// 15006BF3
//EDX = child2->byteValue + child1->byteValue;
//EAX = child1->byteValue;
//ECX = maxByte;                        // The greatest character (0xFF usually)
// 0x02
// Prev item in the
// EAX = item->byteValue;
// EDI
// 15006C2D
// The first item changed
// First->prev changed to negative value
// 15006C62
// Set item with 0x100 byte value
// Set item with 0x17 byte value
// Changed prev of item with
// 15006C7B
// 15006C88
// EDX
// EAX
// esi
// ecx = pFirst->next;
// edi = pItem305C;
// ecx
// edi
// eax
// edx
// ebx
// 1500E920
// Store the compression type into output buffer
// Flush completed bytes
// ecx
// eax
// Store the loaded byte into output stream
// Flush the whole byte(s)
// 1500EB62
// 1500EB98
// 1500EB9D
// 1500EBAF
// for(; nInLength != 0; nInLength--)
// 1500EBB8
// 1500EBE6
// 1500EBEF
// Flush the remaining bits
// Decompression using Huffman tree (1500E450)
// 8 bits loaded from input stream
// 7 bits loaded from input stream
// Test the output length. Must not be NULL.
// Get the compression type from the input stream
// Build the Huffman tree
// Security check: If we are at the end of the input buffer,
// it means that the data are corrupt.
// Get 7 bits from input stream
// Try to use quick decompression. Check TQDecompress array for corresponding item.
// If found, ise the result byte instead.
// If there is a quick-pass possible (ebx)
// If we can use quick decompress, use it.
// Move down by one level
// If current bit is set, move to previous
// If we are at 7th bit, save current HTree item.
// Walk until tree has no deeper level
// Huffman tree needs to be modified
// Table for (de)compression. Every compression type has 258 entries
// Data for compression type 0x00
// Data for compression type 0x01
// Data for compression type 0x02
// Data for compression type 0x03
// Data for compression type 0x04
// Data for compression type 0x05
// Data for compression type 0x06
// Data for compression type 0x07
// Data for compression type 0x08
/*****************************************************************************/
/* huffman.cpp                       Copyright (c) Ladislav Zezula 1998-2003 */
/*---------------------------------------------------------------------------*/
/* This module contains Huffmann (de)compression methods                     */
/*                                                                           */
/* Authors : Ladislav Zezula (ladik.zezula.net)                              */
/*           ShadowFlare     (BlakFlare@hotmail.com)                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of dcmp.cpp                        */
/* 03.05.03  1.00  Lad  Added compression methods                            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// Public functions
// There must be at least 4 bytes of free space in the output buffer now
// Put the original data length (in little endian)
// If there is at least 3 bytes in the input buffer, do this loop
// Reset the zero count and frontal pointer
// Count number of zeros
// Were there at least 3 zeros before? If yes, we need to flush the data
// Get number of nonzeros that we found so far and flush them
// Process blocks that are longer than 0x81 nonzero bytes
// Verify if we still have enough space in output buffer
// Put marker that means "0x80 of nonzeros"
// Adjust counter of nonzeros and both pointers
// BUGBUG: The following code will be triggered if the NumberOfNonZeros
// was 0x81 before. It will copy just one byte. This seems like a bug to me,
// but since I want StormLib to be exact like Blizzard code is, I will keep
// it that way here
// Verify if we still have enough space in output buffer
// Put marker that means "1 nonzero byte"
// Adjust counter of nonzeros and both pointers
// If there is 1 nonzero or more, put the block
// Verify if we still have enough space in output buffer
// Put marker that means "Several nonzero bytes"
// Adjust pointers
// Verify if we still have enough space in output buffer
// Put marker that means "1 nonzero byte"
// Adjust pointers
// Now flush all zero bytes
// Do we have at least 2 bytes in the output buffer ?
// Put marker that means "0x82 zeros"
// Adjust zero counter and input pointer
// If we got more than 0x82 zeros, flush 3 of them now
// Do we have at least 2 bytes in the output buffer ?
// Put marker that means "0x03 zeros"
// Adjust zero counter and input pointer
// Is there at least three zeros ?
// Do we have at least 2 bytes in the output buffer ?
// Put marker that means "Several zeros"
// Adjust pointer
// Flush last three bytes
// Get number of bytes remaining
// Not enough space in the output buffer ==> exit
// Terminate with a marker that means "0x80 of nonzeros"
// Adjust pointer
// Is there are more chars in the input buffer
// If the compression will not compress it by even 1 byte, do nothing
// Terminate with a chunk that means "0x82 of zeros"
// Out the length of the output buffer
// Don't decompress anything that is shorter than 5 bytes
// Get the 32-bits from the input stream
// Verify the size of the stream against the output buffer size
// Put the output size to the buffer
// Process the input buffer
// Get (next) byte from the stream
// If highest bit, it means that that normal data follow
// Increment output buffer pointer
/*****************************************************************************/
/* Storm.cpp                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* This is just a dummy module for building import library for Storm.dll     */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.04.03  1.00  Lad  The first version of Storm.cpp                       */
/*****************************************************************************/
/*****************************************************************************/
/* StormLibTest.cpp                       Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Test module for StormLib                                                  */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 25.03.03  1.00  Lad  The first version of StormLibTest.cpp                */
/*****************************************************************************/
// Don't use StormLib.lib
// 'XXX' : unreferenced local function has been removed
//------------------------------------------------------------------------------
// Defines
// Unicode MPQ names
/* Czech    */ static const wchar_t szUnicodeName1[] = {0x010C, 0x0065, 0x0073, 0x006B, 0x00FD, _T('.'), _T('m'), _T('p'), _T('q'), 0};
/* Russian  */ static const wchar_t szUnicodeName2[] = {0x0420, 0x0443, 0x0441, 0x0441, 0x043A, 0x0438, 0x0439, _T('.'), _T('m'), _T('p'), _T('q'), 0};
/* Greece   */ static const wchar_t szUnicodeName3[] = {0x03B5, 0x03BB, 0x03BB, 0x03B7, 0x03BD, 0x03B9, 0x03BA, 0x03AC, _T('.'), _T('m'), _T('p'), _T('q'), 0};
/* Chinese  */ static const wchar_t szUnicodeName4[] = {0x65E5, 0x672C, 0x8A9E, _T('.'), _T('m'), _T('p'), _T('q'), 0};
/* Japanese */ static const wchar_t szUnicodeName5[] = {0x7B80, 0x4F53, 0x4E2D, 0x6587, _T('.'), _T('m'), _T('p'), _T('q'), 0};
/* Arabic */   static const wchar_t szUnicodeName6[] = {0x0627, 0x0644, 0x0639, 0x0639, 0x0631, 0x0628, 0x064A, 0x0629, _T('.'), _T('m'), _T('p'), _T('q'), 0};
//-----------------------------------------------------------------------------
// Constants
//  Compression          Encryption             Fixed key           Single Unit            Sector CRC
//-----------------------------------------------------------------------------
// Local testing functions
// PLATFORM_WINDOWS
// Convert ANSI string to TCHAR
// Copy directory name
// Add separator
// Copy file name
// Terminate the string
/* lpParam */, DWORD dwWork, ULONGLONG BytesDone, ULONGLONG TotalBytes)
// If there are no bytes to put, we will generate new byte and length
// A short sequence of zeros
// A long sequence of zeros
// A short sequence of non-zeros
// A long sequence of non-zeros
// A short random data
// A long random data
// A single random byte
// Generate random byte, if needed
// Put next byte to the output buffer
// Number of bytes read (Storm.dll)
// Number of bytes read (StormLib)
// Result from Storm.dll
// Result from StormLib
// Allocate buffers
// Read the file's content by both methods and compare the result
// Test the number of bytes read
// No more bytes ==> OK
// Test the content
// Random read version
/* szFileName */, HANDLE hFile1, HANDLE hFile2, DWORD dwBlockSize)
// File size (Storm.dll)
// File size (StormLib)
// Number of bytes read (Storm.dll)
// Number of bytes read (StormLib)
// Result from Storm.dll
// Result from StormLib
// Test the file size
// Also test negative seek
// Allocate buffers
// Set the file pointer
// Read the file's content by both methods and compare the result
// Test the number of bytes read
// Test the content
//-----------------------------------------------------------------------------
// Opening local file
//-----------------------------------------------------------------------------
// Partial file reading
// Open the partial file
// Get the size of the stream
// Read the last 0x7000 bytes
// Read the last 0x100 bytes
// Read 0x100 bytes from position (FileSize - 0xFF)
//-----------------------------------------------------------------------------
// Compare PKLIB decompression
//-----------------------------------------------------------------------------
// Compare LZMA decompression
// Compressed by our code
// Compressed by Blizzard's code
// Decompressed by our code
// Decompressed by Blizzard's code
// Allocate buffers
// Must allocate twice blocks due to probable bug in Storm.dll.
// Storm.dll corrupts stack when uncompresses data with PKWARE DCL
// and no compression occurs.
// Generate random data sector
// Compress the sector by both methods
//          Compress_LZMA((char *)pbCompressed1, &nCmpLength1, (char *)pbOriginalData, nSectorSize, 0, 0);
// Only test decompression when the compression actually succeeded
// Decompress both data
//              Decompress_LZMA((char *)pbDecompressed1, &nDcmpLength1, (char *)pbCompressed1, nCmpLength1);
// Compare the length of the output data
// Compare the output
// Check for data overflow
// Compare the decompressed data against original data
// Cleanup
// PLATFORM_WINDOWS
//-----------------------------------------------------------------------------
// Compression method test
// Allocate buffers
// Generate random data sector
// Compress the sector
//          SCompImplode((char *)pbCompressed, &nCompressedLength, (char *)pbOriginal, nOriginalLength);
// When the method was unable to compress data,
// the compressed data must be identical to original data
// Uncompress the sector
//          SCompExplode((char *)pbDecompressed, &nDecompressedLength, (char *)pbCompressed, nCompressedLength);
// Check the decompressed length against original length
// Check decompressed block against original block
// Cleanup
//  const char * szFileName2 = "items\\map\\mapz_deleted.cel";
//  HANDLE hFile2 = NULL;
/*
// Load the index to the BET table
// Load the index to the BET table
// Verify the bits
// Verify the raw data in the archive
// Verify the archive
// Try to open a file
// Dummy read from the file
/*
// Open the archive
// Compact the archive
// Open the archive
/*
// Handle of created archive 
// Create the new file
// Write some data
// Well, now create the MPQ archive
// Add the same file multiple times
// Add FileTest.exe
// Delete a file in the middle of the file table
// Try to decrement max file count
// Add ZeroSize.txt (1)
// Add ZeroSize.txt (1)
// Test rename function
// Compact the archive
//  if(nError == ERROR_SUCCESS)
//      SFileCompactArchive(hMpq);
// Test changing hash table size
// Try to reopen the archive
// Handle of created archive 
// Add the file there
// Add the same file 10 times
// Convert the plain name to ANSI
// Add the file to MPQ
// random memory data
// Create an mpq file for testing
// Handle of existing archive
// Handle of created archive 
// If no listfile or an empty one, use NULL
// Create the new file
// Write some data
// Open the existing MPQ archive
// Well, now create the MPQ archive
// Copy all files from one archive to another
// Create the local file name
// Delete the added file
// Find the next file
// Close the search handle
// Close both archives
// Open the primary MPQ
// Add all patches
// Now search all files
// Now try to open patched version of a file
// Now try to open patched version of "Achievement.dbc"
// Verify of the patched version is correct
// Get the patch chain
// Get the size of the full patched file
// Allocate space for the full file
//"), GetPlainFileNameA(szFileName));
// Close handles
// Handle of the first archive
// Handle of the second archive
// If no listfile or an empty one, use NULL
// Open the first MPQ archive
// Open the second MPQ archive
// Compare the header
// Find all files in the first archive and compare them
//          printf("%s           \r", sf.cFileName);
// Open the first file
// Get the TMPQFile pointers
// Compare the file sizes
//              if(!CompareArchivedFilesRR(sf.cFileName, hFile1, hFile2, dwBlockSize))
//                  printf("Different file data: %s\n", sf.cFileName);
// Close both files
// Find the next file
// Close the find handle
// Close both archives
//-----------------------------------------------------------------------------
// Searching all known MPQs
// Get the file extension
// Only search defined extensions
// Try to open the MPQ
// Initiate search
// Begin search
// Eliminate "." and ".."
// Construct the full path
// If it a directory?
//-----------------------------------------------------------------------------
// Main
// 
// defined(_MSC_VER) && defined(_DEBUG)
//  FileStream_OpenEncrypted(_T("e:\\Multimedia\\MPQs\\2010 - Starcraft II\\Installer UI 2 deDE.MPQE"));
// Mix the random number generator
//  srand(GetTickCount());
// Test structure sizes
//  if(nError == ERROR_SUCCESS)
//      nError = TestStructureSizes();
//  if(nError == ERROR_SUCCESS)
//      nError = TestOpenLocalFile("C:\\autoexec.bat");
// Test reading partial file
//  if(nError == ERROR_SUCCESS)
//      nError = TestPartFileRead(MAKE_PATH("2009 - PartialMPQs/patch.MPQ.part"));
//  if(nError == ERROR_SUCCESS)
//      nError = ComparePklibCompressions();
// Test LZMA compression method against the code ripped from Starcraft II
//  if(nError == ERROR_SUCCESS)
//      nError = CompareLzmaCompressions(MPQ_SECTOR_SIZE);
// Test compression methods
//  if(nError == ERROR_SUCCESS)
//      nError = TestSectorCompress(MPQ_SECTOR_SIZE);
// Test the archive open and close
//  if(nError == ERROR_SUCCESS)
//      nError = TestArchiveOpenAndClose(_T("d:\\Install\\Blizzard\\Diablo III\\Diablo-III-8370-enGB-Installer\\Installer Tome 1.MPQE"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("2011 - WoW BETA/wow-update-13202.MPQ"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("2002 - Warcraft III/ProtectedMap_HashTable_FakeValid.w3x"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("2010 - Starcraft II/Installer Tome 1 enGB.MPQE"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("1997 - Diablo I/DIABDAT_orig.MPQ"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("2004 - World of Warcraft/SoundCache-enUS.MPQ"));
//      nError = TestArchiveOpenAndClose(MAKE_PATH("smpq.mpq "));
//  if(nError == ERROR_SUCCESS)
//      nError = TestFindFiles(MAKE_PATH("2002 - Warcraft III/HumanEd.mpq"));
// Create a big MPQ archive
//  if(nError == ERROR_SUCCESS)
//      nError = TestCreateArchive_PaliRoharBug(MAKE_PATH("Test.mpq"));
//      nError = TestCreateArchive(MAKE_PATH("Test.mpq"));
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName1);
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName2);
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName3);
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName4);
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName5);
//      nError = TestCreateArchive((const TCHAR*)szUnicodeName6);
//  if(nError == ERROR_SUCCESS)
//      nError = TestAddFilesToMpq(MAKE_PATH("wow-update-13202.MPQ"),
//                                 "c:\\Tools32\\Arj32.exe",
//                                 "c:\\Tools32\\autoruns.chm",
//                                 "c:\\Tools32\\CPUEater.exe",
//                                 "c:\\Tools32\\dumpbin.exe",
//                                 "c:\\Tools32\\editbin.exe",
//                                 "c:\\Tools32\\fsg.ini",
//                                 "c:\\Tools32\\hiew8.ini",
//                                 "c:\\Tools32\\ida.bat",
//                                 "c:\\Tools32\\mp3.ini",
//                                 NULL);
//  if(nError == ERROR_SUCCESS)
//      nError = TestCreateArchiveFromMemory(MAKE_PATH("Test-leak.mpq"));
//  if(nError == ERROR_SUCCESS)
//      nError = TestFileReadAndWrite(MAKE_PATH("2002 - Warcraft III/(10)DustwallowKeys.w3m"), "war3map.j");
// Verify the archive signature
//  if(nError == ERROR_SUCCESS)
//      nError = TestSignatureVerify(MAKE_PATH("1998 - Starcraft/BW-1152.exe"));
//      nError = TestSignatureVerify(MAKE_PATH("2002 - Warcraft III/(10)DustwallowKeys.w3m"));
//      nError = TestSignatureVerify(MAKE_PATH("2002 - Warcraft III/War3TFT_121b_English.exe"));
//      nError = TestSignatureVerify(MAKE_PATH("2004 - World of Warcraft/WoW-2.3.3.7799-to-2.4.0.8089-enUS-patch.exe"));
//      nError = TestSignatureVerify(MAKE_PATH("2004 - World of Warcraft/standalone.MPQ"));
// Compact the archive        
//  if(nError == ERROR_SUCCESS)
//      nError = TestMpqCompacting(MAKE_PATH("wow-update-base-14333.MPQ"));
// Create copy of the archive, appending some bytes before the MPQ header
//  if(nError == ERROR_SUCCESS)
//      nError = TestCreateArchiveCopy(MAKE_PATH("PartialMPQs/interface.MPQ.part"), MAKE_PATH("PartialMPQs/interface-copy.MPQ.part"), NULL);
/*
//  if(nError == ERROR_SUCCESS)
//      nError = TestSearchAllArchives(MAKE_PATH("*"));
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/**
// [-20, 19], default is 0
// Setting it to true stops the server
// Accessor to the authserver database
/// Handle authserver's termination signals
/// Print out the usage string for this program on the console.
/// Launch the auth server
// Command line parsing to get the configuration file name
//www.projectskyfire.org/> \n");
///- Check the version of the configuration file
// authserver PID file creation
// Initialize the database connection
// Get the list of realms for the server
// Launch the listening network socket
// Initialize the signal handlers
// Register authservers's signal handlers
///- Handle affinity for multiple processors and process priority
// Windows
// remove non accessible processors
// Linux
// maximum counter for next ping
// Wait for termination signal
// dont move this outside the loop, the reactor will modify it
// Close the Database Pool and library
/// Initialize connection to the database
// NOTE: While authserver is singlethreaded you should keep synch_threads == 1. Increasing it is just silly since only 1 will be used ever.
// Enables DB appenders when realm is set.
/// Close the connection to the database
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Last version MoP
// terminator
// terminator
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Base32 implementation
// Copyright 2010 Google Inc.
// Author: Markus Gutschke
// Licensed under the Apache License, Version 2.0
// Deal with commonly mistyped characters
// Look up one base32 digit
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Load the realm list from the database
// Get the content of the realmlist table in the database
// Create new if not exist or update existed
// Append port to IP address.
// maybe disabled or updated recently
// Clears Realm list
// Get the content of the realmlist table in the database
// Circle through results and add them to the realm map
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// GCC have alternative #pragma pack(N) syntax and old gcc version not support pack(push, N), also any gcc version not support it at some paltform
// 0x00-0x04
// XFER_INITIATE
// strlen(fileName);
// fileName[fileNameLen]
// file size (bytes)
// MD5
// GCC have alternative #pragma pack() syntax and old gcc version not support pack(pop), also any gcc version not support it at some paltform
// Launch a thread to transfer a patch to the client
// Caches MD5 hash of client patches present on the server
// Holds the MD5 hash of client patches present on the server
// Constructor - set the N and g values for SRP6
// Close patch file descriptor before leaving
// Accept the connection
// Read the packet from the client
// Circle through known commands and call the correct command handler
// Report unknown packets in the error log
// Make the SRP6 calculation from hash in dB
// In case of leading zeros in the rI hash, restore them
// No SQL injection (username escaped)
// Logon Challenge command handler
// Read the first 4 bytes (header) to get the length of the remaining of the packet
//No big fear of memory outage (size is int16, i.e. < 65536)
// Read the remaining of the packet
// BigEndian code, nop in little endian case
// size already converted
// Restore string order as its byte order is reversed
// Verify that this IP is not in the ip_banned table
// Get the account details from the account table
// No SQL injection (prepared statement)
// If the IP is 'locked', check that the player comes indeed from the correct IP address
// if ip is locked
//set expired bans to inactive
// If the account is banned, reject the logon attempt
// Get the password from the account table, upper it, and make the SRP6 calculation
// Don't calculate (v, s) if there are already some in the database
// multiply with 2 since bytes are stored as hexstring
// Fill the response packet with the result
// B may be calculated < 32B so we force minimal length to 32B
// 32 bytes
// 32 bytes
// Check if token is used
// security flags (0x0...0x04)
// PIN input
// 16 bytes hash?
// Matrix input
// Security token input
//no account
// Logon Proof command handler
// Read the packet
// If the client has no valid version
// Check if we have the appropriate patch on the disk
// Continue the SRP6 calculation based on data received from the client
// SRP safeguard: abort if A == 0
// Check if SRP6 results match (password is correct), else send an error
// Update the sessionkey, last_ip, last login time and reset number of failed logins in the account table for this account
// No SQL injection (escaped user name) and IP address as received by socket
// Finish SRP6 and send the final result to the client
// Check auth token
// 2.x and 3.x clients
// Accountflags. 0x01 = GM, 0x08 = Trial, 0x00800000 = Pro pass (arena tournament)
// SurveyId
//Increment number of failed logins by one and if it reaches the limit temporarily ban that account or IP
// Reconnect Challenge command handler
// Read the first 4 bytes (header) to get the length of the remaining of the packet
// No big fear of memory outage (size is int16, i.e. < 65536)
// Read the remaining of the packet
// Stop if the account is not found
// Reinitialize build, expansion and the account securitylevel
// Restore string order as its byte order is reversed
// Sending response
// 16 bytes random
// 16 bytes zeros
// Reconnect Proof command handler
// Read the packet
// Sending response
// 2 bytes zeros
// Attempt to send best address for client
// Try guessing if realm is also connected locally
// Assume that user connecting from the machine that authserver is located on
// has all realms available in his local network
// Check if connecting client is in the same network
// Return external IP
// Realm List command handler
// Get the user id (else close the connection)
// No SQL injection (prepared statement)
// Update realm list if need
// Circle through realms in the RealmList and construct the return packet (including # of user characters in each realm)
// don't work with realms which not compatible with the client
// No SQL injection. id of realm is controlled by the database.
// tell the client what build the realm is for
// We don't need the port number from which client connects with but the realm's port
// realm type
// only 2.x and 3.x clients
// if 1, then realm locked
// RealmFlags
// realm category
// 2.x and 3.x clients
// unk, may be realm number/id?
// 1.12.1 and 1.12.2 clients
// 2.x and 3.x clients
// 1.12.1 and 1.12.2 clients
// make a ByteBuffer which stores the RealmList's size
// only 2.x and 3.x clients
// append RealmList's size buffer
// append realms in the realmlist
// Resume patch transfer
// Check packet length and patch existence
// FIXME: pPatch is never used
// Launch a PatcherRunnable thread starting at given patch file offset
// Cancel patch transfer
// Close and delete the socket
//clear input buffer
// Accept patch transfer
// Check packet length and patch existence
// Launch a PatcherRunnable thread, starting at the beginning of the patch file
// clear input buffer
// Send content of patch file to the client
// Preload MD5 hashes of existing patch files on server
/*.mpq", &fil);
// no patches were found
// Calculate and store MD5 hash for a given patch file
// Try to open the patch file
// Calculate the MD5 hash
// Store the result in the internal patch hash map
// Get cached MD5 hash for a given patch file
// Launch the patch hashing mechanism on object creation
// Empty and delete the patch map on termination
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// delete RealmSocketObject must never be called from our code.
// Register with ACE Reactor
// reactor takes care of the socket from now on
// Try to send the message directly.
// MSG_NOSIGNAL
// Blocking signal
// Error happened
// Can this happen ?
// return bytes transmitted
// Try to send it directly.
// fall down
// As opposed to WorldSocket::handle_close, we don't need locks here.
// EOF
// return 1 in case there is more data to read from OS
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// create space for the first node
// dummy leaf
//tempTree.add(0);
// seed bbox
// seed subdivide function
// write leaf node
// calculate extents
// perform quick consistency checks
//UI.printError(Module.ACCEL, "Reached tree area in error - discarding node with: %d objects", right - left + 1);
// find longest axis
// partition L/R subsets
// save this for later
// stay left
// move to the right most
// check for empty space
// node box is too big compare to space occupied by primitives?
// allocate child
// write bvh2 clip node
// update nodebox and recurse
// ensure we are making progress in the subdivision
// all left
// we are stuck here - create a leaf
// keep looping on left half
// all right
// we are stuck here - create a leaf
// keep looping on right half
// we are actually splitting stuff
// second time through - lets create the previous split
// since it produced empty space
// allocate child node
// create a node with a left child
// write leaf node
// create a node with a right child
// write leaf node
// count stats for the unused leaf
// now we keep going as we are, with a new nodeIndex:
// compute index of child nodes
// allocate left node
// allocate right node
// write leaf node
// prepare L/R child boxes
// recurse
// = new uint32[nObjects];
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//#include "QuadTree.h"
//#include "RegularGrid.h"
// namespace
/*
/*, public Intersectable*/
// valid map coords should *never ever* produce float overflow, but this would produce NaNs too
// prevent NaN values which can cause BIH intersection to enter infinite loop
// direction with length of 1
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ######################## MMapFactory ########################
// our global singleton copy
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ######################## MMapManager ########################
// by now we should not have maps loaded
// if we had, tiles in MMapData->mmapLoadedTiles, their actual data is lost!
// we already have this map loaded?
// load and init dtNavMesh - read parameters from file
// store inside our map list
/*basePath*/, uint32 mapId, int32 x, int32 y)
// make sure the mmap is loaded and ready to load tiles
// get this mmap data
// check if we already have this tile loaded
// load this tile :: mmaps/MMMM_XX_YY.mmtile
// read header
// memory allocated for data is now managed by detour, and will be deallocated when the tile is removed
/*DT_TILE_FREE_DATA*/, 0, &tileRef)))
// load this tile :: mmaps/MMMM_XX_YY.mmtile
// Not all tiles have phased versions, don't flood this msg
//SF_LOG_DEBUG("phase", "MMAP:LoadTile: Could not open mmtile file '%s'", fileName);
// read header
// only a few tiles have terrain swaps, do not write error for them
// map existence already checked when loading
// check if we have this map loaded
// file may not exist, therefore not loaded
// check if we have this tile loaded
// file may not exist, therefore not loaded
// unload, and mark as non loaded
// this is technically a memory leak
// if the grid is later reloaded, dtNavMesh::addTile will return error but no extra memory is used
// we cannot recover from this error - assert out
// file may not exist, therefore not loaded
// unload all tiles from given map
// check if we have this map loaded
// file may not exist, therefore not loaded
// allocate mesh query
// remove old tile
// restore base tile
// header xy is based on the swap map's tile set, wich doesn't have all the same tiles as root map, so copy the xy from the orignal header
// the removed tile's data
// remove old tile
// store the removed data first time, this is the origonal, non-phased tile
// add new swapped tile
// swap not active
// remove swap
// for each of the calling unit's terrain swaps
// for each of the terrain swap's xy tiles
// swap not active
// add swap
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//===============================================
// just return the instance
// should be taken from config ... Please change if you like :-)
//===============================================
// delete all internal data structures
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// move to MapTree too?
// load one tile (internal use only)
/**
/**
// No height
// z is not touched by convertPositionToInternalRep(), so just copy
// entry from LiquidType.dbc
//! Critical section, thread safe access to iLoadedModelFiles
//! Critical section, thread safe access to iLoadedModelFiles
// namespace VMAP
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//=========================================================
//tilefilename << std::setw(2) << tileX << '_' << std::setw(2) << tileY << ".vmtile";
//=========================================================
//! Make sure to call unloadMap() to unregister acquired model references before destroying
//=========================================================
/**
//=========================================================
// return false if distance is over max float, in case of cheater teleporting to the end of the universe
// valid map coords should *never ever* produce float overflow, but this would produce NaNs too
// prevent NaN values which can cause BIH intersection to enter infinite loop
// direction with length of 1
//=========================================================
/**
// valid map coords should *never ever* produce float overflow, but this would produce NaNs too
// prevent NaN values which can cause BIH intersection to enter infinite loop
// direction with length of 1
//=========================================================
// direction with length of 1
//=========================================================
/// @todo check magic number when implemented...
//=========================================================
// global model spawns
// only non-tiled maps have them, and if so exactly one (so far at least...)
// assume that global model always is the first and only tree value (could be improved...)
//=========================================================
//=========================================================
// currently, core creates grids for all maps, whether it has terrain tiles or not
// so we need "fake" tile loads to know when we can unload map geometry
// read model spawns
// acquire model instance
// update tree
//=========================================================
// file associated with tile
// read model spawns
// release model instance
// update tree
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//=================================================================
//mkdir(iDestDir);
//init();
//delete iCoordModelMapping;
// export Map data
// build global map tree
// M2 models don't have a bound set in WDT/ADT placement data, i still think they're not used for LoS at all on retail
// WMO maps and terrain maps use different origin, so we need to adapt :/
/// @todo remove extractor hack and uncomment below line:
//entry->second.iPos += Vector3(533.33333f*32, 533.33333f*32, 0.f);
// ===> possibly move this code to StaticMapTree class
// write map tree file
//general info
// only maps without terrain (tiles) have global WMO
// Nodes
// global map spawns (WDT), if any (most instances)
// <====
// write map tile files, similar to ADT files, only with extra BSP tree node info
// WDT spawn, saved as tile 65/65 currently...
// file header
// write number of tile spawns
// write tile spawns
// MapTree nodes to update when loading tile:
// break; //test, extract only first map; TODO: remvoe this line
// add an object models, listed in temp_gameobject_models file
// export objects
//cleanup:
// read mapID, tileX, tileY, Flags, adtID, ID, Pos, Rot, Scale, Bound_lo, Bound_hi, name
// EoF...
// should be only one for M2 files...
//=================================================================
// write WorldModel
//std::cout << "readRawFile2: '" << pModelFilename << "' tris: " << nElements << " nodes: " << nNodes << std::endl;
// EOF flag is only set after failed reading attempt
// temporary use defines to simplify read/check code (close file and return at fail)
// will this ever be used? what is it good for anyway??
// indexes for each branch (not used jet)
// ---- indexes
// ---- vectors
// ----- liquid
// we have to read one int. This is needed during the export and we have to skip it here
/// rf will be freed inside Read if the function had any errors.
// drop of temporary use defines
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// EOF flag is only set after failed reading attempt
// ignore models with no bounds
//flags = VMAP::MOD_M2;
//adtId = 0;
//ID = 0;
// transform bounding box:
// test:
// child bounds are defined in object space:
// ignore models with no bounds
// transform bounding box:
// test:
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//std::cout << "<object not loaded>\n";
//            std::cout << "Ray does not hit '" << name << "'\n";
//        std::cout << "Ray crosses bound of '" << name << "'\n";
/*        std::cout << "ray from:" << pRay.origin().x << ", " << pRay.origin().y << ", " << pRay.origin().z
// child bounds are defined in object space:
// M2 files don't contain area info, only WMO files
// child bounds are defined in object space:
// Transform back to world space. Note that:
// Mat * vec == vec * Mat.transpose()
// and for rotation matrices: Mat.inverse() == Mat.transpose()
// M2 files don't contain area info, only WMO files
// child bounds are defined in object space:
// Transform back to world space. Note that:
// Mat * vec == vec * Mat.transpose()
// and for rotation matrices: Mat.inverse() == Mat.transpose()
// hm...could it be handled automatically with zDist at intersection?
// child bounds are defined in object space:
//Vector3 zDirModel = iInvRot * Vector3(0.f, 0.f, -1.f);
// calculate world height (zDist in model coords):
// assume WMO not tilted (wouldn't make much sense anyway)
// EoF?
// only WMOs have bound in MPQ, only available after computation
// file names should never be that long, must be file error
// only WMOs have bound in MPQ, only available after computation
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// See RTR2 ch. 13.7 for the algorithm.
// Determinant is ill-conditioned; abort early
// We hit the plane of the m_geometry, but outside the m_geometry
// We hit the plane of the triangle, but outside the triangle
// This is a new hit, closer than the previous one
/* baryCoord[0] = 1.0 - u - v;
// This hit is after the previous hit, so ignore it
// ===================== WmoLiquid ==================================
// use assignment operator...
// check if tile shall be used for liquid level
// checking for 0x08 *might* be enough, but disabled tiles always are 0x?F:
// (dx, dy) coordinates inside tile, in [0, 1]^2
/* Tesselate tile to two triangles (not sure if client does it exactly like this)
// case (a)
// case (b)
// ===================== GroupModel ==================================
// write vertices
// models without (collision) geometry end here, unsure if they are useful
// write triangle mesh
// write mesh BIH
// write liquid data
// read vertices
// models without (collision) geometry end here, unsure if they are useful
// read triangle mesh
// read mesh BIH
// write liquid data
/*pStopAtFirstHit*/)
// ===================== WorldModel ==================================
// small M2 workaround, maybe better make separate class with virtual intersection funcs
// in any case, there's no need to use a bound tree if we only have one submodel
//float pVol = prims[entry].GetBound().volume();
//if (pVol < minVol)
//{
/* if (prims[entry].iBound.contains(point)) */
//minVol = pVol;
//hit = prims + entry;
//}
//std::cout << "trying to intersect '" << prims[entry].name << "'\n";
// write group models
//chunkSize = sizeof(uint32)+ sizeof(GroupModel)*count;
//if (result && fwrite(&chunkSize, sizeof(uint32), 1, wf) != 1) result = false;
// write group BIH
// Ignore the added magic header
// read group models
//if (fread(&chunkSize, sizeof(uint32), 1, rf) != 1) result = false;
//if (result && fread(&groupModels[0], sizeof(GroupModel), count, rf) != count) result = false;
// read group BIH
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// username's too long
// username does already exist
// Enforce saving, otherwise AddGroup can fail
// everything's fine
// Check if accounts exists
// Obtain accounts characters
// Kick if player is online
// mark session to remove at next session list update
// logout player without waiting next session list update
// no need to update realm characters
// table realm specific but common for all characters of account for realm
// Check if accounts exists
// account doesn't exist
// account doesn't exist
// account doesn't exist
// We simply return false for a non-existing email
// check character count
// Delete old security level from DB
// Add new security level
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* = 0*/)
// Check if permission Id exists
// Check if already added in denied list
// Already added?
// Do not save to db when loading data from DB (realmId = 0)
/* = 0*/)
// Check if permission Id exists
// Check if already added in granted list
// Already added?
// Do not save to db when loading data from DB (realmId = 0)
/* = 0*/)
// Check if it's present in any list
// Do not save to db when loading data from DB (realmId = 0)
// Load account permissions (granted and denied) that affect current realm
// Add default permissions
// Force calculation of permissions
// Get the list of granted permissions
// remove the permission from original list
// insert into the final list (expanded list)
// add all linked permissions (that are not already expanded) to the list of permissions to be checked
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// namespace Skyfire
// only hardcoded list
// only Children's Week achievements
// only Children's Week achievements
// not check correctness node indexes
/*= 0*/) const
/*= 0*/) const
// disable for gamemasters with GM-mode enabled
// don't update already completed criteria if not forced or achievement already complete
/*type*/, uint64 /*miscValue1*/, uint64 /*miscValue2*/, bool /*evenIfCriteriaComplete*/)
// Not needed
/*lowguid*/)
/*trans*/)
// must not happen: cleanup at server startup in sAchievementMgr->LoadCompletedAchievements()
// title achievement rewards are retroactive
// we will remove not existed criteria for all characters
// must not happen: cleanup at server startup in sAchievementMgr->LoadCompletedAchievements()
// we will remove not existed criteria for all guilds
// Unk
// re-fill data
// Don't send for achievements with ACHIEVEMENT_FLAG_HIDDEN
// broadcast realm first reached
// GuildAchievement
//29
// if player is in world he can tell his friends about new achievement
// does not notify player ingame
// broadcast realm first reached
// GuildAchievement
//29
/*entry*/, CriteriaProgress const* /*progress*/, uint32 /*timeElapsed*/, bool /*timedCompleted*/) const
// this are some flags, 1 is for keeping the counter at 0 in client
// time elapsed in seconds
// unk
/*timeElapsed*/, bool /*timedCompleted*/) const
//will send response to criteria progress request
// for accessing every byte individually
// unknown date
// unknown date
// last update time (not packed!)
/**
// suppress sending packets
// ach_cr_id, is_dungeon, is_raid, is_heroic_dungeon
// Helper function to avoid having to specialize template for a 800 line long function
/**
/*= 0*/, uint64 miscValue2 /*= 0*/, uint64 miscValue3 /*= 0*/, Unit const* unit /*= NULL*/, Player* referencePlayer /*= NULL*/)
// disable for gamemasters with GM-mode enabled
// Lua_GetGuildLevelEnabled() is checked in achievement UI to display guild tab
// requirements not found in the dbc
// std. case: increment at 1
/* FIXME: for online player only currently */
// This also behaves like ACHIEVEMENT_CRITERIA_TYPE_WIN_RATED_ARENA
// std case: increment at miscValue1
/* FIXME: for online player only currently */
// std case: high value at miscValue1
/* FIXME: for online player only currently */
// Login case.
// reset if player missed one day.
// 1st time. Start count.
// last progress is older than 2 days. Player missed 1 day => Restart count.
// last progress is between 1 and 2 days. => 1st time of the day.
// last progress is within the day before the reset => Already counted today.
// miscValue1 is the ingame fallheight*100 as stored in dbc
/*
// login case
// login case
// FIXME: not triggered in code as result, need to implement
// Not implemented yet :(
// check again the completeness for SUMM and REQ COUNT achievements,
// as they don't depend on the completed criteria but on the sum of the progress of each individual criteria
// counter can never complete
// someone on this realm has already completed that achievement
// handle all statistic-only criteria here
// counter can never complete
// already completed and stored
// counter can never complete
// for achievement with referenced achievement criterias get from referenced and counter from self
// For SUMM achievements, we have to count the progress of each criteria of the achievement.
// Oddly, the target count is NOT contained in the achievement, but in each individual criteria
// for counters, field4 contains the main count requirement
// Default case - need complete all or
// found an uncompleted criteria, but DONT return false yet - there might be a completed criteria with ACHIEVEMENT_CRITERIA_COMPLETE_FLAG_ALL
// completed as have req. count of completed criterias
// all criterias completed requirement
// Don't allow to cheat - doing timed achievements without timer active
// not create record for 0 counter but allow it for timed achievements
// we will need to send 0 progress to client to start the timer
// avoid overflow
// not update (not mark as changed) if counter will have same value
// set the date to the latest update.
// @todo : Fix me
// Client expects this in packet
// Remove the timer, we wont need it anymore
// Time is up, remove timer and reset progress
/*type*/, uint32 /*entry*/, uint32 /*timeLost = 0*/)
/* = 0 */)
// Start the timer
// and at client too
// We don't have timer for this achievement
// remove progress
// Remove the timer
// disable for gamemasters with GM-mode enabled
// don't insert for ACHIEVEMENT_FLAG_REALM_FIRST_KILL since otherwise only the first group member would reach that achievement
/// @todo where do set this instead?
// reward items and titles if any
// no rewards
// titles
//! Currently there's only one achievement that deals with gender-specific titles.
//! Since no common attributes were found, (not even in titleRewardFlags field)
//! we explicitly check by ID. Maybe in the future we could move the achievement_reward
//! condition fields to the condition system.
// mail
// subject and text
// save new item before send
// save for prevent lost at next mail load, if send fail then item will deleted
// item
/*receiver*/) const
/*
// timer 1
// criteria id
// timer 2
// criteria date
// achievement Id
// achievement date
/*achievementId = 0 */) const
// criteria progress flags
// timer 1
// timer 2
//RealmID
//RealmID
/*= 0*/) const
/*AchievementEntry const* achievement = sAchievementStore.LookupEntry(achievementId);
// send empty packet
// send empty packet
//will send response to criteria progress request
// send empty packet
// unknown date
// unknown date
// last update time (not packed!)
/* for (uint32 i = 0; i < MAX_CRITERIA_REQUIREMENTS; ++i)
// update at loading or specific skill update
// update at loading or specific skill update
// skip wrong arena achievements, if not achievIdByArenaSlot then normal total death counter
/*bool notfit = false;
/*
// search case
// if raid accepted (ignore difficulty)
// for
// dungeon in normal mode accepted
// for
// dungeon in heroic mode accepted
// for
// for
//FIXME: work only for instances where max == min for players
// if miscValues != 0, it contains the questID.
// login case.
// miscValue1 = itemId - miscValue2 = count of item loot
// miscValue3 = loot_type (note: 0 = LOOT_CORPSE and then it ignored)
// array have 0 only in empty tail
// miscValue1 = itemid miscValue2 = itemSlot
// miscValue1 = itemid miscValue2 = diced value
// map specific case (BG in fact) expected player targeted damage/heal
// miscValue1 = item_id
// 4
// 5
// 6
// 7
// 8
// 10
// 11
// 14
// miscValue1 is itemid
// 15
// miscValue1 is itemid
// 17
// 18
// 20
// 25
// 26
// 27
// 28
// 29
// 30
// 32
// 38
// miscValue1 is title's bit index
// 39
// 40
// 41
// 46
//==========================================================
// Once Bitten, Twice Shy (10 player) - Icecrown Citadel
// Correct map requirement (currently has Ulduar)
// need for reload case
// not empty
// this will allocate empty data set storage
// add real data only for not NONE data types
// counting data by and data types
// Remove non existent achievements from all characters
// need for reload case
//                                               0      1        2        3     4       5        6
// must be title or mail at least
//check mail data before item for report including wrong item case
// need for reload case
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Anonymous namespace ensures file scope of all the stuff inside it, even
// if you add something more to this namespace somewhere else.
// List of saved addons (in DB).
// Namespace
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//Disable CreatureAI when charmed
/*apply*/)
//me->IsAIEnabled = !apply;*/
/*= NULL*/)
/*= NULL*/, float maxRangeToNearestTarget /* = 50.0f*/)
//use IsInstance instead of Instanceable, in case battlegrounds will be instantiated
// Intended duplicated check, the code above this should select a victim
// If it can't find a suitable attack target then we should error out.
/* Causes certain things to never leave the threat list (Priest Lightwell, etc):
// scripts does not take care about MoveInLineOfSight loops
// MoveInLineOfSight can be called inside another MoveInLineOfSight and cause stack overflow
// non-combat pets should just stand there and look good;)
//else if (who->GetVictim() && me->IsFriendlyTo(who)
//    && me->IsWithinDistInMap(who, sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS))
//    && me->CanStartAttack(who->GetVictim(), true)) /// @todo if we use true, it will not attack it when it arrives
//    me->GetMotionMaster()->MoveChase(who->GetVictim());
// otherwise me will be in evade mode forever
// Required to prevent attacking creatures that are evading and cause them to reenter combat
// Does not apply to MoveFollow
// use the same sequence of addtoworld, aireset may remove all summons!
/*void CreatureAI::AttackedBy(Unit* attacker)
// don't remove vehicle auras, passengers aren't supposed to drop off the vehicle
// don't remove clone caster on evade (to be verified)
// sometimes bosses stuck in combat?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//scriptname in db
// AIname in db
// select by NPC flags
// select by permit check
// select NullCreatureAI if not another cases
/* if (mv_factory == NULL)
// scriptname in db
//future goAI types go here
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// have some hostile factions, it will be selected by IsHostileTo check at MoveInLineOfSight
/*diff*/)
// some day we will delete these useless things
/*creature*/)
/*creature*/)
/*creature*/)
/*creature*/)
/////////////////
//CasterAI
/////////////////
//////////////
//ArcherAI
//////////////
/*diff*/)
//////////////
//TurretAI
//////////////
/*who*/) const
/// @todo use one function to replace it
/*diff*/)
//////////////
//VehicleAI
//////////////
//NOTE: VehicleAI::UpdateAI runs even while the vehicle is mounted
//was used and has conditions
//needs reset
//in use again
//reset timer
//check other pessanger in next tick
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//GameObjectAI::GameObjectAI(GameObject* g) : go(g) { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Remove ChaseMovementGenerator from MotionMaster stack list, and add HomeMovementGenerator instead
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*diff*/)
/*u*/)
// We died while possessed, disable our loot
// We killed a creature, disable victim's loot
/*done_by*/, uint32&)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// This is needed for charmed creatures, as once their target was reset other effects can trigger threat
// Should stop pet's attack button from flashing
// UpdateAllies self set update timer
// is only necessary to stop casting, the pet must not exit combat
// Check before attacking to prevent pets from leaving stay position
// Every update we need to check targets only in certain cases
// Aggressive - Allow auto select if owner or pet don't have a target
// Stay - Only pick from pet or owner targets / attackers so targets won't run by
//   while chasing our owner. Don't do auto select.
// All other cases (ie: defensive) - Targets are assigned by AttackedBy(), OwnerAttackedBy(), OwnerAttacked(), etc.
// Autocast (casted only in combat or persistent spells in any state)
// check spell cooldown
// Check if we're in combat or commanded to attack
// Some spells can target enemy or friendly (DK Ghoul's Leap)
// Check for enemy first (pet then owner)
// Pets must only jump to target
// No enemy, check friendly
//only buff targets that are in combat, unless the spell can only be cast while out of combat
// No valid targets at all
//found units to cast on to
// deleted cached Spell objects
// Update speed as needed to prevent dropping too far behind and despawning
// update friendly targets every 10 seconds, lesser checks increase performance
//only pet and owner/not in group->ok
//owner is in group; group members filled in already (no raid -> subgroupcount = whole count)
//add group
//remove group
// Called from Unit::Kill() in case where pet or owner kills something
// if owner killed this victim, pet may still be attacking something else
// Clear target just in case. May help problem where health / focus / mana
// regen gets stuck. Also resets attack command.
// Can't use _stopAttack() because that activates movement handlers and ignores
// next target selection
// Stops the pet's 'Attack' button from flashing
// Before returning to owner, see if there are more things to attack
// Return
// Overrides Unit::AttackStart to correctly evaluate Pet states
// Check all pet states to decide if we can attack this target
// Only chase if not commanded to stay or if stay but commanded to attack
// Called when owner takes damage. This function helps keep pets from running off
//  simply due to owner gaining aggro.
// Passive pets don't do anything
// Prevent pet from disengaging from current target
// Continue to evaluate and attack if necessary
// Called when owner attacks something. Allows defensive pets to know
//  that they need to assist
// Target might be NULL if called from spell with invalid cast targets
// Passive pets don't do anything
// Prevent pet from disengaging from current target
// Continue to evaluate and attack if necessary
// Provides next target selection after current target death.
// This function should only be called internally by the AI
// Targets are not evaluated here for being valid targets, that is done in _CanAttack()
// The parameter: allowAutoSelect lets us disable aggressive pet auto targeting for certain situations
// Passive pets don't do next target selection
// Check pet attackers first so we don't drag a bunch of targets to the owner
// Not sure why we wouldn't have an owner but just in case...
// Check owner attackers
// Check owner victim
// 3.0.2 - Pets now start attacking their owners victim in defensive mode as soon as the hunter does
// Neither pet or owner had a target and aggressive pets can pick any target
// To prevent aggressive pets from chain selecting targets and running off, we
//  only select a random target if certain conditions are met.
// Default - no valid targets
// Handles moving the pet back to stay or owner
// Prevent activating movement when under control of spells
// such as "Eyes of the Beast"
// Return to previous position where stay was clicked
// COMMAND_FOLLOW
// Handles attack with or without chase and also resets flags
// for next update / creature kill
// Play sound to let the player know the pet is attacking something it picked on its own
// This needs to be reset after other flags are cleared
// For passive pets commanded to attack so they will use spells
// (Stay && ((Aggressive || Defensive) && In Melee Range)))
// Receives notification when pet reaches stay or follow owner
// Pet is returning to where stay was clicked. data should be
// pet's GUIDLow since we set that as the waypoint ID
// If data is owner's GUIDLow then we've reached follow point,
// otherwise we're probably chasing a creature
// Evaluates wether a pet can attack a specific target based on CommandState, ReactState and other flags
// IMPORTANT: The order in which things are checked is important, be careful if you add or remove checks
// Hmmm...
// Clear target to prevent getting stuck on dead targets
// Passive - passive pets can attack if told to
// CC - mobs under crowd control can be attacked if owner commanded
// Returning - pets ignore attacks only if owner clicked follow
// Stay - can attack if target is within range or commanded to
//  Pets attacking something (or chasing) should only switch targets if owner tells them to
// Check if our owner selected this target and clicked "attack"
// Follow
// default, though we shouldn't ever get here
/*EMOTE_ONESHOT_ROAR*/EMOTE_ONESHOT_OMNICAST_GHOUL);
/*EMOTE_ONESHOT_COWER*/EMOTE_STATE_STUN);
// Quick access to set all flags to FALSE
// Called when pet takes damage. This function helps keep pets from running off
//  simply due to gaining aggro.
// Passive pets don't do anything
// Prevent pet from disengaging from current target
// Continue to evaluate and attack if necessary
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*diff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*who*/) { }
/*diff*/)
// Search spell
// Get spell range
// SPELLMOD_RANGE not applied in this place just because not existence range mods for attacking totems
// pointer to appropriate target if found any
// Search victim if no, not attackable, or out of range, or friendly (possible in case duel end)
// If have target
// remember
// attack
// client change orientation by self
/*victim*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//Make sure our attack is ready and we aren't currently casting before checking distance
//Enable PlayerAI when charmed
/*diff*/)
//kill self if charm aura has infinite duration
// copypasta from Spell::CheckRange
// Because of lag, we can not check too strictly here.
// skip this check if min_range = 0
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Spell summary for ScriptedAI::SelectSpell
/*diff*/)
//Check if we have a current target
//No target so we can't cast
//Silenced so we can't cast
//Using the extended script system we first create a list of viable spells
//Check if each spell is viable(set it to null if not)
//This spell doesn't exist
// Targets and Effects checked first as most used restrictions
//Check the spell targets if specified
//Check the type of spell if we are looking for a specific spell type
//Check for school if specified
//Check for spell mechanic if specified
//Make sure that the spell uses the requested amount of power
//Continue if we don't have the mana to actually cast this spell
//Check if the spell meets our range requirements
//Check if our target is in range
//All good so lets add it to the spell list
//We got our usable spells so now lets randomly pick one
/*= EQUIP_NO_CHANGE*/, int32 offHand /*= EQUIP_NO_CHANGE*/, int32 ranged /*= EQUIP_NO_CHANGE*/)
// Hacklike storage used for misc creatures that are expected to evade of outside of a certain area.
// It is assumed the information is found elswehere and can be handled by the core. So far no luck finding such information/way to extract it.
// broodlord (not move down stairs)
// void reaver (calculate from center of room)
// jan'alai (calculate by Z)
// sartharion (calculate box)
// For most of creatures that certain area is their home area.
// BossAI - for instanced bosses
// bosses do not respawn, check only on enter combat
// WorldBossAI - for non-instanced bosses
// SD2 grid searchers.
/*= true*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//see followerAI
//experimental (unknown) flag not present
//not a player
//never attack friendly
//too far away and no free sight?
//already fighting someone?
/*killer*/)
//add a small delay before going to first waypoint, normal in near all cases
//Waypoint Updating
//End of the line
//Check if player or any member of his group is within range
/*diff*/)
//Combat start position reached, continue waypoint movement
//Make sure that we are still on the right waypoint
//Call WP function
/*
// We got possessed in the middle of being escorted, store the point
// where we left off to come back to when possess is removed
// i think SD2 no longer uses this function
/*PointMovement wp;
/// @todo get rid of this many variables passed in function.
/* = true*/, bool run /* = false */, uint64 playerGUID /* = 0 */, Quest const* quest /* = NULL */, bool instantRespawn /* = false */, bool canLoopPath /* = false */, bool resetWaypoints /* = true */)
// sd2 never adds wp in script, but tc does
//set variables
//disable npcflags
//Set initial speed
// we failed.
// we reset the waypoints in the start; if we pulled any, reset it again
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//This part provides assistance to a player that are attacked by who, even if out of normal aggro range
//It will cause me to attack who that are attacking _any_ player (which has been confirmed may happen also on offi)
//The flag (type_flag) is unconfirmed, but used here for further research and is a good candidate.
//experimental (unknown) flag not present
//not a player
//never attack friendly
//too far away and no free sight?
//already fighting someone?
/*killer*/)
/// @todo need a better check for quests with time limit.
/*uiDiff*/)
//set variables
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// copy script to local (protection for table reload)
//first wp id is 1 !!
// spawn in run mode
//dont mess up escort movement after combat
/*invoker*/)
// no wp movement in combat
//force stop
//force stop
//mDespawnTime = DespawnTime;
//force stop
//mWPReached = false;
// handle pause
// if paused between 2 wps resend movement
//reached OOC WP
// handle next wp
//reached WP
/// @todo move to void
//escort targets were not set, ignore range check
/// @fixme: duplicated logic in CreatureAI::_EnterEvadeMode (could use RemoveAllAurasExceptType)
//must be after aura clear so we can cast spells from db
/* if (me->GetMap()->IsDungeon())*/
/*who*/) const
//experimental (unknown) flag not present
//not a player
//never attack friendly
//too far away and no free sight?
//already fighting someone?
//do not reset follower on Reset(), we need it after combat evade
// must be before ProcessEvents
/*damagetype*/)
/*diff*/) { }
/*id*/) const
/*guid*/, int32 /*id*/) { }
/*id*/) const
/*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/) { }
//Reset();
// Called when a player opens a gossip dialog with the gameobject.
// Called when a player selects a gossip item in the gameobject's gossip menu.
// Called when a player selects a gossip with a code in the gameobject's gossip menu.
/*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/)
// Called when a player accepts a quest from the gameobject.
// Called when a player selects a quest reward.
// Called when the dialog status between a player and the gameobject is requested.
/*player*/) { return 100; }
// Called when the gameobject is destroyed (destructible buildings only).
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 2.1.0
// Unit Target
// target name length
// target name
// ChatTag
//special handling
/* && (!(*i).event.event_phase_mask || IsInPhase((*i).event.event_phase_mask)) && !((*i).event.event_flags & SMART_EVENT_FLAG_NOT_REPEATABLE && (*i).runOnce)*/)
//calc random
//used for repeat check
// Prevented sending text to pets.
// used for $vars in texts and whisper target
//set model based on entry from creature_template
//if no param1, then use value from param2 (modelId)
// Special handling for vehicles
// Activate
// Special handling for vehicles
// Loot recipient and his group members
// Specific target type
// Special handling for vehicles
// The AI is only updated if the creature is alive
// Next tick
// Otherwise we call the despawn directly
//break;
// casters already validated, delete now
/// @todo Resume path when reached jump location
// store a copy of target list
// store a copy of target list
//store cage as id1
//reset(close) cage on hostage(me) respawn
//phase 1: give quest credit on movepoint reached
//phase 1: despawn after time on movepoint reached
//store hostage as id1
//store invoker as id2
//signal hostage
//when hostage raeched end point, give credit to invoker
/*= NULL*/)
// We still add the player to the list if there is no group. If we do
// this even if there is a group (thus the else-check), it will add the
// same player to the list twice. We don't want that to happen.
// will always return a valid pointer, even if empty list
// will always return a valid pointer, even if empty list
// will always return a valid pointer, even if empty list
// will always return a valid pointer, even if empty list
// will always return a valid pointer, even if empty list
// will always return a valid pointer, even if empty list
//special handling
//called from Update tick
//no params
//can trigger if closer than fMaxAllowedRange
//if range is ok and we are actually in LOS
//if friendly event&&who is not hostile OR hostile event&&who is hostile
//can trigger if closer than fMaxAllowedRange
//if range is ok and we are actually in LOS
//if friendly event&&who is not hostile OR hostile event&&who is hostile
//little help for scripters
//set only events which have initial timers
// min/max was checked at loading!
//can be used with me=NULL (go script)
// delay spell cast event if another spell is being casted
//activate events with cooldown
//process ONLY timed events
//disable event if it is in an ActionList and was processed once
//find the first event which is not the current one and enable it
//must be before UpdateTimers
//before UpdateTimers
//if has instance flag add only if in it
//NOTE: 'world(0)' events still get processed in ANY instance mode
//handle object based scripts
//load copy of script
//calculate timers for first time use
/*
// SmartScript end
//enable processing only for the first action
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//Drop Existing SmartAI List
//nothing to check, really
//check target
// check all event and action params
// creature entry / guid not found in storage, create empty event list for it and increase counters
// store the new event
// AI template has special handling
// in SMART_SCRIPT_TYPE_TIMED_ACTIONLIST all event types are overriden by core
//force default OOC, can change when calling the script!
//if (e.event.textOver.textGroupID && !IsTextValid(e, e.event.textOver.textGroupID)) return false;// 0 is a valid text group!
//PhaseMin, PhaseMax
// unused
/*bool SmartAIMgr::IsTextValid(SmartScriptHolder const& e, uint32 id) // unused
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// teams have linked auction houses
//does not clear ram
// data for gm.log
// receiver exist
// set owner to bidder (to prevent delete item with sender char deleting)
// owner in `data` will set at mail receive and item extracting
// FIXME: for offline player need also
// owner exist (online or offline)
//call this method to send mail to auction owner, when auction is successful, it does not clear ram
// owner exist
//FIXME: what do if owner offline
//send auction owner notification, bidder must be current!
//does not clear ram
//return an item in auction to its owner by mail
// owner exist
//this function sends mail to old bidder
// old bidder exist
//this function sends mail, when auction is cancelled to old bidder
// bidder exist
// need to clear in case we are reloading
// data needs to be at first place for Item::LoadFromDB
// goblin auction house
// FIXME: found way for proper auctionhouse selection by another way
// AuctionHouse.dbc have faction field with _player_ factions associated with auction house races.
// but no easy way convert creature faction to player race faction for specific city
// human
// orc, and generic for horde
// dwarf, and generic for alliance
// undead
// n-elf
// trolls
// booty bay, neutral
// gadgetzan, neutral
// everlook, neutral
// b-elfs,
// for unknown case
// goblin auction house
// human auction house
// orc auction house
// goblin auction house
/*itemEntry*/)
// we need to delete the entry, it is not referenced any more
///- Handle expired auctions
// If storage is empty, no need to update. next == NULL in this case.
// from auctionhousehandler.cpp, creates auction pointer & player pointer
///- Either cancel the auction if there was no bidder
///- Or perform the transaction
//we should send an "item sold" message if the seller is online
//we send the item to the winner
//we send the money to the seller
///- In any case clear the auction
// Allow search by suffix (ie: of the Monkey) or partial name (ie: Monkey)
// No need to do any of this if no search term was entered
// local name
// DO NOT use GetItemEnchantMod(proto->RandomProperty) as it may return a result
//  that matches the search but it may not equal item->GetItemRandomPropertyId()
//  used in BuildAuctionInfo() which then causes wrong items to be listed
// Append the suffix to the name (ie: of the Monkey) if one exists
// These are found in ItemRandomProperties.dbc, not ItemRandomSuffix.dbc
//  even though the DBC names seem misleading
// dbc local name
// Append the suffix (ie: of the Monkey) to the name using localization
// or default enUS if localization is invalid
// Perform the search (with or without suffix)
// Add the item if no search term or if entered search term was found
//this function inserts to WorldPacket auction's data
// PROP_ENCHANTMENT_SLOT_0 = 10
// Random item property id
// SuffixFactor
// item->count
// item->charge FFFFFFF
// Unknown
// Auction->owner
// Auction->startbid (not sure if useful)
// Minimal outbid
// Auction->buyout
// time left
// auction->bidder current
// current bid
/// the sum of outbid is (1% from current bid)*5, if bid is very small, it is 1c
// check if sold item exists for guid
// and itemEntry in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
// Deletes expired auctions. Should be called at server start before loading auctions.
// DO NOT USE after auctions are already loaded since this deletes from the DB
//  and assumes the auctions HAVE NOT been loaded into a list or AuctionEntryMap yet
// Query the DB to see if there are any expired auctions
// Can't use LoadFromDB() because it assumes the auction map is loaded
// For some reason the record in the DB is broken (possibly corrupt
//  faction info). Delete the object and move on.
// Cancel the auction, there was no bidder
// Send the item to the winner and money to seller
// Call the appropriate AuctionHouseObject script
//  ** Do we need to do this while core is still loading? **
// Delete the auction from the DB
// Release memory
// Loads an AuctionEntry item from a field list. Unlike "LoadFromDB()", this one
//  does not require the AuctionEntryMap to have been loaded with items. It simply
//  acts as a wrapper to fill out an AuctionEntry struct from a field list
// HIGHGUID_PLAYER always present, even for empty guids
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Called when a player enters the zone
/*zone*/)
// If battle is started,
// If not full of players > invite player to join the war
// If full of players > announce to player that BF is full and kick him after a few second if he desn't leave
// Vacant spaces
// No more vacant places
/// @todo Send a packet to announce it to player
// If time left is < 15 minutes invite player to join queue
// Add player in the list of player in zone
// Called when a player leave the zone
/*zone*/)
// If the player is participating to the battle
// Remove the player from the raid group
// Battlefield ends on time
// Time to start a new battle!
// Invite players a few minutes before the battle's beginning
// Kick players who chose not to accept invitation to the battle
//Full
// Battlefield is full of players
/// @todo needed ?
// If the player does not match minimal level requirements for the battlefield, kick him
// Check if player is not already in war
// Reset battlefield timer
// Called in WorldSession::HandleBfQueueInviteResponse
// Add player in queue
// Send notification
// Called in WorldSession::HandleBfExitRequest
// Remove player from queue
// Called in WorldSession::HandleBfEntryInviteResponse
//for scripting
// Send Language
// FIXME: replaced CHAT_TYPE_END with CHAT_MSG_BG_SYSTEM_NEUTRAL to fix compile, it's a guessed change :/
// ****************************************************
// ******************* Group System *******************
// ****************************************************
//***************End of Group System*******************
/***************End of Group System*******************
//*****************************************************
/*****************************************************
//*****************************************************
/*****************************************************
//--------------------
//-Battlefield Method-
//--------------------
// resurrect every 30 seconds
// ----------------------
// - BfGraveyard Method -
// ----------------------
// Get player object from his guid
// Check  if the player is in world and on the good graveyard
// Resurect player
// For changing graveyard control
// Guide switching
// Note: Visiblity changes are made by phasing
/*if (m_SpiritGuide[1 - team])
// Teleport to other graveyard, player witch were on this graveyard
// *******************************************************
// *************** End Spirit Guide system ***************
// *******************************************************
// ********************** Misc ***************************
// *******************************************************
//Get map object
// force using DB speeds -- do we really need this?
// Set creature in world
// Method for spawning gameobject on map
// Get map object
// *vomits*
// Create gameobject
// Add to world
// *******************************************************
// ******************* CapturePoint **********************
// *******************************************************
// return end()
// send this too, sometimes the slider disappears, dunno why :(
// send these updates to only the ones in this objective
// send this too, sometimes it resets :S
// check info existence
// get the needed values from goinfo
// not save respawn time
// get the difference of numbers
// horde is in majority, but it's already horde-controlled -> no change
// ally is in majority, but it's already ally-controlled -> no change
// red
// blue
// grey, go through mid point
// if challenger is ally, then n->a challenge
// if challenger is horde, then n->h challenge
// grey, did not go through mid point
// old phase and current are on the same side, so one team challenges the other
//SF_LOG_ERROR("bg.battlefield", "%u->%u", m_OldState, m_State);
// send to all players present in the area
// send to all players present in the area
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//SF_LOG_DEBUG("bg.battlefield", "Instantiating BattlefieldMgr");
//SF_LOG_DEBUG("bg.battlefield", "Deleting BattlefieldMgr");
// respawn, init variables
/* For Cataclysm: Tol Barad
// respawn, init variables
// teleport: remove once in removefromworld, once in updatezone
// no handle for this zone, return
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// @todo Implement proper support for vehicle+player teleportation
/// @todo Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
/// @todo Add proper implement of achievement
// See enum BattlefieldTypes
// Init GraveYards
// Load from db
// When between games, the graveyard is controlled by the defending team
// Spawn workshop creatures and gameobjects
// Note: Capture point is added once the gameobject is created.
// Spawn NPCs in the defender's keep, both Horde and Alliance
// Horde npc
// Alliance npc
// Hide NPCs from the Attacker's team in the keep
// Spawn Horde NPCs outside the keep
// Spawn Alliance NPCs outside the keep
// Hide units outside the keep that are defenders
// Spawn turrets and hide them per default
// Spawn all gameobjects
// Spawning portal defender
// Spawn titan relic
// Update faction of relic, only attacker can click on
// Set in use (not allow to click on before last door is broken)
// Update tower visibility and update faction
// Rebuild all wall
// Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
// Kick player in orb room, TODO: offline player ?
// Initialize vehicle counter
// Send start warning to all players
// Remove relic
// Remove turret
// One player triggered the relic
// Change all npc in keep
// Change all npc out of keep
// Update all graveyard, control is to defender when no wartime
// Update portal defender faction
// Saving data
// Send Wintergrasp victory achievement
// Award achievement for succeeding in Wintergrasp in 10 minutes or less
// win alli/horde
// defend alli/horde
// *******************************************************
// ******************* Reward System *********************
// *******************************************************
/*incrementNumber*/)
// player->UpdateAchievementCriteria();
// Accessing to db spawned creatures
// untested code - not sure if it is valid.
/*creature*/)
/* possibly can be used later
// Called when player kill a unit in wg zone
/// @todoRecent PvP activity worldstate
// Update rank for player
// Updating rank of player
// Remove all aura from WG /// @todo false we can go out of this zone on retail and keep Rank buff, remove on end of WG
// Remove vehicle of player if he go out.
// Send worldstate to player
// Used to determine when the phasing spells must be casted
// See: SpellArea::IsFitToRequirements
// Graveyards and Workshops are controlled by the same team.
// Note: cleanup these two, their names look awkward
/*team*/)
// might be some use for this in the future. old code commented out below. KL
/*    if (team == GetDefenderTeam())
// Called when a tower is broke
// Destroy an attack tower
// Update counter
// Remove buff stack on attackers
// Add buff stack to defenders
// If all three south towers are destroyed (ie. all attack towers), remove ten minutes from battle time
// We handle only gameobjects here
// On click on titan relic
// if destroy or damage event, search the wall/tower and update worldstate/send warning message
// Called when a tower is damaged, used for honor reward calcul
// Update vehicle count WorldState to player
// positive, should cast on alliance
// negative, should cast on horde
// old buff was on alliance
// old buff was on horde
// Remove old buff
// Apply new buff
/*oldTeam*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// team id
// rating
// games this week
// wins this week
// played this season
// wins this season
// rank
// This is called after a rated match ended
// Updates arena team stats for every member of the team (not only the ones who participated!)
//player->SetArenaTeamInfoField(ArenaTeam::GetSlotByType(type), ARENA_TEAM_PERSONAL_RATING, PersonalRating);
//player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_PERSONAL_RATING, PersonalRating, type);
/*slot*/)
// unk
// Skip if player is not online
// Skip if player is not a member of group
// x/0 = crash
// Returns the chance to win against a team with the given rating, used in the rating adjustment calculation
// ELO system
// 'Chance' calculation - to beat the opponent
// This is a simulation. Not much info on how it really works
// Work in progress:
/*
// Apply confidence factor to the mod:
// And only after that update the new confidence factor
// Real rating modification
/*, float confidence_factor*/)
// 'Chance' calculation - to beat the opponent
// This is a simulation. Not much info on how it really works
// Calculate the rating modification
/// @todo Replace this hack with using the confidence factor (limiting the factor to 2.0f)
// Rating can only drop to 0
// Check if rating related achivements are met
// Update number of games played per season or week
// Update team's rank, start with rank 1 and increase until no team with more rating was found
// Called when the team has won
// Change in Matchmaker rating
// Change in Team Rating
// Modify the team stats accordingly
// Update number of wins per season and week
// Return the rating change, used to display it on the results screen
// Called when the team has lost
// Change in Matchmaker Rating
// Change in Team Rating
// Modify the team stats accordingly
// return the rating change, used to display it on the results screen
// Called for each participant of a match after losing
// Update personal rating
// Update matchmaker rating
// Update personal played stats
// update the unit fields
//player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_WEEK,  itr->WeekGames);
//player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_SEASON,  itr->SeasonGames);
// Called for offline player after ending rated arena match!
// update personal rating
// update matchmaker rating
// update personal played stats
// called for each participant after winning a match
// update personal rating
// update matchmaker rating
// update personal stats
// update unit fields
//player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_WEEK, itr->WeekGames);
//player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_SEASON, itr->SeasonGames);
// Reset team stats
// Reset member stats
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Arena teams collection
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// we need copy va_list before use or original va_list will corrupted
// namespace Skyfire
//we must set to some default existing values
// remove objects and creatures
// (this is done automatically in mapmanager update, when the instance is reset after the reset time)
// unload map
//unlink to prevent crash, always unlink all pointer reference before destruction
// remove from bg free slot queue
//BG is empty
// if there are no players invited, delete BG
// this will delete arena or bg object, where any player entered
// [[   but if you use battleground object again (more battles possible to be played on 1 instance)
//      then this condition should be removed and code:
//      if (!GetInvitedCount(HORDE) && !GetInvitedCount(ALLIANCE))
//          this->AddToFreeBGObjectsQueue(); // not yet implemented
//      should be used instead of current
// ]]
// Battleground Template instance cannot be updated, because it would be deleted
// after 47 minutes without one team losing, the arena closes with no winner and no rating change
// Update start time and reset stats timer
// remove offline players from bg after 5 minutes
// remove player from BG
// remove from offline queue
//do not use itr for anything, because it is erased in RemovePlayerAtLeave()
// *********************************************************
// ***        BATTLEGROUND RESSURECTION SYSTEM           ***
// *********************************************************
// this should be handled by spell system
// only for visual effect
// Spirit Heal, effect 117
// Resurrection visual
// queue is clear and time passed, just update last resurrection time
// Resurrect players only half a second later, to see spirit heal effect on NPC
// *********************************************************
// ***           BATTLEGROUND BALLANCE SYSTEM            ***
// *********************************************************
// if less then minimum players are in on one side, then start premature finish timer
// time's up!
// announce every minute
//announce every 15 seconds
// *********************************************************
// ***           BATTLEGROUND STARTING SYSTEM            ***
// *********************************************************
// Send packet every 10 seconds until the 2nd field reach 0
// unk
// Setup here, only when at least one player has ported to the map
// First start warning - 2 or 1 minute
// After 1 minute or 30 seconds, warning is signaled
// After 30 or 15 seconds, warning is signaled
// Delay expired (after 2 or 1 minute)
// Remove preparation
/// @todo add arena sound PlaySoundToAll(SOUND_ARENA_START);
// BG Status packet
// Correctly display EnemyUnitFrame
// remove auras with duration lower than 30s
// Announce BG starting
// *********************************************************
// ***           BATTLEGROUND ENDING SYSTEM              ***
// *********************************************************
// remove all players from battleground after 2 minutes
//itr is erased here!
// remove player from BG
// do not change any battleground's private variables
// alliance wins sound
// horde wins sound
//we must set it this way, because end time is sent in packet!
// arena rating calculation
// Deduct 16 points from each teams arena-rating if there are no winners after 45+2 minutes
//if rated arena match - make member lost!
// should remove spirit of redemption
// Last standing - Rated 5v5 arena & be solely alive player
//needed cause else in av some creatures will kill the players at the end
// per player calculation
// update achievement BEFORE personal rating update
// Arena lost => reset the win_rated_arena having the "no_lose" condition
// remove temporary currency bonus auras before rewarding player
// Reward winner team
// 100cp awarded for the first random battleground won each day
// 50cp awarded for each non-rated battleground won
/*
// send updated arena team stats to players
// this way all arena team members will get notified, not only the ones who participated in this match
//variable kills means how many honorable kills you scored (so we need kills * honor_for_one_kill)
// movement disabled NOTE: the effect will be automatically removed by client when the player is teleported from the battleground, so no need to send with uint8(1) in RemovePlayerAtLeave()
// Remove from lists/maps
// -1 player
// check if the player was a participant of the match, or only entered through gm command (goname)
// delete player's score
// should remove spirit of redemption
// resurrect on exit
// BG subclass specific code
// if the player was a match participant, remove auras, calc rating, update queue
// if arena, remove the specific arena auras
// set the bg type to all arenas (it will be used for queue refreshing)
// unsummon current and summon old pet if there was one and there isn't a current pet
//left a rated match while the encounter was in progress, consider as loser
// this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
// removing offline participant
//left a rated match while the encounter was in progress, consider as loser
// remove from raid group if player is member
// group was disbanded
//we should update battleground queue, but only if bg isn't ending
// a player has left the battleground, so there are free slots -> add to queue
// Let others know
// Do next only if found in battleground
// We're not in BG.
// reset destination bg team
//battleground object will be deleted next Battleground::Update() call
// this method is called when no players remains in battleground
// add BG to free slot queue
// add bg to update list
// This must be done here, because we need to have already invited some players when first BG::Update() method is executed
// and it doesn't matter if we call StartBattleground() more times, because m_Battlegrounds is a map and instance id never changes
// remove afk from player
// score struct must be created in inherited class
// Add to list/maps
// +1 player
// BG Status packet
// add arena specific auras
// gold
// green
// not started yet
// not started yet
// reduces all mana cost of spells.
// unk
// setup BG group membership
// this method adds player to his team's bg group, or sets his correct group if player is already in bg group
// first player joined
// raid already exist
// This method should be called when player logs into running battleground
// player is correct pointer
// if battleground is starting, then add preparation aura
// we don't have to do that, because preparation aura isn't removed when player logs out
// This method should be called when player logs out from running battleground
// Check if this player really is in battleground (might be a GM who teleported inside)
// player is correct pointer, it is checked in WorldSession::LogoutPlayer()
// drop flag and handle other cleanups
// 1 player is logging out, if it is the last, then end arena!
// This method should be called only once ... it adds pointer to queue
// This method removes this battleground from free queue - it must be called when deleting battleground
// get the number of free slots for team
// returns the number how many players can join battleground to MaxPlayersPerTeam
// if BG is starting ... invite anyone
// if BG is already started .. do not allow to join too much players of one faction
// difference based on ppl invited (not necessarily entered battle)
// default: allow 0
// allow join one person if the sides are equal (to fill up bg to minplayersperteam)
// allow join more ppl if the other side has more players
// difference based on max players per team (don't allow inviting more)
// difference based on players who already entered
// default: allow 0
// allow join one person if the sides are equal (to fill up bg minplayersperteam)
// allow join more ppl if the other side has more players
// or other side has less than minPlayersPerTeam
// return the minimum of the 3 differences
// min of diff and diff 2
// min of diff, diff2 and diff3
//this procedure is called from virtual function implemented in bg subclass
// player not found...
// Killing blows
// Deaths
// Honorable kills
// Honor bonus
// do not add honor in arenas
// reward honor instantly
// RewardHonor calls UpdatePlayerScore with doAddHonor = false
// used only in EY, but in MSG_PVP_LOG_DATA opcode
// Damage Done
// Healing Done
// Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
/*respawnTime*/)
// If the assert is called, means that BgObjects must be resized!
// Must be created this way, adding to godatamap would add it to the base map of the instance
// and when loading it (in go::LoadFromDB()), a new guid would be assigned to the object, and a new object would be created
// So we must create it specific for this instance
/*
// without this, UseButtonOrDoor caused the crash, since it tried to get go info from godata
// iirc that was changed, so adding to go data map is no longer required if that was the only function using godata from GameObject without checking if it existed
// Add to world, so it can be later looked up from HashMapHolder
// Some doors aren't despawned so we cannot handle their closing in gameobject::update()
// It would be nice to correctly implement GO_ACTIVATED state and open/close doors in gameobject code
// If doors are open, close it
// Change state from GO_JUST_DEACTIVATED to GO_READY in case battleground is starting again
// If the assert is called, means that BgCreatures must be resized!
// Force using DB speeds
// not save respawn time
// aura
/// @todo Fix display here
// creature->SetVisibleAura(0, SPELL_SPIRIT_HEAL_CHANNEL);
// casting visual effect
// correct cast speed
//creature->CastSpell(creature, SPELL_SPIRIT_HEAL_CHANNEL, true);
// To be removed
// FIXME: now we have different DBC locales and need localized message for each target client
// IMPORTANT NOTICE:
// buffs aren't spawned/despawned when players captures anything
// buffs are in their positions when battleground starts
// Change buff type, when buff is used:
// Randomly select new buff
// Despawn current buff
// Set index for new one
// Keep in mind that for arena this will have to be changed a bit
// Add +1 deaths
// Add +1 kills to group and +1 killing_blows to killer
// Don't reward credit for killing ourselves, like fall damage of hellfire (warlock)
// To be able to remove insignia -- ONLY IN Battlegrounds
// Return the player's team based on battlegroundplayer info
// Used in same faction arena matches mainly
/*victim*/, Player* /*killer*/) { }
/*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*********************************************************/
/***            BATTLEGROUND MANAGER                   ***/
/*********************************************************/
// used to update running battlegrounds, and delete finished ones
// first one is template and should not be deleted
// update events timer
// update scheduled queues
// if rating difference counts, maybe force-update queues
// it's time to force update
// forced update for rated arenas (scan all, but skipped non rated)
// Join Time
// Id
// Queue slot
// Is Rated
// AsGroup
// Eligible In Queue
// IsSuspended
// Id
// Estimated Wait Time
// MinLevel
// Join Time
// PremadeSize
// Time since joined
// Queue slot
// MaxLevel
// Client Instance ID
// Missing Role
// Is Rated
// Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
// Queue slot
// *data << uint32(role);
// Client Instance ID
// Join Time
// MaxLevel
// Time until closed
// Min Level
// Id
// Map Id
// Left Early
// Is Rated
// Join Time
// Remaining Time
// Elapsed Time
// Max Level
// Queue slot
// Min Level
// Map Id
// Client Instance ID or faction ?
// Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
// Id
// If Ended
// Unk Some player stuff
// isRated
// Rating Change
// MMR Change
// PreMatch MMR
// Prematch Rating
// healing done
// damage done
// Custom values
// flag captures
// flag returns
// flag captures
// bases assaulted
// bases defended
// GraveyardsAssaulted
// GraveyardsDefended
// TowersAssaulted
// TowersDefended
// MinesCaptured
// IC
// bases assaulted
// bases defended
// flag captures
// flag returns
// bases assaulted
// bases defended
// GraveyardsAssaulted
// GraveyardsDefended
// TowersAssaulted
// TowersDefended
// MinesCaptured
// flag captures
// flag returns
// bases assaulted
// bases defended
// flag captures
// bases assaulted
// bases defended
// flag captures
// flag returns
// bases assaulted
// bases defended
// arena
/*if (isRated)                                             // arena
// it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
// Matchmaking Value
// Rating Lost
// Rating gained
// player who caused the error
// Join Time
// Id ???
// Queue slot
// Result
//cause at HandleBattlegroundJoinOpcode the clients sends the instanceid he gets from
//SMSG_BATTLEFIELD_LIST we need to find the battleground with this clientinstance-id
// map is sorted and we can be sure that lowest instance id has only BG template
//arenas don't have client-instanceids
// we create here an instanceid, which is just for
// displaying this to the client and without any other use..
// the client-instanceIds are unique for each battleground-type
// the instance-id just needs to be as low as possible, beginning with 1
// the following works, because std::set is default ordered with "<"
// the optimalization would be to use as bitmask std::vector<uint32> - but that would only make code unreadable
//if there is a gap between the ids, we will break..
// create a new battleground that will really be used to play
/// Intentional fallback, "All Arenas" is random too
// get the template BG
// create a copy of the BG template
// reset the new bg (set status to status_wait_queue from status_none)
// start the joining of the bg
// Set up correct min/max player counts for scoreboards
// used to create the BG templates
// Create the BG
//                                               0   1                  2                  3       4       5                 6               7              8            9             10      11
// can be overwrite by values from DB
// Winner Conquest Reward or Random Winner Conquest Reward
// Loser Honor Reward or Random Loser Honor Reward
// min level
// Winner Conquest Reward or Random Winner Conquest Reward
// Winner Honor Reward or Random Winner Honor Reward
// battleground id
// Winner Honor Reward or Random Winner Honor Reward
// max level
// Loser Honor Reward or Random Loser Honor Reward
// fake bit ?
// fake bit ?
// fake bit ?
// fake bit ?
// placeholder
// bg instance count
// resurrect every 30 seconds
// used for unknown template (it existed and do nothing)
//This method must be atomic, @todo add mutex
//we will use only 1 number created of bgTypeId and bracket_id
// this is for stupid people who can't use brain and set max rating difference to 0
// need for reload case
// Select a random value
// Select the correct bg (if we have in DB A(10), B(20), C(10), D(15) --> [0---A---9|10---B---29|30---C---39|40---D---54])
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*********************************************************/
/***            BATTLEGROUND QUEUE SYSTEM              ***/
/*********************************************************/
/*********************************************************/
/***      BATTLEGROUND QUEUE SELECTION POOLS           ***/
/*********************************************************/
// selection pool initialization, used to clean up from prev selection
// remove group info from selection pool
// returns true when we need to try to add new group to selection pool
// returns false when selection pool is ok or when we kicked smaller group than we need to kick
// sometimes it can be called on empty selection pool
//find maxgroup or LAST group with size == size and kick it
//if pool is empty, do nothing
//update player count
//return false if we kicked smaller group or there are enough players in selection pool
// add group to selection pool
// used when building selection pools
// returns true if we can invite more players, or when we added group to selection pool
// returns false when selection pool is full
//if group is larger than desired count - don't allow to add it to pool
// increase selected players count
/*********************************************************/
/***               BATTLEGROUND QUEUES                 ***/
/*********************************************************/
// add group or player (grp == NULL) to bg queue with the given leader and bg specifications
// create new ginfo
//compute index (if group is premade or joined a rated match) to queues
//add players from group to ginfo
// this should never happen
// add the pinfo to ginfo's list
//add GroupInfo to m_QueuedGroups
//ACE_Guard<ACE_Recursive_Thread_Mutex> guard(m_Lock);
//announce to world, this code needs mutex
// Show queue status to player only (when joining queue)
// System message
//release mutex
//default set to TEAM_ALLIANCE - or non rated arenas!
//for rated arenas use TEAM_HORDE
//store pointer to arrayindex of player that was added first
//remove his time from sum
//set average time to new
//add new time to sum
//set index of last player added to next one
//default set to TEAM_ALLIANCE - or non rated arenas!
//for rated arenas use TEAM_HORDE
//check if there is enought values(we always add values > 0)
//if there aren't enough values return 0 - not available
//remove player from queue and from group info, if group info is empty then remove it too
// signed for proper for-loop finish
//remove player from map, if he's there
// mostly people with the highest levels are in battlegrounds, thats why
// we count from MAX_BATTLEGROUND_QUEUES - 1 to 0
//we must check premade and normal team's queue - because when players from premade are joining bg,
//they leave groupinfo so we can't use its players size to find out index
//we must store index to be able to erase iterator
//player can't be in queue without group, but just in case
// ALL variables are correctly set
// We can ignore leveling up in queue - it should not cause crash
// remove player from group
// if only one player there, remove group
// remove player queue info from group queue info
// if invited to bg, and should decrease invited count, then do it
// remove player queue info
// if player leaves queue and he is invited to rated arena match, then he have to lose
/*
// remove group queue info if needed
// if group wasn't empty, so it wasn't deleted, and player have left a rated
// queue -> everyone from the group should leave too
// don't remove recursively if already invited to bg!
// remove next player, this is recursive
// first send removal information
// must be called this way, because if you move this call to
// queue->removeplayer, it causes bugs
// then actually delete, this may delete the group as well!
//returns true when player pl_guid is in queue and is invited to bgInstanceGuid
// set side if needed
// not yet invited
// set invitation
// loop through the players
// get the player
// if offline, skip him, this should not happen - player is removed from queue when he logs out
// invite the player
//sBattlegroundMgr->InvitePlayer(player, bg, ginfo->Team);
// set invited player counters
// create remind invite events
// create automatic remove events
// send status packet
/*
//iterator for iterating through bg queue
//count of groups in queue - used to stop cycles
//index to queue which group is current
//the same thing for horde
//if ofc like BG queue invitation is set in config, then we are happy
/*
// At first we need to compare free space in bg and our selection pool
//each cycle execution we need to kick at least 1 group
//kick alliance group, add to pool new group if needed
//if ali selection is already empty, then kick horde group, but if there are less horde than ali in bg - break;
//kick horde group, add to pool new group if needed
//count diffs after small update
// this method checks if premade versus premade battleground is possible
// then after 30 mins (default) in queue it moves premade group to normal queue
// it tries to invite as much players as it can - to MaxPlayersPerTeam, because premade groups have more than MinPlayersPerTeam players
//check match
//start premade match
//if groups aren't invited
//add groups/players from normal queue to size of bigger group
//if itr can join BG and player count is less that maxPlayers, then add group to selectionpool
//premade selection pools are set
// now check if we can move group from Premade queue to normal queue (timer has expired) or group size lowered!!
// this could be 2 cycles but i'm checking only first team in queue - it can cause problem -
// if first is invited to BG and seconds timer expired, but we can ignore it, because players have only 80 seconds to click to enter bg
// and when they click or after 80 seconds the queue info is removed from queue
//we must insert group to normal queue and erase pointer from premade queue
//selection pools are not set
// this method tries to create battleground or arena with MinPlayersPerTeam against MinPlayersPerTeam
/*bg_template*/, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers)
//try to invite same number of players - this cycle may cause longer wait time even if there are enough players in queue, but we want ballanced bg
//we will try to invite more groups to team with less players indexed by j
//this will not cause a crash, because for cycle above reached break;
// do not allow to start bg with more than 2 players more on 1 faction
//allow 1v0 if debug bg
//return true if there are enough players in selection pools - enable to work .debug bg command correctly
// this method will check if we can invite players to same faction skirmish match
//clear other team's selection
//store last ginfo pointer
//set itr_team to group that was added to selection pool latest
//invite players to other selection pool
//if selection pool is full then break;
//here we have correct 2 selections and we need to change one teams team and move selection pool teams to other team's queue
//set correct team
//add team to other queue
//remove team from old queue
/*
/*diff*/, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType, bool isRated, uint32 arenaRating)
//if no players in queue - do nothing
// battleground with free slot for player should be always in the beggining of the queue
// maybe it would be better to create bgfreeslotqueue for each bracket_id
// DO NOT allow queue manager to invite new player to rated games
// clear selection pools
// call a function that does the job for us
// now everything is set, invite players
// finished iterating through the bgs with free slots, maybe we need to create a new bg
// get the min. players per team, properly for larger arenas as well. (must have full teams for arena matches!)
// create new battleground
// invite those selection pools
//clear structures
// now check if there are in queues enough players to start new game of (normal battleground, or non-rated arena)
// if there are enough players in pools, start new battleground or non rated arena
// we successfully created a pool
// invite those selection pools
// start bg
// found out the minimum and maximum ratings the newly added team should battle against
// arenaRating is the rating of the latest joined team, or 0
// 0 is on (automatic update call) and we must set it to team's with longest wait time
//queues are empty
//set rating range
// if max rating difference is set and the time past since server startup is greater than the rating discard time
// (after what time the ratings aren't taken into account when making teams) then
// the discard time is current_time - time_to_discard, teams that joined after that, will have their ratings taken into account
// else leave the discard time on 0, this way all ratings will be discarded
// we need to find 2 teams which will play next game
// take the group that joined first
// if group match conditions, then add it to pool
//if we have 2 teams, then start new arena and invite players!
// now we must move team if we changed its faction to another faction queue, because then we will spam log by errors in Queue::RemovePlayer
/*********************************************************/
/***            BATTLEGROUND QUEUE EVENTS              ***/
/*********************************************************/
/*e_time*/, uint32 /*p_time*/)
// player logged off (we should do nothing, he is correctly removed from queue in another procedure)
//if battleground ended and its instance deleted - do nothing
// player is in queue or in battleground
// check if player is invited to this bg
//we must send remaining time in queue
//event will be deleted
/*e_time*/)
//do nothing
/*
/*e_time*/, uint32 /*p_time*/)
// player logged off (we should do nothing, he is correctly removed from queue in another procedure)
//battleground can be deleted already when we are removing queue info
//bg pointer can be NULL! so use it carefully!
// player is in queue, or in Battleground
// check if player is in queue for this BG and if we are removing his invite event
//update queues if battleground isn't ended
//event will be deleted
/*e_time*/)
//do nothing
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//+5 for aura triggers
// 3 sec delay to spawn new banner instead previous despawned one
// 1-minute to occupy a node from contested state
// Change from contested to occupied !
// burn current contested banner
// create new occupied banner
// Message to chatlog
// FIXME: team and node names not localized
// FIXME: team and node names not localized
// Accumulate points
// update achievement flags
// we increased m_TeamScores[team] so we just need to check if it is 500 more than other teams resources
// Test win condition
// despawn banners, auras and buffs
// Starting doors
// Starting base spirit guides
// spawn neutral banners
//randomly select buff to spawn
// Achievement: Let's Get This Done
//create score and add it to map, default values are set in the constructor
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// Arathi Basin Alliance Exit.
// Arathi Basin Horde Exit.
// Stables
// Gold Mine
// Farm
// Lumber Mill
// Black Smith
// Unk1
// Unk2
// Unk3
//break;
// Just put it into the queue
// handle aura with banner
// handle aura with banner
// Node icons
// Node occupied states
// How many bases each team owns
// Team scores
// other unknown
// 37 1861 unk
// Send node owner state update to refresh map icons on client
// How many bases each team owns
//only dynamic nodes, no start points
//0-6 spirit guides
//add bonus honor aura trigger creature when node is accupied
//cast bonus aura (+50% honor in 25yards)
//aura should only apply to players who have accupied the node, set correct faction for trigger
//remove bonus honor aura trigger creature when node is lost
//only dynamic nodes, no start points
//NULL checks are in DelCreature! 0-6 spirit guides
// buff object isn't despawned
/* Invoked if a player used a banner as a gameobject */
/*target_obj*/)
// this means our player isn't close to any of banners - maybe cheater ??
// Check if player really could use this banner, not cheated
// If node is neutral, change to contested
// burn current neutral banner
// create new contested banner
// FIXME: team and node names not localized
// If node is contested
// If last state is NOT occupied, change node to enemy-contested
// burn current contested banner
// create new contested banner
// FIXME: node names not localized
// If contested, change back to occupied
// burn current contested banner
// create new occupied banner
// FIXME: node names not localized
// If node is occupied, change to enemy-contested
// burn current occupied banner
// create new contested banner
// FIXME: node names not localized
// If node is occupied again, send "X has taken the Y" msg.
// FIXME: team and node names not localized
// How many bases each team owns
// If the values are equal, fall back to the original result (based on number of players on each team)
//buffs
//call parent's class reset
//+5 for aura triggers
// Win reward
// Complete map_end rewards (even if no team wins)
// Is there any occupied node for this team?
// If so, select the closest node to place ghost on
// If not, place ghost on starting location
// player not found...
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// @todo move this function to Battleground.cpp (needs to find a way to get m_MaxLevel)
/*
//this is a spell which finishes a quest where a player has to kill the boss
//this is a spell which finishes a quest where a player has to kill the boss
//spawn destroyed aura
//spawn destroyed aura
//maybe we should log this, cause this must be a cheater or a big bug
/// @todo add reputation, events (including quest not available anymore, next quest availabe, go/npc de/spawning)and maybe honor
//25, 50, 75 turn ins
//maybe this is bad, because it will instantly respawn all creatures on every grave..
//you can turn in 10 or 1 item..
//was no interesting quest at all
//note: to remove reinforcementpoints points must be negative, for adding reinforcements points must be positive
//0=ally 1=horde
//static
/// @todo look if this can be done by database + also add this for the wingcommanders
//else spawndist will be 15, so creatures move maximum=10
//creature->SetDefaultMovementType(RANDOM_MOTION_TYPE);
/// @todo find a way to add a motionmaster without killing the creature (i
//just copied this code from a gm-command
//maybe we can do this more generic for custom level-range.. actually it's blizzlike
//0=alliance, 1=horde
/// @todo make the captains a dynamic creature
//as far as i could see, the buff is randomly so i make 2minutes (thats the duration of the buff itself) + 0-4minutes @todo get the right times
//add points from mine owning, and look if he neutral team wanrts to reclaim the mine
//we don't need to set this timer to 0 cause this codepart wont get called when this thing is 0
//this is at the end, cause we need to update both mines
//looks for all timers of the nodes and destroy the building (for graveyards the building wont get destroyed, it goes just to the other team
//maybe remove this
//mine population
// Achievement: The Alterac Blitz
//create score and add it to map, default values are set in constructor
/// @todo just look at the code \^_^/ --but queue-info should provide this information..
//calculate bonuskills for both teams:
//first towers:
// 0 = Alliance 1 = Horde
// 0 = Alliance 1 = Horde
/// @todo add enterevademode for all attacking creatures
/*guid*/, uint32 /*team*/)
/// @todo search more buffs
//Source->Unmount();
// player not found...
//despawn banner
//despawn marshal
//spawn destroyed aura
//snowfall eyecandy
//send a nice message to all :)
// mine=0 northmine mine=1 southmin
// changing the owner results in setting respawntim to infinite for current creatures,
// spawning new mine owners creatures and changing the chest-objects so that the current owning team can use them
/// @todo just set the respawntime to 999999
/// @todo here also
//also neutral team exists.. after a big time, the neutral team tries to conquer the mine
//vermin
//the next chooses randomly between 2 cretures
//i think this gets called all the time
//cause it's no mine'object it is ok if this is true
//spiritguide
//fail safe
//0-302 other creatures
//add bonus honor aura trigger creature when node is accupied
//cast bonus aura (+50% honor in 25yards)
//aura should only apply to players who have accupied the node, set correct faction for trigger
//node can be neutral, remove trigger
//spiritguide
//remove bonus honor aura trigger creature when node is lost
//fail safe
//NULL checks are in DelCreature! 0-302 spirit guides
//this function is the counterpart to GetNodeThroughObject()
//called when using banner
//maybe should name it prevowner
//until snowfall doesn't belong to anyone it is better handled in assault-code
//currently the only neutral grave
//spawn new go :)
//spawn horde banner
//spawn alliance banner
// despawn old go
//spawn big flag+aura on top of tower
//snowfall eyecandy
//send a nice message to all :)
//update the statistic for the defending player
//maybe name it prevowner
//surely a gm used this object
//snowfall is a bit special in capping + it gets eyecandy stuff
//initial capping
//neutral aura spawn
//recapping, when no team owns this node realy
//eyecandy
//if snowfall gots capped it can be handled like all other graveyards
//spawning/despawning of bigflag+aura
//spawning/despawning of aura
//neutral aura spawn
//teeamaura despawn
//delete old banner
//send a nice message to all :)
//update the statistic for the assaulting player
//graveyards
//j=1=assaulted j=3=controled
//towers
//j=1=assaulted j=3=controled //i dont have j=2=destroyed cause destroyed is the same like enemy-team controll
//cause neutral teams aren't handled generic
//only if game started the teamscores are displayed
//this is used for node worldstates and returns values which fit good into the worldstatesarray
//neutral stuff cant get handled (currently its only snowfall)
//a_c a_a h_c h_a the positions in worldstate-array
//this will crash the game, but i want to know if something is wrong here
//currently only snowfall is supported as neutral node (i don't want to make an extra row (neutral states) in worldstatesarray just for one node
// currently i'm sure, that this works (:
//    ASSERT(m_Mine_PrevOwner[mine] == ALLIANCE || m_Mine_PrevOwner[mine] == HORDE || m_Mine_PrevOwner[mine] == AV_NEUTRAL_TEAM);
//    ASSERT(m_Mine_Owner[mine] == ALLIANCE || m_Mine_Owner[mine] == HORDE || m_Mine_Owner[mine] == AV_NEUTRAL_TEAM);
//those variables are needed to access the right worldstate in the BG_AV_MineWorldStates array
// Create starting objects
// alliance gates
// horde gates
//spawn node-objects
//aura
//towers
//alliance towers
//horde towers
//burning aura
//burning aura for buildings
// Initial Nodes
//flag
//aura
//flag
//aura
//snowfall and the doors
//creatures
//all creatures which don't get despawned through the script are static
//mainspiritguides:
//spawn the marshals (those who get deleted, if a tower gets destroyed)
//only assault an assaulted node if no totalowner exists
//the timer gets another time, if the previous owner was 0 == Neutral
//forloop for both teams (it just make 0 == alliance and 1 == horde also for both mines 0=north 1=south
//as far as i could see, the buff is randomly so i make 2minutes (thats the duration of the buff itself) + 0-4minutes @todo get the right times
//alliance graves
//alliance towers
//horde graves
//horde towers
//give snowfall neutral owner
// alliance towers controlled
// horde towers destroyed
// horde towers controlled
// alliance towers destroyed
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//we must set messageIds
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// buff trigger?
// buff trigger?
// 9
//call parent's class reset
// gates
// buffs
// player not found...
//there is nothing special in this score
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 3 sec delay to spawn new banner instead previous despawned one
// 1-minute to occupy a node from contested state
// Change from contested to occupied !
// burn current contested banner
// create new occupied banner
// Message to chatlog
// FIXME: team and node names not localized
// FIXME: team and node names not localized
// Accumulate points
// update achievement flags
// we increased m_TeamScores[team] so we just need to check if it is 500 more than other teams resources
// Test win condition
// despawn banners, auras and buffs
// Starting doors
// Starting base spirit guides
// spawn neutral banners
//randomly select buff to spawn
// Achievement: Let's Get This Done
/*player*/, uint64 /*guid*/, uint32 /*team*/) { }
// Alliance start
// Horde start
// Waterworks heal
// Mine speed
// Waterworks speed
// Mine berserk
// Lighthouse berserk
//break;
// Just put it into the queue
// handle aura with banner
// handle aura with banner
// Node icons
// Node occupied states
// How many bases each team owns
// Team scores
// other unknown
// 37 1861 unk
// Send node owner state update to refresh map icons on client
// How many bases each team owns
//only dynamic nodes, no start points
// 0-5 spirit guides
//add bonus honor aura trigger creature when node is accupied
//cast bonus aura (+50% honor in 25yards)
//aura should only apply to players who have accupied the node, set correct faction for trigger
//remove bonus honor aura trigger creature when node is lost
//only dynamic nodes, no start points
//NULL checks are in DelCreature! 0-5 spirit guides
// buff object isn't despawned
/* Invoked if a player used a banner as a gameobject */
/*target_obj*/)
// this means our player isn't close to any of banners - maybe cheater ??
// Check if player really could use this banner, not cheated
// If node is neutral, change to contested
// burn current neutral banner
// create new contested banner
// FIXME: team and node names not localized
// If node is contested
// If last state is NOT occupied, change node to enemy-contested
// burn current contested banner
// create new contested banner
// FIXME: node names not localized
// If contested, change back to occupied
// burn current contested banner
// create new occupied banner
// FIXME: node names not localized
// If node is occupied, change to enemy-contested
// burn current occupied banner
// create new contested banner
// FIXME: node names not localized
// If node is occupied again, send "X has taken the Y" msg.
// FIXME: team and node names not localized
// How many bases each team owns
// If the values are equal, fall back to the original result (based on number of players on each team)
// Buffs
//call parent's class reset
//+3 for aura triggers
// Win reward
// Complete map_end rewards (even if no team wins)
// Is there any occupied node for this team?
// If so, select the closest node to place ghost on
// If not, place ghost on starting location
/*WorldSafeLocsEntry const* BattlegroundBFG::GetExploitTeleportLocation(Team team)
// player not found...
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Repeat knockback while the waterfall still active
// Add the water
// Active collision and start knockback timer
//if (getWaterFallStatus() == BG_DS_WATERFALL_STATUS_ON) // Remove collision and water
// turn off collision
// Turn off collision
// Remove effects of Demonic Circle Summon
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// Remove effects of Demonic Circle Summon
// Someone has get back into the pipes and the knockback has already been performed,
// so we reset the knockback count for kicking the player again into the arena.
// 9 show
//call parent's class reset
// gates
// water
// buffs
// knockback creatures
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// these variables aren't used outside of this file, so declare them only here
// normal honor
// holiday
//check if player joined point
/*I used this order of calls, because although we will check if one player is in gameobject's distance 2 times
//check if player left point
//randomly spawn buff
// Achievement: Flurry
//player joined point!
//show progress bar
//add player to point
//remove player from "free space"
//reset current point counts
//move not existed player to "free space" - this will cause many error showing in log, but it is a very important bug
//move player out of point (add him to players that are out of points
//player is neat flag, so update count:
//count new point bar status:
//point is fully alliance's
//point is fully horde's
//find which team should own this point
//if point owner changed we must evoke event!
//point was uncontrolled and player is from team which captured point
//point was under control and player isn't from team which controlled it
/// @workaround The original AreaTrigger is covered by a bigger one and not triggered on client side.
/// @todo there should be some sound played when one team is near victory!! - and define variables
/*if (!m_IsInformedNearVictory && score >= BG_EY_WARNING_NEAR_VICTORY_SCORE)
// Win reward
// Complete map reward
//we MUST firstly send 0, after that we can send 1!!!
//create score and add it to map
/*team*/)
// sometimes flag aura not removed :(
//hack code, must be removed later
// doors
// banners (alliance)
// banners (horde)
// banners (natural)
// flags
// tower cap
//buffs
//call parent's class reset
//tip size
// flags respawned sound...
// if not running, do not cast things at the dropper player, neither send unnecessary messages
// just take off the aura
//this does not work correctly :((it should remove flag carrier name)
//get flag aura on player
//Natural point
//buff isn't despawned
//remove bonus honor aura trigger creature when node is lost
//NULL checks are in DelCreature! 0-5 spirit guides
//buff isn't respawned
//    SpawnBGCreature(Point, RESPAWN_IMMEDIATELY);
//0-5 spirit guides
//add bonus honor aura trigger creature when node is accupied
//cast bonus aura (+50% honor in 25yards)
//aura should only apply to players who have accupied the node, set correct faction for trigger
// player not found
// flags captured
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// the doors are closed again... in a special way
// this must be changed, there is a trigger in each transport that casts the spell.
// Alliance door
// Horde door
// we need to confirm this, i am not sure if this every 3 minutes
// we need to confirm this is blizzlike, not sure if it is every 3 minutes
// this always should be true
// following sniffs the vehicle always has UNIT_FLAG_UNK_14
// we need to confirm if it is every 3 minutes
// the point is waiting for a change on its banner
// nodePoint[i].faction = the faction should be the same one...
// this should never happen
// Show Full Gate Displays
// Alliance door
// Alliance door
// Horde door
// Horde door
//after 20 seconds they should be despawned
/*guid*/, uint32 /*team*/)
// this is wrong way to implement these things. On official it done by gameobject spell cast.
/// @hack: this spell should be cast by npc 22515 (World Trigger) and not by the player
// player not found...
//Send transport init packet to all player in map
// setting correct factions for Keep Cannons
// correcting spawn time for keeps bombs
//Achievement Mowed Down
// TO-DO: This should be done on the script of each vehicle of the BG.
// we must end the battleground
// All the node points are iterated to find the clicked one
// THIS SHOULD NEEVEER HAPPEN
// we set the new settings of the nodePoint
// this is just needed if the next banner is grey
// 1 minute for last change (real faction banner)
// if we are here means that the point has been lost, or it is the first capture
// if we are going to spawn the definitve faction banner, we dont need the timer anymore
// this should never happen
// we dont need iterating if we are here
// If the needChange bool was set true, we will handle the rest in the Update Map function.
//updating worldstate
// with this we are sure we dont bug the client
// this is only used in the update map function
// here is a special case, here we must return the definitve faction banner after the grey banner was spawned 1 minute
// there were no changes, this point has never been captured by any faction or at least clicked
// 1 returns the CONTESTED ALLIANCE BANNER, 3 returns the HORDE one
// If the actual banner is the definitive faction banner, we must return the grey banner of the player's faction
// If the actual banner is the grey faction banner, we must return the previous banner
// we should never be here...
// all the players on the stopped transport should be teleported out
//SF_LOG_ERROR("bg.battleground", "BG_IC_GO_HANGAR_BANNER CAPTURED Faction: %u", nodePoint->faction);
// we should spawn teleporters
// we must del opposing faction vehicles when the node is captured (unused ones)
// spawning glaive throwers
// spawning catapults
// we must del opposing faction vehicles when the node is captured (unused ones)
// is IsVehicleInUse working as expected?
// we check if the opossing siege engine is in use
// is VehicleInUse working as expected ?
/*player*/, GameObject* /*go*/, uint32 /*eventType*/) { }
// Is there any occupied node for this team?
// If so, select the closest node to place ghost on
// If not, place ghost on starting location
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//we must set messageIds
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// buff trigger?
// buff trigger?
// 9
//call parent's class reset
// gates
// buffs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//we must set messageIds
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// buff trigger?
// buff trigger?
// 9
//call parent's reset
// gates
// buffs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Open fire (only at game start)
// Fire got closed after five seconds, leaves twenty seconds before toggling pillars
// Buff respawn
// Elevators
// Should be false at first, TogglePillarCollision will do it.
/*player*/, uint64 /*guid*/, uint32 /*team*/)
// fire was removed in 3.2.0
//call parent's class reset
// elevators
// buffs
// fire
// Gear
// Pulley
// Pilars
// Pilars Collision
// Toggle visual pillars, pulley, gear, and collision based on previous state
// Forced collision toggle
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//! This is here to prevent an uninitialised variable warning
//! The warning only occurs when SetUpBattleGround fails though.
//! In the future this function should be called BEFORE sending initial worldstates.
// MAD props for Kiper for discovering those values - 4 hours of his work.
//Cannons and demolishers - NPCs are spawned
//By capturing GYs.
//Graveyards
//GY capture points
//Player may enter BEFORE we set up BG - lets update his worldstates anyway...
// set status manually so preparation is cast correctly in 2nd round too
// status was set to STATUS_WAIT_JOIN manually for Preparation, set it back now
//Time will be sent on first update...
//create score and add it to map, default values are set in constructor
//Without this player falls before boat loads...
/*player*/, uint64 /*guid*/, uint32 /*team*/) { }
/*Source*/, uint32 /*Trigger*/)
// this is wrong way to implement these things. On official it done by gameobject spell cast.
// player not found...
// should remove spirit of redemption
//Without this player falls before boat loads...
/*player*/, GameObject* go, uint32 eventType)
/*
// set flags only for the demolishers on the beach, factory ones dont need it
//Achievement Storm the Beach (1310)
//Achievement Storm the Beach (1310)
//honor reward for winning
//complete map_end rewards (even if no team wins)
// Demolisher is not in list
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// normal honor
// holiday
// normal honor
// holiday
// No one scored - result is tie
// Horde has more points and thus wins
// Alliance has > 0, Horde has 0, alliance wins
// Team score equal, winner is team that scored the last flag
// Last but not least, check who has the higher score
// first update needed after 1 minute of game already in progress
//10 minutes
// 15 minutes
//reset timer.
// players joining later are not eligible
//StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, TP_EVENT_START_BATTLE);
//create score and add it to map, default values are set in constructor
//when map_update will be allowed for battlegrounds this code will be useless
// flag respawned sound...
// must be before aura remove to prevent 2 events (drop+capture) at the same time
// horde flag in base (but not respawned yet)
// Drop Horde Flag from Player
// must be before aura remove to prevent 2 events (drop+capture) at the same time
// alliance flag in base (but not respawned yet)
// Drop Alliance Flag from Player
//for flag capture is reward 2 honorable kills
// flag state none
// only flag capture should be updated
// +1 flag captures
// update last flag capture to be used if teamscore is equal
// if not running, do not cast things at the dropper player (prevent spawning the "dropped" flag), neither send unnecessary messages
// just take off the aura
//alliance flag picked up from base
//update world state to show correct flag carrier
//horde flag picked up from base
//update world state to show correct flag carrier
//Alliance flag on ground(not in base) (returned or picked up again from ground!)
//called in HandleGameObjectUseOpcode:
//target_obj->Delete();
//Horde flag on ground(not in base) (returned or picked up again)
//called in HandleGameObjectUseOpcode:
//target_obj->Delete();
/*team*/)
// sometimes flag aura not removed :(
//uint32 SpellId = 0;
//uint64 buff_guid = 0;
// Alliance Flag spawn
// Horde Flag spawn
// Horde Tower
// Twin Peak House big
// Horde House
// Twin Peak House small
// Alliance Start right
// Alliance Start
// Alliance Start left
// Horde Start
// Horde Start Front entrance
// Horde Start left Water channel
//if (buff_guid)
//    HandleTriggerBuff(buff_guid, Source);
// flags X Y Z Orientation Rotation2 Rotation3
// buffs
// alliance gates
// horde gates
//call parent's class reset
// win reward
// complete map_end rewards (even if no team wins)
// player not found
// flags captured
// flags returned
// if status in progress, it returns main or start graveyards with spiritguides
// else it will return the graveyard in the flagroom - this is especially good
// if a player dies in preparation phase - then the player can't cheat
// and teleport to the graveyard outside the flagroom
// and start running around, while the doors are still closed
/*
//www.gnu.org/licenses/>.
//we must set messageIds
/*player*/, uint64 /*guid*/, uint32 /*team*/)
//call parent's class reset
// gates
// buffs
// player not found...
//there is nothing special in this score
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// these variables aren't used outside of this file, so declare them only here
// normal honor
// holiday
// No one scored - result is tie
// Horde has more points and thus wins
// Alliance has > 0, Horde has 0, alliance wins
// Team score equal, winner is team that scored the last flag
// Last but not least, check who has the higher score
// first update needed after 1 minute of game already in progress
//10 minutes
//15 minutes
//reset timer.
// players joining later are not eligibles
//create score and add it to map, default values are set in constructor
//when map_update will be allowed for battlegrounds this code will be useless
// flag respawned sound...
// must be before aura remove to prevent 2 events (drop+capture) at the same time
// horde flag in base (but not respawned yet)
// Drop Horde Flag from Player
// must be before aura remove to prevent 2 events (drop+capture) at the same time
// alliance flag in base (but not respawned yet)
// Drop Alliance Flag from Player
//for flag capture is reward 2 honorable kills
// flag state none
// only flag capture should be updated
// +1 flag captures
// update last flag capture to be used if teamscore is equal
// if not running, do not cast things at the dropper player (prevent spawning the "dropped" flag), neither send unnecessary messages
// just take off the aura
//alliance flag picked up from base
//update world state to show correct flag carrier
//horde flag picked up from base
//update world state to show correct flag carrier
//Alliance flag on ground(not in base) (returned or picked up again from ground!)
//called in HandleGameObjectUseOpcode:
//target_obj->Delete();
//Horde flag on ground(not in base) (returned or picked up again)
//called in HandleGameObjectUseOpcode:
//target_obj->Delete();
/*team*/)
// sometimes flag aura not removed :(
//uint32 SpellId = 0;
//uint64 buff_guid = 0;
// Alliance elixir of speed spawn. Trigger not working, because located inside other areatrigger, can be replaced by IsWithinDist(object, dist) in Battleground::Update().
//buff_guid = BgObjects[BG_WS_OBJECT_SPEEDBUFF_1];
// Horde elixir of speed spawn. Trigger not working, because located inside other areatrigger, can be replaced by IsWithinDist(object, dist) in Battleground::Update().
//buff_guid = BgObjects[BG_WS_OBJECT_SPEEDBUFF_2];
// Alliance elixir of regeneration spawn
//buff_guid = BgObjects[BG_WS_OBJECT_REGENBUFF_1];
// Horde elixir of regeneration spawn
//buff_guid = BgObjects[BG_WS_OBJECT_REGENBUFF_2];
// Alliance elixir of berserk spawn
//buff_guid = BgObjects[BG_WS_OBJECT_BERSERKBUFF_1];
// Horde elixir of berserk spawn
//buff_guid = BgObjects[BG_WS_OBJECT_BERSERKBUFF_2];
// Alliance Flag spawn
// Horde Flag spawn
// unk1
// unk2
// unk3
// unk4
//if (buff_guid)
//    HandleTriggerBuff(buff_guid, player);
// flags
// buffs
// alliance gates
// horde gates
//call parent's class reset
// Win reward
// Complete map_end rewards (even if no team wins)
// player not found
// flags captured
// flags returned
//if status in progress, it returns main graveyards with spiritguides
//else it will return the graveyard in the flagroom - this is especially good
//if a player dies in preparation phase - then the player can't cheat
//and teleport to the graveyard outside the flagroom
//and start running around, while the doors are still closed
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ITEM_QUALITY_POOR
// No round in older cpp, just for compatibility
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// highest quality client supports, currently players can not obtain legendary pets on retail
// client supports up to level 255 (uint8)
// update flag and spell state for new alt characters
// alert client of new Battle Pet loadout slot
// alert the client of a new Battle Pet
// this shouldn't happen since the client doesn't allow releasing of slotted Battle Pets
// alert client of deleted pet
/*WorldPacket data(SMSG_BATTLE_PET_JOURNAL_LOCK_DENINED, 0);
// packet size is over estimated
// placeholder
// BATTLE_PET_FLAG_NOT_ACCOUNT_BOUND
// unknown
// slots enabled
// unknown
// has slot number
// fake
// unknown
// unknown
// has slot number
// unknown
// unknown
// fake
// unknown
// BATTLE_PET_FLAG_NOT_ACCOUNT_BOUND
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Delete expired auctions
// Add New Auctions
// Select a template
// LastUpdateID
// ItemCount Placeholder
// MarketId
// Quantity
// AuctionId
// NumBids
// ItemEntry
// MinBid
// CurrentBid
// MinIncrement
// SellerNPC
// SecondsRemaining
// HIGHGUID_PLAYER always present, even for empty guids
// 6 - might be OK - 6 (win msg recvd)
// 4 - ItemEntry
// 5 - might be OK - 5 (win msg recvd)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// BagCount
// unEquip after sending
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//                                                       0   1        2      3            4     5        6          7
//                                                       0   1      2        3       4       5           6     7
/*= true*/, bool forceEventInviteAlertPacket /*= false*/)
// guild events only? check invite status here?
// When an event is deleted, all invited (accepted/declined? - verify) guildies are notified via in-game mail. (wowwiki)
/*remover*/)
// we need to find out how to use CALENDAR_INVITE_REMOVED_MAIL_SUBJECT to force client to display different mail
//if ((*itr)->GetInviteeGUID() != remover)
//    MailDraft(calendarEvent->BuildCalendarMailSubject(remover), calendarEvent->BuildCalendarMailBody())
//        .SendMailTo(trans, MailReceiver((*itr)->GetInvitee()), calendarEvent, MAIL_CHECK_MASK_COPIED);
// don't send mail if removing a character
// we are supposed to send PackedTime so i used WorldPacket to pack it
// true only if the invite is sign-up
// FIXME: Clear pendings
// Pre-invite
// correct?
// Lock Date?
// FIXME: Clear pendings
// FIXME: Clear pendings
// FIXME: Clear pendings
// FIXME: Clear pendings
// FIXME: Clear pendings
// Lock Date? Always 0
/*= NULL*/)
// FIXME: Command
// Send packet to all guild members
// Send packet to all invitees if event is non-guild, in other case only to non-guild invitees (packet was broadcasted for them)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// allow everything from console and RA console
// ignore only for non-players for non strong checks (when allow apply command at least to same sec level)
// caller must report error for (target == NULL && target_account == 0)
// non "" command
// "" part from non-"" command
// allow with any for ""
// need copy to prevent corruption by strtok call in LineFromMessage original string
// Chat output
// need copy to prevent corruption by strtok call in LineFromMessage original string
// Chat output
// need copy to prevent corruption by strtok call in LineFromMessage original string
// select subcommand from child commands list
// must be available and have handler
// table[i].Name == "" is special case: send original command to handler
// ignore console
// some commands have custom error messages. Don't send the default one in these cases.
// for data fill use full explicit command names
// select subcommand from child commands list (including "")
// fail with "" subcommands, then use normal level up command instead
// expected subcommand by full name DB content
// in case "" command let process by caller
/// chat case (.command or !command format)
/// ignore single . and ! in line
// original `text` can't be used. It content destroyed in command code processing.
/// ignore messages staring from many dots.
/// skip first . or ! (in console allowed use command with . and ! and without its)
/*
// more simple checks
// find next pipe command
// validate sequence
// must be available (ignore handler existence for show command with possible available subcommands)
// for empty subcmd show all available
// must be available (ignore handler existence for show command with possible available subcommands)
// have subcommand
// must be available (ignore handler existence for show command with possible available subcommands)
/*= ""*/, std::string const& receiverName /*= ""*/,
/*= 0*/, bool gmMessage /*= false*/, std::string const& channelName /*= ""*/,
/*= ""*/)
// HideInChatLog - only bubble shows
// Fake Bit
// Unk
// SendFakeTime - float later
// ChatFlags
// RealmID ?
// Fake Bit
// Fake Bit
// RealmID ?
// Fake Bit
// if (hasFakeTime)
//     data << float(fakeTime);
/*= 0*/, std::string const& channelName /*= ""*/, LocaleConstant locale /*= DEFAULT_LOCALE*/, std::string const& addonPrefix /*= ""*/)
// skip empty
// skip spaces
// return non link case
// [name] Shift-click form |color|linkType:key|h[name]|h|r
// or
// [name] Shift-click form |color|linkType:key:something1:...:somethingN|h[name]|h|r
// skip color
// end of data
// linktype
// end of data
// skip link tail (to allow continue strtok(NULL, s) use after retturn from function
// extract keys and values
// extract key
// extract something
// restart scan tail and skip name with possible spaces
// skip link tail (to allow continue strtok(NULL, s) use after return from function
// skip empty
// skip spaces
// return non link case
// [name] Shift-click form |color|linkType:key|h[name]|h|r
// or
// [name] Shift-click form |color|linkType:key:something1:...:somethingN|h[name]|h|r
// or
// [name] Shift-click form |linkType:key|h[name]|h|r
// skip color
// end of data
// tail
// skip first |
// linktype
// end of data
// extract keys and values
// extract key
// extract something
// restart scan tail and skip name with possible spaces
// skip link tail (to allow continue strtok(NULL, s) use after return from function
// skip link tail (to allow continue strtok(NULL, s) use after return from function
// guid is DB guid of object
// search near player then
// normal spell
// talent spell
// enchanting recipe spell
// profession/skill spell
// glyph
// number or [name] Shift-click form |color|Henchant:recipe_spell_id|h[prof_name: recipe_name]|h|r
// number or [name] Shift-click form |color|Hglyph:glyph_slot_id:glyph_prop_id|h[%s]|h|r
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r
// number or [name] Shift-click form |color|Htalent:talent_id, rank|h[name]|h|r
// number or [name] Shift-click form |color|Htrade:spell_id, skill_id, max_value, cur_value|h[name]|h|r
// talent
// unknown type?
// id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
// id case (explicit or from shift link)
// must be first for selection in not link case
// |color|Hcreature:creature_guid|h[name]|h|r
// |color|Hgameobject:go_guid|h[name]|h|r
// |color|Hplayer:name|h[name]|h|r
// unknown type?
// |color|Hplayer:name|h[name]|h|r
/*=NULL*/, std::string* player_name /*= NULL*/)
// if allowed player pointer
// if need guid value from DB (in name case for check player existence)
// if allowed player guid (if no then only online players allowed)
// if allowed player pointer
// if allowed player guid (if no then only online players allowed)
// some from req. data must be provided (note: name is empty if player not exist)
// skip non-console commands in console case
/*chr*/) const
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Supported shift-links (client generated and server side)
// |color|Hachievement:achievement_id:player_guid:0:0:0:0:0:0:0:0|h[name]|h|r
//                                                                        - client, item icon shift click, not used in server currently
// |color|Harea:area_id|h[name]|h|r
// |color|Hcreature:creature_guid|h[name]|h|r
// |color|Hcreature_entry:creature_id|h[name]|h|r
// |color|Henchant:recipe_spell_id|h[prof_name: recipe_name]|h|r          - client, at shift click in recipes list dialog
// |color|Hgameevent:id|h[name]|h|r
// |color|Hgameobject:go_guid|h[name]|h|r
// |color|Hgameobject_entry:go_id|h[name]|h|r
// |color|Hglyph:glyph_slot_id:glyph_prop_id|h[%s]|h|r                    - client, at shift click in glyphs dialog, GlyphSlot.dbc, GlyphProperties.dbc
// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
//                                                                        - client, item icon shift click
// |color|Hitemset:itemset_id|h[name]|h|r
// |color|Hplayer:name|h[name]|h|r                                        - client, in some messages, at click copy only name instead link
// |color|Hquest:quest_id:quest_level|h[name]|h|r                         - client, quest list name shift-click
// |color|Hskill:skill_id|h[name]|h|r
// |color|Hspell:spell_id|h[name]|h|r                                     - client, spellbook spell icon shift-click
// |color|Htalent:talent_id, rank|h[name]|h|r                              - client, talent icon shift-click
// |color|Htaxinode:id|h[name]|h|r
// |color|Htele:id|h[name]|h|r
// |color|Htitle:id|h[name]|h|r
// |color|Htrade:spell_id:cur_value:max_value:unk3int:unk3str|h[name]|h|r - client, spellbook profession icon shift-click
//uint32 size = uint32(iss.gcount());
/*context*/)
// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:0:reporter_level|h[name]|h|r
// |cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
// Read item entry
// Validate item
// Validate item's color
// Number of various item properties after item entry
// Validate random property
// |color|Hquest:quest_id:quest_level|h[name]|h|r
// |cff808080|Hquest:2278:47|h[The Platinum Discs]|h|r
// Read quest id
// Validate quest
// Check delimiter
// Read quest level
// Validate quest level
// |color|Hspell:spell_id|h[name]|h|r
// |cff71d5ff|Hspell:21563|h[Command]|h|r
// Read spell id
// Validate spell
// spells with that flag have a prefix of "$PROFESSION: "
// found the prefix, remove it to perform spellname validation below
// -2 = strlen(": ")
// |color|Hachievement:achievement_id:player_guid:0:0:0:0:0:0:0:0|h[name]|h|r
// |cffffff00|Hachievement:546:0000000000000001:0:0:0:-1:0:0:0:0|h[Safe Deposit]|h|r
// Read achievemnt Id
// Validate achievement
// Check delimiter
// Read HEX
// Skip progress
// |color|Htrade:spell_id:cur_value:max_value:player_guid:base64_data|h[name]|h|r
// |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
// Spell Id
// Validate spell
// Check delimiter
// Minimum talent level
// Check delimiter
// Maximum talent level
// Check delimiter
// Something hexadecimal
// Skip base64 encoded stuff
// |color|Htalent:talent_id:rank|h[name]|h|r
// |cff4e96f7|Htalent:2232:-1|h[Taste for Blood]|h|r
// Read talent entry
// Validate talent
// Validate talent's spell
// Delimiter
// Rank
// |color|Henchant:recipe_spell_id|h[prof_name: recipe_name]|h|r
// |cffffd000|Henchant:3919|h[Engineering: Rough Dynamite]|h|r
// Spell Id
// Validate spell
// |color|Hglyph:glyph_slot_id:glyph_prop_id|h[%s]|h|r
// |cff66bbff|Hglyph:21:762|h[Glyph of Bladestorm]|h|r
// Slot
// Check delimiter
// Glyph Id
// Validate glyph
// Validate glyph's spell
// pipe has always to be followed by at least one char
// no further pipe commands
// | in normal messages is escaped by ||
// no escaped pipes in sequences
// read chars up to colon = link type
// if h is next element in sequence, this one must contain the linked text :)
// links start with '['
// no further payload
// check if every opened sequence was also closed properly
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// set special flags if built-in channel
// check whether it's a built-in channel
// no join/leave announces
// no ownership handout
// for all built-in channels
// for trade channel
// for city only channels
// for LFG channel
// for all other channels
// it's custom channel
// If storing custom channels in the db is enabled either load or save the channel
//load
// save
// Do not send error message for built-in channels
//FIXME: Move to RBAC
// Custom channel handling
// Update last_used timestamp in db
// If the channel has no owner yet and ownership is allowed, set the new owner.
// Update last_used timestamp in db
// If the channel owner left and there are still playersStore inside, pick a new owner
// channel type?
// channel name
// channel flags?
// size of list, placeholder
// PLAYER can't see MODERATOR, GAME MASTER, ADMINISTRATOR characters
// MODERATOR, GAME MASTER, ADMINISTRATOR can see all
// flags seems to be changed...
// TODO: Add proper RBAC check
// [] will re-add player after it possible removed
/*guid1*/, uint64 /*guid2*/)
/*guid1*/, uint64 /*guid2*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// cross-faction
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//=================================================
// send threat to all my hateres for the victim
// The victim is hated than by them as well
// use for buffs and healing threat functionality
//=================================================
//=================================================
//=================================================
// The online / offline status is given to the method. The calculation has to be done before
//=================================================
// The online / offline status is calculated and set
//=================================================
// The references are not needed anymore
// tell the source to remove them from the list and free the mem
//=================================================
// delete one reference, defined by faction
//=================================================
// delete one reference, defined by Unit
//=================================================
// set state for one reference, defined by Unit
//=================================================
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//==============================================================
//================= ThreatCalcHelper ===========================
//==============================================================
// The hatingUnit is not used yet
/*hatingUnit*/, float threat, SpellSchoolMask schoolMask, SpellInfo const* threatSpell)
// Energize is not affected by Mods
//function deals with adding threat and adding players and pets into ThreatList
//mobs, NPCs, guards have ThreatList and HateOfflineList
//players and pets have only InHateListOf
//HateOfflineList is used co contain unattackable victims (in-flight, in-water, GM etc.)
// not to self
// not to GM
// not to dead and not for dead
// not in same map or phase
// spell not causing threat
//============================================================
//================= HostileReference ==========================
//============================================================
//============================================================
// Tell our refTo (target) object that we have a link
//============================================================
// Tell our refTo (taget) object, that the link is cut
//============================================================
// Tell our refFrom (source) object, that the link is cut (Target destroyed)
//============================================================
// Inform the source, that the status of the reference changed
//============================================================
// the threat is changed. Source and target unit have to be available
// if the link was cut before relink it again
// create a threat to the owner of a pet, if the pet attacks
//============================================================
// check, if source can reach target and set the status
// only check for online status if
// ref is valid
// target is no player or not gamemaster
// target is not in flight
// not accessible but stays online
//============================================================
// set the status and fire the event on status change
// if not online that not accessable as well
//============================================================
//============================================================
// prepare the reference for deleting
// this is called be the target
//============================================================
//============================================================
//================ ThreatContainer ===========================
//============================================================
//============================================================
// Return the HostileReference of NULL, if not found
//============================================================
// Add the threat, if we find the reference
//============================================================
//============================================================
// Check if the list is dirty and sort if necessary
//============================================================
// return the next best victim
// could be the current victim
// if the ref has status online the target must be there !
// some units are prefered in comparison to others
// current victim is a second choice target, so don't compare threat with it below
// if we reached to this point, everyone in the threatlist is a second choice target. In such a situation the target with the highest threat should be attacked.
// skip non attackable currently targets
// select 1.3/1.1 better target in comparison current target
// list sorted and and we check current target, then this is best case
// for second case, if currentvictim is attackable
//implement 110% threat rule for targets in melee range
//and 130% rule for targets in ranged distances
//for selecting alive targets
// select any
//============================================================
//=================== ThreatManager ==========================
//============================================================
//============================================================
//============================================================
// must check > 0.0f, otherwise dead loop
// Ref is not in the online refs, search the offline refs next
// there was no ref => create a new one
// threat has to be 0 here
// now we add the real threat
// GM is always offline
//============================================================
//============================================================
//============================================================
//============================================================
// Ok, temp threat is unused
//============================================================
//============================================================
//============================================================
// The hated unit is gone, dead or deleted
// return true, if the event is consumed
// now we can set the threat manager
// the order in the threat list might have changed
// Reset all aggro without modifying the threatlist.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Checks if object meets the condition
// Can have CONDITION_SOURCE_TYPE_NONE && !mReferenceId if called from a special event (ie: SmartAI)
// object not present, return false
// empty condition, always met
// don't allow 0 items (it's checked during table load)
// Returns true by default.
// build mask of types for which condition can return true
// this is used for speeding up gridsearches
// returns number of targets which are available for given source type
//     groupId, typeMask
// no point of having not loaded conditions in list
// group not filled yet, fill with widest mask possible
// no point of checking anymore, empty mask
// handle reference
// handle normal condition
// object will match conditions in one ElseGroupStore only when it matches all of them
// so, let's find a smallest possible mask which satisfies all conditions
// object will match condition when one of the checks in ElseGroupStore is matching
// so, let's include all possible masks
//     groupId, groupCheckPassed
//! Find ElseGroup in ElseGroupStore
//! If not found, add an entry in the store and set to true (placeholder)
//handle reference
//checked at loading, should never happen
//handle normal condition
//must clear all custom handled cases (groupped types) before reload
//it has a reference
//self referencing, skip
//check for useless data
//doesn't have reference, validate ConditionType
//it is a reference template
//make sure we have a list for our conditions, based on reference id
//add to reference storage
//end of reference templates
//if not a reference and SourceType is invalid, skip
//Grouping is only allowed for some types (loot templates, gossip menus, gossip items)
// handle grouped conditions
// do not add to m_AllocatedMemory to avoid double deleting
// do not add to m_AllocatedMemory to avoid double deleting
//! TODO: PAIR_32 ?
//handle not grouped conditions
//make sure we have a storage list for our SourceType
//add new empty list for SourceType
//make sure we have a condition list for our SourceType's entry
//add new Condition to storage based on Type/Entry
// check if effect is already a part of some shared mask
// build new shared mask with found effect
// some effect indexes should have same data
// get shared data
// there's already data entry for that sharedMask
// we have overlapping masks in db
// no data for shared mask, we can create new submask
// add new list, create new shared mask
// all effects were removed, no need to add the condition at all
// this is a BIG hack, feel free to fix it if you can figure out the ConditionMgr ;)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// params0, params1
// single disables here with optional data
// global disable map by source
// reload case
// checked later
// check only quests, rest already done at startup
// not disabled
// Spell is disabled on current map
// Spell is disabled on another map, but not this one, return false
// Spell is disabled in an area, but not explicitly our current mapId. Continue processing.
// Spell is disabled in this area
// Spell is disabled in another area, but not this one, return false
// Spell disabled for all maps
// call not from spellcast
//case DIFFICULTY_10MAN_FLEX:
//    return disabledModes & RAID_STATUSFLAG_10MAN_FLEX;
// Namespace
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*, &DB2Utilities::HasBroadcastTextEntry, &DB2Utilities::WriteBroadcastTextDbReply*/);
/*hash*/, DB2StorageBase*> DB2StorageMap;
// ASSERT must fail after function call
// compatibility format and C++ structure sizes
// mark as not available for speedup next checks
// sort problematic db2 to (1) non compatible and (2) nonexistent
// error checks
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*store*/, uint32 id)
/*store*/, uint32 id)
/*store*/, uint32 id, uint32 /*locale*/, ByteBuffer& buffer)
/*store*/, uint32 id, uint32 locale, ByteBuffer& buffer)
// item name
// other 3 names
// StatScalingFactor
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ordered by entropy; that way memcmp will have a minimal medium runtime
// for instances without generated *.map files
//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
// DBC used only for initialization sMapDifficultyMap at startup.
// only for loading
// store absolute bit position for first rank for talent inspect
// DBC used only for initialization sTaxiPathSetBySource at startup.
// DBC used only for initialization sTaxiPathNodeStore at startup.
// ASSERT must fail after function call
// compatibility format and C++ structure sizes
// mark as not available for speedup next checks
// sort problematic dbc to (1) non compatible and (2) non-existed
// must be after sAreaStore loading
// areaflag numbered from 0
// fill AreaId->DBC records
// fill MapId->DBC records (skip sub zones and continents)
//15595
/*, &CustomAchievementfmt, &CustomAchievementIndex*/);//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//18414
//18414
//15595
// 18414
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
// 15595
// 15595
// 15595
// 15595
// 15595
// 15595
//15595
// 15595
//LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     -- not used currently
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
// fill data
//map 0 is missingg from MapDifficulty.dbc use this till its ported to sql
//15595
//15595
//15595
//18414
//15595
//15595
// 18414
// 18414
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
// must be after sQuestPOIPointStore and sResearchSiteStore loading
//15595
//15595
//15595
//15595
//15595
//
/*, &CustomSpellEntryfmt, &CustomSpellEntryIndex*/);//
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
/*, &CustomSpellEffectEntryfmt, &CustomSpellEffectEntryIndex*/);//15595
//15595
// LoadDBC(availableDbcLocales, bad_dbc_files, sSpellDifficultyStore,        dbcPath, "SpellDifficulty.dbc", &CustomSpellDifficultyfmt, &CustomSpellDifficultyIndex);//15595 -- DBC gone, wtf blizzard ...
//15595
//15595
//18414
//17538
//17538
//15595
//15595
//15595
//15595
//15595
//15595
//15595
// Must be done when sSkillLineAbilityStore, sSpellStore, sSpellLevelsStore and sCreatureFamilyStore are all loaded
//15595
// Create Spelldifficulty searcher
//don't show error if spell is <= 0, not all modes have spells and there are unknown negative values
//spell was <= 0 or invalid, set to 0
//id0-1 must be always set!
// create talent spells set
// prepare fast data access to bit pos of talent ranks for use at inspecting
// now have all max ranks (and then bit amount used for store talent ranks in inspect)
// prevent memory corruption; otherwise cls will become 12 below
//15595
//15595
//## TaxiPathNode.dbc ## Loaded only for initialization different structures
//15595
// Calculate path nodes count
// 0 and some other indexes not used
// Set path length
// 0 and some other indexes not used
// fill data
// Initialize global taxinodes mask
// include existed nodes that have at least single not spell base (scripted) path
// not spell path
// valid taxi network node
// old continent node (+ nodes virtually at old continents, check explicitly to avoid loading map files for zone info)
// fix DK node at Ebon Hold and Shadow Vault flight master
//LoadDBC(availableDbcLocales, bad_dbc_files, sTeamContributionPointsStore, dbcPath, "TeamContributionPoints.dbc");
//15595
//15595
//15595
//15595
//15595
//15595
//15595
//15595
// error checks
// Check loaded DBC files proper version
// last area (areaflag) added in 5.4.8 (18414)
// last char title added in 5.4.8 (18414)
// last gem property added in 5.4.8 (18414)
// last map added in 5.4.8 (18414)
// last spell added in 5.4.8 (18414)
/*dbclang*/)
/*locale*/)
/*locale*/)
// speed for most cases
/*
// no need enum all maps from phasing
//LostIslands
//Gilneas
// if not listed then map coordinates (instance)
// at client map coords swapped
// client y coord from top to down
// if not listed then map coordinates (instance)
// client y coord from top to down
// client have map coords swapped
// pull new data
// used for level > max listed level case
// skip unrelated and too-high brackets
// exactly fit
// remember for possible out-of-range case (search higher from existed)
// two-handed weapons
/// Returns LFGDungeonEntry for a specific map and difficulty. Will return first found entry if multiple dungeons use the same map (such as Scarlet Monastery)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//case LFG_STATE_BOOT:
//    entry = LANG_LFG_STATE_BOOT;
//    break;
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// No break on purpose
/* = true */) const
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//case LFG_STATE_BOOT:
/// Load rewards for completing dungeons
// ORDER BY is very important for GetRandomDungeonReward!
/* = false */)
// Initialize Dungeon map with data from dbcs
// Fill teleport locations from DB
// Fill all other teleport coords from areatriggers
// No teleport coords in database, load from areatriggers
// Remove obsolete role checks
// Remove obsolete proposals
// Remove obsolete kicks
// Check if a proposal can be formed with the new groups being added
// FIXME lastProposalId ? lastProposalId +1 ?
// Update all players status queue info
/**
// Do not allow to change dungeon in the middle of a current dungeon
// Already in queue?
// Check player or group member restrictions
// Check if all dungeons are valid
// Only allow 1 random dungeon
// No break on purpose (Random can only be dungeon or heroic dungeon)
// it could be changed
// Expand random dungeons and check restrictions
// if we have lockmap then there are no compatible dungeons
// Can't join. Send result
// Only should show lockmap when have no dungeons available
// Begin rolecheck
// Create new rolecheck
// Send update to player
// Update leader role
// Add player to queue
// Send update to player
/**
// No player to update role = LFG_ROLECHECK_ABORTED
// Remove from Proposals
// Mark the player/leader of group who left as didn't accept the proposal
// Remove from queue - if proposal is found, RemoveProposal will call RemoveFromQueue
//case LFG_STATE_BOOT:
// Player
/**
/* = 0 */, uint8 roles /* = PLAYER_ROLE_NONE */)
// Player selected no role.
// Check if all players have selected a role
// use temporal var to check roles, CheckGroupRoles modifies the roles
/**
// Compare dungeon ids
// Don't remove the dungeon if team members are trying to continue a locked instance
/**
/**
// Set the dungeon difficulty
// Add the cooldown spell if queued for a random dungeon
// Teleport Player
// Update group info
/**
// Check if the proposal exists
// Check if proposal have the current player
// check if all have answered and reorder players (leader first)
// No answer (-1) or not accepted (0)
// Update timers
// Remove players/groups from Queue
/**
// Mark all people that didn't answered as no accept
// Mark players/groups to be removed
// Player didn't accept or still pending when no secs left
// Notify players
// Didn't accept or in same group that someone that didn't accept
// Remove players/groups from queue
// Readd to queue
/**
// Set votes
// Victim auto vote NO
// Kicker auto vote YES
// Notify players
/**
// Cheat check: Player can't vote twice
// if we don't have enough votes (agree or deny) do nothing
// Send update info to all players
// Vote passed - Kick player
/**
/*= false*/)
// Do not teleport players in dungeon to the entrance
// Select a player inside to be teleported to
/**
// Shouldn't happen. Do not reward multiple times
// Give rewards only if its a random dungeon
// Update achievements
// if we can take the quest, means that we haven't done this kind of "run", IE: First Heroic Random of Day.
// we give reward without informing client (retail does this)
// Give rewards
// --------------------------------------------------------------------------//
// Auxiliar Functions
// --------------------------------------------------------------------------//
/**
/**
// ordered properly at loading
/**
/*= true */)
// should never happen - We provide a list from sLFGDungeonStore
/* @todo VoA closed if WG is not under team control (LFG_LOCKSTATUS_RAID_LOCKED)
// If group is being formed after proposal success do nothing more
// Only for debugging purposes
// The Headless Horseman
// The Frost Lord Ahune
// Coren Direbrew
// The Crown Chemical Co.
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// No break on purpose
// No break on purpose
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/**
// need the guids in order to avoid duplicates
/**
/**
/**
// Lfg group not found, add this group to the queue.
/**
// Not previously cached, calculate
// Try to match with queued groups
/**
// Check for correct size
// Check all-but-new compatiblitity
// Check all-but-new compatibilities (New, A, B, C, D) --> check(A, B, C, D)
// Group not compatible
// Check if more than one LFG group and number of players joining
// Store group so we don't need to call Mgr to get it later (if it's player group will be 0 otherwise would have joined as group)
// Group with less that MAXGROUPSIZE members always compatible
// If it's single group no need to check for duplicate players, ignores, bad roles or bad dungeons as it's been checked before joining
// assing new roles
// Enough players?
// Create a new proposal
// Assing new leader
// Assing player data and roles
// Player from existing group, autoaccept
// Mark proposal members as not queued (but not remove queue data)
// Should not happen - just in case
/* = false */) const
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*loginFirst*/)
// Temporal: Trying to determine when group data and LFG data gets desynched
/// @todo - Restore LfgPlayerData and send proper status to player if it was in a group
// This function is also called when players log in
// if for some reason the LFG system recognises the player as being in a LFG dungeon,
// but the player was loaded without a valid group, we'll teleport to homebind to prevent
// crashes or other undefined behaviour
// Player have been kicked
/// @todo - Update internal kick cooldown of kicker
// If group is being formed after proposal success do nothing more
// LfgData: Remove player from group
//else if (state == LFG_STATE_BOOT)
// Update internal kick cooldown of kicked
// Teleport player out the dungeon
// Need more players to finish the dungeon
// No gguid ==  new group being formed
// No leader == after group creation first invite is new leader
// leader and no gguid == first invite after leader is added to new group (this is the real invite)
// namespace lfg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
///- Register the AreaTrigger for guid lookup and for caster
///- Remove the AreaTrigger from the accessor and from all lists of objects in world
//SetFloatValue(AREATRIGGER_FINAL_POS + 0, pos.GetPositionX());
//SetFloatValue(AREATRIGGER_FINAL_POS + 1, pos.GetPositionY());
//SetFloatValue(AREATRIGGER_FINAL_POS + 2, pos.GetPositionZ());
// expired
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
///- Register the corpse for guid lookup
///- Remove the corpse from the accessor
//we need to assign owner's map for corpse
//in other way we will get a crash in Corpse::SaveToDB()
// prevent DB data inconsistence problems and duplicates
// corpseGuid
// guid
// posX
// posY
// posZ
// orientation
// mapId
// displayId
// itemCache
// bytes1
// bytes2
// flags
// dynFlags
// time
// corpseType
// instanceId
// phaseMask
// Only specific bones
// all corpses (not bones)
//        0     1     2     3            4      5          6          7       8       9      10        11    12          13          14          15         16
// SELECT posX, posY, posZ, orientation, mapId, displayId, itemCache, bytes1, bytes2, flags, dynFlags, time, corpseType, instanceId, phaseMask, corpseGuid, guid FROM corpse WHERE corpseType <> 0
// place
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*e_time*/, uint32 /*p_time*/)
/*e_time*/, uint32 /*p_time*/)
// since we are here, we are not TempSummon as object type cannot change during runtime
//MELEE_RANGE;
// restore default loot mode
//if (m_uint32Values)
//    SF_LOG_ERROR("entities.unit", "Deconstruct Creature Entry = %u", GetEntry());
///- Register the creature for guid lookup
//SetVisibility(VISIBILITY_OFF);
//ObjectAccessor::UpdateObjectVisibility(this);
// Should get removed later, just keep "compatibility" with scripts
/**
/*team*/, const CreatureData* data)
// Initialize loot duplicate count depending on raid difficulty
// normal entry always
// map mode related always
// equal to player Race field, but creature does not have race
// known valid are: CLASS_WARRIOR, CLASS_PALADIN, CLASS_ROGUE, CLASS_MAGE
// Cancel load if no model defined
// Cancel load if no model defined
// Load creature equipment
// use default equipment (if available)
// override, 0 means no equipment
// at normal entry always
// using 1.0 rate
// using 1.0 rate
// Will set UNIT_FIELD_BOUNDING_RADIUS and UNIT_FIELD_COMBAT_REACH
// checked at loading
// creatures always have melee weapon ready if any unless specified otherwise
/// @todo Why is this treated as uint32 when it's a float?
// checked and error show at loading templates
// updates spell bars for vehicles and set player's faction - should be called here, to overwrite faction that is set from the new template
// this check comes in case we don't have a player
// vehicles should have same as owner faction
// trigger creature is always not selectable and can not be attacked
// Must not be called, see Creature::setDeathState JUST_RESPAWNED -> ALIVE promoting.
// Must not be called, see Creature::setDeathState JUST_DIED -> CORPSE promoting.
// First check if there are any scripts that object to us respawning
// Will be rechecked on next Update call
// Can respawn
// the master is dead
// if linking self, never respawn (check delayed to next day)
// else copy time from master and add a little
// also save to DB immediately
// deathstate changed on spells update, prevent problems
// creature can be dead after Unit::Update call
// CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
// if creature is charmed, switch to charmed AI (and back)
// do not allow the AI to be changed during update
// creature can be dead after UpdateAI call
// CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
// if IsInCombat() is true and this has no victim
// or the victim/owner/charmer is not a player
// or the victim/owner/charmer is not a GameMaster
/*if (m_regenTimer <= diff)
// regenerate health if not in combat or if polymorphed
// only increase the timer if not polymorphed
/*if (!bIsPolymorphed) // only increase the timer if not polymorphed
// if polymorphed, skip the timer
// Combat and any controlled creature
// Apply modifiers (if any).
// Not only pet, but any controlled creature
// Apply modifiers (if any).
//SetFeared(true, GetVictim()->GetGUID(), 0, sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY));
/// @todo use 31365
// make sure nothing can change the AI during AI update
// Initialize vehicle
//wait the order of leader
//! Relocate before CreateFromProto, to initialize coords and allow
//! returning correct zone id for selecting OutdoorPvP/Battlefield script
//oX = x;     oY = y;    dX = x;    dY = y;    m_moveTime = 0;    m_startMove = 0;
//! Need to be called after LoadCreaturesAddon - MOVEMENTFLAG_HOVER is set there
//! Relocate again with updated Z coord
// Cancel load if no model defined or if totem
/// @todo Replace with spell, handle from DB
/*else if (IsCivilian())
// set the player whose group should receive the right
// to loot the creature after it dies
// should be set to NULL after the loot disappears
// normal creature, no player involved
// return true if this creature is tapped by the player or by a member of his group.
// if we dont have a group we arent the recipient
// if creature doesnt have group bound it means it was solo killed by someone else
// this should only be used when the creature has already been loaded
// preferably after adding to map, because mapid may not be valid otherwise
// update in loaded data
// check if it's a custom model and if not, use 0 for displayId
// data->guid = guid must not be updated at save
// prevent add data integrity problems
// prevent add data integrity problems
// update in DB
// level
// health
// mana
//damage
//float damagemod = _GetDamageMod(rank);      // Set during loading templates into dmg_multiplier field
// define rates for each elite rank
// define rates for each elite rank
// define rates for each elite rank
//We should set first home position, because then AI calls home movement
// respawn on Update
// checked at creature_template loading
/*= true*/)
// Do not attack non-combat pets
//|| who->IsControlledByPlayer() && who->IsFlying()))
// we cannot check flying for other creatures, too much map/vmap calculation
/// @todo should switch to range attack
// "The maximum Aggro Radius has a cap of 25 levels under. Example: A level 30 char has the same Aggro Radius of a level 5 char on a level 60 mob."
// "The aggro radius of a mob having the same level as the player is roughly 20 yards"
// "Aggro Radius varies with level difference at a rate of roughly 1 yard/level"
// radius grow if playlevel < creaturelevel
// detect range auras
// detected range auras
// "Minimum Aggro Radius for a mob seems to be combat range (5 yards)"
// always save boss respawn time at death to prevent crash cheating
// remove target selection in any cases (can be set at aura remove in Unit::setDeathState)
//Dismiss group if is leader
//if (IsPet())
//    setActive(true);
//if (GetCreatureData() && GetPhaseMask() != GetCreatureData()->phaseMask)
//    SetPhaseMask(GetCreatureData()->phaseMask, false);
// Cancel load if no model defined
//Call AI respawn virtual function
//delay event to next tick so all creatures are created on the map before processing
//Re-initialize reactstate that could be altered by movementgenerators
/*= 0*/)
// Creature is immune to main mechanic of the spell
// This check must be done instead of 'if (GetCreatureTemplate()->MechanicImmuneMask & (1 << (spellInfo->Mechanic - 1)))' for not break
// the check of mechanic immunity on DB (tested) because GetCreatureTemplate()->MechanicImmuneMask and m_spellImmune[IMMUNITY_MECHANIC] don't have same data.
//if (!isInFront(victim, range) && spellInfo->AttributesEx)
//    continue;
// select nearest hostile unit within the given distance (regardless of threat list).
/* = false */) const
// select nearest hostile unit within the given attack distance (i.e. distance is ignored if > than ATTACK_DISTANCE), regardless of threat list.
// Pushing guids because in delay can happen some creature gets despawned => invalid pointer
/*= true*/) const
// is it true?
// we don't need help from zombies :)
// we don't need help from non-combatant ;)
// skip fighting creature
// only free creature
// only from same creature faction
// skip non hostile to caster enemy creatures
// use this function to avoid having hostile creatures attack
// friendlies and other mobs they shouldn't attack
// if the target cannot be attacked, the target is not acceptable
// guards can detect fake death
// if I'm already fighting target, or I'm hostile towards the target, the target is acceptable
// if the target's victim is friendly, and the target is neutral, the target is acceptable
// if the target's victim is not friendly, or the target is friendly, the target is not acceptable
// this should not be called by petAI or
/*force*/) const
//Use AttackDistance in distance check if threat radius is lower. This prevents creature bounce in and out of combat every update tick.
// dependent from difficulty mode entry
//creature_addon table
// 0 StandState
// 1 FreeTalentPoints   Pet only, so always 0 for default creature
// 2 StandFlags
// 3 StandMiscFlags
//SetByteValue(UNIT_FIELD_ANIM_TIER, 1, uint8((cainfo->bytes1 >> 8) & 0xFF));
//! Suspected correlation between UNIT_FIELD_ANIM_TIER, offset 3, value 0x2:
//! If no inhabittype_fly (if no MovementFlag_DisableGravity or MovementFlag_CanFly flag found in sniffs)
//! Check using InhabitType as movement flags are assigned dynamically
//! basing on whether the creature is in air or not
//! Set MovementFlag_Hover. Otherwise do nothing.
// 0 SheathState
// 1 Bytes2Flags
// 2 UnitRename         Pet only, so always 0 for default creature
// 3 ShapeshiftForm     Must be determined/set by shapeshift spell/aura
//SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1, uint8((cainfo->bytes2 >> 8) & 0xFF));
//SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 2, uint8((cainfo->bytes2 >> 16) & 0xFF));
//SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 3, uint8((cainfo->bytes2 >> 24) & 0xFF));
//Load Path
// skip already applied aura
/// Send a message to LocalDefense channel for players opposition team in the zone
// Not send cooldown for this spells
//broke before end of iteration of known spells
// corpse skinnable, but without skinning flag, and then skinned, corpse will despawn next update
// overwrite WorldObject function for proper name localization
//Do not if this works or not, moving creature to another map is very dangerous
// prevent crash when a bad coord is sent by the client
// Determines the aggro range for creatures (usually pets), used mainly for aggressive pet target selection.
// Based on data from wowwiki due to lack of 3.3.5a data
// The maximum Aggro Radius is capped at 45 yards (25 level difference)
// The base aggro radius for mob of same level
// Aggro Radius varies with level difference at a rate of roughly 1 yard/level
// detect range auras
// detected range auras
// Just in case, we don't want pets running all over the map
// Minimum Aggro Radius for a mob seems to be combat range (5 yards)
//  hunter pets seem to ignore minimum aggro radius so we'll default it a little higher
// Default
// Selects nearest hostile target within creature's aggro range. Used primarily by
//  pets set to aggressive. Will not return neutral or friendly targets.
// Do not update movement flags if creature is controlled by a player (charm/vehicle)
// Set the movement flags if the creature is in that mode. (Only fly if actually in air, only swim if in water, etc)
// Can be underground too, prevent the falling
// already focused
// Set serverside orientation if needed (needs to be after attribute check)
// focused to something else
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//Add member to an existing group
//Create new group
// for reload case
//Get group data
//Load group member data
//If creature is group leader we may skip loading of dist/angle
// check data correctness
//Check if it is a leader
// avoid crash if leader was killed and reset.
// Skip self
//! To do: This should probably get its own movement generator or use WaypointMovementGenerator.
//! If the leader's path is known, member's path can be plotted as well using formation offsets.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*= false*/)
// Find a free new id - script case
/**
/// Find items for given menu id.
/// Return if there are none.
/// Iterate over each of them.
/// Find the one with the given menu item id.
/// Store texts for localization.
/// Check need of localization.
/// Find localizations from database.
/// Translate texts if there are any.
/// Add menu item with existing method. Menu item id -1 is also used in ADD_GOSSIP_ITEM macro.
// Guessed
// max count 0x20
// Store this instead of checking the Singleton every loop iteration
// max count 0x10
// money required to open menu, 2.0.3
// accept text (related to money) pop up box, 2.0.
// makes pop up box password
// text for gossip item
// new 2.4.0
//FriendshipFactionID
// guess size
/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/
// can be set for max from most often sizes to speedup push_back and less memory use
// guess size
// NPC emote
// player emote
// Store this instead of checking the Singleton every loop iteration
// quest ender guid?
// guess size
/// SpellCompletionID
/// StartCheat
/// DisplayPopup
/// Learned Spells
// DetailsEmoteDelay (in ms)
/// Learned Spells (uint32 vector)
// guess size
// has data
// values need rechecking and zero values need more research
// bonus talents
// columnid+1 QuestFactionReward.dbc?
// unknown usage
// reward factions ids
// reward money (below max lvl)
// used in XP calculation at client
// rewarded honor points
// reward skill points
// suggested players count
// quest id
// min level
// rep mask (unsure on what it does)
// may be -1, static data, in other cases must be used dynamic level: Player::GetQuestLevel (0 is not known, but assuming this is no longer valid for quest intended for client)
// Accepted values: 0, 1 or 2. 0 == IsAutoComplete() (skip objectives/details)
// seems to always have the same value as the first XP ID field
// casted spell
// unknown
// unknown
// quest type
// used for calculating rewarded experience
// unknown
// unknown
// client will request this quest from NPC, if not 0
// unknown
// unknown
// CharTitleId, new 2.4.0, player gets this title (id from CharTitles)
// zone or sort to display in quest log
// reward skill id
// reward spell, this spell will display (icon) (casted if RewSpellCast == 0)
// unknown
// quest flags
// source item id
// guess size
// ender NPC or GO entry
/// SpellCompletionID
// We can always call to RequestItems, but this packet only goes out if there are actually
// items.  Otherwise, we'll skip straight to the OfferReward
/// It's CompEmoteDelay, but not sure if send right value
///Status flags: (v10 = (v9 >> 1) & 1 && (v9 >> 2) & 1 && (v9 >> 3) & 1 && (v9 >> 4) & 1 && (v9 >> 6) & 1;)
// quest starter NPC/GO entry
// Adds the quest level to the front of the quest title
// example: [13] Westfall Stew
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// if m_deathState is DEAD, CORPSE was skipped
// if m_deathState is DEAD, CORPSE was skipped
// if m_deathState is DEAD, CORPSE was skipped
// properties should be vehicle
//ASSERT(!IsPet());
/*e_time*/, uint32 /*p_time*/)
//if (GetOwnerGUID())
//    SF_LOG_ERROR("entities.unit", "Unit %u has owner guid when removed from world", GetEntry());
/// @todo: Find correct way
//maybe true?
//check if caster is channelling?
/// @todo why long distance .die does not remove it
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// make sure all references were properly removed
///- Register the dynamicObject for guid lookup and for caster
///- Remove the dynamicObject from the accessor and from all lists of objects in world
// dynobj could get removed in Aura::RemoveAura
//must before add to map to be put in world container
// caster has to be always available and in the same map
// _aura may be set to null in Aura::UpdateOwner call
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// restore default loot mode
//if (m_uint32Values)                                      // field array can be not exist if GameOBject not loaded
//    CleanupsBeforeDelete();
/*finalCleanup*/)
// field array can be not exist if GameOBject not loaded
///- Register the gameobject for guid lookup
// The state can be changed after GameObject::Create but before GameObject::AddToWorld
///- Remove the gameobject from the accessor
// GAMEOBJECT_FACING, GAMEOBJECT_ROTATION, GAMEOBJECT_FIELD_PARENT_ROTATION+2/3
// set name for logs usage, doesn't affect anything ingame
// GAMEOBJECT_FIELD_STATE_SPELL_VISUAL_ID, index at 0, 1, 2 and 3
// Initialize loot duplicate count depending on raid difficulty
// Arming Time for GAMEOBJECT_TYPE_TRAP (6)
// Bombs
// Hardcoded tooltip value
/* TODO: Fix movement in unloaded grid - currently GO will just disappear
// fishing code (bobber ready)
// splash bobber (bobber ready now)
// can be successfully open with some chance
// for other GOis same switched without delay to GO_READY
// NO BREAK for switch (m_lootState)
// timer on
// timer expired
// Can't respawn, the master is dead
// if linking self, never respawn (check delayed to next day)
// else copy time from master and add a little
// also save to DB immediately
//  can't fish now
// can be delete
//we need to open doors if they are closed (add there another condition if this code breaks some usage, but it need to be here for battlegrounds)
// Initialize a new max fish count on respawn
// despawn timer
// can be despawned or destroyed
// respawn timer
// traps can have time and can not have
// Type 2 - Bomb (will go away after casting it's spell)
// FIXME: null target won't work for target type 1
// Type 0 and 1 - trap (type 0 will not get removed after casting a spell)
// pointer to appropriate target if found any
//FIXME: this is activation radius (in different casting radius that must be selected from spell data)
/// @todo move activated state code (cast itself) to GO_ACTIVATED, in this place only check activating and set state
/// @todo rename radius to diameter (goInfo->trap.radius) should be (goInfo->trap.diameter)
// cast in other case (at some triggering/linked go/etc explicit call)
// battlegrounds gameobjects has data2 == 0 && data5 == 3
// Note: this hack with search required until GO casting not implemented
// search unfriendly creature
// hunter trap
// environmental trap
// environmental damage spells already have around enemies targeting but this not help in case not existed GO casting support
// affect only players
// some traps do not have spell but should be triggered
// template or 4 seconds
//Battleground gameobjects case
// can be despawned or destroyed
//if Gameobject should cast spell, then this, but some GOs (type = 10) should be destroyed
// m_unique_users can contain only player GUIDs
//any return here in case battleground traps
//! If this is summoned by a spell with ie. SPELL_EFFECT_SUMMON_OBJECT_WILD, with or without owner, we check respawn criteria based on spell
//! The GetOwnerGUID() check is mostly for compatibility with hacky scripts - 99% of the time summoning should be done trough spells.
//burning flags in some battlegrounds, if you find better condition, just add it
//reset flags
// if option not set then object will be saved at grid unload
// not refresh despawned not casted GO (despawned casted GO destroyed in all cases anyway)
// if subzone loot exist use it
// else use zone loot (must exist in like case)
// this should only be used when the gameobject has already been loaded
// preferably after adding to map, because mapid may not be valid otherwise
// update in loaded data (changing data only in this place)
// data->guid = guid must not be updated at save
// Update in DB
//uint32 map_id = data->mapid;                          // already used before call
// ready to respawn
/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/
// If something is marked as a transport, don't transmit an out of range packet for it.
// is Dynamic transport = non-stop Transport
// If something is marked as a transport, don't transmit an out of range packet for it.
// Always seen by owner and friendly units
// Despawned
// scan GO chest with loot including quest items
// checked at load already
// search nearest linked GO
// using original GO distance
// found correct GO
/* = false */, Unit* user /*=NULL*/)
/* = false */)
//if closed -> open
//if open -> close
// by default spell caster is user
// If cooldown data present in template
//0
//1
//doors/buttons never really despawn, only reset to default state/flags
//2
//6
// template or 4 seconds
// Deactivate after trigger
//Sitting: Wooden bench, chairs enzz
//7
// this is called once at first chair use to make list of available slots
// sometimes chairs in DB have error in fields and we dont know number of slots
// Last user of current slot set to 0 (none sit here yet)
// error in DB, make one default slot
// a chair may have n slots. we have to calculate their positions and teleport the player to the nearest one
// the object orientation + 1/2 pi
// every slot will be on that straight line
// find nearest slot
// the distance between this slot and the center of the go - imagine a 1D space
// This seat is already occupied by ChairUser. NOTE: Not sure if the ChairUser->getStandState() != UNIT_STAND_STATE_SIT check is required.
// This seat is unoccupied.
// The seat may of had an occupant, but they're offline.
// calculate the distance between the player and this slot
//this slot in now used by player
//big gun, its a spell/aura
//10
// show page...
// possible quest objective for active quests
//Quest require to be active for GO using
// this appear to be ok, however others exist in addition to this that should have custom (ex: 190510, 188692, 187389)
// cast this spell later if provided
//13
//fishing bobber
//17
// ready for loot
//provide error, no fishable zone or area should be 0
// but you will likely cause junk in areas that require a high fishing skill (not yet implemented)
/// @todo I do not understand this hack. Need some explanation.
// prevent removing GO at spell cancel
/// @todo find reasonable value for fishing hole search
/// @todo else: junk
// nothing to do, will be deleted at next update
//18
// ritual owner is set for GO's without owner (not summoned)
// accept only use by player from same group as owner, excluding owner itself (unique use already added in spell effect)
// expect owner to already be channeling, so if not...
// in case summoning ritual caster is GO creator
// for this case, summoningRitual.spellId is always triggered
// full amount unique participants including original summoner
// GO store nonexistent spell, replace by expected
// spell have reagent and mana cost but it not expected use its
// it triggered spell in fact casted at currently channeled GO
// Cast casterTargetSpell at a random GO user
// on the current DB there is only one gameobject that uses this (Ritual of Doom)
// and its required target number is 1 (outter for loop will run once)
// No idea why this field is a bool in some cases
// m_unique_users can contain only player GUIDs
// finish owners spell
// can be deleted now, if
// reset ritual for this GO
// go to end function to spell casting
//22
//23
// accept only use by player from same raid as caster, except caster itself
//required lvl checks!
// Ritual of Summoning
// Summoning Stone Effect
// 24
// in battleground check
// BG flag click
// AB:
// 15001
// 15002
// 15003
// 15004
// 15005
//we don;t need to delete flag ... it is despawned!
// 25
// 26
// in battleground check
// BG flag dropped
// WS:
// 179785 - Silverwing Flag
// 179786 - Warsong Flag
// EotS:
// 184142 - Netherstorm Flag
// Silverwing Flag
// Warsong Flag
// Netherstorm Flag
//this cause to call return, all flags must be deleted here!!
//32
// fallback, will always work
//summon world trigger
// needed for GO casts for proper target validation checks
// Set owner guid for target if no owner available - needed by trigger auras
// - trigger gets despawned and there's no caster avalible (see AuraEffect::TriggerSpell())
//unk
//! Check if the distance between the 2 objects is 0, can happen if both objects are on the same position.
//! The code below this check wont crash if dist is 0 because 0/0 in float operations is valid, and returns infinite
// overwrite WorldObject function for proper name localization
/*=0.0f*/, float rotation3 /*=0.0f*/)
//float f_rot2 = std::sin(0.0f / 2.0f);
//int64 i_rot2 = f_rot2 / atan(pow(2.0f, -20.0f));
//rotation |= (((i_rot2 << 22) >> 32) >> 11) & 0x000003FFFFE00000;
//float f_rot3 = std::sin(0.0f / 2.0f);
//int64 i_rot3 = f_rot3 / atan(pow(2.0f, -21.0f));
//rotation |= (i_rot3 >> 42) & 0x7FFFFC0000000000;
/*= NULL*/, uint32 spellId /*= 0*/)
// prevent double destructions of the same object
// Set the health bar, value = 255 * healthPct;
// dealing damage, send packet
// change  < 0 triggers SPELL_BUILDING_HEAL combat log event
// change >= 0 triggers SPELL_BUILDING_DAMAGE event
/*= NULL*/, bool setHealth /*= false*/)
// the user calling this must know he is already operating on destructible gameobject
// in this case current health is 0 anyway so just prevent crashing here
// restores to full health
// Use the current go state
// startOpen determines whether we are going to add or remove the LoS on activation
/*if (enable && !GetMap()->ContainsGameObjectModel(*m_model))
// set the player whose group should receive the right
// to loot the creature after it dies
// should be set to NULL after the loot disappears
// normal creature, no player involved
// if we dont have a group we arent the recipient
// if go doesnt have group bound it means it was solo killed by someone else
// other cases
/* = NULL*/) const
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//not enough for  spell
//new spell
// free slot
// spell casted only if fit form requirement, in other case will casted at form change
// can be in case now enough skill requirement for set appling but set has been appliend when skill requirement not enough
// enough for spell
// spell can be not active if not fit form requirement
//all items of a set were removed
// Returns true if Item is a bag AND it is not empty.
// Returns false if Item is not a bag OR it is an empty bag.
// save new time in database
// reforge Id
// Transmogrification Id
// Delete the items if this is a container
//                                                    0                1      2         3        4      5             6                 7  8          9               10          11          12
//result = CharacterDatabase.PQuery("SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, reforgeId, transmogrifyId, durability, playedTime, text FROM item_instance WHERE guid = '%u'", guid);
// create item before any checks for store correct guid
// and allow use "FSetState(ITEM_REMOVED); SaveToDB();" for deleting item from DB
// Set entry, MUST be before proto check
// set owner (not if item is only loaded for gbank/auction/mail
// need explicit save data at load fixes
// update duration if need, and remove if not need
// Remove bind flag for items vs NO_BIND set
// recalculate suffix factor
// update max durability (and durability) if need
// normal item changed state set not work at loading
/*static*/
// Delete the items if this is a container
/*static*/
// item must have one from this field values not null if it can have random enchantments
// item can have not null only one from field values
// RandomProperty case
// RandomSuffix case
// pretend the item never existed
// new items must stay in new state until saved
// unset in queue
// the item must be removed from the queue manually
// Check all enchants for required skill
// not holding enchantment id
// Check all enchants for soulbound
// not holding enchantment id
// not allow merge looting currently items
// check item type
// check free space (full stacks can't be target of merge
// -1 == any item class
// Special case - accept vellum for armor/weapon requirements
// only for enchanting spells
//  wrong item class
// 0 == any subclass
// subclass not present in mask
// 0 == any inventory type
// Special case - accept weapon type for main and offhand requirements
// inventory type not present in mask
/*= 0*/)
// Better lost small time at check in comparison lost time at item save to DB.
// Cannot use GetOwner() here, has to be passed as an argument to avoid freeze due to hashtable locking
// no socket slot
// no gems on this socket
// invalid gem id on this socket
// bad gem color on this socket
// Though the client has the information in the item's data field,
// we have to send SMSG_ITEM_TIME_UPDATE to display the remaining
// time.
//don't create item at zero count
// player CAN be NULL in which case we must not update random properties because that accesses player's item update queue
// not binded item
// own item
// BOA item case
/*=true*/, SQLTransaction* trans /*=NULL*/)
// Following is not applicable in the trading procedure
/*  Here we update our played time
// Get current played time
// Calculate time elapsed since last played time update
// Check if the refund timer has expired yet
// No? Proceed.
// Update the data field
// Flag as changed to get saved to DB
// Speaks for itself
// Yes
// called from owner's update - GetOwner() MUST be valid
// remove from tradeable list
// source
// dest
// used by mail items, transmog cost, stationeryinfo and others
// it only has two rows, it's unclear which is the one used
/*= 10000*/)
// Saves the money and item loot associated with an openable item to the DB
// no money and no loot
// Save this for when a LootItem is removed
// Save money
// Save items
// Now insert the items
// When an item is looted, it doesn't get removed from the items collection
//  but we don't want to resave it.
// container_id, item_id, item_count, follow_rules, ffa, blocked, counted, under_threshold, needs_quest, rnd_prop, rnd_suffix
// Loads the money and item loot associated with an openable item from the DB
// Default. If there are no records for this item then it will be rolled for in Player::SendLoot()
// Save this for later use
// First, see if there was any money loot. This gets added directly to the container.
// Next, load any items that were saved
// Get a LootTemplate for the container item. This is where
//  the saved loot was originally rolled from, we will copy conditions from it
// Create an empty LootItem
// Fill in the rest of the LootItem from the DB
// item_id, itm_count, follow_rules, ffa, blocked, counted, under_threshold, needs_quest, rnd_prop, rnd_suffix
// Copy the extra loot conditions from the item in the loot template
// If container item is in a bag, add that player as an allowed looter
// Finally add the LootItem to the container
// Increment unlooted count
// Mark the item if it has loot so it won't be generated again on open
// Deletes items associated with an openable item from the DB
// Deletes a single item associated with an openable item from the DB
// Deletes the money loot associated with an openable item from the DB
// Deletes money and items associated with an openable item from the DB
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// for reload case
//                                                 0      1      2
//we could get here only if sum of all enchantment chances is lower than 100%
// Items of that type don`t have points
// Select point coefficient
// Select rare/epic modifier
// not have random properties
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Setting the number of Slots the Container has
// Cleaning 20 slots
// checked in Item::LoadFromDB
// cleanup bag content related item value fields (its will be filled correctly from `character_inventory`)
/*update*/)
/*update*/)
// If the bag is empty returns true
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//case HIGHGUID_CONTAINER:    return TYPEID_CONTAINER; HIGHGUID_CONTAINER == HIGHGUID_ITEM currently
// unknown
// this may happen because there are many !create/delete
// synchronize values mirror with values array (changes will send in updatecreate opcode any way
// if we remove from world then sending changes not required
/** lower flag1 **/
// building packet for yourself
// UPDATETYPE_CREATE_OBJECT2 for some gameobject types...
// send create update to player
//! If the following bool is true, the client will call "void CGUnit_C::OnDeath()" for this object.
//! OnDeath() does for eg trigger death animation and interrupts certain spells/missiles/auras/sounds...
// 676  UPDATEFLAG_HAS_GAMEOBJECT          // NEW
// 498  UPDATEFLAG_ANIMKITS                // OLD
/*flags & UPDATEFLAG_ANIMKITS*/);    // 498  UPDATEFLAG_ANIMKITS                // OLD
// 368  UPDATEFLAG_LIVING                  // OLD
// 810  UPDATEFLAG_SCENE_LOCAL_SCRIPT_DATA // NEW
// 1068 UPDATEFLAG_TRANSPORT_FRAME_COUNT   // NEW
// 488  UPDATEFLAG_VEHICLE                 // OLD
// 1044 UNK
// 476  UPDATEFLAG_TRANSPORT               // OLD
// 512  UPDATEFLAG_ROTATION                // OLD
// 680  UPDATEFLAG_SELF                    // OLD
// 464  UPDATEFLAG_HAS_TARGET              // OLD
// 1032 UPDATEFLAG_SCENE_OBJECT            // NEW
// 1064 UPDATEFLAG_SCENE_PENDING_INSTANCES // NEW
// 668  UPDATEFLAG_HAS_AREATRIGGER         // NEW
// 424  UPDATEFLAG_GO_TRANSPORT_POSITION   // OLD
// 681  UPDATEFLAG_REPLACE_YOU             // NEW
// 448  UPDATEFLAG_STATIONARY_POSITION     // OLD
// 368
//!G3D::fuzzyEq(self->GetOrientation(), 0.0f)
// Forces
// 1032 {}
// 424
// 668 {}
/*
// Missing AnimKit1
// Missing AnimKit2
// Missing AnimKit3
// 464
// 1064 {}
// 810 {}
// 1068 {}
// 1032 {}
// 668
// 464
// 676 {}
/*
// 810 {}
// 1064 {}
// 1044 {}
// Only handle Item type
// TODO: Implement Player dynamis fields
// Dynamic Fields (5.0.5 MoP new fields)
// Always 1 or (1<<i)?
// ASSERT must fail after function call
/*finalCleanup*/)
/*= true*/) const
/*= true*/) const
/*float x, y, z;
/* = true */) const
/* = true */) const
// check only for real range
// check only for real range
// check only for real range
// Return angle in range 0..2*pi
// always have self in arc
// move arc to range 0.. 2*pi
// move angle to range -pi ... +pi
// in range -pi..0
// in range 0..pi
// not using sqrt() for performance
// not using sqrt() for performance
// angle to face `obj` to `this`
// update to LOS height if available
// just to be sure that we are not a few pixel under the surface
// non fly unit don't must be in air
// non swim unit must be at ground (mostly speedup, because it don't must be in water and water level check less fast
// for server controlled moves playr work same as creature (but it can always swim)
// Cheap way to check for ghost state
// GM visibility off or hidden NPC
// Stop checking other things for GMs
// Ghost players, Spirit Healers, and some other NPCs
// Alive players can see dead players in some cases, but other objects can't do that
// Pets don't have detection, they use the detection of their masters
// Check for not detected types
// Too low value to detect
// Combat reach is the minimal distance (both in front and behind),
//   and it is also used in the range calculation.
// One stealth point increases the visibility range by 0.3 yard.
// Starting points
// Level difference: 5 point / level, starting from level 1.
// There may be spells for this and the starting points too, but
// not in the DBCs of the client.
// Apply modifiers
// Calculate max distance
// ToSelf ignored in this case
/// @todo i_object.GetName() also must be localized?
/// @todo i_object.GetName() also must be localized?
// namespace Skyfire
/*self*/)
// command add npc: first create, than loadfromdb
//maybe not for corpse
//m_mapId = 0;
//m_InstanceId = 0;
/*= NULL*/, uint32 duration /*= 0*/, Unit* summoner /*= NULL*/, uint32 spellId /*= 0*/, uint32 vehId /*= 0*/)
// Mirror Image, Summon Gargoyle
//ObjectAccessor::UpdateObjectVisibility(summon);
/**
/*= NULL*/)
/*vehId*/) const
/*= 0*/, TempSummonType spwtype /*= TEMPSUMMON_MANUAL_DESPAWN*/, uint32 despwtime /*= 0*/) const
//not sure how to handle this
//summon->SetName(GetName());
/**
/*= NULL*/)
/*
// skip self or target
// skip self or target
// we must add used pos that can fill places around center
// u is too nearest/far away to i_object
// move angle to range -pi ... +pi
// dist include size of u
// namespace Skyfire
//===================================================================================================
/*searcher*/, float &x, float &y, float &z, float searcher_size, float distance2d, float absAngle) const
/*
// update to LOS height if available
// or remember first point
// first point LOS problems
// prepare selector for work
// adding used positions around object
// maybe can just place in primary position
// update to LOS height if available
// first point have LOS problems
// candidate of angle for free pos
// special case when one from list empty and then empty side preferred
// update to LOS height if available
// set first used pos in lists
// select in positions after current nodes (selection one by one)
// angle for free pos
// update to LOS height if available
// BAD NEWS: not free pos (or used or have LOS problems)
// Attempt find _used_ pos without LOS problem
// update to LOS height if available
// special case when one from list empty and then empty side preferred
// _used_ pos
// update to LOS height if available
// set first used pos in lists
// select in positions after current nodes (selection one by one)
// angle for used pos but maybe without LOS problem
// update to LOS height if available
// BAD BAD NEWS: all found pos (free and used) have LOS problem :(
// update to LOS height if available
/*= 0*/, float angle /*= 0*/) const
// angle calculated from current orientation
/*= CONTACT_DISTANCE*/) const
// angle to face `obj` to `this` using distance includes size of `obj`
// Prevent invalid coordinates here, position is unchanged
// do not allow too big z changes
// we have correct destz now
// Prevent invalid coordinates here, position is unchanged
// collision occured
// move back a bit
// check dynamic collision
// Collided with a gameobject
// do not allow too big z changes
// we have correct destz now
// Clear all terrain swaps, will be rebuilt below
// Reason for this is, multiple phases can have the same terrain swap, we should not remove the swap if another phase still use it
// Check all applied phases for terrain swap and add it only once
// only add terrain swaps for current map
// get default terrain swaps, only for current map always
// online players have a game client with world map display
// Clear all world map area swaps, will be rebuilt below
// get ALL default terrain swaps, if we are using it (condition is true) 
// send the worldmaparea for it, to see swapped worldmaparea in client from other maps too, not just from our current
// Check all applied phases for world map area swaps
// add new phase if condition passed, true if it wasnt added before
// condition failed, remove phase, true if there was something removed
// not in area, remove phase, true if there was something removed
// do not remove a phase if it would be removed by an area but we have the same phase from an aura
// only update visibility and send packets if there was a change in the phase list
// only update visibilty once, to prevent objects appearing for a moment while adding in multiple phases
// do not run the updates if we are already in this phase
// do not run the updates if we are not in this phase
// PhaseId 169 is the default fallback phase
//Temp Speshul Tactics 
/*= NULL*/)
/*= NULL*/)
/// @todo this is for puppet
/*forced*/)
//updates object's visibility for nearby players
//Caster may be NULL if DynObj is in removelist
// Only send update once to a player
//we must build packets for all visible players
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// calculate next possible angle
// calculate next possible angle
// ++ direction less updated
// increase. only at fail (original or checked)
// -- direction less updated
// both list empty
// -- direction less updated
// no angles
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// shouldn't happen
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// ITEM_FIELD_OWNER + 0
// ITEM_FIELD_OWNER + 1
// ITEM_FIELD_CONTAINED_IN + 0
// ITEM_FIELD_CONTAINED_IN + 1
// ITEM_FIELD_CREATOR + 0
// ITEM_FIELD_CREATOR + 1
// ITEM_FIELD_GIFT_CREATOR + 0
// ITEM_FIELD_GIFT_CREATOR + 1
// ITEM_FIELD_STACK_COUNT
// ITEM_FIELD_EXPIRATION
// ITEM_FIELD_SPELL_CHARGES + 0
// ITEM_FIELD_SPELL_CHARGES + 1
// ITEM_FIELD_SPELL_CHARGES + 2
// ITEM_FIELD_SPELL_CHARGES + 3
// ITEM_FIELD_SPELL_CHARGES + 4
// ITEM_FIELD_DYNAMIC_FLAGS
// ITEM_FIELD_ENCHANTMENT + 0
// ITEM_FIELD_ENCHANTMENT + 1
// ITEM_FIELD_ENCHANTMENT + 2
// ITEM_FIELD_ENCHANTMENT + 3
// ITEM_FIELD_ENCHANTMENT + 4
// ITEM_FIELD_ENCHANTMENT + 5
// ITEM_FIELD_ENCHANTMENT + 6
// ITEM_FIELD_ENCHANTMENT + 7
// ITEM_FIELD_ENCHANTMENT + 8
// ITEM_FIELD_ENCHANTMENT + 9
// ITEM_FIELD_ENCHANTMENT + 10
// ITEM_FIELD_ENCHANTMENT + 11
// ITEM_FIELD_ENCHANTMENT + 12
// ITEM_FIELD_ENCHANTMENT + 13
// ITEM_FIELD_ENCHANTMENT + 14
// ITEM_FIELD_ENCHANTMENT + 15
// ITEM_FIELD_ENCHANTMENT + 16
// ITEM_FIELD_ENCHANTMENT + 17
// ITEM_FIELD_ENCHANTMENT + 18
// ITEM_FIELD_ENCHANTMENT + 19
// ITEM_FIELD_ENCHANTMENT + 20
// ITEM_FIELD_ENCHANTMENT + 21
// ITEM_FIELD_ENCHANTMENT + 22
// ITEM_FIELD_ENCHANTMENT + 23
// ITEM_FIELD_ENCHANTMENT + 24
// ITEM_FIELD_ENCHANTMENT + 25
// ITEM_FIELD_ENCHANTMENT + 26
// ITEM_FIELD_ENCHANTMENT + 27
// ITEM_FIELD_ENCHANTMENT + 28
// ITEM_FIELD_ENCHANTMENT + 29
// ITEM_FIELD_ENCHANTMENT + 30
// ITEM_FIELD_ENCHANTMENT + 31
// ITEM_FIELD_ENCHANTMENT + 32
// ITEM_FIELD_ENCHANTMENT + 33
// ITEM_FIELD_ENCHANTMENT + 34
// ITEM_FIELD_ENCHANTMENT + 35
// ITEM_FIELD_ENCHANTMENT + 36
// ITEM_FIELD_ENCHANTMENT + 37
// ITEM_FIELD_ENCHANTMENT + 38
// ITEM_FIELD_PROPERTY_SEED
// ITEM_FIELD_RANDOM_PROPERTIES_ID
// ITEM_FIELD_DURABILITY
// ITEM_FIELD_MAX_DURABILITY
// ITEM_FIELD_CREATE_PLAYED_TIME
// ITEM_FIELD_MODIFIERS_MASK
// CONTAINER_FIELD_SLOTS + 0
// CONTAINER_FIELD_SLOTS + 1
// CONTAINER_FIELD_SLOTS + 2
// CONTAINER_FIELD_SLOTS + 3
// CONTAINER_FIELD_SLOTS + 4
// CONTAINER_FIELD_SLOTS + 5
// CONTAINER_FIELD_SLOTS + 6
// CONTAINER_FIELD_SLOTS + 7
// CONTAINER_FIELD_SLOTS + 8
// CONTAINER_FIELD_SLOTS + 9
// CONTAINER_FIELD_SLOTS + 10
// CONTAINER_FIELD_SLOTS + 11
// CONTAINER_FIELD_SLOTS + 12
// CONTAINER_FIELD_SLOTS + 13
// CONTAINER_FIELD_SLOTS + 14
// CONTAINER_FIELD_SLOTS + 15
// CONTAINER_FIELD_SLOTS + 16
// CONTAINER_FIELD_SLOTS + 17
// CONTAINER_FIELD_SLOTS + 18
// CONTAINER_FIELD_SLOTS + 19
// CONTAINER_FIELD_SLOTS + 20
// CONTAINER_FIELD_SLOTS + 21
// CONTAINER_FIELD_SLOTS + 22
// CONTAINER_FIELD_SLOTS + 23
// CONTAINER_FIELD_SLOTS + 24
// CONTAINER_FIELD_SLOTS + 25
// CONTAINER_FIELD_SLOTS + 26
// CONTAINER_FIELD_SLOTS + 27
// CONTAINER_FIELD_SLOTS + 28
// CONTAINER_FIELD_SLOTS + 29
// CONTAINER_FIELD_SLOTS + 30
// CONTAINER_FIELD_SLOTS + 31
// CONTAINER_FIELD_SLOTS + 32
// CONTAINER_FIELD_SLOTS + 33
// CONTAINER_FIELD_SLOTS + 34
// CONTAINER_FIELD_SLOTS + 35
// CONTAINER_FIELD_SLOTS + 36
// CONTAINER_FIELD_SLOTS + 37
// CONTAINER_FIELD_SLOTS + 38
// CONTAINER_FIELD_SLOTS + 39
// CONTAINER_FIELD_SLOTS + 40
// CONTAINER_FIELD_SLOTS + 41
// CONTAINER_FIELD_SLOTS + 42
// CONTAINER_FIELD_SLOTS + 43
// CONTAINER_FIELD_SLOTS + 44
// CONTAINER_FIELD_SLOTS + 45
// CONTAINER_FIELD_SLOTS + 46
// CONTAINER_FIELD_SLOTS + 47
// CONTAINER_FIELD_SLOTS + 48
// CONTAINER_FIELD_SLOTS + 49
// CONTAINER_FIELD_SLOTS + 50
// CONTAINER_FIELD_SLOTS + 51
// CONTAINER_FIELD_SLOTS + 52
// CONTAINER_FIELD_SLOTS + 53
// CONTAINER_FIELD_SLOTS + 54
// CONTAINER_FIELD_SLOTS + 55
// CONTAINER_FIELD_SLOTS + 56
// CONTAINER_FIELD_SLOTS + 57
// CONTAINER_FIELD_SLOTS + 58
// CONTAINER_FIELD_SLOTS + 59
// CONTAINER_FIELD_SLOTS + 60
// CONTAINER_FIELD_SLOTS + 61
// CONTAINER_FIELD_SLOTS + 62
// CONTAINER_FIELD_SLOTS + 63
// CONTAINER_FIELD_SLOTS + 64
// CONTAINER_FIELD_SLOTS + 65
// CONTAINER_FIELD_SLOTS + 66
// CONTAINER_FIELD_SLOTS + 67
// CONTAINER_FIELD_SLOTS + 68
// CONTAINER_FIELD_SLOTS + 69
// CONTAINER_FIELD_SLOTS + 70
// CONTAINER_FIELD_SLOTS + 71
// CONTAINER_FIELD_NUM_SLOTS
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// UNIT_FIELD_CHARM + 0
// UNIT_FIELD_CHARM + 1
// UNIT_FIELD_SUMMON + 0
// UNIT_FIELD_SUMMON + 1
// UNIT_FIELD_CRITTER + 0
// UNIT_FIELD_CRITTER + 1
// UNIT_FIELD_CHARMED_BY + 0
// UNIT_FIELD_CHARMED_BY + 1
// UNIT_FIELD_SUMMONED_BY + 0
// UNIT_FIELD_SUMMONED_BY + 1
// UNIT_FIELD_CREATED_BY + 0
// UNIT_FIELD_CREATED_BY + 1
// UNIT_FIELD_DEMON_CREATOR + 0
// UNIT_FIELD_DEMON_CREATOR + 1
// UNIT_FIELD_TARGET + 0
// UNIT_FIELD_TARGET + 1
// UNIT_FIELD_BATTLE_PET_COMPANION_GUID + 0
// UNIT_FIELD_BATTLE_PET_COMPANION_GUID + 1
// UNIT_FIELD_CHANNEL_OBJECT + 0
// UNIT_FIELD_CHANNEL_OBJECT + 1
// UNIT_FIELD_CHANNEL_SPELL
// UNIT_FIELD_SUMMONED_BY_HOME_REALM
// UNIT_FIELD_SEX
// UNIT_FIELD_ANIM_TIER
// UNIT_FIELD_SHAPESHIFT_FORM
// UNIT_FIELD_HEALTH
// UNIT_FIELD_POWER + 0
// UNIT_FIELD_POWER + 1
// UNIT_FIELD_POWER + 2
// UNIT_FIELD_POWER + 3
// UNIT_FIELD_POWER + 4
// UNIT_FIELD_MAX_HEALTH
// UNIT_FIELD_MAX_POWER + 0
// UNIT_FIELD_MAX_POWER + 1
// UNIT_FIELD_MAX_POWER + 2
// UNIT_FIELD_MAX_POWER + 3
// UNIT_FIELD_MAX_POWER + 4
// UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + 0
// UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + 1
// UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + 2
// UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + 3
// UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + 4
// UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + 0
// UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + 1
// UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + 2
// UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + 3
// UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + 4
// UNIT_FIELD_LEVEL
// UNIT_FIELD_EFFECTIVE_LEVEL
// UNIT_FIELD_FACTION_TEMPLATE
// UNIT_FIELD_VIRTUAL_ITEM_ID + 0
// UNIT_FIELD_VIRTUAL_ITEM_ID + 1
// UNIT_FIELD_VIRTUAL_ITEM_ID + 2
// UNIT_FIELD_FLAGS
// UNIT_FIELD_FLAGS2
// UNIT_FIELD_AURA_STATE
// UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 0
// UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 1
// UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME
// UNIT_FIELD_BOUNDING_RADIUS
// UNIT_FIELD_COMBAT_REACH
// UNIT_FIELD_DISPLAY_ID
// UNIT_FIELD_NATIVE_DISPLAY_ID
// UNIT_FIELD_MOUNT_DISPLAY_ID
// UNIT_FIELD_MIN_DAMAGE
// UNIT_FIELD_MAX_DAMAGE
// UNIT_FIELD_MIN_OFF_HAND_DAMAGE
// UNIT_FIELD_MAX_OFF_HAND_DAMAGE
// UNIT_FIELD_ANIM_TIER
// UNIT_FIELD_PET_NUMBER
// UNIT_FIELD_PET_NAME_TIMESTAMP
// UNIT_FIELD_PET_EXPERIENCE
// UNIT_FIELD_PET_NEXT_LEVEL_EXPERIENCE
// UNIT_FIELD_MOD_CASTING_SPEED
// UNIT_FIELD_MOD_SPELL_HASTE
// UNIT_FIELD_MOD_HASTE
// UNIT_FIELD_MOD_RANGED_HASTE
// UNIT_FIELD_MOD_HASTE_REGEN
// UNIT_FIELD_CREATED_BY_SPELL
// UNIT_FIELD_NPC_FLAGS[_UMNW0]
// UNIT_FIELD_NPC_FLAGS + 0
// UNIT_FIELD_NPC_FLAGS + 1
// UNIT_FIELD_STATS + 0
// UNIT_FIELD_STATS + 1
// UNIT_FIELD_STATS + 2
// UNIT_FIELD_STATS + 3
// UNIT_FIELD_STATS + 4
// UNIT_FIELD_STAT_POS_BUFF + 0
// UNIT_FIELD_STAT_POS_BUFF + 1
// UNIT_FIELD_STAT_POS_BUFF + 2
// UNIT_FIELD_STAT_POS_BUFF + 3
// UNIT_FIELD_STAT_POS_BUFF + 4
// UNIT_FIELD_STAT_NEG_BUFF + 0
// UNIT_FIELD_STAT_NEG_BUFF + 1
// UNIT_FIELD_STAT_NEG_BUFF + 2
// UNIT_FIELD_STAT_NEG_BUFF + 3
// UNIT_FIELD_STAT_NEG_BUFF + 4
// UNIT_FIELD_RESISTANCES + 0
// UNIT_FIELD_RESISTANCES + 1
// UNIT_FIELD_RESISTANCES + 2
// UNIT_FIELD_RESISTANCES + 3
// UNIT_FIELD_RESISTANCES + 4
// UNIT_FIELD_RESISTANCES + 5
// UNIT_FIELD_RESISTANCES + 6
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 0
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 1
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 2
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 3
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 4
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 5
// UNIT_FIELD_RESISTANCE_BUFF_MODS_POSITIVE + 6
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 0
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 1
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 2
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 3
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 4
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 5
// UNIT_FIELD_RESISTANCE_BUFF_MODS_NEGATIVE + 6
// UNIT_FIELD_BASE_MANA
// UNIT_FIELD_BASE_HEALTH
// UNIT_FIELD_SHAPESHIFT_FORM
// UNIT_FIELD_ATTACK_POWER
// UNIT_FIELD_ATTACK_POWER_MOD_POS
// UNIT_FIELD_ATTACK_POWER_MOD_NEG
// UNIT_FIELD_ATTACK_POWER_MULTIPLIER
// UNIT_FIELD_RANGED_ATTACK_POWER
// UNIT_FIELD_RANGED_ATTACK_POWER_MOD_POS
// UNIT_FIELD_RANGED_ATTACK_POWER_MOD_NEG
// UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER
// UNIT_FIELD_MIN_RANGED_DAMAGE
// UNIT_FIELD_MAX_RANGED_DAMAGE
// UNIT_FIELD_POWER_COST_MODIFIER + 0
// UNIT_FIELD_POWER_COST_MODIFIER + 1
// UNIT_FIELD_POWER_COST_MODIFIER + 2
// UNIT_FIELD_POWER_COST_MODIFIER + 3
// UNIT_FIELD_POWER_COST_MODIFIER + 4
// UNIT_FIELD_POWER_COST_MODIFIER + 5
// UNIT_FIELD_POWER_COST_MODIFIER + 6
// UNIT_FIELD_POWER_COST_MULTIPLIER + 0
// UNIT_FIELD_POWER_COST_MULTIPLIER + 1
// UNIT_FIELD_POWER_COST_MULTIPLIER + 2
// UNIT_FIELD_POWER_COST_MULTIPLIER + 3
// UNIT_FIELD_POWER_COST_MULTIPLIER + 4
// UNIT_FIELD_POWER_COST_MULTIPLIER + 5
// UNIT_FIELD_POWER_COST_MULTIPLIER + 6
// UNIT_FIELD_MAX_HEALTH_MODIFIER
// UNIT_FIELD_HOVER_HEIGHT
// UNIT_FIELD_MIN_ITEM_LEVEL
// UNIT_FIELD_MAX_ITEM_LEVEL
// UNIT_FIELD_WILD_BATTLE_PET_LEVEL
// UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP
// UNIT_FIELD_INTERACT_SPELL_ID
// PLAYER_FIELD_DUEL_ARBITER + 0
// PLAYER_FIELD_DUEL_ARBITER + 1
// PLAYER_FIELD_PLAYER_FLAGS
// PLAYER_FIELD_GUILD_RANK_ID
// PLAYER_FIELD_GUILD_DELETE_DATE
// PLAYER_FIELD_GUILD_LEVEL
// PLAYER_FIELD_HAIR_COLOR_ID
// PLAYER_FIELD_REST_STATE
// PLAYER_FIELD_ARENA_FACTION
// PLAYER_FIELD_DUEL_TEAM
// PLAYER_FIELD_GUILD_TIME_STAMP
// PLAYER_FIELD_QUEST_LOG + 0
// PLAYER_FIELD_QUEST_LOG + 1
// PLAYER_FIELD_QUEST_LOG + 2
// PLAYER_FIELD_QUEST_LOG + 3
// PLAYER_FIELD_QUEST_LOG + 4
// PLAYER_FIELD_QUEST_LOG + 5
// PLAYER_FIELD_QUEST_LOG + 6
// PLAYER_FIELD_QUEST_LOG + 7
// PLAYER_FIELD_QUEST_LOG + 8
// PLAYER_FIELD_QUEST_LOG + 9
// PLAYER_FIELD_QUEST_LOG + 10
// PLAYER_FIELD_QUEST_LOG + 11
// PLAYER_FIELD_QUEST_LOG + 12
// PLAYER_FIELD_QUEST_LOG + 13
// PLAYER_FIELD_QUEST_LOG + 14
// PLAYER_FIELD_QUEST_LOG + 15
// PLAYER_FIELD_QUEST_LOG + 16
// PLAYER_FIELD_QUEST_LOG + 17
// PLAYER_FIELD_QUEST_LOG + 18
// PLAYER_FIELD_QUEST_LOG + 19
// PLAYER_FIELD_QUEST_LOG + 20
// PLAYER_FIELD_QUEST_LOG + 21
// PLAYER_FIELD_QUEST_LOG + 22
// PLAYER_FIELD_QUEST_LOG + 23
// PLAYER_FIELD_QUEST_LOG + 24
// PLAYER_FIELD_QUEST_LOG + 25
// PLAYER_FIELD_QUEST_LOG + 26
// PLAYER_FIELD_QUEST_LOG + 27
// PLAYER_FIELD_QUEST_LOG + 28
// PLAYER_FIELD_QUEST_LOG + 29
// PLAYER_FIELD_QUEST_LOG + 30
// PLAYER_FIELD_QUEST_LOG + 31
// PLAYER_FIELD_QUEST_LOG + 32
// PLAYER_FIELD_QUEST_LOG + 33
// PLAYER_FIELD_QUEST_LOG + 34
// PLAYER_FIELD_QUEST_LOG + 35
// PLAYER_FIELD_QUEST_LOG + 36
// PLAYER_FIELD_QUEST_LOG + 37
// PLAYER_FIELD_QUEST_LOG + 38
// PLAYER_FIELD_QUEST_LOG + 39
// PLAYER_FIELD_QUEST_LOG + 40
// PLAYER_FIELD_QUEST_LOG + 41
// PLAYER_FIELD_QUEST_LOG + 42
// PLAYER_FIELD_QUEST_LOG + 43
// PLAYER_FIELD_QUEST_LOG + 44
// PLAYER_FIELD_QUEST_LOG + 45
// PLAYER_FIELD_QUEST_LOG + 46
// PLAYER_FIELD_QUEST_LOG + 47
// PLAYER_FIELD_QUEST_LOG + 48
// PLAYER_FIELD_QUEST_LOG + 49
// PLAYER_FIELD_QUEST_LOG + 50
// PLAYER_FIELD_QUEST_LOG + 51
// PLAYER_FIELD_QUEST_LOG + 52
// PLAYER_FIELD_QUEST_LOG + 53
// PLAYER_FIELD_QUEST_LOG + 54
// PLAYER_FIELD_QUEST_LOG + 55
// PLAYER_FIELD_QUEST_LOG + 56
// PLAYER_FIELD_QUEST_LOG + 57
// PLAYER_FIELD_QUEST_LOG + 58
// PLAYER_FIELD_QUEST_LOG + 59
// PLAYER_FIELD_QUEST_LOG + 60
// PLAYER_FIELD_QUEST_LOG + 61
// PLAYER_FIELD_QUEST_LOG + 62
// PLAYER_FIELD_QUEST_LOG + 63
// PLAYER_FIELD_QUEST_LOG + 64
// PLAYER_FIELD_QUEST_LOG + 65
// PLAYER_FIELD_QUEST_LOG + 66
// PLAYER_FIELD_QUEST_LOG + 67
// PLAYER_FIELD_QUEST_LOG + 68
// PLAYER_FIELD_QUEST_LOG + 69
// PLAYER_FIELD_QUEST_LOG + 70
// PLAYER_FIELD_QUEST_LOG + 71
// PLAYER_FIELD_QUEST_LOG + 72
// PLAYER_FIELD_QUEST_LOG + 73
// PLAYER_FIELD_QUEST_LOG + 74
// PLAYER_FIELD_QUEST_LOG + 75
// PLAYER_FIELD_QUEST_LOG + 76
// PLAYER_FIELD_QUEST_LOG + 77
// PLAYER_FIELD_QUEST_LOG + 78
// PLAYER_FIELD_QUEST_LOG + 79
// PLAYER_FIELD_QUEST_LOG + 80
// PLAYER_FIELD_QUEST_LOG + 81
// PLAYER_FIELD_QUEST_LOG + 82
// PLAYER_FIELD_QUEST_LOG + 83
// PLAYER_FIELD_QUEST_LOG + 84
// PLAYER_FIELD_QUEST_LOG + 85
// PLAYER_FIELD_QUEST_LOG + 86
// PLAYER_FIELD_QUEST_LOG + 87
// PLAYER_FIELD_QUEST_LOG + 88
// PLAYER_FIELD_QUEST_LOG + 89
// PLAYER_FIELD_QUEST_LOG + 90
// PLAYER_FIELD_QUEST_LOG + 91
// PLAYER_FIELD_QUEST_LOG + 92
// PLAYER_FIELD_QUEST_LOG + 93
// PLAYER_FIELD_QUEST_LOG + 94
// PLAYER_FIELD_QUEST_LOG + 95
// PLAYER_FIELD_QUEST_LOG + 96
// PLAYER_FIELD_QUEST_LOG + 97
// PLAYER_FIELD_QUEST_LOG + 98
// PLAYER_FIELD_QUEST_LOG + 99
// PLAYER_FIELD_QUEST_LOG + 100
// PLAYER_FIELD_QUEST_LOG + 101
// PLAYER_FIELD_QUEST_LOG + 102
// PLAYER_FIELD_QUEST_LOG + 103
// PLAYER_FIELD_QUEST_LOG + 104
// PLAYER_FIELD_QUEST_LOG + 105
// PLAYER_FIELD_QUEST_LOG + 106
// PLAYER_FIELD_QUEST_LOG + 107
// PLAYER_FIELD_QUEST_LOG + 108
// PLAYER_FIELD_QUEST_LOG + 109
// PLAYER_FIELD_QUEST_LOG + 110
// PLAYER_FIELD_QUEST_LOG + 111
// PLAYER_FIELD_QUEST_LOG + 112
// PLAYER_FIELD_QUEST_LOG + 113
// PLAYER_FIELD_QUEST_LOG + 114
// PLAYER_FIELD_QUEST_LOG + 115
// PLAYER_FIELD_QUEST_LOG + 116
// PLAYER_FIELD_QUEST_LOG + 117
// PLAYER_FIELD_QUEST_LOG + 118
// PLAYER_FIELD_QUEST_LOG + 119
// PLAYER_FIELD_QUEST_LOG + 120
// PLAYER_FIELD_QUEST_LOG + 121
// PLAYER_FIELD_QUEST_LOG + 122
// PLAYER_FIELD_QUEST_LOG + 123
// PLAYER_FIELD_QUEST_LOG + 124
// PLAYER_FIELD_QUEST_LOG + 125
// PLAYER_FIELD_QUEST_LOG + 126
// PLAYER_FIELD_QUEST_LOG + 127
// PLAYER_FIELD_QUEST_LOG + 128
// PLAYER_FIELD_QUEST_LOG + 129
// PLAYER_FIELD_QUEST_LOG + 130
// PLAYER_FIELD_QUEST_LOG + 131
// PLAYER_FIELD_QUEST_LOG + 132
// PLAYER_FIELD_QUEST_LOG + 133
// PLAYER_FIELD_QUEST_LOG + 134
// PLAYER_FIELD_QUEST_LOG + 135
// PLAYER_FIELD_QUEST_LOG + 136
// PLAYER_FIELD_QUEST_LOG + 137
// PLAYER_FIELD_QUEST_LOG + 138
// PLAYER_FIELD_QUEST_LOG + 139
// PLAYER_FIELD_QUEST_LOG + 140
// PLAYER_FIELD_QUEST_LOG + 141
// PLAYER_FIELD_QUEST_LOG + 142
// PLAYER_FIELD_QUEST_LOG + 143
// PLAYER_FIELD_QUEST_LOG + 144
// PLAYER_FIELD_QUEST_LOG + 145
// PLAYER_FIELD_QUEST_LOG + 146
// PLAYER_FIELD_QUEST_LOG + 147
// PLAYER_FIELD_QUEST_LOG + 148
// PLAYER_FIELD_QUEST_LOG + 149
// PLAYER_FIELD_QUEST_LOG + 150
// PLAYER_FIELD_QUEST_LOG + 151
// PLAYER_FIELD_QUEST_LOG + 152
// PLAYER_FIELD_QUEST_LOG + 153
// PLAYER_FIELD_QUEST_LOG + 154
// PLAYER_FIELD_QUEST_LOG + 155
// PLAYER_FIELD_QUEST_LOG + 156
// PLAYER_FIELD_QUEST_LOG + 157
// PLAYER_FIELD_QUEST_LOG + 158
// PLAYER_FIELD_QUEST_LOG + 159
// PLAYER_FIELD_QUEST_LOG + 160
// PLAYER_FIELD_QUEST_LOG + 161
// PLAYER_FIELD_QUEST_LOG + 162
// PLAYER_FIELD_QUEST_LOG + 163
// PLAYER_FIELD_QUEST_LOG + 164
// PLAYER_FIELD_QUEST_LOG + 165
// PLAYER_FIELD_QUEST_LOG + 166
// PLAYER_FIELD_QUEST_LOG + 167
// PLAYER_FIELD_QUEST_LOG + 168
// PLAYER_FIELD_QUEST_LOG + 169
// PLAYER_FIELD_QUEST_LOG + 170
// PLAYER_FIELD_QUEST_LOG + 171
// PLAYER_FIELD_QUEST_LOG + 172
// PLAYER_FIELD_QUEST_LOG + 173
// PLAYER_FIELD_QUEST_LOG + 174
// PLAYER_FIELD_QUEST_LOG + 175
// PLAYER_FIELD_QUEST_LOG + 176
// PLAYER_FIELD_QUEST_LOG + 177
// PLAYER_FIELD_QUEST_LOG + 178
// PLAYER_FIELD_QUEST_LOG + 179
// PLAYER_FIELD_QUEST_LOG + 180
// PLAYER_FIELD_QUEST_LOG + 181
// PLAYER_FIELD_QUEST_LOG + 182
// PLAYER_FIELD_QUEST_LOG + 183
// PLAYER_FIELD_QUEST_LOG + 184
// PLAYER_FIELD_QUEST_LOG + 185
// PLAYER_FIELD_QUEST_LOG + 186
// PLAYER_FIELD_QUEST_LOG + 187
// PLAYER_FIELD_QUEST_LOG + 188
// PLAYER_FIELD_QUEST_LOG + 189
// PLAYER_FIELD_QUEST_LOG + 190
// PLAYER_FIELD_QUEST_LOG + 191
// PLAYER_FIELD_QUEST_LOG + 192
// PLAYER_FIELD_QUEST_LOG + 193
// PLAYER_FIELD_QUEST_LOG + 194
// PLAYER_FIELD_QUEST_LOG + 195
// PLAYER_FIELD_QUEST_LOG + 196
// PLAYER_FIELD_QUEST_LOG + 197
// PLAYER_FIELD_QUEST_LOG + 198
// PLAYER_FIELD_QUEST_LOG + 199
// PLAYER_FIELD_QUEST_LOG + 200
// PLAYER_FIELD_QUEST_LOG + 201
// PLAYER_FIELD_QUEST_LOG + 202
// PLAYER_FIELD_QUEST_LOG + 203
// PLAYER_FIELD_QUEST_LOG + 204
// PLAYER_FIELD_QUEST_LOG + 205
// PLAYER_FIELD_QUEST_LOG + 206
// PLAYER_FIELD_QUEST_LOG + 207
// PLAYER_FIELD_QUEST_LOG + 208
// PLAYER_FIELD_QUEST_LOG + 209
// PLAYER_FIELD_QUEST_LOG + 210
// PLAYER_FIELD_QUEST_LOG + 211
// PLAYER_FIELD_QUEST_LOG + 212
// PLAYER_FIELD_QUEST_LOG + 213
// PLAYER_FIELD_QUEST_LOG + 214
// PLAYER_FIELD_QUEST_LOG + 215
// PLAYER_FIELD_QUEST_LOG + 216
// PLAYER_FIELD_QUEST_LOG + 217
// PLAYER_FIELD_QUEST_LOG + 218
// PLAYER_FIELD_QUEST_LOG + 219
// PLAYER_FIELD_QUEST_LOG + 220
// PLAYER_FIELD_QUEST_LOG + 221
// PLAYER_FIELD_QUEST_LOG + 222
// PLAYER_FIELD_QUEST_LOG + 223
// PLAYER_FIELD_QUEST_LOG + 224
// PLAYER_FIELD_QUEST_LOG + 225
// PLAYER_FIELD_QUEST_LOG + 226
// PLAYER_FIELD_QUEST_LOG + 227
// PLAYER_FIELD_QUEST_LOG + 228
// PLAYER_FIELD_QUEST_LOG + 229
// PLAYER_FIELD_QUEST_LOG + 230
// PLAYER_FIELD_QUEST_LOG + 231
// PLAYER_FIELD_QUEST_LOG + 232
// PLAYER_FIELD_QUEST_LOG + 233
// PLAYER_FIELD_QUEST_LOG + 234
// PLAYER_FIELD_QUEST_LOG + 235
// PLAYER_FIELD_QUEST_LOG + 236
// PLAYER_FIELD_QUEST_LOG + 237
// PLAYER_FIELD_QUEST_LOG + 238
// PLAYER_FIELD_QUEST_LOG + 239
// PLAYER_FIELD_QUEST_LOG + 240
// PLAYER_FIELD_QUEST_LOG + 241
// PLAYER_FIELD_QUEST_LOG + 242
// PLAYER_FIELD_QUEST_LOG + 243
// PLAYER_FIELD_QUEST_LOG + 244
// PLAYER_FIELD_QUEST_LOG + 245
// PLAYER_FIELD_QUEST_LOG + 246
// PLAYER_FIELD_QUEST_LOG + 247
// PLAYER_FIELD_QUEST_LOG + 248
// PLAYER_FIELD_QUEST_LOG + 249
// PLAYER_FIELD_QUEST_LOG + 250
// PLAYER_FIELD_QUEST_LOG + 251
// PLAYER_FIELD_QUEST_LOG + 252
// PLAYER_FIELD_QUEST_LOG + 253
// PLAYER_FIELD_QUEST_LOG + 254
// PLAYER_FIELD_QUEST_LOG + 255
// PLAYER_FIELD_QUEST_LOG + 256
// PLAYER_FIELD_QUEST_LOG + 257
// PLAYER_FIELD_QUEST_LOG + 258
// PLAYER_FIELD_QUEST_LOG + 259
// PLAYER_FIELD_QUEST_LOG + 260
// PLAYER_FIELD_QUEST_LOG + 261
// PLAYER_FIELD_QUEST_LOG + 262
// PLAYER_FIELD_QUEST_LOG + 263
// PLAYER_FIELD_QUEST_LOG + 264
// PLAYER_FIELD_QUEST_LOG + 265
// PLAYER_FIELD_QUEST_LOG + 266
// PLAYER_FIELD_QUEST_LOG + 267
// PLAYER_FIELD_QUEST_LOG + 268
// PLAYER_FIELD_QUEST_LOG + 269
// PLAYER_FIELD_QUEST_LOG + 270
// PLAYER_FIELD_QUEST_LOG + 271
// PLAYER_FIELD_QUEST_LOG + 272
// PLAYER_FIELD_QUEST_LOG + 273
// PLAYER_FIELD_QUEST_LOG + 274
// PLAYER_FIELD_QUEST_LOG + 275
// PLAYER_FIELD_QUEST_LOG + 276
// PLAYER_FIELD_QUEST_LOG + 277
// PLAYER_FIELD_QUEST_LOG + 278
// PLAYER_FIELD_QUEST_LOG + 279
// PLAYER_FIELD_QUEST_LOG + 280
// PLAYER_FIELD_QUEST_LOG + 281
// PLAYER_FIELD_QUEST_LOG + 282
// PLAYER_FIELD_QUEST_LOG + 283
// PLAYER_FIELD_QUEST_LOG + 284
// PLAYER_FIELD_QUEST_LOG + 285
// PLAYER_FIELD_QUEST_LOG + 286
// PLAYER_FIELD_QUEST_LOG + 287
// PLAYER_FIELD_QUEST_LOG + 288
// PLAYER_FIELD_QUEST_LOG + 289
// PLAYER_FIELD_QUEST_LOG + 290
// PLAYER_FIELD_QUEST_LOG + 291
// PLAYER_FIELD_QUEST_LOG + 292
// PLAYER_FIELD_QUEST_LOG + 293
// PLAYER_FIELD_QUEST_LOG + 294
// PLAYER_FIELD_QUEST_LOG + 295
// PLAYER_FIELD_QUEST_LOG + 296
// PLAYER_FIELD_QUEST_LOG + 297
// PLAYER_FIELD_QUEST_LOG + 298
// PLAYER_FIELD_QUEST_LOG + 299
// PLAYER_FIELD_QUEST_LOG + 300
// PLAYER_FIELD_QUEST_LOG + 301
// PLAYER_FIELD_QUEST_LOG + 302
// PLAYER_FIELD_QUEST_LOG + 303
// PLAYER_FIELD_QUEST_LOG + 304
// PLAYER_FIELD_QUEST_LOG + 305
// PLAYER_FIELD_QUEST_LOG + 306
// PLAYER_FIELD_QUEST_LOG + 307
// PLAYER_FIELD_QUEST_LOG + 308
// PLAYER_FIELD_QUEST_LOG + 309
// PLAYER_FIELD_QUEST_LOG + 310
// PLAYER_FIELD_QUEST_LOG + 311
// PLAYER_FIELD_QUEST_LOG + 312
// PLAYER_FIELD_QUEST_LOG + 313
// PLAYER_FIELD_QUEST_LOG + 314
// PLAYER_FIELD_QUEST_LOG + 315
// PLAYER_FIELD_QUEST_LOG + 316
// PLAYER_FIELD_QUEST_LOG + 317
// PLAYER_FIELD_QUEST_LOG + 318
// PLAYER_FIELD_QUEST_LOG + 319
// PLAYER_FIELD_QUEST_LOG + 320
// PLAYER_FIELD_QUEST_LOG + 321
// PLAYER_FIELD_QUEST_LOG + 322
// PLAYER_FIELD_QUEST_LOG + 323
// PLAYER_FIELD_QUEST_LOG + 324
// PLAYER_FIELD_QUEST_LOG + 325
// PLAYER_FIELD_QUEST_LOG + 326
// PLAYER_FIELD_QUEST_LOG + 327
// PLAYER_FIELD_QUEST_LOG + 328
// PLAYER_FIELD_QUEST_LOG + 329
// PLAYER_FIELD_QUEST_LOG + 330
// PLAYER_FIELD_QUEST_LOG + 331
// PLAYER_FIELD_QUEST_LOG + 332
// PLAYER_FIELD_QUEST_LOG + 333
// PLAYER_FIELD_QUEST_LOG + 334
// PLAYER_FIELD_QUEST_LOG + 335
// PLAYER_FIELD_QUEST_LOG + 336
// PLAYER_FIELD_QUEST_LOG + 337
// PLAYER_FIELD_QUEST_LOG + 338
// PLAYER_FIELD_QUEST_LOG + 339
// PLAYER_FIELD_QUEST_LOG + 340
// PLAYER_FIELD_QUEST_LOG + 341
// PLAYER_FIELD_QUEST_LOG + 342
// PLAYER_FIELD_QUEST_LOG + 343
// PLAYER_FIELD_QUEST_LOG + 344
// PLAYER_FIELD_QUEST_LOG + 345
// PLAYER_FIELD_QUEST_LOG + 346
// PLAYER_FIELD_QUEST_LOG + 347
// PLAYER_FIELD_QUEST_LOG + 348
// PLAYER_FIELD_QUEST_LOG + 349
// PLAYER_FIELD_QUEST_LOG + 350
// PLAYER_FIELD_QUEST_LOG + 351
// PLAYER_FIELD_QUEST_LOG + 352
// PLAYER_FIELD_QUEST_LOG + 353
// PLAYER_FIELD_QUEST_LOG + 354
// PLAYER_FIELD_QUEST_LOG + 355
// PLAYER_FIELD_QUEST_LOG + 356
// PLAYER_FIELD_QUEST_LOG + 357
// PLAYER_FIELD_QUEST_LOG + 358
// PLAYER_FIELD_QUEST_LOG + 359
// PLAYER_FIELD_QUEST_LOG + 360
// PLAYER_FIELD_QUEST_LOG + 361
// PLAYER_FIELD_QUEST_LOG + 362
// PLAYER_FIELD_QUEST_LOG + 363
// PLAYER_FIELD_QUEST_LOG + 364
// PLAYER_FIELD_QUEST_LOG + 365
// PLAYER_FIELD_QUEST_LOG + 366
// PLAYER_FIELD_QUEST_LOG + 367
// PLAYER_FIELD_QUEST_LOG + 368
// PLAYER_FIELD_QUEST_LOG + 369
// PLAYER_FIELD_QUEST_LOG + 370
// PLAYER_FIELD_QUEST_LOG + 371
// PLAYER_FIELD_QUEST_LOG + 372
// PLAYER_FIELD_QUEST_LOG + 373
// PLAYER_FIELD_QUEST_LOG + 374
// PLAYER_FIELD_QUEST_LOG + 375
// PLAYER_FIELD_QUEST_LOG + 376
// PLAYER_FIELD_QUEST_LOG + 377
// PLAYER_FIELD_QUEST_LOG + 378
// PLAYER_FIELD_QUEST_LOG + 379
// PLAYER_FIELD_QUEST_LOG + 380
// PLAYER_FIELD_QUEST_LOG + 381
// PLAYER_FIELD_QUEST_LOG + 382
// PLAYER_FIELD_QUEST_LOG + 383
// PLAYER_FIELD_QUEST_LOG + 384
// PLAYER_FIELD_QUEST_LOG + 385
// PLAYER_FIELD_QUEST_LOG + 386
// PLAYER_FIELD_QUEST_LOG + 387
// PLAYER_FIELD_QUEST_LOG + 388
// PLAYER_FIELD_QUEST_LOG + 389
// PLAYER_FIELD_QUEST_LOG + 390
// PLAYER_FIELD_QUEST_LOG + 391
// PLAYER_FIELD_QUEST_LOG + 392
// PLAYER_FIELD_QUEST_LOG + 393
// PLAYER_FIELD_QUEST_LOG + 394
// PLAYER_FIELD_QUEST_LOG + 395
// PLAYER_FIELD_QUEST_LOG + 396
// PLAYER_FIELD_QUEST_LOG + 397
// PLAYER_FIELD_QUEST_LOG + 398
// PLAYER_FIELD_QUEST_LOG + 399
// PLAYER_FIELD_QUEST_LOG + 400
// PLAYER_FIELD_QUEST_LOG + 401
// PLAYER_FIELD_QUEST_LOG + 402
// PLAYER_FIELD_QUEST_LOG + 403
// PLAYER_FIELD_QUEST_LOG + 404
// PLAYER_FIELD_QUEST_LOG + 405
// PLAYER_FIELD_QUEST_LOG + 406
// PLAYER_FIELD_QUEST_LOG + 407
// PLAYER_FIELD_QUEST_LOG + 408
// PLAYER_FIELD_QUEST_LOG + 409
// PLAYER_FIELD_QUEST_LOG + 410
// PLAYER_FIELD_QUEST_LOG + 411
// PLAYER_FIELD_QUEST_LOG + 412
// PLAYER_FIELD_QUEST_LOG + 413
// PLAYER_FIELD_QUEST_LOG + 414
// PLAYER_FIELD_QUEST_LOG + 415
// PLAYER_FIELD_QUEST_LOG + 416
// PLAYER_FIELD_QUEST_LOG + 417
// PLAYER_FIELD_QUEST_LOG + 418
// PLAYER_FIELD_QUEST_LOG + 419
// PLAYER_FIELD_QUEST_LOG + 420
// PLAYER_FIELD_QUEST_LOG + 421
// PLAYER_FIELD_QUEST_LOG + 422
// PLAYER_FIELD_QUEST_LOG + 423
// PLAYER_FIELD_QUEST_LOG + 424
// PLAYER_FIELD_QUEST_LOG + 425
// PLAYER_FIELD_QUEST_LOG + 426
// PLAYER_FIELD_QUEST_LOG + 427
// PLAYER_FIELD_QUEST_LOG + 428
// PLAYER_FIELD_QUEST_LOG + 429
// PLAYER_FIELD_QUEST_LOG + 430
// PLAYER_FIELD_QUEST_LOG + 431
// PLAYER_FIELD_QUEST_LOG + 432
// PLAYER_FIELD_QUEST_LOG + 433
// PLAYER_FIELD_QUEST_LOG + 434
// PLAYER_FIELD_QUEST_LOG + 435
// PLAYER_FIELD_QUEST_LOG + 436
// PLAYER_FIELD_QUEST_LOG + 437
// PLAYER_FIELD_QUEST_LOG + 438
// PLAYER_FIELD_QUEST_LOG + 439
// PLAYER_FIELD_QUEST_LOG + 440
// PLAYER_FIELD_QUEST_LOG + 441
// PLAYER_FIELD_QUEST_LOG + 442
// PLAYER_FIELD_QUEST_LOG + 443
// PLAYER_FIELD_QUEST_LOG + 444
// PLAYER_FIELD_QUEST_LOG + 445
// PLAYER_FIELD_QUEST_LOG + 446
// PLAYER_FIELD_QUEST_LOG + 447
// PLAYER_FIELD_QUEST_LOG + 448
// PLAYER_FIELD_QUEST_LOG + 449
// PLAYER_FIELD_QUEST_LOG + 450
// PLAYER_FIELD_QUEST_LOG + 451
// PLAYER_FIELD_QUEST_LOG + 452
// PLAYER_FIELD_QUEST_LOG + 453
// PLAYER_FIELD_QUEST_LOG + 454
// PLAYER_FIELD_QUEST_LOG + 455
// PLAYER_FIELD_QUEST_LOG + 456
// PLAYER_FIELD_QUEST_LOG + 457
// PLAYER_FIELD_QUEST_LOG + 458
// PLAYER_FIELD_QUEST_LOG + 459
// PLAYER_FIELD_QUEST_LOG + 460
// PLAYER_FIELD_QUEST_LOG + 461
// PLAYER_FIELD_QUEST_LOG + 462
// PLAYER_FIELD_QUEST_LOG + 463
// PLAYER_FIELD_QUEST_LOG + 464
// PLAYER_FIELD_QUEST_LOG + 465
// PLAYER_FIELD_QUEST_LOG + 466
// PLAYER_FIELD_QUEST_LOG + 467
// PLAYER_FIELD_QUEST_LOG + 468
// PLAYER_FIELD_QUEST_LOG + 469
// PLAYER_FIELD_QUEST_LOG + 470
// PLAYER_FIELD_QUEST_LOG + 471
// PLAYER_FIELD_QUEST_LOG + 472
// PLAYER_FIELD_QUEST_LOG + 473
// PLAYER_FIELD_QUEST_LOG + 474
// PLAYER_FIELD_QUEST_LOG + 475
// PLAYER_FIELD_QUEST_LOG + 476
// PLAYER_FIELD_QUEST_LOG + 477
// PLAYER_FIELD_QUEST_LOG + 478
// PLAYER_FIELD_QUEST_LOG + 479
// PLAYER_FIELD_QUEST_LOG + 480
// PLAYER_FIELD_QUEST_LOG + 481
// PLAYER_FIELD_QUEST_LOG + 482
// PLAYER_FIELD_QUEST_LOG + 483
// PLAYER_FIELD_QUEST_LOG + 484
// PLAYER_FIELD_QUEST_LOG + 485
// PLAYER_FIELD_QUEST_LOG + 486
// PLAYER_FIELD_QUEST_LOG + 487
// PLAYER_FIELD_QUEST_LOG + 488
// PLAYER_FIELD_QUEST_LOG + 489
// PLAYER_FIELD_QUEST_LOG + 490
// PLAYER_FIELD_QUEST_LOG + 491
// PLAYER_FIELD_QUEST_LOG + 492
// PLAYER_FIELD_QUEST_LOG + 493
// PLAYER_FIELD_QUEST_LOG + 494
// PLAYER_FIELD_QUEST_LOG + 495
// PLAYER_FIELD_QUEST_LOG + 496
// PLAYER_FIELD_QUEST_LOG + 497
// PLAYER_FIELD_QUEST_LOG + 498
// PLAYER_FIELD_QUEST_LOG + 499
// PLAYER_FIELD_QUEST_LOG + 500
// PLAYER_FIELD_QUEST_LOG + 501
// PLAYER_FIELD_QUEST_LOG + 502
// PLAYER_FIELD_QUEST_LOG + 503
// PLAYER_FIELD_QUEST_LOG + 504
// PLAYER_FIELD_QUEST_LOG + 505
// PLAYER_FIELD_QUEST_LOG + 506
// PLAYER_FIELD_QUEST_LOG + 507
// PLAYER_FIELD_QUEST_LOG + 508
// PLAYER_FIELD_QUEST_LOG + 509
// PLAYER_FIELD_QUEST_LOG + 510
// PLAYER_FIELD_QUEST_LOG + 511
// PLAYER_FIELD_QUEST_LOG + 512
// PLAYER_FIELD_QUEST_LOG + 513
// PLAYER_FIELD_QUEST_LOG + 514
// PLAYER_FIELD_QUEST_LOG + 515
// PLAYER_FIELD_QUEST_LOG + 516
// PLAYER_FIELD_QUEST_LOG + 517
// PLAYER_FIELD_QUEST_LOG + 518
// PLAYER_FIELD_QUEST_LOG + 519
// PLAYER_FIELD_QUEST_LOG + 520
// PLAYER_FIELD_QUEST_LOG + 521
// PLAYER_FIELD_QUEST_LOG + 522
// PLAYER_FIELD_QUEST_LOG + 523
// PLAYER_FIELD_QUEST_LOG + 524
// PLAYER_FIELD_QUEST_LOG + 525
// PLAYER_FIELD_QUEST_LOG + 526
// PLAYER_FIELD_QUEST_LOG + 527
// PLAYER_FIELD_QUEST_LOG + 528
// PLAYER_FIELD_QUEST_LOG + 529
// PLAYER_FIELD_QUEST_LOG + 530
// PLAYER_FIELD_QUEST_LOG + 531
// PLAYER_FIELD_QUEST_LOG + 532
// PLAYER_FIELD_QUEST_LOG + 533
// PLAYER_FIELD_QUEST_LOG + 534
// PLAYER_FIELD_QUEST_LOG + 535
// PLAYER_FIELD_QUEST_LOG + 536
// PLAYER_FIELD_QUEST_LOG + 537
// PLAYER_FIELD_QUEST_LOG + 538
// PLAYER_FIELD_QUEST_LOG + 539
// PLAYER_FIELD_QUEST_LOG + 540
// PLAYER_FIELD_QUEST_LOG + 541
// PLAYER_FIELD_QUEST_LOG + 542
// PLAYER_FIELD_QUEST_LOG + 543
// PLAYER_FIELD_QUEST_LOG + 544
// PLAYER_FIELD_QUEST_LOG + 545
// PLAYER_FIELD_QUEST_LOG + 546
// PLAYER_FIELD_QUEST_LOG + 547
// PLAYER_FIELD_QUEST_LOG + 548
// PLAYER_FIELD_QUEST_LOG + 549
// PLAYER_FIELD_QUEST_LOG + 550
// PLAYER_FIELD_QUEST_LOG + 551
// PLAYER_FIELD_QUEST_LOG + 552
// PLAYER_FIELD_QUEST_LOG + 553
// PLAYER_FIELD_QUEST_LOG + 554
// PLAYER_FIELD_QUEST_LOG + 555
// PLAYER_FIELD_QUEST_LOG + 556
// PLAYER_FIELD_QUEST_LOG + 557
// PLAYER_FIELD_QUEST_LOG + 558
// PLAYER_FIELD_QUEST_LOG + 559
// PLAYER_FIELD_QUEST_LOG + 560
// PLAYER_FIELD_QUEST_LOG + 561
// PLAYER_FIELD_QUEST_LOG + 562
// PLAYER_FIELD_QUEST_LOG + 563
// PLAYER_FIELD_QUEST_LOG + 564
// PLAYER_FIELD_QUEST_LOG + 565
// PLAYER_FIELD_QUEST_LOG + 566
// PLAYER_FIELD_QUEST_LOG + 567
// PLAYER_FIELD_QUEST_LOG + 568
// PLAYER_FIELD_QUEST_LOG + 569
// PLAYER_FIELD_QUEST_LOG + 570
// PLAYER_FIELD_QUEST_LOG + 571
// PLAYER_FIELD_QUEST_LOG + 572
// PLAYER_FIELD_QUEST_LOG + 573
// PLAYER_FIELD_QUEST_LOG + 574
// PLAYER_FIELD_QUEST_LOG + 575
// PLAYER_FIELD_QUEST_LOG + 576
// PLAYER_FIELD_QUEST_LOG + 577
// PLAYER_FIELD_QUEST_LOG + 578
// PLAYER_FIELD_QUEST_LOG + 579
// PLAYER_FIELD_QUEST_LOG + 580
// PLAYER_FIELD_QUEST_LOG + 581
// PLAYER_FIELD_QUEST_LOG + 582
// PLAYER_FIELD_QUEST_LOG + 583
// PLAYER_FIELD_QUEST_LOG + 584
// PLAYER_FIELD_QUEST_LOG + 585
// PLAYER_FIELD_QUEST_LOG + 586
// PLAYER_FIELD_QUEST_LOG + 587
// PLAYER_FIELD_QUEST_LOG + 588
// PLAYER_FIELD_QUEST_LOG + 589
// PLAYER_FIELD_QUEST_LOG + 590
// PLAYER_FIELD_QUEST_LOG + 591
// PLAYER_FIELD_QUEST_LOG + 592
// PLAYER_FIELD_QUEST_LOG + 593
// PLAYER_FIELD_QUEST_LOG + 594
// PLAYER_FIELD_QUEST_LOG + 595
// PLAYER_FIELD_QUEST_LOG + 596
// PLAYER_FIELD_QUEST_LOG + 597
// PLAYER_FIELD_QUEST_LOG + 598
// PLAYER_FIELD_QUEST_LOG + 599
// PLAYER_FIELD_QUEST_LOG + 600
// PLAYER_FIELD_QUEST_LOG + 601
// PLAYER_FIELD_QUEST_LOG + 602
// PLAYER_FIELD_QUEST_LOG + 603
// PLAYER_FIELD_QUEST_LOG + 604
// PLAYER_FIELD_QUEST_LOG + 605
// PLAYER_FIELD_QUEST_LOG + 606
// PLAYER_FIELD_QUEST_LOG + 607
// PLAYER_FIELD_QUEST_LOG + 608
// PLAYER_FIELD_QUEST_LOG + 609
// PLAYER_FIELD_QUEST_LOG + 610
// PLAYER_FIELD_QUEST_LOG + 611
// PLAYER_FIELD_QUEST_LOG + 612
// PLAYER_FIELD_QUEST_LOG + 613
// PLAYER_FIELD_QUEST_LOG + 614
// PLAYER_FIELD_QUEST_LOG + 615
// PLAYER_FIELD_QUEST_LOG + 616
// PLAYER_FIELD_QUEST_LOG + 617
// PLAYER_FIELD_QUEST_LOG + 618
// PLAYER_FIELD_QUEST_LOG + 619
// PLAYER_FIELD_QUEST_LOG + 620
// PLAYER_FIELD_QUEST_LOG + 621
// PLAYER_FIELD_QUEST_LOG + 622
// PLAYER_FIELD_QUEST_LOG + 623
// PLAYER_FIELD_QUEST_LOG + 624
// PLAYER_FIELD_QUEST_LOG + 625
// PLAYER_FIELD_QUEST_LOG + 626
// PLAYER_FIELD_QUEST_LOG + 627
// PLAYER_FIELD_QUEST_LOG + 628
// PLAYER_FIELD_QUEST_LOG + 629
// PLAYER_FIELD_QUEST_LOG + 630
// PLAYER_FIELD_QUEST_LOG + 631
// PLAYER_FIELD_QUEST_LOG + 632
// PLAYER_FIELD_QUEST_LOG + 633
// PLAYER_FIELD_QUEST_LOG + 634
// PLAYER_FIELD_QUEST_LOG + 635
// PLAYER_FIELD_QUEST_LOG + 636
// PLAYER_FIELD_QUEST_LOG + 637
// PLAYER_FIELD_QUEST_LOG + 638
// PLAYER_FIELD_QUEST_LOG + 639
// PLAYER_FIELD_QUEST_LOG + 640
// PLAYER_FIELD_QUEST_LOG + 641
// PLAYER_FIELD_QUEST_LOG + 642
// PLAYER_FIELD_QUEST_LOG + 643
// PLAYER_FIELD_QUEST_LOG + 644
// PLAYER_FIELD_QUEST_LOG + 645
// PLAYER_FIELD_QUEST_LOG + 646
// PLAYER_FIELD_QUEST_LOG + 647
// PLAYER_FIELD_QUEST_LOG + 648
// PLAYER_FIELD_QUEST_LOG + 649
// PLAYER_FIELD_QUEST_LOG + 650
// PLAYER_FIELD_QUEST_LOG + 651
// PLAYER_FIELD_QUEST_LOG + 652
// PLAYER_FIELD_QUEST_LOG + 653
// PLAYER_FIELD_QUEST_LOG + 654
// PLAYER_FIELD_QUEST_LOG + 655
// PLAYER_FIELD_QUEST_LOG + 656
// PLAYER_FIELD_QUEST_LOG + 657
// PLAYER_FIELD_QUEST_LOG + 658
// PLAYER_FIELD_QUEST_LOG + 659
// PLAYER_FIELD_QUEST_LOG + 660
// PLAYER_FIELD_QUEST_LOG + 661
// PLAYER_FIELD_QUEST_LOG + 662
// PLAYER_FIELD_QUEST_LOG + 663
// PLAYER_FIELD_QUEST_LOG + 664
// PLAYER_FIELD_QUEST_LOG + 665
// PLAYER_FIELD_QUEST_LOG + 666
// PLAYER_FIELD_QUEST_LOG + 667
// PLAYER_FIELD_QUEST_LOG + 668
// PLAYER_FIELD_QUEST_LOG + 669
// PLAYER_FIELD_QUEST_LOG + 670
// PLAYER_FIELD_QUEST_LOG + 671
// PLAYER_FIELD_QUEST_LOG + 672
// PLAYER_FIELD_QUEST_LOG + 673
// PLAYER_FIELD_QUEST_LOG + 674
// PLAYER_FIELD_QUEST_LOG + 675
// PLAYER_FIELD_QUEST_LOG + 676
// PLAYER_FIELD_QUEST_LOG + 677
// PLAYER_FIELD_QUEST_LOG + 678
// PLAYER_FIELD_QUEST_LOG + 679
// PLAYER_FIELD_QUEST_LOG + 680
// PLAYER_FIELD_QUEST_LOG + 681
// PLAYER_FIELD_QUEST_LOG + 682
// PLAYER_FIELD_QUEST_LOG + 683
// PLAYER_FIELD_QUEST_LOG + 684
// PLAYER_FIELD_QUEST_LOG + 685
// PLAYER_FIELD_QUEST_LOG + 686
// PLAYER_FIELD_QUEST_LOG + 687
// PLAYER_FIELD_QUEST_LOG + 688
// PLAYER_FIELD_QUEST_LOG + 689
// PLAYER_FIELD_QUEST_LOG + 690
// PLAYER_FIELD_QUEST_LOG + 691
// PLAYER_FIELD_QUEST_LOG + 692
// PLAYER_FIELD_QUEST_LOG + 693
// PLAYER_FIELD_QUEST_LOG + 694
// PLAYER_FIELD_QUEST_LOG + 695
// PLAYER_FIELD_QUEST_LOG + 696
// PLAYER_FIELD_QUEST_LOG + 697
// PLAYER_FIELD_QUEST_LOG + 698
// PLAYER_FIELD_QUEST_LOG + 699
// PLAYER_FIELD_QUEST_LOG + 700
// PLAYER_FIELD_QUEST_LOG + 701
// PLAYER_FIELD_QUEST_LOG + 702
// PLAYER_FIELD_QUEST_LOG + 703
// PLAYER_FIELD_QUEST_LOG + 704
// PLAYER_FIELD_QUEST_LOG + 705
// PLAYER_FIELD_QUEST_LOG + 706
// PLAYER_FIELD_QUEST_LOG + 707
// PLAYER_FIELD_QUEST_LOG + 708
// PLAYER_FIELD_QUEST_LOG + 709
// PLAYER_FIELD_QUEST_LOG + 710
// PLAYER_FIELD_QUEST_LOG + 711
// PLAYER_FIELD_QUEST_LOG + 712
// PLAYER_FIELD_QUEST_LOG + 713
// PLAYER_FIELD_QUEST_LOG + 714
// PLAYER_FIELD_QUEST_LOG + 715
// PLAYER_FIELD_QUEST_LOG + 716
// PLAYER_FIELD_QUEST_LOG + 717
// PLAYER_FIELD_QUEST_LOG + 718
// PLAYER_FIELD_QUEST_LOG + 719
// PLAYER_FIELD_QUEST_LOG + 720
// PLAYER_FIELD_QUEST_LOG + 721
// PLAYER_FIELD_QUEST_LOG + 722
// PLAYER_FIELD_QUEST_LOG + 723
// PLAYER_FIELD_QUEST_LOG + 724
// PLAYER_FIELD_QUEST_LOG + 725
// PLAYER_FIELD_QUEST_LOG + 726
// PLAYER_FIELD_QUEST_LOG + 727
// PLAYER_FIELD_QUEST_LOG + 728
// PLAYER_FIELD_QUEST_LOG + 729
// PLAYER_FIELD_QUEST_LOG + 730
// PLAYER_FIELD_QUEST_LOG + 731
// PLAYER_FIELD_QUEST_LOG + 732
// PLAYER_FIELD_QUEST_LOG + 733
// PLAYER_FIELD_QUEST_LOG + 734
// PLAYER_FIELD_QUEST_LOG + 735
// PLAYER_FIELD_QUEST_LOG + 736
// PLAYER_FIELD_QUEST_LOG + 737
// PLAYER_FIELD_QUEST_LOG + 738
// PLAYER_FIELD_QUEST_LOG + 739
// PLAYER_FIELD_QUEST_LOG + 740
// PLAYER_FIELD_QUEST_LOG + 741
// PLAYER_FIELD_QUEST_LOG + 742
// PLAYER_FIELD_QUEST_LOG + 743
// PLAYER_FIELD_QUEST_LOG + 744
// PLAYER_FIELD_QUEST_LOG + 745
// PLAYER_FIELD_QUEST_LOG + 746
// PLAYER_FIELD_QUEST_LOG + 747
// PLAYER_FIELD_QUEST_LOG + 748
// PLAYER_FIELD_QUEST_LOG + 749
// PLAYER_FIELD_VISIBLE_ITEMS + 0
// PLAYER_FIELD_VISIBLE_ITEMS + 1
// PLAYER_FIELD_VISIBLE_ITEMS + 2
// PLAYER_FIELD_VISIBLE_ITEMS + 3
// PLAYER_FIELD_VISIBLE_ITEMS + 4
// PLAYER_FIELD_VISIBLE_ITEMS + 5
// PLAYER_FIELD_VISIBLE_ITEMS + 6
// PLAYER_FIELD_VISIBLE_ITEMS + 7
// PLAYER_FIELD_VISIBLE_ITEMS + 8
// PLAYER_FIELD_VISIBLE_ITEMS + 9
// PLAYER_FIELD_VISIBLE_ITEMS + 10
// PLAYER_FIELD_VISIBLE_ITEMS + 11
// PLAYER_FIELD_VISIBLE_ITEMS + 12
// PLAYER_FIELD_VISIBLE_ITEMS + 13
// PLAYER_FIELD_VISIBLE_ITEMS + 14
// PLAYER_FIELD_VISIBLE_ITEMS + 15
// PLAYER_FIELD_VISIBLE_ITEMS + 16
// PLAYER_FIELD_VISIBLE_ITEMS + 17
// PLAYER_FIELD_VISIBLE_ITEMS + 18
// PLAYER_FIELD_VISIBLE_ITEMS + 19
// PLAYER_FIELD_VISIBLE_ITEMS + 20
// PLAYER_FIELD_VISIBLE_ITEMS + 21
// PLAYER_FIELD_VISIBLE_ITEMS + 22
// PLAYER_FIELD_VISIBLE_ITEMS + 23
// PLAYER_FIELD_VISIBLE_ITEMS + 24
// PLAYER_FIELD_VISIBLE_ITEMS + 25
// PLAYER_FIELD_VISIBLE_ITEMS + 26
// PLAYER_FIELD_VISIBLE_ITEMS + 27
// PLAYER_FIELD_VISIBLE_ITEMS + 28
// PLAYER_FIELD_VISIBLE_ITEMS + 29
// PLAYER_FIELD_VISIBLE_ITEMS + 30
// PLAYER_FIELD_VISIBLE_ITEMS + 31
// PLAYER_FIELD_VISIBLE_ITEMS + 32
// PLAYER_FIELD_VISIBLE_ITEMS + 33
// PLAYER_FIELD_VISIBLE_ITEMS + 34
// PLAYER_FIELD_VISIBLE_ITEMS + 35
// PLAYER_FIELD_VISIBLE_ITEMS + 36
// PLAYER_FIELD_VISIBLE_ITEMS + 37
// PLAYER_FIELD_PLAYER_TITLE
// PLAYER_FIELD_FAKE_INEBRIATION
// PLAYER_FIELD_VIRTUAL_PLAYER_REALM
// PLAYER_FIELD_CURRENT_SPEC_ID
// PLAYER_FIELD_TAXI_MOUNT_ANIM_KIT_ID
// PLAYER_FIELD_CURRENT_BATTLE_PET_BREED_QUALITY
// PLAYER_FIELD_INV_SLOTS + 0
// PLAYER_FIELD_INV_SLOTS + 1
// PLAYER_FIELD_INV_SLOTS + 2
// PLAYER_FIELD_INV_SLOTS + 3
// PLAYER_FIELD_INV_SLOTS + 4
// PLAYER_FIELD_INV_SLOTS + 5
// PLAYER_FIELD_INV_SLOTS + 6
// PLAYER_FIELD_INV_SLOTS + 7
// PLAYER_FIELD_INV_SLOTS + 8
// PLAYER_FIELD_INV_SLOTS + 9
// PLAYER_FIELD_INV_SLOTS + 10
// PLAYER_FIELD_INV_SLOTS + 11
// PLAYER_FIELD_INV_SLOTS + 12
// PLAYER_FIELD_INV_SLOTS + 13
// PLAYER_FIELD_INV_SLOTS + 14
// PLAYER_FIELD_INV_SLOTS + 15
// PLAYER_FIELD_INV_SLOTS + 16
// PLAYER_FIELD_INV_SLOTS + 17
// PLAYER_FIELD_INV_SLOTS + 18
// PLAYER_FIELD_INV_SLOTS + 19
// PLAYER_FIELD_INV_SLOTS + 20
// PLAYER_FIELD_INV_SLOTS + 21
// PLAYER_FIELD_INV_SLOTS + 22
// PLAYER_FIELD_INV_SLOTS + 23
// PLAYER_FIELD_INV_SLOTS + 24
// PLAYER_FIELD_INV_SLOTS + 25
// PLAYER_FIELD_INV_SLOTS + 26
// PLAYER_FIELD_INV_SLOTS + 27
// PLAYER_FIELD_INV_SLOTS + 28
// PLAYER_FIELD_INV_SLOTS + 29
// PLAYER_FIELD_INV_SLOTS + 30
// PLAYER_FIELD_INV_SLOTS + 31
// PLAYER_FIELD_INV_SLOTS + 32
// PLAYER_FIELD_INV_SLOTS + 33
// PLAYER_FIELD_INV_SLOTS + 34
// PLAYER_FIELD_INV_SLOTS + 35
// PLAYER_FIELD_INV_SLOTS + 36
// PLAYER_FIELD_INV_SLOTS + 37
// PLAYER_FIELD_INV_SLOTS + 38
// PLAYER_FIELD_INV_SLOTS + 39
// PLAYER_FIELD_INV_SLOTS + 40
// PLAYER_FIELD_INV_SLOTS + 41
// PLAYER_FIELD_INV_SLOTS + 42
// PLAYER_FIELD_INV_SLOTS + 43
// PLAYER_FIELD_INV_SLOTS + 44
// PLAYER_FIELD_INV_SLOTS + 45
// PLAYER_FIELD_INV_SLOTS + 46
// PLAYER_FIELD_INV_SLOTS + 47
// PLAYER_FIELD_INV_SLOTS + 48
// PLAYER_FIELD_INV_SLOTS + 49
// PLAYER_FIELD_INV_SLOTS + 50
// PLAYER_FIELD_INV_SLOTS + 51
// PLAYER_FIELD_INV_SLOTS + 52
// PLAYER_FIELD_INV_SLOTS + 53
// PLAYER_FIELD_INV_SLOTS + 54
// PLAYER_FIELD_INV_SLOTS + 55
// PLAYER_FIELD_INV_SLOTS + 56
// PLAYER_FIELD_INV_SLOTS + 57
// PLAYER_FIELD_INV_SLOTS + 58
// PLAYER_FIELD_INV_SLOTS + 59
// PLAYER_FIELD_INV_SLOTS + 60
// PLAYER_FIELD_INV_SLOTS + 61
// PLAYER_FIELD_INV_SLOTS + 62
// PLAYER_FIELD_INV_SLOTS + 63
// PLAYER_FIELD_INV_SLOTS + 64
// PLAYER_FIELD_INV_SLOTS + 65
// PLAYER_FIELD_INV_SLOTS + 66
// PLAYER_FIELD_INV_SLOTS + 67
// PLAYER_FIELD_INV_SLOTS + 68
// PLAYER_FIELD_INV_SLOTS + 69
// PLAYER_FIELD_INV_SLOTS + 70
// PLAYER_FIELD_INV_SLOTS + 71
// PLAYER_FIELD_INV_SLOTS + 72
// PLAYER_FIELD_INV_SLOTS + 73
// PLAYER_FIELD_INV_SLOTS + 74
// PLAYER_FIELD_INV_SLOTS + 75
// PLAYER_FIELD_INV_SLOTS + 76
// PLAYER_FIELD_INV_SLOTS + 77
// PLAYER_FIELD_INV_SLOTS + 78
// PLAYER_FIELD_INV_SLOTS + 79
// PLAYER_FIELD_INV_SLOTS + 80
// PLAYER_FIELD_INV_SLOTS + 81
// PLAYER_FIELD_INV_SLOTS + 82
// PLAYER_FIELD_INV_SLOTS + 83
// PLAYER_FIELD_INV_SLOTS + 84
// PLAYER_FIELD_INV_SLOTS + 85
// PLAYER_FIELD_INV_SLOTS + 86
// PLAYER_FIELD_INV_SLOTS + 87
// PLAYER_FIELD_INV_SLOTS + 88
// PLAYER_FIELD_INV_SLOTS + 89
// PLAYER_FIELD_INV_SLOTS + 90
// PLAYER_FIELD_INV_SLOTS + 91
// PLAYER_FIELD_INV_SLOTS + 92
// PLAYER_FIELD_INV_SLOTS + 93
// PLAYER_FIELD_INV_SLOTS + 94
// PLAYER_FIELD_INV_SLOTS + 95
// PLAYER_FIELD_INV_SLOTS + 96
// PLAYER_FIELD_INV_SLOTS + 97
// PLAYER_FIELD_INV_SLOTS + 98
// PLAYER_FIELD_INV_SLOTS + 99
// PLAYER_FIELD_INV_SLOTS + 100
// PLAYER_FIELD_INV_SLOTS + 101
// PLAYER_FIELD_INV_SLOTS + 102
// PLAYER_FIELD_INV_SLOTS + 103
// PLAYER_FIELD_INV_SLOTS + 104
// PLAYER_FIELD_INV_SLOTS + 105
// PLAYER_FIELD_INV_SLOTS + 106
// PLAYER_FIELD_INV_SLOTS + 107
// PLAYER_FIELD_INV_SLOTS + 108
// PLAYER_FIELD_INV_SLOTS + 109
// PLAYER_FIELD_INV_SLOTS + 110
// PLAYER_FIELD_INV_SLOTS + 111
// PLAYER_FIELD_INV_SLOTS + 112
// PLAYER_FIELD_INV_SLOTS + 113
// PLAYER_FIELD_INV_SLOTS + 114
// PLAYER_FIELD_INV_SLOTS + 115
// PLAYER_FIELD_INV_SLOTS + 116
// PLAYER_FIELD_INV_SLOTS + 117
// PLAYER_FIELD_INV_SLOTS + 118
// PLAYER_FIELD_INV_SLOTS + 119
// PLAYER_FIELD_INV_SLOTS + 120
// PLAYER_FIELD_INV_SLOTS + 121
// PLAYER_FIELD_INV_SLOTS + 122
// PLAYER_FIELD_INV_SLOTS + 123
// PLAYER_FIELD_INV_SLOTS + 124
// PLAYER_FIELD_INV_SLOTS + 125
// PLAYER_FIELD_INV_SLOTS + 126
// PLAYER_FIELD_INV_SLOTS + 127
// PLAYER_FIELD_INV_SLOTS + 128
// PLAYER_FIELD_INV_SLOTS + 129
// PLAYER_FIELD_INV_SLOTS + 130
// PLAYER_FIELD_INV_SLOTS + 131
// PLAYER_FIELD_INV_SLOTS + 132
// PLAYER_FIELD_INV_SLOTS + 133
// PLAYER_FIELD_INV_SLOTS + 134
// PLAYER_FIELD_INV_SLOTS + 135
// PLAYER_FIELD_INV_SLOTS + 136
// PLAYER_FIELD_INV_SLOTS + 137
// PLAYER_FIELD_INV_SLOTS + 138
// PLAYER_FIELD_INV_SLOTS + 139
// PLAYER_FIELD_INV_SLOTS + 140
// PLAYER_FIELD_INV_SLOTS + 141
// PLAYER_FIELD_INV_SLOTS + 142
// PLAYER_FIELD_INV_SLOTS + 143
// PLAYER_FIELD_INV_SLOTS + 144
// PLAYER_FIELD_INV_SLOTS + 145
// PLAYER_FIELD_INV_SLOTS + 146
// PLAYER_FIELD_INV_SLOTS + 147
// PLAYER_FIELD_INV_SLOTS + 148
// PLAYER_FIELD_INV_SLOTS + 149
// PLAYER_FIELD_INV_SLOTS + 150
// PLAYER_FIELD_INV_SLOTS + 151
// PLAYER_FIELD_INV_SLOTS + 152
// PLAYER_FIELD_INV_SLOTS + 153
// PLAYER_FIELD_INV_SLOTS + 154
// PLAYER_FIELD_INV_SLOTS + 155
// PLAYER_FIELD_INV_SLOTS + 156
// PLAYER_FIELD_INV_SLOTS + 157
// PLAYER_FIELD_INV_SLOTS + 158
// PLAYER_FIELD_INV_SLOTS + 159
// PLAYER_FIELD_INV_SLOTS + 160
// PLAYER_FIELD_INV_SLOTS + 161
// PLAYER_FIELD_INV_SLOTS + 162
// PLAYER_FIELD_INV_SLOTS + 163
// PLAYER_FIELD_INV_SLOTS + 164
// PLAYER_FIELD_INV_SLOTS + 165
// PLAYER_FIELD_INV_SLOTS + 166
// PLAYER_FIELD_INV_SLOTS + 167
// PLAYER_FIELD_INV_SLOTS + 168
// PLAYER_FIELD_INV_SLOTS + 169
// PLAYER_FIELD_INV_SLOTS + 170
// PLAYER_FIELD_INV_SLOTS + 171
// PLAYER_FIELD_FARSIGHT_OBJECT + 0
// PLAYER_FIELD_FARSIGHT_OBJECT + 1
// PLAYER_FIELD_KNOWN_TITLES + 0
// PLAYER_FIELD_KNOWN_TITLES + 1
// PLAYER_FIELD_KNOWN_TITLES + 2
// PLAYER_FIELD_KNOWN_TITLES + 3
// PLAYER_FIELD_KNOWN_TITLES + 4
// PLAYER_FIELD_KNOWN_TITLES + 5
// PLAYER_FIELD_KNOWN_TITLES + 6
// PLAYER_FIELD_KNOWN_TITLES + 7
// PLAYER_FIELD_KNOWN_TITLES + 8
// PLAYER_FIELD_KNOWN_TITLES + 9
// PLAYER_FIELD_COINAGE + 0
// PLAYER_FIELD_COINAGE + 1
// PLAYER_FIELD_XP
// PLAYER_FIELD_NEXT_LEVEL_XP
// PLAYER_FIELD_SKILL + 0
// PLAYER_FIELD_SKILL + 1
// PLAYER_FIELD_SKILL + 2
// PLAYER_FIELD_SKILL + 3
// PLAYER_FIELD_SKILL + 4
// PLAYER_FIELD_SKILL + 5
// PLAYER_FIELD_SKILL + 6
// PLAYER_FIELD_SKILL + 7
// PLAYER_FIELD_SKILL + 8
// PLAYER_FIELD_SKILL + 9
// PLAYER_FIELD_SKILL + 10
// PLAYER_FIELD_SKILL + 11
// PLAYER_FIELD_SKILL + 12
// PLAYER_FIELD_SKILL + 13
// PLAYER_FIELD_SKILL + 14
// PLAYER_FIELD_SKILL + 15
// PLAYER_FIELD_SKILL + 16
// PLAYER_FIELD_SKILL + 17
// PLAYER_FIELD_SKILL + 18
// PLAYER_FIELD_SKILL + 19
// PLAYER_FIELD_SKILL + 20
// PLAYER_FIELD_SKILL + 21
// PLAYER_FIELD_SKILL + 22
// PLAYER_FIELD_SKILL + 23
// PLAYER_FIELD_SKILL + 24
// PLAYER_FIELD_SKILL + 25
// PLAYER_FIELD_SKILL + 26
// PLAYER_FIELD_SKILL + 27
// PLAYER_FIELD_SKILL + 28
// PLAYER_FIELD_SKILL + 29
// PLAYER_FIELD_SKILL + 30
// PLAYER_FIELD_SKILL + 31
// PLAYER_FIELD_SKILL + 32
// PLAYER_FIELD_SKILL + 33
// PLAYER_FIELD_SKILL + 34
// PLAYER_FIELD_SKILL + 35
// PLAYER_FIELD_SKILL + 36
// PLAYER_FIELD_SKILL + 37
// PLAYER_FIELD_SKILL + 38
// PLAYER_FIELD_SKILL + 39
// PLAYER_FIELD_SKILL + 40
// PLAYER_FIELD_SKILL + 41
// PLAYER_FIELD_SKILL + 42
// PLAYER_FIELD_SKILL + 43
// PLAYER_FIELD_SKILL + 44
// PLAYER_FIELD_SKILL + 45
// PLAYER_FIELD_SKILL + 46
// PLAYER_FIELD_SKILL + 47
// PLAYER_FIELD_SKILL + 48
// PLAYER_FIELD_SKILL + 49
// PLAYER_FIELD_SKILL + 50
// PLAYER_FIELD_SKILL + 51
// PLAYER_FIELD_SKILL + 52
// PLAYER_FIELD_SKILL + 53
// PLAYER_FIELD_SKILL + 54
// PLAYER_FIELD_SKILL + 55
// PLAYER_FIELD_SKILL + 56
// PLAYER_FIELD_SKILL + 57
// PLAYER_FIELD_SKILL + 58
// PLAYER_FIELD_SKILL + 59
// PLAYER_FIELD_SKILL + 60
// PLAYER_FIELD_SKILL + 61
// PLAYER_FIELD_SKILL + 62
// PLAYER_FIELD_SKILL + 63
// PLAYER_FIELD_SKILL + 64
// PLAYER_FIELD_SKILL + 65
// PLAYER_FIELD_SKILL + 66
// PLAYER_FIELD_SKILL + 67
// PLAYER_FIELD_SKILL + 68
// PLAYER_FIELD_SKILL + 69
// PLAYER_FIELD_SKILL + 70
// PLAYER_FIELD_SKILL + 71
// PLAYER_FIELD_SKILL + 72
// PLAYER_FIELD_SKILL + 73
// PLAYER_FIELD_SKILL + 74
// PLAYER_FIELD_SKILL + 75
// PLAYER_FIELD_SKILL + 76
// PLAYER_FIELD_SKILL + 77
// PLAYER_FIELD_SKILL + 78
// PLAYER_FIELD_SKILL + 79
// PLAYER_FIELD_SKILL + 80
// PLAYER_FIELD_SKILL + 81
// PLAYER_FIELD_SKILL + 82
// PLAYER_FIELD_SKILL + 83
// PLAYER_FIELD_SKILL + 84
// PLAYER_FIELD_SKILL + 85
// PLAYER_FIELD_SKILL + 86
// PLAYER_FIELD_SKILL + 87
// PLAYER_FIELD_SKILL + 88
// PLAYER_FIELD_SKILL + 89
// PLAYER_FIELD_SKILL + 90
// PLAYER_FIELD_SKILL + 91
// PLAYER_FIELD_SKILL + 92
// PLAYER_FIELD_SKILL + 93
// PLAYER_FIELD_SKILL + 94
// PLAYER_FIELD_SKILL + 95
// PLAYER_FIELD_SKILL + 96
// PLAYER_FIELD_SKILL + 97
// PLAYER_FIELD_SKILL + 98
// PLAYER_FIELD_SKILL + 99
// PLAYER_FIELD_SKILL + 100
// PLAYER_FIELD_SKILL + 101
// PLAYER_FIELD_SKILL + 102
// PLAYER_FIELD_SKILL + 103
// PLAYER_FIELD_SKILL + 104
// PLAYER_FIELD_SKILL + 105
// PLAYER_FIELD_SKILL + 106
// PLAYER_FIELD_SKILL + 107
// PLAYER_FIELD_SKILL + 108
// PLAYER_FIELD_SKILL + 109
// PLAYER_FIELD_SKILL + 110
// PLAYER_FIELD_SKILL + 111
// PLAYER_FIELD_SKILL + 112
// PLAYER_FIELD_SKILL + 113
// PLAYER_FIELD_SKILL + 114
// PLAYER_FIELD_SKILL + 115
// PLAYER_FIELD_SKILL + 116
// PLAYER_FIELD_SKILL + 117
// PLAYER_FIELD_SKILL + 118
// PLAYER_FIELD_SKILL + 119
// PLAYER_FIELD_SKILL + 120
// PLAYER_FIELD_SKILL + 121
// PLAYER_FIELD_SKILL + 122
// PLAYER_FIELD_SKILL + 123
// PLAYER_FIELD_SKILL + 124
// PLAYER_FIELD_SKILL + 125
// PLAYER_FIELD_SKILL + 126
// PLAYER_FIELD_SKILL + 127
// PLAYER_FIELD_SKILL + 128
// PLAYER_FIELD_SKILL + 129
// PLAYER_FIELD_SKILL + 130
// PLAYER_FIELD_SKILL + 131
// PLAYER_FIELD_SKILL + 132
// PLAYER_FIELD_SKILL + 133
// PLAYER_FIELD_SKILL + 134
// PLAYER_FIELD_SKILL + 135
// PLAYER_FIELD_SKILL + 136
// PLAYER_FIELD_SKILL + 137
// PLAYER_FIELD_SKILL + 138
// PLAYER_FIELD_SKILL + 139
// PLAYER_FIELD_SKILL + 140
// PLAYER_FIELD_SKILL + 141
// PLAYER_FIELD_SKILL + 142
// PLAYER_FIELD_SKILL + 143
// PLAYER_FIELD_SKILL + 144
// PLAYER_FIELD_SKILL + 145
// PLAYER_FIELD_SKILL + 146
// PLAYER_FIELD_SKILL + 147
// PLAYER_FIELD_SKILL + 148
// PLAYER_FIELD_SKILL + 149
// PLAYER_FIELD_SKILL + 150
// PLAYER_FIELD_SKILL + 151
// PLAYER_FIELD_SKILL + 152
// PLAYER_FIELD_SKILL + 153
// PLAYER_FIELD_SKILL + 154
// PLAYER_FIELD_SKILL + 155
// PLAYER_FIELD_SKILL + 156
// PLAYER_FIELD_SKILL + 157
// PLAYER_FIELD_SKILL + 158
// PLAYER_FIELD_SKILL + 159
// PLAYER_FIELD_SKILL + 160
// PLAYER_FIELD_SKILL + 161
// PLAYER_FIELD_SKILL + 162
// PLAYER_FIELD_SKILL + 163
// PLAYER_FIELD_SKILL + 164
// PLAYER_FIELD_SKILL + 165
// PLAYER_FIELD_SKILL + 166
// PLAYER_FIELD_SKILL + 167
// PLAYER_FIELD_SKILL + 168
// PLAYER_FIELD_SKILL + 169
// PLAYER_FIELD_SKILL + 170
// PLAYER_FIELD_SKILL + 171
// PLAYER_FIELD_SKILL + 172
// PLAYER_FIELD_SKILL + 173
// PLAYER_FIELD_SKILL + 174
// PLAYER_FIELD_SKILL + 175
// PLAYER_FIELD_SKILL + 176
// PLAYER_FIELD_SKILL + 177
// PLAYER_FIELD_SKILL + 178
// PLAYER_FIELD_SKILL + 179
// PLAYER_FIELD_SKILL + 180
// PLAYER_FIELD_SKILL + 181
// PLAYER_FIELD_SKILL + 182
// PLAYER_FIELD_SKILL + 183
// PLAYER_FIELD_SKILL + 184
// PLAYER_FIELD_SKILL + 185
// PLAYER_FIELD_SKILL + 186
// PLAYER_FIELD_SKILL + 187
// PLAYER_FIELD_SKILL + 188
// PLAYER_FIELD_SKILL + 189
// PLAYER_FIELD_SKILL + 190
// PLAYER_FIELD_SKILL + 191
// PLAYER_FIELD_SKILL + 192
// PLAYER_FIELD_SKILL + 193
// PLAYER_FIELD_SKILL + 194
// PLAYER_FIELD_SKILL + 195
// PLAYER_FIELD_SKILL + 196
// PLAYER_FIELD_SKILL + 197
// PLAYER_FIELD_SKILL + 198
// PLAYER_FIELD_SKILL + 199
// PLAYER_FIELD_SKILL + 200
// PLAYER_FIELD_SKILL + 201
// PLAYER_FIELD_SKILL + 202
// PLAYER_FIELD_SKILL + 203
// PLAYER_FIELD_SKILL + 204
// PLAYER_FIELD_SKILL + 205
// PLAYER_FIELD_SKILL + 206
// PLAYER_FIELD_SKILL + 207
// PLAYER_FIELD_SKILL + 208
// PLAYER_FIELD_SKILL + 209
// PLAYER_FIELD_SKILL + 210
// PLAYER_FIELD_SKILL + 211
// PLAYER_FIELD_SKILL + 212
// PLAYER_FIELD_SKILL + 213
// PLAYER_FIELD_SKILL + 214
// PLAYER_FIELD_SKILL + 215
// PLAYER_FIELD_SKILL + 216
// PLAYER_FIELD_SKILL + 217
// PLAYER_FIELD_SKILL + 218
// PLAYER_FIELD_SKILL + 219
// PLAYER_FIELD_SKILL + 220
// PLAYER_FIELD_SKILL + 221
// PLAYER_FIELD_SKILL + 222
// PLAYER_FIELD_SKILL + 223
// PLAYER_FIELD_SKILL + 224
// PLAYER_FIELD_SKILL + 225
// PLAYER_FIELD_SKILL + 226
// PLAYER_FIELD_SKILL + 227
// PLAYER_FIELD_SKILL + 228
// PLAYER_FIELD_SKILL + 229
// PLAYER_FIELD_SKILL + 230
// PLAYER_FIELD_SKILL + 231
// PLAYER_FIELD_SKILL + 232
// PLAYER_FIELD_SKILL + 233
// PLAYER_FIELD_SKILL + 234
// PLAYER_FIELD_SKILL + 235
// PLAYER_FIELD_SKILL + 236
// PLAYER_FIELD_SKILL + 237
// PLAYER_FIELD_SKILL + 238
// PLAYER_FIELD_SKILL + 239
// PLAYER_FIELD_SKILL + 240
// PLAYER_FIELD_SKILL + 241
// PLAYER_FIELD_SKILL + 242
// PLAYER_FIELD_SKILL + 243
// PLAYER_FIELD_SKILL + 244
// PLAYER_FIELD_SKILL + 245
// PLAYER_FIELD_SKILL + 246
// PLAYER_FIELD_SKILL + 247
// PLAYER_FIELD_SKILL + 248
// PLAYER_FIELD_SKILL + 249
// PLAYER_FIELD_SKILL + 250
// PLAYER_FIELD_SKILL + 251
// PLAYER_FIELD_SKILL + 252
// PLAYER_FIELD_SKILL + 253
// PLAYER_FIELD_SKILL + 254
// PLAYER_FIELD_SKILL + 255
// PLAYER_FIELD_SKILL + 256
// PLAYER_FIELD_SKILL + 257
// PLAYER_FIELD_SKILL + 258
// PLAYER_FIELD_SKILL + 259
// PLAYER_FIELD_SKILL + 260
// PLAYER_FIELD_SKILL + 261
// PLAYER_FIELD_SKILL + 262
// PLAYER_FIELD_SKILL + 263
// PLAYER_FIELD_SKILL + 264
// PLAYER_FIELD_SKILL + 265
// PLAYER_FIELD_SKILL + 266
// PLAYER_FIELD_SKILL + 267
// PLAYER_FIELD_SKILL + 268
// PLAYER_FIELD_SKILL + 269
// PLAYER_FIELD_SKILL + 270
// PLAYER_FIELD_SKILL + 271
// PLAYER_FIELD_SKILL + 272
// PLAYER_FIELD_SKILL + 273
// PLAYER_FIELD_SKILL + 274
// PLAYER_FIELD_SKILL + 275
// PLAYER_FIELD_SKILL + 276
// PLAYER_FIELD_SKILL + 277
// PLAYER_FIELD_SKILL + 278
// PLAYER_FIELD_SKILL + 279
// PLAYER_FIELD_SKILL + 280
// PLAYER_FIELD_SKILL + 281
// PLAYER_FIELD_SKILL + 282
// PLAYER_FIELD_SKILL + 283
// PLAYER_FIELD_SKILL + 284
// PLAYER_FIELD_SKILL + 285
// PLAYER_FIELD_SKILL + 286
// PLAYER_FIELD_SKILL + 287
// PLAYER_FIELD_SKILL + 288
// PLAYER_FIELD_SKILL + 289
// PLAYER_FIELD_SKILL + 290
// PLAYER_FIELD_SKILL + 291
// PLAYER_FIELD_SKILL + 292
// PLAYER_FIELD_SKILL + 293
// PLAYER_FIELD_SKILL + 294
// PLAYER_FIELD_SKILL + 295
// PLAYER_FIELD_SKILL + 296
// PLAYER_FIELD_SKILL + 297
// PLAYER_FIELD_SKILL + 298
// PLAYER_FIELD_SKILL + 299
// PLAYER_FIELD_SKILL + 300
// PLAYER_FIELD_SKILL + 301
// PLAYER_FIELD_SKILL + 302
// PLAYER_FIELD_SKILL + 303
// PLAYER_FIELD_SKILL + 304
// PLAYER_FIELD_SKILL + 305
// PLAYER_FIELD_SKILL + 306
// PLAYER_FIELD_SKILL + 307
// PLAYER_FIELD_SKILL + 308
// PLAYER_FIELD_SKILL + 309
// PLAYER_FIELD_SKILL + 310
// PLAYER_FIELD_SKILL + 311
// PLAYER_FIELD_SKILL + 312
// PLAYER_FIELD_SKILL + 313
// PLAYER_FIELD_SKILL + 314
// PLAYER_FIELD_SKILL + 315
// PLAYER_FIELD_SKILL + 316
// PLAYER_FIELD_SKILL + 317
// PLAYER_FIELD_SKILL + 318
// PLAYER_FIELD_SKILL + 319
// PLAYER_FIELD_SKILL + 320
// PLAYER_FIELD_SKILL + 321
// PLAYER_FIELD_SKILL + 322
// PLAYER_FIELD_SKILL + 323
// PLAYER_FIELD_SKILL + 324
// PLAYER_FIELD_SKILL + 325
// PLAYER_FIELD_SKILL + 326
// PLAYER_FIELD_SKILL + 327
// PLAYER_FIELD_SKILL + 328
// PLAYER_FIELD_SKILL + 329
// PLAYER_FIELD_SKILL + 330
// PLAYER_FIELD_SKILL + 331
// PLAYER_FIELD_SKILL + 332
// PLAYER_FIELD_SKILL + 333
// PLAYER_FIELD_SKILL + 334
// PLAYER_FIELD_SKILL + 335
// PLAYER_FIELD_SKILL + 336
// PLAYER_FIELD_SKILL + 337
// PLAYER_FIELD_SKILL + 338
// PLAYER_FIELD_SKILL + 339
// PLAYER_FIELD_SKILL + 340
// PLAYER_FIELD_SKILL + 341
// PLAYER_FIELD_SKILL + 342
// PLAYER_FIELD_SKILL + 343
// PLAYER_FIELD_SKILL + 344
// PLAYER_FIELD_SKILL + 345
// PLAYER_FIELD_SKILL + 346
// PLAYER_FIELD_SKILL + 347
// PLAYER_FIELD_SKILL + 348
// PLAYER_FIELD_SKILL + 349
// PLAYER_FIELD_SKILL + 350
// PLAYER_FIELD_SKILL + 351
// PLAYER_FIELD_SKILL + 352
// PLAYER_FIELD_SKILL + 353
// PLAYER_FIELD_SKILL + 354
// PLAYER_FIELD_SKILL + 355
// PLAYER_FIELD_SKILL + 356
// PLAYER_FIELD_SKILL + 357
// PLAYER_FIELD_SKILL + 358
// PLAYER_FIELD_SKILL + 359
// PLAYER_FIELD_SKILL + 360
// PLAYER_FIELD_SKILL + 361
// PLAYER_FIELD_SKILL + 362
// PLAYER_FIELD_SKILL + 363
// PLAYER_FIELD_SKILL + 364
// PLAYER_FIELD_SKILL + 365
// PLAYER_FIELD_SKILL + 366
// PLAYER_FIELD_SKILL + 367
// PLAYER_FIELD_SKILL + 368
// PLAYER_FIELD_SKILL + 369
// PLAYER_FIELD_SKILL + 370
// PLAYER_FIELD_SKILL + 371
// PLAYER_FIELD_SKILL + 372
// PLAYER_FIELD_SKILL + 373
// PLAYER_FIELD_SKILL + 374
// PLAYER_FIELD_SKILL + 375
// PLAYER_FIELD_SKILL + 376
// PLAYER_FIELD_SKILL + 377
// PLAYER_FIELD_SKILL + 378
// PLAYER_FIELD_SKILL + 379
// PLAYER_FIELD_SKILL + 380
// PLAYER_FIELD_SKILL + 381
// PLAYER_FIELD_SKILL + 382
// PLAYER_FIELD_SKILL + 383
// PLAYER_FIELD_SKILL + 384
// PLAYER_FIELD_SKILL + 385
// PLAYER_FIELD_SKILL + 386
// PLAYER_FIELD_SKILL + 387
// PLAYER_FIELD_SKILL + 388
// PLAYER_FIELD_SKILL + 389
// PLAYER_FIELD_SKILL + 390
// PLAYER_FIELD_SKILL + 391
// PLAYER_FIELD_SKILL + 392
// PLAYER_FIELD_SKILL + 393
// PLAYER_FIELD_SKILL + 394
// PLAYER_FIELD_SKILL + 395
// PLAYER_FIELD_SKILL + 396
// PLAYER_FIELD_SKILL + 397
// PLAYER_FIELD_SKILL + 398
// PLAYER_FIELD_SKILL + 399
// PLAYER_FIELD_SKILL + 400
// PLAYER_FIELD_SKILL + 401
// PLAYER_FIELD_SKILL + 402
// PLAYER_FIELD_SKILL + 403
// PLAYER_FIELD_SKILL + 404
// PLAYER_FIELD_SKILL + 405
// PLAYER_FIELD_SKILL + 406
// PLAYER_FIELD_SKILL + 407
// PLAYER_FIELD_SKILL + 408
// PLAYER_FIELD_SKILL + 409
// PLAYER_FIELD_SKILL + 410
// PLAYER_FIELD_SKILL + 411
// PLAYER_FIELD_SKILL + 412
// PLAYER_FIELD_SKILL + 413
// PLAYER_FIELD_SKILL + 414
// PLAYER_FIELD_SKILL + 415
// PLAYER_FIELD_SKILL + 416
// PLAYER_FIELD_SKILL + 417
// PLAYER_FIELD_SKILL + 418
// PLAYER_FIELD_SKILL + 419
// PLAYER_FIELD_SKILL + 420
// PLAYER_FIELD_SKILL + 421
// PLAYER_FIELD_SKILL + 422
// PLAYER_FIELD_SKILL + 423
// PLAYER_FIELD_SKILL + 424
// PLAYER_FIELD_SKILL + 425
// PLAYER_FIELD_SKILL + 426
// PLAYER_FIELD_SKILL + 427
// PLAYER_FIELD_SKILL + 428
// PLAYER_FIELD_SKILL + 429
// PLAYER_FIELD_SKILL + 430
// PLAYER_FIELD_SKILL + 431
// PLAYER_FIELD_SKILL + 432
// PLAYER_FIELD_SKILL + 433
// PLAYER_FIELD_SKILL + 434
// PLAYER_FIELD_SKILL + 435
// PLAYER_FIELD_SKILL + 436
// PLAYER_FIELD_SKILL + 437
// PLAYER_FIELD_SKILL + 438
// PLAYER_FIELD_SKILL + 439
// PLAYER_FIELD_SKILL + 440
// PLAYER_FIELD_SKILL + 441
// PLAYER_FIELD_SKILL + 442
// PLAYER_FIELD_SKILL + 443
// PLAYER_FIELD_SKILL + 444
// PLAYER_FIELD_SKILL + 445
// PLAYER_FIELD_SKILL + 446
// PLAYER_FIELD_SKILL + 447
// PLAYER_FIELD_CHARACTER_POINTS
// PLAYER_FIELD_MAX_TALENT_TIERS
// PLAYER_FIELD_TRACK_CREATURE_MASK
// PLAYER_FIELD_TRACK_RESOURCE_MASK
// PLAYER_FIELD_MAINHAND_EXPERTISE
// PLAYER_FIELD_OFFHAND_EXPERTISE
// PLAYER_FIELD_RANGED_EXPERTISE
// PLAYER_FIELD_COMBAT_RATING_EXPERTISE
// PLAYER_FIELD_BLOCK_PERCENTAGE
// PLAYER_FIELD_DODGE_PERCENTAGE
// PLAYER_FIELD_PARRY_PERCENTAGE
// PLAYER_FIELD_CRIT_PERCENTAGE
// PLAYER_FIELD_RANGED_CRIT_PERCENTAGE
// PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 0
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 1
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 2
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 3
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 4
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 5
// PLAYER_FIELD_SPELL_CRIT_PERCENTAGE + 6
// PLAYER_FIELD_SHIELD_BLOCK
// PLAYER_FIELD_SHIELD_BLOCK_CRIT_PERCENTAGE
// PLAYER_FIELD_MASTERY
// PLAYER_FIELD_PVP_POWER_DAMAGE
// PLAYER_FIELD_PVP_POWER_HEALING
// PLAYER_FIELD_EXPLORED_ZONES + 0
// PLAYER_FIELD_EXPLORED_ZONES + 1
// PLAYER_FIELD_EXPLORED_ZONES + 2
// PLAYER_FIELD_EXPLORED_ZONES + 3
// PLAYER_FIELD_EXPLORED_ZONES + 4
// PLAYER_FIELD_EXPLORED_ZONES + 5
// PLAYER_FIELD_EXPLORED_ZONES + 6
// PLAYER_FIELD_EXPLORED_ZONES + 7
// PLAYER_FIELD_EXPLORED_ZONES + 8
// PLAYER_FIELD_EXPLORED_ZONES + 9
// PLAYER_FIELD_EXPLORED_ZONES + 10
// PLAYER_FIELD_EXPLORED_ZONES + 11
// PLAYER_FIELD_EXPLORED_ZONES + 12
// PLAYER_FIELD_EXPLORED_ZONES + 13
// PLAYER_FIELD_EXPLORED_ZONES + 14
// PLAYER_FIELD_EXPLORED_ZONES + 15
// PLAYER_FIELD_EXPLORED_ZONES + 16
// PLAYER_FIELD_EXPLORED_ZONES + 17
// PLAYER_FIELD_EXPLORED_ZONES + 18
// PLAYER_FIELD_EXPLORED_ZONES + 19
// PLAYER_FIELD_EXPLORED_ZONES + 20
// PLAYER_FIELD_EXPLORED_ZONES + 21
// PLAYER_FIELD_EXPLORED_ZONES + 22
// PLAYER_FIELD_EXPLORED_ZONES + 23
// PLAYER_FIELD_EXPLORED_ZONES + 24
// PLAYER_FIELD_EXPLORED_ZONES + 25
// PLAYER_FIELD_EXPLORED_ZONES + 26
// PLAYER_FIELD_EXPLORED_ZONES + 27
// PLAYER_FIELD_EXPLORED_ZONES + 28
// PLAYER_FIELD_EXPLORED_ZONES + 29
// PLAYER_FIELD_EXPLORED_ZONES + 30
// PLAYER_FIELD_EXPLORED_ZONES + 31
// PLAYER_FIELD_EXPLORED_ZONES + 32
// PLAYER_FIELD_EXPLORED_ZONES + 33
// PLAYER_FIELD_EXPLORED_ZONES + 34
// PLAYER_FIELD_EXPLORED_ZONES + 35
// PLAYER_FIELD_EXPLORED_ZONES + 36
// PLAYER_FIELD_EXPLORED_ZONES + 37
// PLAYER_FIELD_EXPLORED_ZONES + 38
// PLAYER_FIELD_EXPLORED_ZONES + 39
// PLAYER_FIELD_EXPLORED_ZONES + 40
// PLAYER_FIELD_EXPLORED_ZONES + 41
// PLAYER_FIELD_EXPLORED_ZONES + 42
// PLAYER_FIELD_EXPLORED_ZONES + 43
// PLAYER_FIELD_EXPLORED_ZONES + 44
// PLAYER_FIELD_EXPLORED_ZONES + 45
// PLAYER_FIELD_EXPLORED_ZONES + 46
// PLAYER_FIELD_EXPLORED_ZONES + 47
// PLAYER_FIELD_EXPLORED_ZONES + 48
// PLAYER_FIELD_EXPLORED_ZONES + 49
// PLAYER_FIELD_EXPLORED_ZONES + 50
// PLAYER_FIELD_EXPLORED_ZONES + 51
// PLAYER_FIELD_EXPLORED_ZONES + 52
// PLAYER_FIELD_EXPLORED_ZONES + 53
// PLAYER_FIELD_EXPLORED_ZONES + 54
// PLAYER_FIELD_EXPLORED_ZONES + 55
// PLAYER_FIELD_EXPLORED_ZONES + 56
// PLAYER_FIELD_EXPLORED_ZONES + 57
// PLAYER_FIELD_EXPLORED_ZONES + 58
// PLAYER_FIELD_EXPLORED_ZONES + 59
// PLAYER_FIELD_EXPLORED_ZONES + 60
// PLAYER_FIELD_EXPLORED_ZONES + 61
// PLAYER_FIELD_EXPLORED_ZONES + 62
// PLAYER_FIELD_EXPLORED_ZONES + 63
// PLAYER_FIELD_EXPLORED_ZONES + 64
// PLAYER_FIELD_EXPLORED_ZONES + 65
// PLAYER_FIELD_EXPLORED_ZONES + 66
// PLAYER_FIELD_EXPLORED_ZONES + 67
// PLAYER_FIELD_EXPLORED_ZONES + 68
// PLAYER_FIELD_EXPLORED_ZONES + 69
// PLAYER_FIELD_EXPLORED_ZONES + 70
// PLAYER_FIELD_EXPLORED_ZONES + 71
// PLAYER_FIELD_EXPLORED_ZONES + 72
// PLAYER_FIELD_EXPLORED_ZONES + 73
// PLAYER_FIELD_EXPLORED_ZONES + 74
// PLAYER_FIELD_EXPLORED_ZONES + 75
// PLAYER_FIELD_EXPLORED_ZONES + 76
// PLAYER_FIELD_EXPLORED_ZONES + 77
// PLAYER_FIELD_EXPLORED_ZONES + 78
// PLAYER_FIELD_EXPLORED_ZONES + 79
// PLAYER_FIELD_EXPLORED_ZONES + 80
// PLAYER_FIELD_EXPLORED_ZONES + 81
// PLAYER_FIELD_EXPLORED_ZONES + 82
// PLAYER_FIELD_EXPLORED_ZONES + 83
// PLAYER_FIELD_EXPLORED_ZONES + 84
// PLAYER_FIELD_EXPLORED_ZONES + 85
// PLAYER_FIELD_EXPLORED_ZONES + 86
// PLAYER_FIELD_EXPLORED_ZONES + 87
// PLAYER_FIELD_EXPLORED_ZONES + 88
// PLAYER_FIELD_EXPLORED_ZONES + 89
// PLAYER_FIELD_EXPLORED_ZONES + 90
// PLAYER_FIELD_EXPLORED_ZONES + 91
// PLAYER_FIELD_EXPLORED_ZONES + 92
// PLAYER_FIELD_EXPLORED_ZONES + 93
// PLAYER_FIELD_EXPLORED_ZONES + 94
// PLAYER_FIELD_EXPLORED_ZONES + 95
// PLAYER_FIELD_EXPLORED_ZONES + 96
// PLAYER_FIELD_EXPLORED_ZONES + 97
// PLAYER_FIELD_EXPLORED_ZONES + 98
// PLAYER_FIELD_EXPLORED_ZONES + 99
// PLAYER_FIELD_EXPLORED_ZONES + 100
// PLAYER_FIELD_EXPLORED_ZONES + 101
// PLAYER_FIELD_EXPLORED_ZONES + 102
// PLAYER_FIELD_EXPLORED_ZONES + 103
// PLAYER_FIELD_EXPLORED_ZONES + 104
// PLAYER_FIELD_EXPLORED_ZONES + 105
// PLAYER_FIELD_EXPLORED_ZONES + 106
// PLAYER_FIELD_EXPLORED_ZONES + 107
// PLAYER_FIELD_EXPLORED_ZONES + 108
// PLAYER_FIELD_EXPLORED_ZONES + 109
// PLAYER_FIELD_EXPLORED_ZONES + 110
// PLAYER_FIELD_EXPLORED_ZONES + 111
// PLAYER_FIELD_EXPLORED_ZONES + 112
// PLAYER_FIELD_EXPLORED_ZONES + 113
// PLAYER_FIELD_EXPLORED_ZONES + 114
// PLAYER_FIELD_EXPLORED_ZONES + 115
// PLAYER_FIELD_EXPLORED_ZONES + 116
// PLAYER_FIELD_EXPLORED_ZONES + 117
// PLAYER_FIELD_EXPLORED_ZONES + 118
// PLAYER_FIELD_EXPLORED_ZONES + 119
// PLAYER_FIELD_EXPLORED_ZONES + 120
// PLAYER_FIELD_EXPLORED_ZONES + 121
// PLAYER_FIELD_EXPLORED_ZONES + 122
// PLAYER_FIELD_EXPLORED_ZONES + 123
// PLAYER_FIELD_EXPLORED_ZONES + 124
// PLAYER_FIELD_EXPLORED_ZONES + 125
// PLAYER_FIELD_EXPLORED_ZONES + 126
// PLAYER_FIELD_EXPLORED_ZONES + 127
// PLAYER_FIELD_EXPLORED_ZONES + 128
// PLAYER_FIELD_EXPLORED_ZONES + 129
// PLAYER_FIELD_EXPLORED_ZONES + 130
// PLAYER_FIELD_EXPLORED_ZONES + 131
// PLAYER_FIELD_EXPLORED_ZONES + 132
// PLAYER_FIELD_EXPLORED_ZONES + 133
// PLAYER_FIELD_EXPLORED_ZONES + 134
// PLAYER_FIELD_EXPLORED_ZONES + 135
// PLAYER_FIELD_EXPLORED_ZONES + 136
// PLAYER_FIELD_EXPLORED_ZONES + 137
// PLAYER_FIELD_EXPLORED_ZONES + 138
// PLAYER_FIELD_EXPLORED_ZONES + 139
// PLAYER_FIELD_EXPLORED_ZONES + 140
// PLAYER_FIELD_EXPLORED_ZONES + 141
// PLAYER_FIELD_EXPLORED_ZONES + 142
// PLAYER_FIELD_EXPLORED_ZONES + 143
// PLAYER_FIELD_EXPLORED_ZONES + 144
// PLAYER_FIELD_EXPLORED_ZONES + 145
// PLAYER_FIELD_EXPLORED_ZONES + 146
// PLAYER_FIELD_EXPLORED_ZONES + 147
// PLAYER_FIELD_EXPLORED_ZONES + 148
// PLAYER_FIELD_EXPLORED_ZONES + 149
// PLAYER_FIELD_EXPLORED_ZONES + 150
// PLAYER_FIELD_EXPLORED_ZONES + 151
// PLAYER_FIELD_EXPLORED_ZONES + 152
// PLAYER_FIELD_EXPLORED_ZONES + 153
// PLAYER_FIELD_EXPLORED_ZONES + 154
// PLAYER_FIELD_EXPLORED_ZONES + 155
// PLAYER_FIELD_EXPLORED_ZONES + 156
// PLAYER_FIELD_EXPLORED_ZONES + 157
// PLAYER_FIELD_EXPLORED_ZONES + 158
// PLAYER_FIELD_EXPLORED_ZONES + 159
// PLAYER_FIELD_EXPLORED_ZONES + 160
// PLAYER_FIELD_EXPLORED_ZONES + 161
// PLAYER_FIELD_EXPLORED_ZONES + 162
// PLAYER_FIELD_EXPLORED_ZONES + 163
// PLAYER_FIELD_EXPLORED_ZONES + 164
// PLAYER_FIELD_EXPLORED_ZONES + 165
// PLAYER_FIELD_EXPLORED_ZONES + 166
// PLAYER_FIELD_EXPLORED_ZONES + 167
// PLAYER_FIELD_EXPLORED_ZONES + 168
// PLAYER_FIELD_EXPLORED_ZONES + 169
// PLAYER_FIELD_EXPLORED_ZONES + 170
// PLAYER_FIELD_EXPLORED_ZONES + 171
// PLAYER_FIELD_EXPLORED_ZONES + 172
// PLAYER_FIELD_EXPLORED_ZONES + 173
// PLAYER_FIELD_EXPLORED_ZONES + 174
// PLAYER_FIELD_EXPLORED_ZONES + 175
// PLAYER_FIELD_EXPLORED_ZONES + 176
// PLAYER_FIELD_EXPLORED_ZONES + 177
// PLAYER_FIELD_EXPLORED_ZONES + 178
// PLAYER_FIELD_EXPLORED_ZONES + 179
// PLAYER_FIELD_EXPLORED_ZONES + 180
// PLAYER_FIELD_EXPLORED_ZONES + 181
// PLAYER_FIELD_EXPLORED_ZONES + 182
// PLAYER_FIELD_EXPLORED_ZONES + 183
// PLAYER_FIELD_EXPLORED_ZONES + 184
// PLAYER_FIELD_EXPLORED_ZONES + 185
// PLAYER_FIELD_EXPLORED_ZONES + 186
// PLAYER_FIELD_EXPLORED_ZONES + 187
// PLAYER_FIELD_EXPLORED_ZONES + 188
// PLAYER_FIELD_EXPLORED_ZONES + 189
// PLAYER_FIELD_EXPLORED_ZONES + 190
// PLAYER_FIELD_EXPLORED_ZONES + 191
// PLAYER_FIELD_EXPLORED_ZONES + 192
// PLAYER_FIELD_EXPLORED_ZONES + 193
// PLAYER_FIELD_EXPLORED_ZONES + 194
// PLAYER_FIELD_EXPLORED_ZONES + 195
// PLAYER_FIELD_EXPLORED_ZONES + 196
// PLAYER_FIELD_EXPLORED_ZONES + 197
// PLAYER_FIELD_EXPLORED_ZONES + 198
// PLAYER_FIELD_EXPLORED_ZONES + 199
// PLAYER_FIELD_REST_STATE_BONUS_POOL
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 0
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 1
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 2
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 3
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 4
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 5
// PLAYER_FIELD_MOD_DAMAGE_DONE_POS + 6
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 0
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 1
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 2
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 3
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 4
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 5
// PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + 6
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 0
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 1
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 2
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 3
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 4
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 5
// PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + 6
// PLAYER_FIELD_MOD_HEALING_DONE_POS
// PLAYER_FIELD_MOD_HEALING_PERCENT
// PLAYER_FIELD_MOD_HEALING_DONE_PERCENT
// PLAYER_FIELD_MOD_PERIODIC_HEALING_DONE_PERCENT
// PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS + 0
// PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS + 1
// PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS + 2
// PLAYER_FIELD_MOD_SPELL_POWER_PERCENT
// PLAYER_FIELD_MOD_RESILIENCE_PERCENT
// PLAYER_FIELD_OVERRIDE_SPELL_POWER_BY_APPERCENT
// PLAYER_FIELD_OVERRIDE_APBY_SPELL_POWER_PERCENT
// PLAYER_FIELD_MOD_TARGET_RESISTANCE
// PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE
// PLAYER_FIELD_LIFETIME_MAX_RANK
// PLAYER_FIELD_SELF_RES_SPELL
// PLAYER_FIELD_PVP_MEDALS
// PLAYER_FIELD_BUYBACK_PRICE + 0
// PLAYER_FIELD_BUYBACK_PRICE + 1
// PLAYER_FIELD_BUYBACK_PRICE + 2
// PLAYER_FIELD_BUYBACK_PRICE + 3
// PLAYER_FIELD_BUYBACK_PRICE + 4
// PLAYER_FIELD_BUYBACK_PRICE + 5
// PLAYER_FIELD_BUYBACK_PRICE + 6
// PLAYER_FIELD_BUYBACK_PRICE + 7
// PLAYER_FIELD_BUYBACK_PRICE + 8
// PLAYER_FIELD_BUYBACK_PRICE + 9
// PLAYER_FIELD_BUYBACK_PRICE + 10
// PLAYER_FIELD_BUYBACK_PRICE + 11
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 0
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 1
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 2
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 3
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 4
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 5
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 6
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 7
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 8
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 9
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 10
// PLAYER_FIELD_BUYBACK_TIMESTAMP + 11
// PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS
// PLAYER_FIELD_LIFETIME_HONORABLE_KILLS
// PLAYER_FIELD_WATCHED_FACTION_INDEX
// PLAYER_FIELD_COMBAT_RATINGS + 0
// PLAYER_FIELD_COMBAT_RATINGS + 1
// PLAYER_FIELD_COMBAT_RATINGS + 2
// PLAYER_FIELD_COMBAT_RATINGS + 3
// PLAYER_FIELD_COMBAT_RATINGS + 4
// PLAYER_FIELD_COMBAT_RATINGS + 5
// PLAYER_FIELD_COMBAT_RATINGS + 6
// PLAYER_FIELD_COMBAT_RATINGS + 7
// PLAYER_FIELD_COMBAT_RATINGS + 8
// PLAYER_FIELD_COMBAT_RATINGS + 9
// PLAYER_FIELD_COMBAT_RATINGS + 10
// PLAYER_FIELD_COMBAT_RATINGS + 11
// PLAYER_FIELD_COMBAT_RATINGS + 12
// PLAYER_FIELD_COMBAT_RATINGS + 13
// PLAYER_FIELD_COMBAT_RATINGS + 14
// PLAYER_FIELD_COMBAT_RATINGS + 15
// PLAYER_FIELD_COMBAT_RATINGS + 16
// PLAYER_FIELD_COMBAT_RATINGS + 17
// PLAYER_FIELD_COMBAT_RATINGS + 18
// PLAYER_FIELD_COMBAT_RATINGS + 19
// PLAYER_FIELD_COMBAT_RATINGS + 20
// PLAYER_FIELD_COMBAT_RATINGS + 21
// PLAYER_FIELD_COMBAT_RATINGS + 22
// PLAYER_FIELD_COMBAT_RATINGS + 23
// PLAYER_FIELD_COMBAT_RATINGS + 24
// PLAYER_FIELD_COMBAT_RATINGS + 25
// PLAYER_FIELD_COMBAT_RATINGS + 26
// PLAYER_FIELD_PVP_INFO + 0
// PLAYER_FIELD_PVP_INFO + 1
// PLAYER_FIELD_PVP_INFO + 2
// PLAYER_FIELD_PVP_INFO + 3
// PLAYER_FIELD_PVP_INFO + 4
// PLAYER_FIELD_PVP_INFO + 5
// PLAYER_FIELD_PVP_INFO + 6
// PLAYER_FIELD_PVP_INFO + 7
// PLAYER_FIELD_PVP_INFO + 8
// PLAYER_FIELD_PVP_INFO + 9
// PLAYER_FIELD_PVP_INFO + 10
// PLAYER_FIELD_PVP_INFO + 11
// PLAYER_FIELD_PVP_INFO + 12
// PLAYER_FIELD_PVP_INFO + 13
// PLAYER_FIELD_PVP_INFO + 14
// PLAYER_FIELD_PVP_INFO + 15
// PLAYER_FIELD_PVP_INFO + 16
// PLAYER_FIELD_PVP_INFO + 17
// PLAYER_FIELD_PVP_INFO + 18
// PLAYER_FIELD_PVP_INFO + 19
// PLAYER_FIELD_PVP_INFO + 20
// PLAYER_FIELD_PVP_INFO + 21
// PLAYER_FIELD_PVP_INFO + 22
// PLAYER_FIELD_PVP_INFO + 23
// PLAYER_FIELD_MAX_LEVEL
// PLAYER_FIELD_RUNE_REGEN + 0
// PLAYER_FIELD_RUNE_REGEN + 1
// PLAYER_FIELD_RUNE_REGEN + 2
// PLAYER_FIELD_RUNE_REGEN + 3
// PLAYER_FIELD_NO_REAGENT_COST_MASK + 0
// PLAYER_FIELD_NO_REAGENT_COST_MASK + 1
// PLAYER_FIELD_NO_REAGENT_COST_MASK + 2
// PLAYER_FIELD_NO_REAGENT_COST_MASK + 3
// PLAYER_FIELD_GLYPH_SLOTS + 0
// PLAYER_FIELD_GLYPH_SLOTS + 1
// PLAYER_FIELD_GLYPH_SLOTS + 2
// PLAYER_FIELD_GLYPH_SLOTS + 3
// PLAYER_FIELD_GLYPH_SLOTS + 4
// PLAYER_FIELD_GLYPH_SLOTS + 5
// PLAYER_FIELD_GLYPHS + 0
// PLAYER_FIELD_GLYPHS + 1
// PLAYER_FIELD_GLYPHS + 2
// PLAYER_FIELD_GLYPHS + 3
// PLAYER_FIELD_GLYPHS + 4
// PLAYER_FIELD_GLYPHS + 5
// PLAYER_FIELD_GLYPH_SLOTS_ENABLED
// PLAYER_FIELD_PET_SPELL_POWER
// PLAYER_FIELD_RESEARCHING + 0
// PLAYER_FIELD_RESEARCHING + 1
// PLAYER_FIELD_RESEARCHING + 2
// PLAYER_FIELD_RESEARCHING + 3
// PLAYER_FIELD_RESEARCHING + 4
// PLAYER_FIELD_RESEARCHING + 5
// PLAYER_FIELD_RESEARCHING + 6
// PLAYER_FIELD_RESEARCHING + 7
// PLAYER_FIELD_PROFESSION_SKILL_LINE + 0
// PLAYER_FIELD_PROFESSION_SKILL_LINE + 1
// PLAYER_FIELD_UI_HIT_MODIFIER
// PLAYER_FIELD_UI_SPELL_HIT_MODIFIER
// PLAYER_FIELD_HOME_REALM_TIME_OFFSET
// PLAYER_FIELD_MOD_PET_HASTE
// PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID + 0
// PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID + 1
// PLAYER_FIELD_OVERRIDE_SPELLS_ID
// PLAYER_FIELD_LFG_BONUS_FACTION_ID
// PLAYER_FIELD_LOOT_SPEC_ID
// PLAYER_FIELD_OVERRIDE_ZONE_PVPTYPE
// PLAYER_FIELD_ITEM_LEVEL_DELTA
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// GAMEOBJECT_FIELD_CREATED_BY + 0
// GAMEOBJECT_FIELD_CREATED_BY + 1
// GAMEOBJECT_FIELD_DISPLAY_ID
// GAMEOBJECT_FIELD_FLAGS
// GAMEOBJECT_FIELD_PARENT_ROTATION + 0
// GAMEOBJECT_FIELD_PARENT_ROTATION + 1
// GAMEOBJECT_FIELD_PARENT_ROTATION + 2
// GAMEOBJECT_FIELD_PARENT_ROTATION + 3
// GAMEOBJECT_FIELD_FACTION_TEMPLATE
// GAMEOBJECT_FIELD_LEVEL
// GAMEOBJECT_FIELD_PERCENT_HEALTH
// GAMEOBJECT_FIELD_STATE_SPELL_VISUAL_ID
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// DYNAMICOBJECT_FIELD_CASTER + 0
// DYNAMICOBJECT_FIELD_CASTER + 1
// DYNAMICOBJECT_FIELD_TYPE_AND_VISUAL_ID
// DYNAMICOBJECT_FIELD_SPELL_ID
// DYNAMICOBJECT_FIELD_RADIUS
// DYNAMICOBJECT_FIELD_CAST_TIME
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// CGCORPSEDATA_FIELD_OWNER + 0
// CGCORPSEDATA_FIELD_OWNER + 1
// CGCORPSEDATA_FIELD_PARTY_GUID + 0
// CGCORPSEDATA_FIELD_PARTY_GUID + 1
// CGCORPSEDATA_FIELD_DISPLAY_ID
// CGCORPSEDATA_FIELD_ITEMS + 0
// CGCORPSEDATA_FIELD_ITEMS + 1
// CGCORPSEDATA_FIELD_ITEMS + 2
// CGCORPSEDATA_FIELD_ITEMS + 3
// CGCORPSEDATA_FIELD_ITEMS + 4
// CGCORPSEDATA_FIELD_ITEMS + 5
// CGCORPSEDATA_FIELD_ITEMS + 6
// CGCORPSEDATA_FIELD_ITEMS + 7
// CGCORPSEDATA_FIELD_ITEMS + 8
// CGCORPSEDATA_FIELD_ITEMS + 9
// CGCORPSEDATA_FIELD_ITEMS + 10
// CGCORPSEDATA_FIELD_ITEMS + 11
// CGCORPSEDATA_FIELD_ITEMS + 12
// CGCORPSEDATA_FIELD_ITEMS + 13
// CGCORPSEDATA_FIELD_ITEMS + 14
// CGCORPSEDATA_FIELD_ITEMS + 15
// CGCORPSEDATA_FIELD_ITEMS + 16
// CGCORPSEDATA_FIELD_ITEMS + 17
// CGCORPSEDATA_FIELD_ITEMS + 18
// CGCORPSEDATA_FIELD_SKIN_ID
// CGCORPSEDATA_FIELD_FACIAL_HAIR_STYLE_ID
// CGCORPSEDATA_FIELD_FLAGS
// CGCORPSEDATA_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_GUID + 0
// OBJECT_FIELD_GUID + 1
// OBJECT_FIELD_DATA + 0
// OBJECT_FIELD_DATA + 1
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// AREATRIGGER_FIELD_CASTER + 0
// AREATRIGGER_FIELD_CASTER + 1
// AREATRIGGER_FIELD_DURATION
// AREATRIGGER_FIELD_SPELL_ID
// AREATRIGGER_FIELD_SPELL_VISUAL_ID
// AREATRIGGER_FIELD_EXPLICIT_SCALE
// SCENEOBJECT_FIELD_SCRIPT_PACKAGE_ID
// SCENEOBJECT_FIELD_RND_SEED_VAL
// SCENEOBJECT_FIELD_CREATED_BY
// SCENEOBJECT_FIELD_CREATED_BY + 1
// SCENEOBJECT_FIELD_SCENE_TYPE
// ITEM_DYNAMIC_FIELD_MODIFIERS
// OBJECT_FIELD_GUID
// OBJECT_FIELD_GUID
// OBJECT_FIELD_DATA
// OBJECT_FIELD_DATA
// OBJECT_FIELD_TYPE
// OBJECT_FIELD_ENTRY_ID
// OBJECT_FIELD_DYNAMIC_FLAGS
// OBJECT_FIELD_SCALE
// UNIT_DYNAMIC_FIELD_PASSIVE_SPELLS
// UNIT_DYNAMIC_FIELD_WORLD_EFFECTS
// PLAYER_DYNAMIC_FIELD_RESERACH_SITE
// PLAYER_DYNAMIC_FIELD_RESEARCH_SITE_PROGRESS
// PLAYER_DYNAMIC_FIELD_DAILY_QUESTS
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
///- Register the pet for guid lookup
///- Register the pet for guid lookup
// Prevent stuck pets when zoning. Pets default to "follow" when added to world
// so we'll reset flags and let the AI handle things
///- Remove the pet from the accessor
///- Don't call the function for Creature, normal mobs + totems go in a different storage
// Known petnumber entry
// Current pet (slot 0)
// known petEntry entry (unique for summoned pet, but non unique for hunter pet (only from current or not stabled pets)
// Any current or other non-stabled pet (for hunter "call pet")
// update for case of current pet "slot = 0"
/*owner->GetPhaseMask(),*/ petEntry, petId))
// this enables popup window (pet dismiss, cancel)
// this enables popup window (pet abandon, cancel)
// cast can't be helped here
//all (?) summon pets come with full health when called, but not when they are current
// set current pet as current
// 0=current
// 1..MAX_PET_STABLES in stable slot
// PET_SAVE_NOT_IN_SLOT(100) = not stable slot (summoning))
// Send fake summon spell cast - this is needed for correct cooldown application for spells
// Example: 46584 - without this cooldown (which should be set always when pet is loaded) isn't set clientside
/// @todo pets should be summoned from real cast instead of just faking it?
// TODO FIX THIS GOD DAMN HACK
/*if (summonSpellId)
// CAST_FLAG_UNKNOWN3
// set original talents points before spell loading
// load action bar, if data broken will fill later by default spells.
// re-init to check talent count
// remove unknown spells from action bar after load
//set last used pet number (for use in BG's)
// save only fully controlled creature
// not save not player pets
// not save pet as current if another pet temporary unsummoned
// pet will lost anyway at restore temporary unsummoned
// for warlock case
// save auras before possibly removing them
// stable and not in slot saves
// current/stable/not_in_slot
// remove current data
// prevent duplicate using slot (except PET_SAVE_NOT_IN_SLOT)
// prevent existence another hunter pet in PET_SAVE_AS_CURRENT and PET_SAVE_NOT_IN_SLOT
// save pet
// delete
// overwrite virtual Creature::setDeathState and Unit::setDeathState
// pet corpse non lootable and non skinnable
//SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
//RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
// pet already removed, just wait in remove queue, no updates
//hunters' pets never get removed because of death, NEVER!
// unsummon pet that lost owner
//if (!owner || (!IsWithinDistInMap(owner, GetMap()->GetVisibilityDistance()) && (owner->GetCharmGUID() && (owner->GetCharmGUID() != GetGUID()))) || (isControlled() && !owner->GetPetGUID()))
//regenerate focus for hunter pets or energy for deathknight's ghoul
// Reset if large diff (lag) causes focus to get 'stuck'
// in creature::update
//case POWER_ENERGY:
//    Regenerate(POWER_ENERGY);
//    m_regenTimer += CREATURE_REGEN_INTERVAL - diff;
//    if (!m_regenTimer) ++m_regenTimer;
//    break;
// For hunter pets.
// For deathknight's ghoul.
// Apply modifiers (if any).
// If pet is detected to be at, or above(?) the players level, don't hand out XP
// Check how much XP the pet should receive, and hand off have any left from previous levelups
// Subtract newXP from amount needed for nextlevel, and give pet the level
// Not affected by special conditions - give it new XP
/*, creature->GetPhaseMask()*/))
/*, owner->GetPhaseMask()*/))
/*, uint32 phaseMask*/)
/*phaseMask,*/ cinfo->Entry, petId))
/// @todo Move stat mods code to pet passive auras
//Determine pet type
// Fire Elemental
// Risen Ghoul
//scale
// Resistance
//health, mana, armor and resistance
// exist in DB
//hunter pet use focus
// not exist in DB, use some default fake data
// remove elite bonuses included in DB values
// the damage bonus used for pets is either fire or shadow damage, whatever is higher
//SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, float(cinfo->attackpower));
//these formula may not be correct; however, it is designed to be close to what it should be
//this makes dps 0.5 of pets level
//damage range is then petlevel / 2
//damage is increased afterwards as strength and pet scaling modify attack power
// mage Water Elemental
//force of nature
//earth elemental 36213
//fire elemental
// Shadowfiend
//Snake Trap - Venomous Snake
//Snake Trap - Viper
// Feral Spirit
// wolf attack speed is 1.5s
// Bonus Armor (35% of player armor)
// Bonus Stamina (30% of player stamina)
//prevent apply twice for the 2 wolves
//Spirit Hunt, passive, Spirit Wolves' attacks heal them and their master for 150% of damage done.
// Mirror Image
// Ebon Gargoyle
// Bloodworms
// -5 or greater food level
//possible to feed level 60 pet with level 55 level food for full effect
// -10..-6
//pure guess, but sounds good
// -14..-11
//level 55 food gets green on 70, makes sense to me
// -15 or less
//food too low level
// Missing flags
// skip outdated cooldown
// remove oudated and save active
// prevent saving family passives to DB
// NULL guid stored - pet is the caster of the spell - see Pet::_SaveAuras
// negative effects should continue counting down after logout
// prevent wrong values of remaincharges
// check if the aura has to be saved
// don't save guid of caster in case we are caster of the spell - guid for pet is generated every pet load, so it won't match saved guid anyways
/*= ACT_DECIDE*/, PetSpellState state /*= PETSPELL_NEW*/, PetSpellType type /*= PETSPELL_NORMAL*/)
// do pet spell book cleanup
// spell load case
// can be in case spell loading but learned at some previous spell loading
// active was not used before, so we save it's autocast/passive state here
// replace by new high rank
// ignore new lesser rank
// update free talent points
// prevent duplicated entires in spell book
// PetLevelupSpellSet ordered by levels, process in reversed order
// will called first if level down
// will learn prev rank if any
// will called if level up
// will unlearn prev rank if any
// default spells (can be not learned if pet level (as owner level decrease result for example) less first possible in normal game)
// will called first if level down
// will called if level up
// update free talent points
// if remove last rank or non-ranked then update action bar at server and client if need
// need update action bar for last removed rank
/*
// not need after this call
// Check pet talent type
// unlearn only talents for pets family talent type
// remove learned spells (all ranks)
// unlearn if first rank is talent or learned by talent
/*= NULL*/)
// not need after this call
// reset for online
// now need only reset for offline pets (all pets except online case)
// no offline pets
// Reset talents in case low level (on level down) or wrong points for level (hunter can unlearn TP increase talent)
// Remove all talent points
// Mod points from owner SPELL_AURA_MOD_PET_TALENT_POINTS
// just search
// just search
/*uint32 phaseMask,*/ uint32 Entry, uint32 petId)
//SetPhaseMask(phaseMask, false);
// Get all passive spells in our skill line
// For general hunter pets skill 270
// Passive 01~10, Passive 00 (20782, not used), Ferocious Inspiration (34457)
// Scale 01~03 (34902~34904, bonus from owner, not used)
// Demonic Knowledge
// if the owner has that pet aura, return true
// always same level
// can't be greater owner level
// Missing flags
// Not send cooldown for this spells
// in m.secs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// name, gender, etc...
// name, gender, faction, etc...
// name, gender, race, etc...
// corpse reclaim times
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// Death Knight
// Shaman
// Mage
// Warlock
// Druid
// == PlayerTaxi ================================================
// class specific initial known nodes
// race specific initial known nodes: capital and taxi hub masks
// Human
// Orc
// Dwarf
// Night Elf
// Undead
// Tauren
// Gnome
// Troll
// Blood Elf
// Draenei
// new continent starting masks (It will be accessible only at new map)
// level dependent taxi hubs
//Shattered Sun Staging Area
// load and set bits only for existing taxi nodes
// all existed nodes
// known nodes
// Check integrity
// can't load taxi path without mount set (quest taxi path?)
//== TradeData =================================================
// need remove possible trader spell applied to changed item
// need remove possible player spell applied (possible move reagent)
/*= NULL*/)
// send spell info to item owner
// send spell info to caster self
/*= true*/)
// player state for trader
// player state for player
/*= false*/)
// == KillRewarder ====================================================
// KillRewarder incapsulates logic of rewarding player upon kill with:
// * XP;
// * honor;
// * reputation;
// * kill credit (for quest objectives).
// Rewarding is initiated in two cases: when player kills unit in Unit::Kill()
// and on battlegrounds in Battleground::RewardXPAtKill().
//
// Rewarding algorithm is:
// 1. Initialize internal variables to default values.
// 2. In case when player is in group, initialize variables necessary for group calculations:
// 2.1. _count - number of alive group members within reward distance;
// 2.2. _sumLevel - sum of levels of alive group members within reward distance;
// 2.3. _maxLevel - maximum level of alive group member within reward distance;
// 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
//      for whom victim is not gray;
// 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
//      so 100% XP will be rewarded (50% otherwise).
// 3. Reward killer (and group, if necessary).
// 3.1. If killer is in group, reward group.
// 3.1.1. Initialize initial XP amount based on maximum level of group member,
//        for whom victim is not gray.
// 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
// 3.1.3. Reward each group member (even dead) within reward distance (see 4. for more details).
// 3.2. Reward single killer (not group case).
// 3.2.1. Initialize initial XP amount based on killer's level.
// 3.2.2. Reward killer (see 4. for more details).
// 4. Reward player.
// 4.1. Give honor (player must be alive and not on BG).
// 4.2. Give XP.
// 4.2.1. If player is in group, adjust XP:
//        * set to 0 if player's level is more than maximum level of not gray member;
//        * cut XP in half if _isFullXP is false.
// 4.2.2. Apply auras modifying rewarded XP.
// 4.2.3. Give XP to player.
// 4.2.4. If player has pet, reward pet with XP (100% for single player, 50% for group case).
// 4.3. Give reputation (player must not be on BG).
// 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
// 5. Credit instance encounter.
// 6. Update guild achievements.
// 1. Initialize internal variables to default values.
// mark the credit as pvp if victim is player
// or if its owned by player and its not a vehicle
// 2. In case when player is in group, initialize variables necessary for group calculations:
// 2.1. _count - number of alive group members within reward distance;
// 2.2. _sumLevel - sum of levels of alive group members within reward distance;
// 2.3. _maxLevel - maximum level of alive group member within reward distance;
// 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
//      for whom victim is not gray;
// 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
//      so 100% XP will be rewarded (50% otherwise).
// Get initial value of XP for kill.
// XP is given:
// * on battlegrounds;
// * otherwise, not in PvP;
// * not if killer is on vehicle.
// Rewarded player must be alive.
// 4.2.1. If player is in group, adjust XP:
//        * set to 0 if player's level is more than maximum level of not gray member;
//        * cut XP in half if _isFullXP is false.
// Reward FULL XP if all group members are not gray.
// Reward only HALF of XP if some of group members are gray.
// 4.2.2. Apply auras modifying rewarded XP (SPELL_AURA_MOD_XP_PCT).
// 4.2.3. Calculate expansion penalty
// Players get only 10% xp for killing creatures of lower expansion levels than himself
// 4.2.4. Give XP to player.
// 4.2.5. If player has pet, reward pet with XP (100% for single player, 50% for group case).
// 4.3. Give reputation (player must not be on BG).
// Even dead players and corpses are rewarded.
// 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
// 4. Reward player.
// 4.1. Give honor (player must be alive and not on BG).
// 4.1.1 Send player killcredit for quests with PlayerSlain
// Give XP only in PvE or in battlegrounds.
// Give reputation and kill credit only in PvE.
// Group rate depends on summary level.
// Personal rate is 100%.
// 4.2. Give XP.
// If killer is in dungeon then all members receive full reputation at kill.
// 3.1.1. Initialize initial XP amount based on maximum level of group member,
//        for whom victim is not gray.
// To avoid unnecessary calculations and calls,
// proceed only if XP is not ZERO or player is not on battleground
// (battleground rewards only XP, that's why).
// 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
// 3.1.3. Reward each group member (even dead or corpse) within reward distance.
// 3. Reward killer (and group, if necessary).
// 3.1. If killer is in group, reward group.
// 3.2. Reward single killer (not group case).
// 3.2.1. Initialize initial XP amount based on killer's level.
// To avoid unnecessary calculations and calls,
// proceed only if XP is not ZERO or player is not on battleground
// (battleground rewards only XP, that's why).
// 3.2.2. Reward killer.
// 5. Credit instance encounter.
// 6. Update guild achievements.
// == Player ====================================================
// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
//m_pad = 0;
// players always accept
// group is initialized in the reference constructor
//cache for UNIT_FIELD_CREATED_BY_SPELL to allow
//returning reagents for temporarily removed pets
//when dying/logging out
////////////////////Rest System/////////////////////
////////////////////Rest System/////////////////////
/////////////////// Instance System /////////////////////
// Honor System
// Player summoning
// it must be unloaded already in PlayerLogout and accessed only for loggined player
//m_social = NULL;
// Note: buy back item already deleted from DB when player was saved
//all mailed items should be deleted, also all mail should be deallocated
//if item is duplicated... then server may crash ... but that item should be deallocated
// clean up player-instance binds, may unload some instance saves
//FIXME: outfitId not used in player creating
/// @todo need more checks against packet modifications
// should check that skin, face, hair* are valid via DBC per race/class
// also do it in Player::BuildEnumData, Player::LoadFromDB
// default for players in 3.0.3
// -1 is default value
// BattlefieldArenaFaction (0 or 1)
// 0=disabled
// set starting level
// start with every map explored
//Reputations if "StartAllReputation" is enabled, -- @todo Fix this in a better way
// Factions depending on team, like cities and some more stuff
// Played time
// base stats and related field values
// to max set before any spell added
// apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
// Update max Health (for add bonus from stamina)
// Update max Mana (for add bonus from intellect)
// original spells
// original action bar
// original items
// just skip, reported in ObjectMgr::LoadItemTemplates
// BuyCount by default
// special amount for food/drink
// food
// drink
// bags and main-hand weapon must equipped at this moment
// now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
// or ammo not equipped in special bag
// equip offhand weapon/shield if it attempt equipped before main-hand weapon
// move other items to more appropriate slots
// all item positions resolved
// attempt equip by one
// equipped
// attempt store
// store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
// stored
// item can't be added
// spell id
// Paused
// check for GM and death state included in isAttackableByAOE
// Absorb, resist some environmental damage type
// Power Data
// DealDamage not apply item durability loss at self damage
// durability lost message
// Desync flags for update on next HandleDrowning
// In water
// Breath timer not activated - activate it
// If activated - do tick
// Timer limit - need deal damage
// Calculate and deal damage
/// @todo Check this formula
// Update time in client if need
// Regen timer
// Need breath regen
// In dark water
// Fatigue timer not activated - activate it
// Timer limit - need deal damage or teleport ghost to graveyard
// Calculate and deal damage
// Teleport ghost to graveyard
// Regen timer
/*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
// Breath timer not activated - activate it
// Calculate and deal damage
/// @todo Check this formula
// need to skip Slime damage in Undercity,
// maybe someone can find better way to handle environmental damage
//else if (m_zoneUpdateId != 1497)
//    EnvironmentalDamage(DAMAGE_SLIME, damage);
// Recheck timers flag
///The player sobers by 1% every 9 seconds
/*= 0*/)
// select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
// reset sobering timer
// undelivered mail
// It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
// If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
// Having this would prevent more aura charges to be dropped, so let's crash
//ASSERT (!m_spellModTakingSpell);
//SF_LOG_FATAL("entities.player", "Player has m_pad %u during update!", m_pad);
//if (m_spellModTakingSpell)
//used to implement delayed far teleports
// Update items that have just a limited lifetime
// check every second
// If mute expired, remove it from the DB
// Set the mute time to 0
// current iter will be removed in FailQuest
// default combat reach 10
/// @todo add weapon, skill check
// send single time (client auto repeat)
//120 degrees of radiant range
// send single time (client auto repeat)
// send single time (client auto repeat)
// prevent base and off attack in same time, delay attack at 0.2 sec
// do attack
// prevent base and off attack in same time, delay attack at 0.2 sec
// do attack
/*Unit* owner = victim->GetOwner();
// freeze update
// freeze update
// speed collect rest bonus (section/in hour)
// also update area
// use area updates as well
// needed for free far all arenas for example
// m_nextSave reset in SaveToDB call
//Handle Water/drowning
// Played time
// Total played time
// Level played time
// Player left the instance
// not auto-free ghost from body in instances
// group update
//if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityDistance()) && (GetCharmGUID() && (pet->GetGUID() != GetCharmGUID())))
//we should execute delayed teleports only for alive(!) players
//because we don't want player's ghost teleported from graveyard
// drunken state is cleared on death
// lost combo points at any target (targeted combo points clear in Unit::setDeathState)
//FIXME: is pet dismissed at dying or releasing spirit? if second, add setDeathState(DEAD) to HandleRepopRequestOpcode and define pet unsummon here with (s == DEAD)
// save value before aura remove in Unit::setDeathState
// passive spell
// restore resurrection spell id for player after aura remove
//clear aura case after resurrection by another way (spells will be applied before next death)
//             0               1                2                3                 4                  5                       6                        7
//    "SELECT characters.guid, characters.name, characters.race, characters.class, characters.gender, characters.playerBytes, characters.playerBytes2, characters.level, "
//     8                9               10                     11                     12                     13                    14
//    "characters.zone, characters.map, characters.position_x, characters.position_y, characters.position_z, guild_member.guildid, characters.playerFlags, "
//    15                    16                   17                     18                   19               20                     21               22
//    "characters.at_login, character_pet.entry, character_pet.modelid, character_pet.level, characters.data, character_banned.guid, characters.slot, character_declinedname.genitive"
// show pet at selection character in character list only for non-ghost character
// Packet content flags
// Can boost ? yes :)
// Character data
// UNK02 - might be swaped with UNK03
// List order
// Hair style
// Name
// X
// UNK00 new field - Boost fieldand the pet fields
// Face
// Class
// values stored in 2 uint16
// Character customization flags
// Pet family
// Map Id
// Race
// Skin
// Level
// Hair color
// Gender
// Facial hair
// Pet level
// Y
// Pet DisplayID
// UNK03 - might be swaped with UNK02 and the pet fields
// Character flags
// Zone id
// Z
// afk player not allowed in battleground
// preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
// don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
// don't let gm level > 1 either
// client without expansion support
// teleport to near graveyard if on transport, looks blizz like :)
// normal client can't teleport to this map...
// reset movement flags at teleport, because player will continue move with these flags after teleport
// The player was ported to another map and loses the duel immediately.
// We have to perform this check before the teleport, otherwise the
// ObjectAccessor won't find the flag.
//lets reset far teleport flag if it wasn't reset during chained teleports
//setup delayed teleport flag
//if teleport spell is casted in Unit::Update() func
//then we need to delay it until update process will be finished
//lets save teleport destination for player
//same map, only remove pet if out of range for new position
// this will be used instead of the current location in SaveToDB
// code for finish transfer called in WorldSession::HandleMovementOpcodes()
// at client packet CMSG_MOVE_TELEPORT_ACK
// near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
// this automatically relocates to oldPos in order to broadcast the packet in the right place
// far teleport to another map
// check if we can enter before stopping combat / removing pet / totems / interrupting spells
// Check enter rights before map getting to avoid creating instance copy for player
// this check not dependent from map instance copy and same for all instance copies of selected map
//I think this always returns true. Correct me if I am wrong.
// If the map is not created, assume it is possible to enter it.
// It will be created in the WorldPortAck.
//Map* map = sMapMgr->FindBaseNonInstanceMap(mapid);
//if (!map || map->CanEnter(this))
//lets reset near teleport flag if it wasn't reset during chained teleports
//setup delayed teleport flag
//if teleport spell is casted in Unit::Update() func
//then we need to delay it until update process will be finished
//lets save teleport destination for player
// remove player from battleground on far teleport (when changing maps)
// Note: at battleground join battleground id set before teleport
// and we already will found "current" battleground
// just need check that this is targeted map or leave
// don't teleport to entry point
// remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
// remove pet on map change
// remove all dyn objects
// stop spellcasting
// not attempt interrupt teleportation spell at caster teleport
//remove auras before removing from map...
// send transfer packets
// unknown
// Might be in wrong order
// remove from old map now
// if the player is saved before worldportack (at logout for example)
// this will be used instead of the current location in SaveToDB
// move packet sent by client always after far teleport
// code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
//else
//    return false;
/*= 0*/)
// Deserter
//we have executed ALL delayed ops, so clear the flag
///- Do not add/remove the player from the object storage
///- It will crash when updating the ObjectAccessor
///- The player should only be added when logging in
// cleanup
///- Release charmed creatures, unsummon totems and remove pets/guardians
///- Do not add/remove the player from the object storage
///- It will crash when updating the ObjectAccessor
///- The player should only be removed when logging out
//if (m_regenTimer <= 500)
//    return;
// Runes act as cooldowns, and they don't need to send any data
// Regenerate second rune of the same type only after first rune is off the cooldown
// Not in combat or they have regeneration
/// @todo possible use of miscvalueb instead of amount
// Skip regeneration for power type we cannot have
// Powers now benefit from haste.
// Skyfire Updates Mana in intervals of 2s, which is correct
// Regenerate rage
// 2.5 rage by tick (= 2 seconds => 1.25 rage/sec)
// Regenerate energy (rogue) & (monk)
// 3 RunicPower by tick
// Regenerate holy power
// remove 1 each 10 sec
// Regenerate chi (monk)
// remove 1 each 10 sec
// Mana regen calculated in Player::UpdateManaRegen()
// Butchery requires combat for this effect
// polymorphed case
// normal regen case (maybe partly in combat case)
// always regeneration bonus (including combat)
// unit checks
// exist (we need look pets also for some interaction (quest/etc)
// Deathstate checks
// alive or spirit healer
// appropriate npc type
// not allow interaction under control, but allow with own pets
// not enemy
// not unfriendly
// not too far
/// @todo find out how the client calculates the maximal usage distance to spellless working
// gameobjects like guildbanks and mailboxes - 10.0 is a just an abitrary choosen number
// max spell range
//define player in water by opcodes
//move player's guid into HateOfflineList of those mobs
//which can't swim and move guid back into ThreatList when
//on surface.
/// @todo exist also swimming mobs, and function must be symmetric to enter/leave water
// remove auras that need water/land
// see and visible in all phases
// restore FFA PvP Server state
// restore FFA PvP area state, remove not allowed for GM mounts
//remove flag
//add flag
///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
/// @todo Shouldn't we also check if there is no other invitees before disbanding the group?
// group has just 1 member => disband
/* = GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
/*group_rate*/)
// has XP
//17
//18
//23
//20
//19
// has group bonus
//16
//21
//22
// unknown
//20
//18
// does the GivenXP include a RaF bonus?
// 1 - none 0 - 100% group bonus output
//23
//17
//19
//22
// given experience
// experience without bonus
//16
//21
// Favored experience increase START
// Thrallmar's Favor and Honor Hold's Favor
// Favored experience increase END
// XP to money conversion processed in Player::RewardQuest
// RaF does NOT stack with rested experience
// xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
// XP resting bonus
// Update player to next level
// Current player experience not update (must be update by caller)
// send levelup info to client
// Stats loop (0-4)
//unk
//unk
//unk
//unk
//update level, max level of skills
// Level Played Time reset
// save base values (bonuses already included in stored stats
// Max weapon skill when leveling up
// Moved to above SetFullHealth so player will have full health from Heirlooms
// set current level health and mana/energy to maximum after applying all mods.
// update level to hunter/summon pet
/// @todo Poor design of mail system
// Refer-A-Friend
// talents base at level diff (talents = level - 9 but some can be used already)
// Remove all talent points
// Free any used talents
// update at client
/*
//reapply stats values only on .reset stats (level) command
// reset before any aura state sources (health set/aura apply)
// set default cast time multiplier
// reset size before reapply auras
// save base values (bonuses already included in stored stats
//set create powers
//reset rating fields values
//reset attack power, damage and attack speed fields
// offhand attack time
// Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
// Init spell schools (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
// Static 30% damage blocked
// reset mastery & pvp power fields
// set armor (resistance 0) to original value
// set other resistance to original value (0)
// Reset no reagent cost field
// Init data for form but skip reapply item mods for form
// save new stats
// stamina bonus will applied later
// cleanup mounted state (it will set correctly at aura loading if player saved at mount.
// cleanup unit flags (will be re-applied if need at aura load).
// must be set
// must be set
// cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
// one form stealth modified bytes
// restore if need some important flags
//SetUInt32Value(PLAYER_FIELD_LIFETIME_MAX_RANK2, 0);                 // flags empty by default
// reapply stats values only on .reset stats (level) command
// set current level health and mana/energy to maximum after applying all mods.
// update level to hunter/summon pet
// spell count placeholder
/*
// cast item id
// spell category
// send infinity cooldown in special format
// cooldown
// category cooldown
// may be wrong, but anyway better than nothing...
// cooldown
// category cooldown
// cooldown
// category cooldown
//do not delete item, because Player::removeMail() is called when returning mail to sender.
// deliver undelivered mail
// calculate next delivery time (min. from non-delivered mails
// and recalculate unReadMail
// ready now
// not ready and no have ready mails
// do character spell book cleanup (all characters)
// spell load case
// do character spell book cleanup (all characters)
// spell load case
/*= false*/)
// do character spell book cleanup (all characters)
// spell load case
// do character spell book cleanup (all characters)
// spell load case
// Remove temporary spell if found to prevent conflicts
// fix activate state for non-stackable low rank (and find next spell for !active case)
// high rank already known so this must !active
// not do anything if already known in expected state
// explicitly load from DB and then exist in it already and set correctly
// dependent spell known as not dependent, overwrite state
// update active state for known spell
// explicitly load from DB and then exist in it already and set correctly
// update spell ranks in spellbook and action bar
// Count
// learn (show in spell book if active now)
// known saved spell
// re-learning removed not saved spell
// need re-add
// known not saved yet spell (new or modified)
// can be in case spell loading but learned at some previous spell loading
// skip new spell adding if spell already known (disabled spells case)
// non talent spell: learn low ranks (recursive call)
// at spells loading, no output, but allow save
// at normal learning
// replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
// not send spell (re-/over-)learn packets at loading
// mark old spell as disable (SMSG_SUPERCEDED_SPELL replace it in client by new)
// new spell replace old in action bars and spell book.
// not send spell (re-/over-)learn packets at loading
// mark new spell as disable (not learned yet for client and will not learned)
// return false if spell disabled
// cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
// note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
// ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
// also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
// update used talent points count
// update free primary prof.points (if any, can be none in case GM .learn prof. learning)
// add dependent skills
// not ranked skills
// runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
// learn dependent spells
// at spells loading, no output, but allow save
// at normal learning
// not ranked skills
// return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
// spell already added - do not do anything
// spell already not in list - do not do anything
// spell has other state than temporary - do not change it
// note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
// talent dependent passives activated at form apply have proper stance data
//Check CasterAuraStates
// prevent duplicated entires in spell book, also not send if not in world (loading)
// learn all disabled higher ranks and required spells (recursive)
// unlearn non talent higher ranks (recursive)
//unlearn spells dependent from recently removed spells
// re-search, it can be corrupted in prev loop
// already unleared
// remove pet auras
// free talent points
// update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
// remove dependent skill
// first rank, remove skill
// search prev. skill setting by spell ranks chain
// not found prev skill setting, remove skill
// set to prev. skill setting values
// not ranked skills
// not unlearn class skills (spellbook/talent pages)
// runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
// not reset skills for professions and racial abilities
// remove dependent spells
// activate lesser rank in spellbook/action bar, and cast it if need
// if talent then lesser rank also talent and need learn
// I cannot see why mangos has these lines.
//if (learn_low_rank)
//    learnSpell(prev_id, false);
// if ranked non-stackable spell: need activate lesser rank and update dendence state
/// No need to check for spellInfo != NULL here because if cur_active is true, then that means that the spell was already in m_spells, and only valid spells can be pushed there.
// need manually update dependence state (learn spell ignore like attempts)
// now re-learn if need re-activate
// downgrade spell ranks in spellbook and action bar
// remove from spell book if not replaced by lesser rank
// Count
/* = false */)
// I am not sure which one is more efficient
/* = false */)
// remove cooldowns on spells that have <= 10 min CD
// check if spellentry is present and if the cooldown is less or equal to 10 min
// remove & notify
// pet cooldowns
// notify player
// actually clear cooldowns
// some cooldowns can be already set at aura loading...
//QueryResult* result = CharacterDatabase.PQuery("SELECT spell, item, time FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());
// skip outdated cooldown
// remove outdated and save active
// not save locked cooldowns, it will be reset or set at reload
// next new/changed record prefix
// if something changed execute
// The first time reset costs 1 gold
// then 5 gold
// After that it increases in increments of 5 gold
// This cost will be reduced by a rate of 5 gold per month
// to a minimum of 10 gold.
// After that it increases in increments of 5 gold
// until it hits a cap of 50 gold.
// The first time reset costs 1 gold
// then 5 gold
// After that it increases in increments of 5 gold
// This cost will be reduced by a rate of 5 gold per month
// to a minimum of 10 gold.
// After that it increases in increments of 5 gold
// until it hits a cap of 50 gold.
// not need after this call
// unlearn only talents for character class
// some spell learned by one class as normal spells or know at creation but another class learn it as talent,
// to prevent unexpected lost normal learned spell skip another class talents
// search for spells that the talent teaches and unlearn them
/* when prev line will dropped use next line
// Needs to be executed orthewise the talents will be screwedsx
// known spell
// check skill requirement
// check level requirement
// check race/class requirement
// check prev.rank requirement
// check additional spell requirement
// check primary prof. limit
// first rank of primary profession spell when there are no proffesions avalible is disabled
/**
// Avoid realm-update for non-existing account
// Convert guid to low GUID for CharacterNameData, but also other methods on success
// To avoid a query, we select loaded data. If it doesn't exist, return.
// Define the required variables
// if we want to finalize the character removal or the character does not meet the level requirement of either heroic or non-heroic settings,
// we set it to mode CHAR_DELETE_REMOVE
// convert corpse to bones if exist (to prevent exiting Corpse in World without DB entry)
// bones will be deleted by corpse/bones deleting thread shortly
// the player was uninvited already on logout so just remove from group
// Remove signs from petitions (also remove petitions if owner);
// Completely remove from the database
// We can return mail now
// So firstly delete the old one
// Mail is not from player
// items are already included
// Data needs to be at first place for Item::LoadFromDB
// it also deletes item object!
// Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
// NOW we can finally clear other DB data related to character
// Delete char from social list of online chars
// The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
/**
/**
/* Preconditions:
// there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
// there must be SMSG.STOP_MIRROR_TIMER
// there we must send 888 opcode
// the player cannot have a corpse already, only bones which are not returned by GetCorpse
// create a corpse and place it at the player's location
// convert player body to ghost
// BG - remove insignia related
//    SendCorpseReclaimDelay();
// to prevent cheating
//disable timers(bars)
// set and clear other
// remove spirit healer position
// speed change, land walk
// remove death flag + set aura
// speed bonuses
// SPELL_AURA_GHOST
// set health/powers (0- will be set in caller)
// trigger update zone for alive state zone updates
// update visibility
//Characters from level 1-10 are not affected by resurrection sickness.
//Characters from level 11-19 will suffer from one minute of sickness
//for each level they are above 10.
//Characters level 20 and up suffer from ten minutes of sickness.
// set resurrection sickness
// not full duration
//disable timers(bars)
//SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);
// 6 minutes until repop at graveyard
// dependent at use SetDeathPvP() call before kill
//SendCorpseReclaimDelay();
// don't create corpse at this moment, player might be falling
// update visibility
// prevent existence 2 corpse for player
// to be able to remove insignia
// we do not need to save corpses for BG/arenas
// register for player, but not show
// at logout we will already store the player
// prevent loading as ghost without corpse
// bags not have durability
// for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
// bags not have durability
// for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
// modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
// modify item stats _after_ restore durability to pass _ApplyItemMods internal check
// equipped, backpack, bags itself
// bank, buyback and keys not repaired
// items in inventory bags
//fix for ITEM_QUALITY_ARTIFACT
// reapply mods for total broken and repaired item if equipped
// note: this can be called also when the player is alive
// for example from WorldSession::HandleMovementOpcodes
// Such zones are considered unreachable as a ghost and the player must be automatically revived
// Special handle for battleground maps
// stop countdown until repop
// if no grave found, stay at the current location
// and don't show spirit healer location
// not send if alive, because it used in TeleportTo()
// show spirit healer position on minimap
// remove from player's channel list
// not send to client, not remove from player's channel list
// deleted channel if empty
// The client handles it automatically after loading, but not after teleporting
// Already on the channel, as city channel names are not changing
// Do not send leave channel, it already replaced at client
// Changed Channel: ... or Joined Channel: ...
// Leave old channel
// Store name, (*i)erase in LeftChannel
// Remove from player's channel list
// Delete if empty
// PCT_MOD
// Table for base dodge values
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// DK
// Shaman
// Mage
// Warlock
// Monk
// Druid
// Crit/agility to dodge/agility coefficient multipliers; 3.2.0 increased required agility by 15%
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// DK
// Shaman
// Mage
// Warlock (?)
// Monk
// Druid
// Dodge per agility is proportional to crit per agility, which is available from DBC files
// TODO: research if talents/effects that increase total agility by x% should increase non-diminishing part
// calculate diminishing (green in char screen) and non-diminishing (white) contribution
// gtOCTClassCombatRatingScalarStore.dbc starts with 1, CombatRating with zero, so cr+1
// By default use minimum coefficient (not must be called)
// Formula get from PaperDollFrame script
// explicit affected values
// Apply bonus from SPELL_AURA_MOD_RATING_FROM_STAT
// stat used stored in miscValueB for this aura
// Deprecated since Cataclysm
// Deprecated since Cataclysm
// Deprecated since Cataclysm
// Deprecated since Cataclysm
// Implemented in Player::ApplyRatingMod
// Implemented in Unit::RollMeleeOutcomeAgainst
// If there is no weapon reset attack time to base (might have been changed from forms)
//skill+step, checking for max value
// itr->second.pos % 2
// Alchemy Discoveries here
// For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
// levels sync. with spell requirement for skill levels to learn
// bonus abilities in sSkillLineAbilityStore
// Used only to avoid scan DBC at each skill grow
// speedup in 0 chance case
// itr->second.pos % 2
// itr->second.pos % 2
// itr->second.pos % 2
//uint16 val = GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
/// update only level dependent max skill values
// itr->second.pos % 2
// This functions sets a skill line value (and adds if doesn't exist yet)
// To "remove" a skill line, set it's values to zero
//has skill
// itr->second.pos % 2
// if skill value is going down, update enchantments before setting the new value
// update step
// update value
// if skill value is going up, update enchantments after setting the new value
//remove
//remove enchantments needing this skill
// clear skill fields
// mark as deleted or simply remove from map if not saved yet
// remove all spells that related to this skill
// Clear profession lines
//add
// i % 2
// insert new entry or update if not deleted old entry yet
// apply skill bonuses
// temporary bonuses
// permanent bonuses
// Learn all spells for skill
// Bits
// Data
// other cases not checked at this moment
// it create new button (NEW state) if need or return existed
// set data and update to CHANGED if not NEW
// new and not saved
// saved, will deleted at next save
//if (movementInfo.flags & MOVEMENTFLAG_MOVING)
//    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
//if (movementInfo.flags & MOVEMENTFLAG_TURNING)
//    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
//AURA_INTERRUPT_FLAG_JUMP not sure
// group update
// we use World::GetMaxVisibleDistance() because i cannot see why not use a distance
// update: replaced by GetMap()->GetVisibilityDistance()
// Calculate total reputation percent player gain with quest/creature level
// faction specific auras only seem to apply to kills
// Multiply result with the faction specific rate
// for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
// Calculates how many reputation points player gains in victim's enemy factions
// support for: Championing - http://www.wowwiki.com/Championing
// Calculate how many reputation points player gain with the quest
/// called when rewarding honor and at each save
// update yesterday's contribution
// this is the first update today, reset today's contribution
// no honor/kills yesterday or today, reset
///Calculate the amount of honor gained based on the victim
///and the size of the group for which the honor is divided
///An exact honor value can also be given (overriding the calcs)
// do not reward honor in arenas, but enable onkill spellproc
// 'Inactive' this aura prevents the player from gaining honor points and battleground Tokenizer
// need call before fields update to have chance move yesterday data to appropriate fields before today data change.
// do not reward honor in arenas, but return true to enable onkill spellproc
// Promote to float for calculations
// PLAYER_FIELD_PLAYER_TITLE VALUES DESCRIPTION
//  [0]      Just name
//  [1..14]  Alliance honor titles and player name
//  [15..28] Horde honor titles and player name
//  [29..38] Other title and player name
//  [39+]    Nothing
// Get Killer titles, CharTitlesEntry::bit_index
// Ranks:
//  title[1..14]  -> rank[5..18]
//  title[15..28] -> rank[5..18]
//  title[other]  -> 0
// Don't show HK: <rank> message, only log.
// Don't show HK: <rank> message, only log.
// count the number of playerkills in one day
// and those in a lifetime
// ??? need more info
// HK: Leader
// apply honor multiplier from aura (not stacking-get highest)
// Back to int now
// honor - for show honor points in log
// victim_guid - for show victim name in log
// victim_rank [1..4]  HK: <dishonored rank>
// victim_rank [5..19] HK: <alliance\horde rank>
// victim_rank [0, 20+] HK: <>
// add honor points
//false: prevent looping
// Check if allowed to receive it in current map
// load total conquest cap. should be after insert.
// should never happen
// should never happen
// some flags
// not send init meta currencies.
// some flags
// UnkMop
// unkMop2
/* = true*/, bool ignoreMultipliers/* = false*/)
// count can't be more then weekCap if used (weekCap > 0)
// count can't be more then totalCap if used (totalCap > 0)
// if we get more then weekCap just set to limit
// weekCap - oldWeekCount always >= 0 as we set limit before!
// if we get more then totalCap set to maximum;
// original conquest cap is highest of bg/arena conquest cap.
// count was changed to week limit, now we can modify original points.
// hasSeasonCount
// print in log
// if hasSeasonCount packet << uint32(seasontotalearned); TODO: save this in character DB and use it
/*printLog*/ /*= true*/)
/*
// set played this week etc values to 0 in memory, too
//arenaTeam->SaveToDB();                                // save changes
// notify the players of the changes
//original conquest not have week cap
// should add precision mod = 100
// should add precision mod = 100
// stored zone is zero, use generic and slow zone detection
// FFA_PVP flags are area and not zone id dependent
// so apply them accordingly
// previously this was in UpdateZone (but after UpdateArea) so nothing will break
// in sanctuary
// only if really enters to new zone, not just area change, works strange...
// group update
// zone changed, so area changed as well, update it
// send fine weather packet to remove old zone's weather
// in PvP, any not controlled zone (except zone->team == 6, default case)
// in PvE, only opposition team capital
// overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
// 6 in fact
// Treat players having a quest flagging for PvP as always in hostile area
// Is in a capital city
// Still inside a tavern or has recently left
// Remove rest state if we have recently left a tavern.
// Recently left a capital city
// remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
// if player resurrected at teleport this will be applied in resurrect code
// check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
// recent client version not send leave/join channel packets for built-in local channels
//If players are too far away from the duel flag... they lose the duel
// duel not requested
// we guess size
// 0 = just won; 1 = fled
// if initiator and opponent are on the same team
// or initiator and opponent are not PvP enabled, forcibly stop attacking
// Credit for quest Death's Challenge
// Honor points after duel (the winner) - ImpConfig
// Victory emote spell
//Remove Duel Flag object
/* remove auras */
// cleanup combo points
//cleanups
//---------------------------------------------------------//
// not apply/remove mods for broken item
//only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
/*= false*/)
// req. check at equip, but allow use for extended range if range limit max level, set proper level
// If set ScalingStatDistribution need get stats and values from it
// modify HP
// modify agility
//modify strength
//modify intellect
//modify spirit
//modify stamina
// case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
//     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
//     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
//     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
//     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
//     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
//     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
//     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
//     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
//     break;
// Apply Spell Power from ScalingStatValue if set
// If set ScalingStatValue armor get it or use item armor
// Add armor bonus from ArmorDamageModifier if > 0
// If set dpsMod in ScalingStatValue use it for min (70% from average), max (130% from average) damage
// don't apply mod if item is broken or cannot be used
// generic not weapon specific case processes in aura code
// don't apply mod if item is broken or cannot be used
// ignore spell mods for not wands
// generic not weapon specific case processes in aura code
// no spell
// wrong triggering type
// check if it is valid spell
// Cannot be used in this stance/form
// check aura active state from other form
// check aura compatibility
// Cannot be used in this stance/form
// and remove only not compatible at form change
// un-apply all spells, not only at-equipped
// un-apply spell (item set case)
// remove spells that not fit to form
// add spells that fit form but not active
// item set bonuses not dependent from item broken state
// remove spells that not fit to form
// add spells that fit form but not active
// If usable, try to cast item spell
// Additional check for weapons
// offhand item cannot proc from main hand hit etc
// Check if item is useable (forms or disarm)
// Can do effect if any damage done to target
//if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
// no spell
// wrong triggering type
// not allow proc extra attack spell at extra attack
// item combat enchantments
// not holding enchantment id
// Check hit/crit/dodge/parry requirement
// Can do effect if any damage done to target
//if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
// Apply spell mods
// Shiv has 100% chance to apply the poison
// special learning case
//set count of casts
// use triggered flag only for items with many spell casts and for not first cast
// item spells casted at use
// no spell
// wrong triggering type
// set count of casts
// glyph index
// Item enchantments spells casted at use
// not holding enchantment id
// set count of casts
// glyph index
// item set bonuses not dependent from item broken state
// item set bonuses not dependent from item broken state
/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
// If not released spirit, do it !
// We have to convert player corpse to bones, not to be able to resurrect there
// SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
// Now we must make bones lootable, and send player loot
// We store the level of our player in the gold field
// We retrieve this information at Player::SendLoot()
// not check distance for GO in case owned GO (fishing bobber case, for example)
// And permit out of range GO with no owner in case fishing hole
// check current RR player and get next if necessary
// get next RR player (for next loot)
// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
// If item doesn't already have loot, attempt to load it. If that
//  fails then this is first time opening, generate loot
// Force save the loot and money items that were just rolled
//  Also saves the container item ID in Loot struct (not to DB)
// remove insignia
// It may need a better formula
// Now it works like this: lvl10: ~6copper, lvl70: ~9silver
// must be in range and creature must be alive for pickpocket and must be dead for another loot
// Generate extra money for pick pocket loot
// the player whose group may loot the corpse
// for creature, loot is filled when creature is killed.
// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
// possible only if creature->lootForBody && loot->empty() at spell cast check
// set group rights only for loot_type != LOOT_SKINNING
// LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
// need know merged fishing/corpse loot type for achievements
// we guess size
// add 'this' player as one of the players that are looting 'loot'
// Guid could also be itemID
// data depends on zoneid/mapid...
// 1
// 2
// 3
// 4
// 5
// 6
// 7 1 - Arena season in progress, 0 - end of season
//builder.AppendState(0xC77, sWorld->getBoolConfig(CONFIG_ARENA_SEASON_IN_PROGRESS));
// 8 Arena season id
//builder.AppendState(0xF3D, sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID));
// Outland
// 7
// 8
// 9
// insert <field> <value>
// Dun Morogh
// Wetlands
// Elwynn Forest
// Loch Modan
// Westfall
// Searing Gorge
// Stormwind City
// Ironforge
// Deeprun Tram
// Shattrath City
// Silithus
// states are always shown
// 7 ally silityst gathered
// 8 horde silityst gathered
// 9 max silithyst
// dunno about these... aq opening event maybe?
// 10 sandworm N
// 11 sandworm S
// 12 sandworm SW
// 13 sandworm E
// Alterac Valley
// 7 snowfall n
// 8 frostwolfhut hc
// 9 frostwolfhut ac
// 10 stormpike firstaid a_a
// 11 east frostwolf tower horde assaulted -unused
// 12 west frostwolf tower horde assaulted - unused
// 13 frostwolfe c
// 14 frostwolfw c
// 15 irondeep (N) ally
// 16 ice grave a_a
// 17 stormpike grave h_c
// 18 stormpike grave a_c
// 19 stoneheart grave a_a
// 20 stoneheart grave h_a
// 21 1396 unk
// 22 iceblood tower horde assaulted -unused
// 23 towerpoint horde assaulted - unused
// 24 1391 unk
// 25 iceblood a
// 26 towerp a
// 27 frostwolfe a
// 28 froswolfw a
// 29 1386 unk
// 30 iceblood c
// 31 towerp c
// 32 stoneh tower a
// 33 icewing tower a
// 34 dunn a
// 35 duns a
// 36 stoneheart bunker alliance assaulted - unused
// 37 icewing bunker alliance assaulted - unused
// 38 dunbaldar south alliance assaulted - unused
// 39 dunbaldar north alliance assaulted - unused
// 40 stone tower d
// 41 966 unk
// 42 964 unk
// 43 962 unk
// 44 stoneheart grave a_c
// 45 stonheart grave h_c
// 46 950 unk
// 47 icewing tower d
// 48 dunn d
// 49 duns d
// 50 1369 unk
// 51 iceblood d
// 52 towerp d
// 53 frostwolfe d
// 54 frostwolfw d
// 55 stoneh tower c
// 56 icewing tower c
// 57 dunn c
// 58 duns c
// 59 irondeep (N) horde
// 60 irondeep (N) ally
// 61 mine (S) neutral
// 62 mine (S) horde
// 63 mine (S) ally
// 64 iceblood h_a
// 65 iceblod h_c
// 66 iceblood a_c
// 67 snowfall h_a
// 68 snowfall a_a
// 69 snowfall h_c
// 70 snowfall a_c
// 71 frostwolf g h_a
// 72 frostwolf g a_a
// 73 frostwolf g h_c
// 74 frostwolf g a_c
// 75 stormpike grave h_a
// 76 stormpike grave a_a
// 77 frostwolf hut h_a
// 78 frostwolf hut a_a
// 79 stormpike first aid h_a
// 80 stormpike first aid h_c
// 81 stormpike first aid a_c
// Warsong Gulch
// 7 1581 alliance flag captures
// 8 1582 horde flag captures
// 9 1545 unk, set to 1 on alliance flag pickup...
// 10 1546 unk, set to 1 on horde flag pickup, after drop it's -1
// 11 1547 unk
// 12 1601 unk (max flag captures?)
// 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
// 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
// Arathi Basin
// 7 1767 stables alliance
// 8 1768 stables horde
// 9 1769 unk, ST?
// 10 1770 stables (show/hide)
// 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
// 12 1773 farm (show/hide)
// 13 1774 farm color
// 14 1775 gold mine color, may be FM?
// 15 1776 alliance resources
// 16 1777 horde resources
// 17 1778 horde bases
// 18 1779 alliance bases
// 19 1780 max resources (2000)
// 20 1782 blacksmith color
// 21 1783 blacksmith (show/hide)
// 22 1784 unk, bs?
// 23 1785 unk, bs?
// 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
// 25 1788 gold mine (0 - conflict, 1 - horde)
// 26 1789 gold mine (1 - show/0 - hide)
// 27 1790 gold mine color
// 28 1792 gold mine color, wtf?, may be LM?
// 29 1793 lumber mill color (0 - conflict, 1 - horde contr)
// 30 1794 lumber mill (show/hide)
// 31 1795 lumber mill color color
// 32 1842 stables (1 - uncontrolled)
// 33 1843 gold mine (1 - uncontrolled)
// 34 1844 lumber mill (1 - uncontrolled)
// 35 1845 farm (1 - uncontrolled)
// 36 1846 blacksmith (1 - uncontrolled)
// 37 1861 unk
// 38 1955 warning limit (1800)
// Eye of the Storm
// 7  2753 Horde Bases
// 8  2752 Alliance Bases
// 9  2742 Mage Tower - Horde conflict
// 10 2741 Mage Tower - Alliance conflict
// 11 2740 Fel Reaver - Horde conflict
// 12 2739 Fel Reaver - Alliance conflict
// 13 2738 Draenei - Alliance conflict
// 14 2737 Draenei - Horde conflict
// 15 2736 unk // 0 at start
// 16 2735 unk // 0 at start
// 17 2733 Draenei - Horde control
// 18 2732 Draenei - Alliance control
// 19 2731 Draenei uncontrolled (1 - yes, 0 - no)
// 20 2730 Mage Tower - Alliance control
// 21 2729 Mage Tower - Horde control
// 22 2728 Mage Tower uncontrolled (1 - yes, 0 - no)
// 23 2727 Fel Reaver - Horde control
// 24 2726 Fel Reaver - Alliance control
// 25 2725 Fel Reaver uncontrolled (1 - yes, 0 - no)
// 26 2724 Boold Elf - Horde control
// 27 2723 Boold Elf - Alliance control
// 28 2722 Boold Elf uncontrolled (1 - yes, 0 - no)
// 29 2757 Flag (1 - show, 0 - hide) - doesn't work exactly this way!
// 30 2770 Horde top-stats (1 - show, 0 - hide) // 02 -> horde picked up the flag
// 31 2769 Alliance top-stats (1 - show, 0 - hide) // 02 -> alliance picked up the flag
// 32 2750 Horde resources
// 33 2749 Alliance resources
// 34 2565 unk, constant?
// 35 2720 Capturing progress-bar (100 -> empty (only grey), 0 -> blue|red (no grey), default 0)
// 36 2719 Capturing progress-bar (0 - left, 100 - right)
// 37 2718 Capturing progress-bar (1 - show, 0 - hide)
// 38 3085 unk
// and some more ... unknown
// any of these needs change! the client remembers the prev setting!
// ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
// Hellfire Peninsula
// 10 // add ally tower main gui icon       // maybe should be sent only on login?
// 11 // add horde tower main gui icon      // maybe should be sent only on login?
// 12 // show neutral broken hill icon      // 2485
// 13 // show icon above broken hill        // 2484
// 14 // show ally broken hill icon         // 2483
// 15 // show neutral overlook icon         // 2482
// 16 // show the overlook arrow            // 2481
// 17 // show ally overlook icon            // 2480
// 18 // horde pvp objectives captured      // 2478
// 19 // ally pvp objectives captured       // 2476
//: ally / horde slider grey area                              // show only in direct vicinity!
//: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
//: ally / horde slider display                                // show only in direct vicinity!
// 20 // show the neutral stadium icon      // 2472
// 21 // show the ally stadium icon         // 2471
// 22 // show the horde stadium icon        // 2470
// Nagrand
// 10
// 11
// 12
// 13
// 14
// 15
// 16
// 17
// 18
// 19
// 20
// 21
// 22
// 23
// 24
// 25
// 26
// 27
// 28
// 29
// 30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// Terokkar Forest
// 10 // 2625 capture bar pos
// 11 // 2624 capture bar neutral
// 12 // 2623 show capture bar
// 13 // 2622 horde towers controlled
// 14 // 2621 ally towers controlled
// 15 // 2620 show towers controlled
// 16 // 2696 SE Neu
// 17 // SE Horde
// 18 // SE Ally
// 19 //S Neu
// 20 S Horde
// 21 S Ally
// 22 NE Neu
// 23 NE Horde
// 24 NE Ally
// 25 // 2686 N Neu
// 26 N Horde
// 27 N Ally
// 28 NW Ally
// 29 NW Horde
// 30 NW Neutral
// 31 // 2512 locked time remaining seconds first digit
// 32 // 2510 locked time remaining seconds second digit
// 33 // 2509 locked time remaining minutes
// 34 // 2508 neutral locked time show
// 35 // 2768 horde locked time show
// 36 // 2767 ally locked time show
// Zangarmarsh
// 10 //2529
// 11
// 12
// 13 //2653
// 14 //2652 east beacon neutral
// 15 horde
// 16 ally
// 17 // 2649 Twin spire graveyard horde  12???
// 18 ally     14 ???
// 19 neutral  7???
// 20 // 2646 west beacon neutral
// 21 horde
// 22 ally
// 23 // 2535
// 24
// 25
// 26 // 2560
// 27
// 28
// 29
// 30
// 31
// 32 // 2658
// 33
// 34
// 35
// Nagrand Arena
// 7
// 8
// 9 show
// Blade's Edge Arena
// 7 gold
// 8 green
// 9 show
// Ruins of Lordaeron
// 7 gold
// 8 green
// 9 show
// Dalaran Sewers
// 7 gold
// 8 green
// 9 show
// Strand of the Ancients
// 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
// 7  3849 Gate of Temple
// 8  3638 Gate of Yellow Moon
// 9  3623 Gate of Green Emerald
// 10 3620 Gate of Blue Sapphire
// 11 3617 Gate of Red Sun
// 12 3614 Gate of Purple Ametyst
// 13 3571 bonus timer (1 - on, 0 - off)
// 14 3565 Horde Attacker
// 15 3564 Alliance Attacker
// End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
// 16 3561 C
// 17 3560 B
// 18 3559 A
// 19 3637 East g - Horde control
// 20 3636 West g - Horde control
// 21 3635 South g - Horde control
// 22 3634 East g - Alliance control
// 23 3633 West g - Alliance control
// 24 3632 South g - Alliance control
// 25 3631 Chamber of Ancients - Horde control
// 26 3630 Chamber of Ancients - Alliance control
// 27 3629 Beach1 - Horde control
// 28 3628 Beach2 - Horde control
// 29 3627 Beach1 - Alliance control
// 30 3626 Beach2 - Alliance control
// and many unks...
// Ring of Valor
// 7 gold
// 8 green
// 9 show
// 7 BG_IC_ALLIANCE_RENFORT_SET
// 8 BG_IC_HORDE_RENFORT_SET
// 9 BG_IC_ALLIANCE_RENFORT
// 10 BG_IC_HORDE_RENFORT
// 11 BG_IC_GATE_FRONT_H_WS_OPEN
// 12 BG_IC_GATE_WEST_H_WS_OPEN
// 13 BG_IC_GATE_EAST_H_WS_OPEN
// 14 BG_IC_GATE_FRONT_A_WS_OPEN
// 15 BG_IC_GATE_WEST_A_WS_OPEN
// 16 BG_IC_GATE_EAST_A_WS_OPEN
// 17 unknown
// 18 BG_IC_DOCKS_UNCONTROLLED
// 19 BG_IC_HANGAR_UNCONTROLLED
// 20 BG_IC_QUARRY_UNCONTROLLED
// 21 BG_IC_REFINERY_UNCONTROLLED
// 22 BG_IC_WORKSHOP_UNCONTROLLED
// 23 unknown
// 24 unknown
// The Ruby Sanctum
// 9  WORLDSTATE_CORPOREALITY_MATERIAL
// 10 WORLDSTATE_CORPOREALITY_TWILIGHT
// 11 WORLDSTATE_CORPOREALITY_TOGGLE
// Icecrown Citadel
// 9  WORLDSTATE_SHOW_TIMER (Blood Quickening weekly)
// 10 WORLDSTATE_EXECUTION_TIME
// 11 WORLDSTATE_SHOW_ATTEMPTS
// 12 WORLDSTATE_ATTEMPTS_REMAINING
// 13 WORLDSTATE_ATTEMPTS_MAX
// The Culling of Stratholme
// 9  WORLDSTATE_SHOW_CRATES
// 10 WORLDSTATE_CRATES_REVEALED
// 11 WORLDSTATE_WAVE_COUNT
// 12 WORLDSTATE_TIME_GUARDIAN
// 13 WORLDSTATE_TIME_GUARDIAN_SHOW
// Ulduar
// 9  WORLDSTATE_ALGALON_TIMER_ENABLED
// 10 WORLDSTATE_ALGALON_DESPAWN_TIMER
// Zul Aman
// 9  WORLD_STATE_ZULAMAN_TIMER_ENABLED
// 10 WORLD_STATE_ZULAMAN_TIMER
// Twin Peaks
//  7 1581 alliance flag captures
//  8 1582 horde flag captures
//  9 1545 unk
// 10 1546 unk
// 11 1547 unk
// 12 1601 unk
// 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
// 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
// Battle for Gilneas
// Wintergrasp
// 9  WORLD_STATE_HOR_WAVES_ENABLED
// 10 WORLD_STATE_HOR_WAVE_COUNT
// No break here, intended.
// 7
// 8
// 9
// 10
/// Send misc stuff that needs to be sent on every login, like the battle timers.
// Time to next battle
// xp for each rested bonus
// max rested_bonus == xp or (r+x) = 200% xp
// 0 = talent, 1 = specialization
// This needs another gossip option + NPC text as a confirmation.
// The confirmation gossip listid has the text: "Yes, please do."
/*********************************************************/
/***                    STORAGE SYSTEM                 ***/
/*********************************************************/
// no prepared weapon
// prepared melee weapon
// prepared ranged weapon
// this must visualize Sheath changing for other players...
// suggest offhand slot only if know dual wielding
// (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
// search free slot at first
// in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
// if not found free and can swap return first appropriate from used
// no free position
// not found req. item count and have unequippable items
// checking every item from 39 to 74 (including bank bags)
//Does additional check for disarmed weapons
/*= false*/) const
// post selected
// any post selected
// equipment
// bag equip slots
// backpack slots
// bank main slots
// bank bag slots
// bag content slots
// bank bag content slots
// any post selected
// where this?
// no maximum
// check unique-equipped limit
/*= NULL*/) const
/*= false*/) const
// ignore move item (this slot will be empty at move)
// empty specific slot - check item fit to slot
// prevent cheating
// non empty stack with space
// non empty slot, check item type
// can be merged at least partly
// free stack space or infinity
// skip specific bag already processed in first called CanStoreItem_InBag
// skip not existed bag or self targeted bag
// specialized bag mode or non-specilized
// skip specific slot already processed in first called CanStoreItem_InSpecificSlot
// ignore move item (this slot will be empty at move)
// if merge skip empty, if !merge skip non-empty
// can be merged at least partly
// descrease at current stacksize
//this is never called for non-bag slots so we can do this
// skip specific slot already processed in first called CanStoreItem_InSpecificSlot
// ignore move item (this slot will be empty at move)
// if merge skip empty, if !merge skip non-empty
// can be merged at least partly
// descrease at current stacksize
// item used
// check count of items (skip for auto move for same player from bank)
// can't store this amount similar items
// in specific slot
// not specific slot or have space for partly store only in specific slot
// in specific bag
// search stack in bag for merge to
// inventory
// equipped bag
// we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
// search free slot in bag for place to
// inventory
// equipped bag
// not specific bag or have space for partly store only in specific bag
// search stack for merge to
// search free slot - special bag case
// search free slot
//////////////////////////////////////////////////////////////////////////
// fill space table
// check free space for all items
// no item
// strange item
// item used
// item it 'bind'
// item is 'one item only'
// search stack for merge to
// special bag case
// not plain container check
// search free slot
// search free slot in bags
// special bag already checked
// no free slot found?
//////////////////////////////////////////////////////////////////////////
// item used
// check count of items (skip for auto move for same player from bank)
// check this only in game
// May be here should be more stronger checks; STUNNED checked
// ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
// do not allow equipping gear except weapons, offhands, projectiles, relics in
// - combat
// - in-progress arenas
// maybe exist better err
// check allowed level (extend range to upper values if MaxLevel more or equal max player level, this let GM set high level with 1...max range items)
// if we are swapping 2 equiped items, CanEquipUniqueItem check
// should ignore the item we are trying to swap, and not the
// destination item. CanEquipUniqueItem should ignore destination
// item only when we are swapping weapon from bag
// check unique-equipped special item classes
// Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
// equip two-hand weapon case (with possible unequip 2 items)
// offhand item must can be stored in inventory for offhand item and it also must be unequipped
// Applied only to equipped items and bank bags
// Applied only to existed equipped item
// item used
// do not allow unequipping gear except weapons, offhands, projectiles, relics in
// - combat
// - in-progress arenas
// item used
// Currency Tokenizer are not supposed to be swapped out of their hidden bag
// check count of items (skip for auto move for same player from bank)
// in specific slot
// not specific slot or have space for partly store only in specific slot
// in specific bag
// search stack in bag for merge to
// search free slot in bag
// not specific bag or have space for partly store only in specific bag
// search stack for merge to
// in slots
// in special bags
// search free place in special bag
// search free space
//if (isStunned())
//    return EQUIP_ERR_GENERIC_STUNNED;
// Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
/// @todo when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.
// In fact it's a visual bug, everything works properly... I need sniffs of operations with
// binded to account items from off server.
// Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
// If World Event is not active, prevent using event dependant items
// not in LFG group
// check if looted object is inside the lfg dungeon
// Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
//Copy from function Item::GetSkill()
// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
// save data
// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
// On obtain trigger
// delete item (it not in any slot currently)
// prevent error at next SetState in case trade/mail/buy from vendor
// On obtain trigger
// item set bonuses applied only at equip and removed at unequip, and still active for broken items
// Missing flags
// update expertise and armor penetration - passive auras may need it
// delete item (it not in any slot currently)
//pItem->DeleteFromDB();
// prevent error at next SetState in case trade/mail/buy from vendor
// only for full equip instead adding to stack
// check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
// note: removeitem does not actually change the item
// it only takes the item out of storage temporarily
// note2: if removeitem is to be used for delinking
// the item must be removed from the player's updatequeue
// item set bonuses applied only at equip and removed at unequip, and still active for broken items
// remove item dependent auras and casts (only weapon and armor slots)
// remove held enchantments, update expertise
// update armor penetration - passive auras may need it
// pItem->SetUInt64Value(ITEM_FIELD_OWNER, 0); not clear owner at remove (it will be set at store). This used in mail and auction code
// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
// Common operation need to add item from inventory without delete in trade, guild bank, mail....
// update quest counters
// store item
// only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
// update owner for last item (this can be original item with wrong owner
// if this original item then it need create record in inventory
// in case trade we already have item in other player inventory
// Also remove all contained items if the item is a bag.
// This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
// On obtain trigger
// equipment and equipped bags can have applied bonuses
// item set bonuses applied only at equip and removed at unequip, and still active for broken items
// remove item dependent auras and casts (only weapon and armor slots)
// update expertise and armor penetration - passive auras may need it
// equipment visual show
// Delete rolled money / loot from db.
// MUST be done before RemoveFromWorld() or GetTemplate() fails
//pItem->SetOwnerGUID(0);
// in inventory
// all items in inventory can unequipped
// in inventory bags
// all items in bags can be unequipped
// in equipment and bag list
// in bank
// in bank bags
// all items in bags can be unequipped
// in inventory
// in inventory bags
// in equipment and bag list
// used when entering arena
// destroys all conjured items
// in inventory
// in inventory bags
// in equipment and bag list
// in inventory
// prevent split looting item (item
//best error message found for attempting to split while looting
// not let split all items (can be only at cheating)
// not let split more existed items (can be only at cheating)
//! If trading
//! If current item is in trade window (only possible with packet spoofing - silent return)
// change item amount before check (for unique max count check)
// change item amount before check (for unique max count check)
// change item amount before check (for unique max count check), provide space for splitted items
// SRC checks
// prevent swap looting item
//best error message found for attempting to swap while looting
// check unequip potability for equipped items and bank bags
// bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
// prevent put equipped/bank bag in self
// prevent equipping bag in the same slot from its inside
// DST checks
// prevent swap looting item
//best error message found for attempting to swap while looting
// check unequip potability for equipped items and bank bags
// bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
// NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
// or swap empty bag with another empty or not empty bag (with items exchange)
// Move case
// attempt merge to / fill target item
// can be merge/fill
// impossible merge/fill, do real swap
// check src->dest move possibility
// check dest->src move possibility
// Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
// bag swap (with items exchange) case
// one from items not go to empty target bag
// too small targeted bag
// Items swap
// will pos in new bag
// now do moves, remove...
// add to dest
// add to src
// if player is moving bags and is looting an item inside this bag
// release the loot
// so we don't need to look at dstBag
// not realy needed here
// if current back slot non-empty search oldest or free
// found empty
// find oldest
// move to next (for non filled list is move most optimized choice)
// if current backslot is filled set to now free slot
// bag type subclass, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2
// no idea about this one...
// slot
// container
// item guid
/*param*/)
// disarm applied only to mainhand weapon
// send yellow "Trade canceled" message to both traders
// cleanup
// also checks for garbage data
/// @todo should never allow an item to be added to m_itemSoulboundTradeable twice
// current element can be erased in UpdateDuration
// not holding enchantment id
// save duration in item
// remove enchantments from equipped items first to clean up the m_enchantDuration list
// Poisons and DK runes are enchants which are allowed on arenas
// remove from stats
// remove visual
// remove from update list
// remove enchants from inventory items
// NOTE: no need to remove these from stats, since these aren't equipped
// in inventory
// in inventory bags
// duration == 0 will remove item enchant
// Cogwheel gems dont have requirement data set in SpellItemEnchantment.dbc, but they do have it in Item-sparse.db2
// If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
// rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
// Check if the requirements for the prismatic socket are met before applying the gem stats
// processed in Player::CastItemCombatSpell
// Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
// Search enchant_amount
// Cast custom spell vs all equal basepoints got from enchant_amount
// Values from ITEM_STAT_MELEE_HA_RATING to ITEM_MOD_HASTE_RANGED_RATING are never used
// in Enchantments
// case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
//     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
//     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
//     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
//     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
//     break;
// case ITEM_MOD_HASTE_MELEE_RATING:
//     ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
//     break;
// case ITEM_MOD_HASTE_RANGED_RATING:
//     ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
//     break;
// case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
//     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
//     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
//     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
//     break;
// case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
//     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
//     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
//     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
//     break;
// Shaman Rockbiter Weapon
// processed in Player::CastItemUseSpell
// nothing do..
/*switch (enchant_display_type)*/
/*for*/
// visualize enchantment at player and equipped items
// set duration
// duration == 0 will remove EnchantDuration
// not holding enchantment id
// Checks if the enchantment needs to be applied or removed
// If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
// rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
// prevent crash
// display in chat
// 0 = looted, 1 = npc
// bonus loot
// 0 = received. 1 = created
// battle pet species
// suffix factor
// battle pet quality
// item id
// random item property id
// battle pet breed
// count of items in inventory
// count of items
// item slot, but when added to stack: 0xFFFFFFFF
// bag slot
// battle pet level
/*********************************************************/
/***                    GOSSIP SYSTEM                  ***/
/*********************************************************/
/*= 0*/, bool showQuests /*= false*/)
// if default menuId and no menu options exist for this, use options from default options
// added in special mode
// no break;
// no checks
// in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
// probably need to find a better way here
// in case non empty gossip menu (that not included quests list size) show it
// (quest entries from quest menu will be included in list)
// if not same, then something funky is going on
// Cast spells that teach dual spec
// Both are also ImplicitTarget self and must be cast by player
// Should show another Gossip text with "Congratulations..."
/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/
// pets also can have quests
//we should obtain map pointer from GetMap() in 99% of cases. Special case
//only for quests which cast teleport spells on player
//else if (status == QUEST_STATUS_AVAILABLE)
//    qm.AddMenuItem(quest_id, 2);
// single element case
// Auto open -- maybe also should verify there is no greeting
// Send completable on repeatable and autoCompletable quest if player don't have quest
/// @todo verify if check for !quest->IsDaily() is really correct (possibly not)
// multiple entries
// need pet case for some quests
//TEXTEMOTE_MESSAGE;              //zyg: player emote
//TEXTEMOTE_HELLO;                //zyg: NPC emote
//QUEST_FLAGS_AUTO_SUBMIT
//we should obtain map pointer from GetMap() in 99% of cases. Special case
//only for quests which cast teleport spells on player
// for unit and go state
// player already have max number (in most case 1) source item, no additional item needed and quest can be added.
// not allow re-complete quest
// auto complete quest
// Solve problem that player don't have the quest and try complete it.
// if repeatable she must be able to complete event if player don't have it.
// Seem that all repeatable quest are DELIVER Flag so, no need to add more.
// not auto complete quest and not completed quest (only cheating case, then ignore without message)
// daily quest can't be rewarded (25 daily quest already completed)
// rewarded and not repeatable quest (only cheating case, then ignore without message)
// prevent receive reward with quest items in bank or for not completed quest
// Player does not have any free slot in the quest log
// if not exist then created with set uState == NEW and rewarded=false
// check for repeatable quests status reset
// not all Quest Objective types need to be tracked, some such as reputation are handled/checked externally
// shared timed quest
// script managment for every quest
//this THING should be here to protect code from quest, which cast on player far teleport as a reward
//should work fine, cause far teleport will be executed in Player::Update()
// Not give XP in case already completed once repeatable quest
// handle SPELL_AURA_MOD_XP_QUEST_PCT auras
// honor reward
// title reward
// Send reward mail
/// @todo Poor design of mail system
// StoreNewItem, mail reward, etc. save data directly to the database
// to prevent exploitable data desynchronisation we save the quest status to the database too
// (to prevent rewarding this quest another time while rewards were already given out)
// cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
//lets remove flag for delayed teleports
// Destroy quest items on quest failure.
// Destroy items received during the quest.
// skip 0 case RequiredSkill
// check skill value
// There doesn't seem to be a specific response for too high player level
// exist free slot
// No previous quest (might be first quest in a series)
// If any of the positive previous quests completed, return true
// skip one-from-all exclusive group
// each-from-all exclusive group (< 0)
// can be start if only all quests in prev quest exclusive group completed and rewarded
// skip checked quest id, only state of other quests in group is interesting
// alternative quest from group also must be completed and rewarded (reported)
// If any of the negative previous quests active, return true
// skip one-from-all exclusive group
// each-from-all exclusive group (< 0)
// can be start if only all quests in prev quest exclusive group active
// skip checked quest id, only state of other quests in group is interesting
// alternative quest from group also must be active
// Has only positive prev. quests in non-rewarded state
// and negative prev. quests in non-active state
//Min required rep
//Max required rep
// ReputationObjective2 does not seem to be an objective requirement but a requirement
// to be able to accept the quest
// non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
// skip checked quest id, only state of other quests in group is interesting
// not allow have daily quest if daily quest from exclusive group already recently completed
// alternative quest already started or completed - but don't check rewarded states if both are repeatable
// next quest in chain already started or completed
// GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
// check for all quests further up the chain
// only necessary if there are quest chains with more than one quest that can be skipped
//return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
// No previous quest in chain
// If any of the previous quests in chain active, return false
// check for all quests further down the chain
// only necessary if there are quest chains with more than one quest that can be skipped
//if (!SatisfyQuestPrevChain(prevId, msg))
//    return false;
// No previous quest in chain active
//GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx);
/*msg*/)
// if not found in cooldown list
/*msg*/)
// if not found in cooldown list
/*msg*/)
// if not found in cooldown list
// player already have max amount required item, just report success
// exist two cases when destroy source quest item not possible:
// a) non un-equippable item (equipped non-empty bag, for example)
// b) when quest is started from an item and item also is needed in
// the end as RequiredItemId
// for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
// not used in Skyfire, but used in scripting code
/*= 0*/)
//not used in Trinityd, function for external script library
// for any leave or dead (with not released body) group member at appropriate distance
/*= 0*/)
// MUST BE CALLED FIRST
// just if !ingroup || !noraidgroup || raidgroup
// just if !ingroup || !noraidgroup || raidgroup
// just if !ingroup || !noraidgroup || raidgroup
// here to not break old scripts, this function should be removed at some point
/*QUEST_OBJECTIVE_TYPE_NPC_INTERACT*/, guid);
// hide quest if player is in raid-group and quest is no raid quest
//there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
// There should be no mixed ReqItem/ReqSource drop
// This part for ReqItem drop
// This part - for ReqSource
// examined item is a source item
// 'unique' item
// allows custom amount drop when not 0
// At max level, increase gold reward
// FIXME: unknown bits, common values sent
// bonus talents (still sent to 5.4.x client)
// 4.x bonus skill id
// 4.x bonus skill points
// failed reason (valid reasons: 4, 16, 50, 17, 74, other values show default message)
// has quest title
/*********************************************************/
/***                   LOAD SYSTEM                     ***/
/*********************************************************/
// SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
// client limit
// Expecting only one row
//        0           1     2      3      4      5      6          7          8        9
// SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell FROM character_battleground_data WHERE guid = ?
// Map
// X
// Y
// Z
// Orientation
// update sql homebind
////                                                     0     1        2     3     4        5      6    7      8     9           10              11
//QueryResult* result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, gender, level, xp, money, playerBytes, playerBytes2, playerFlags, "
// 12          13          14          15   16           17        18        19         20         21          22           23                 24
//"position_x, position_y, position_z, map, orientation, taximask, cinematic, totaltime, leveltime, rest_bonus, logout_time, is_logout_resting, resettalents_cost, "
// 25                 26          27       28       29       30       31         32           33            34        35    36      37                 38         39
//"resettalents_time, talentTree, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, instance_mode_mask, "
//    40           41          42              43           44            45
//"totalKills, todayKills, yesterdayKills, chosenTitle, watchedFaction, drunk, "
// 46      47      48      49      50      51      52           53         54          55             56
//"health, power1, power2, power3, power4, power5, instance_id, speccount, activespec, exploredZones, equipmentCache, "
// 57           58          59               60
//"knownTitles, actionBars, grantableLevels, lfgbonusfaction FROM characters WHERE guid = '%u'", guid);
// check if the character's account in the db and the logged in account match.
// player should be able to load/delete character only with correct account!
// check name limitations
// overwrite possible wrong/corrupted guid
// load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
// set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
// cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
//Need to call it to initialize m_team (m_team can be calculated from race)
//Other way is to saves m_team into characters table.
// load home bind and check in same time class/race pair, it used later for restore broken positions
// to max set before any spell loaded
// init saved position, and fix it later if problematic
// Player was saved in Arena or Bg
//saved in Battleground
//join player to battleground group
// Bg was not found - go to Entry Point
// leave bg
// Do not look for instance if bg not found
// Db field type is type int16, so it can never be MAPID_INVALID
//if (mapId == MAPID_INVALID) -- code kept for reference
// Battleground Entry Point not found (???)
// We are not in BG anymore
// currently we do not support transport in bg
// transport size limited
// currently we do not support taxi in instance
// Not finish taxi flight path
// problems with taxi path loading
// don't know taxi start node, to homebind
// have start node, to it
// save source node as recall coord to prevent recall and fall from sky
// checked in m_taxi.LoadTaxiDestinationsFromString
// flight will started later
// Map could be changed before
// client without expansion support
// fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
// NOW player must have valid map
// load the player's map here if it's not already loaded
// if the player is in an instance and it has been reset in the meantime teleport him to the entrance
//StoreRaidMapDifficulty();
// randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
// this must help in case next save after mass player load after server startup
// since last logout (in seconds)
//uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.
// set value, including drunk invisibility detection
// calculate sobering. after 15 minutes logged out, the player will be sober again
// must be before InitTaxiNodesForLevel
// Honor system
// Update Honor kills data
// clear channel spell data (if saved at channel spell casting)
// clear charm/summon related fields
// reset some aura modifiers before aura apply
// make sure the unit is considered out of combat for proper loading
// make sure the unit is considered not in duel for proper loading
// reset stats before loading any modifiers
// rest bonus can only be calculated after InitStatsForLevel()
//speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
//speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
// load skills after InitStatsForLevel because it triggering aura apply also
//update skills after load, to make sure they are correctly update at player load
// apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
//mails are loaded only when needed ;-) - when player in game click on mailbox.
//_LoadMail();
// sanity check
// Only load selected specializations, learning mastery spells requires this
// must be loaded before spells
// add ghost flag (must be after aura load: PLAYER_FLAGS_GHOST set in aura)
// after spell load, learn rewarded spell if need also
// after spell and quest load
// must be before inventory (some items required reputation check)
// update items with duration and realtime
// unread mails and next delivery time, actual mails not loaded
// check PLAYER_FIELD_PLAYER_TITLE compatibility with PLAYER__FIELD_KNOWN_TITLES
// note: PLAYER__FIELD_KNOWN_TITLES updated at quest status loaded
// has to be called after last Relocate() in Player::LoadFromDB
// Spell code allow apply any auras to dead character in load time in aura/spell/item loading
// Do now before stats re-calculation cleanup for ghost state unexpected auras
//apply all stat bonuses from items and auras
// restore remembered power/health values (but not more max values)
// Verify loaded talent specializations
// invalid tree, reset talents
// GM state
// disable
// enable
// save state
// invisible
// visible
// save state
// disable
// enable
// save state
// disable
// enable
// save state
// RaF stuff.
// SELECT id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154 FROM character_cuf_profiles WHERE guid = ?
// nothing to loot or everything looted.
// may only loot if the player is the loot roundrobin player
// or if there are free/quest/conditional item for the player
// may only loot if the player is the loot roundrobin player
// or item over threshold (so roll(s) can be launched)
// or if there are free/quest/conditional item for the player
// Will deleted in DB at next save (it can create data until save but marked as deleted)
/*                                                           0       1        2         3                 4         5      6       7         8              9            10
// negative effects should continue counting down after logout
// prevent wrong values of remaincharges
// we have no control over the order of applying auras and modifiers allow auras
// to have more charges than value in SpellInfo
/* || remaincharges > spellproto->procCharges*/)
// On any error remove glyph
//Prevent Dead Player login without corpse
//QueryResult* result = CharacterDatabase.PQuery("SELECT data, text, bag, slot, item, item_template FROM character_inventory JOIN item_instance ON character_inventory.item = item_instance.guid WHERE character_inventory.guid = '%u' ORDER BY bag, slot", GetGUIDLow());
//NOTE: the "order by `bag`" is important because it makes sure
//the bagMap is filled before items in the bags are loaded
//NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
//expected to be equipped before offhand items (@todo fixme)
// fast guid lookup for bags
// fast guid lookup for bags
// Prevent items from being added to the queue while loading
// Item is not in bag
// Remember bags that may contain items in them
// Item is in the bag, find the bag
// Item's state may have changed after storing
// Send problematic items by mail
//if (IsAlive())
// SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
// Do not allow to have item limited to another map/zone in alive state
// "Conjured items disappear if you are logged out for more than 15 minutes"
// Remove item from inventory if necessary
// it also deletes item object!
// load mailed item which should receive current player
// data needs to be at first place for Item::LoadFromDB
// it also deletes item object !
//set a count of unread mails
//QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
// store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
//resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
//fixme: the pet should still be loaded if the player is not in world
// just not added to the map
////                                                       0      1       2        3        4           5          6         7           8           9           10
//QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, itemcount1, itemcount2, itemcount3,
//                                                    11           12
//                                                itemcount4, playercount FROM character_queststatus WHERE guid = '%u'", GetGUIDLow());
// used to be new, no delete?
// find or create
// add to quest log
// cast can't be helped
// clear quest log tail
// Quest existence is checked on Quest Objective load, no issue should arise
// SELECT quest FROM character_queststatus_rewarded WHERE guid = ?
// used to be new, no delete?
// learn rewarded spell if unknown
// set rewarded title if any
//for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
//SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, 0);
//QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '%u'", GetGUIDLow());
// max amount with exist data in query
// save _any_ from daily quest times (it must be after last reset anyway)
//SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, quest_id);
//QueryResult* result = CharacterDatabase.PQuery("SELECT spell, active, disabled FROM character_spell WHERE guid = '%u'", GetGUIDLow());
//QueryResult* result = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", GetGUIDLow());
// the group leader may change the instance difficulty while the player is offline
//QueryResult* result = CharacterDatabase.PQuery("SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = '%u'", GUID_LOPART(m_guid));
// the resettime for normal instances is only saved when the InstanceSave is unloaded
// so the value read from the DB may be wrong here but only if the InstanceSave is loaded
// and in that case it is not used
// since non permanent binds are always solo bind, they can always be reset
// some instances only have one difficulty
// save can become invalid
// update the save when the group kills a boss
//it seems sometimes mapSave is NULL, but I did not check why
// isGM?
// placeholder
// extended = 1
// expired = 0
// reset time
// completed encounters mask
// map id
// difficulty
/*
// only permanent binds are sent
//Send opcode SMSG_UPDATE_INSTANCE_OWNERSHIP. true or false means, whether you have current raid/heroic instances
/// convert the player's binds to the group
// copy all binds to the group, when changing leader it's assumed the character
// will not have any solo binds
// permanent binds are not removed
// increments itr in call
// if (missingAchievement) covered by this case
// cannot be in raid instance without a group
// cannot be in normal instance without a group and more players than 1 in instance
// do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
// SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
// accept saved data only for valid position (and non instanceable), and accessable
/*********************************************************/
/***                   SAVE SYSTEM                     ***/
/*********************************************************/
/*=false*/)
// delay auto save at any saves (manual, in code, or autosave)
//lets allow only players in world to be saved
// first save/honor gain after midnight will also update the player's honor fields
//! Insert query
/// @todo: Filter out more redundant fields that can take their default value at player create
//save, far from tavern/city
//save, but in tavern/city
// cache equipment...
// ...and bags for enum opcode
// Update query
//save, far from tavern/city
//save, but in tavern/city
// cache equipment...
// ...and bags for enum opcode
// Index
//save mails only when needed
// changed only while character in game
// check if stats should only be saved on logout
// save stats can be out of transaction
// save pet (hunter pet level and experience and all type pets health/mana).
// fast save function for item/money cheating preventing - save only inventory and money state
// force items in buyback slots to new state
// and remove those that aren't already
// Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
// the client auto counts down in real time after having received the initial played time on the first
// SMSG_ITEM_REFUND_INFO_RESPONSE packet.
// Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
// use copy iterator because itr may be invalid after operations in this loop
// update enchantment durations
// if no changes
// according to the test that was just performed nothing should be in this slot, delete
// also THIS item should be somewhere else, cheat attempt
// we are IN updateQueue right now, can't use SetState which modifies the queue
// don't skip, let the switch delete it
//continue;
// save all changes to the item...
// only for existing items, no dupes
// ...but do not save position in inventory
// item have unchanged inventory record and can be save standalone
// unused item
// DELETE FROM void_storage WHERE slot = ? AND playerGuid = ?
// REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
// unused profile
// DELETE FROM character_cuf_profiles WHERE guid = ? and id = ?
// REPLACE INTO character_cuf_profiles (guid, id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
// 27 of 32 fields used, fits in an int
//deallocate deleted mails...
// save last daily quest time for all quests: we need only mostly reset time for reset check anyway
// we don't need transactions here.
/*for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
// we don't need transactions here.
// we don't need transactions here.
// we don't need transactions here.
// we don't need transactions here.
// add only changed/new not dependent spells
// save player stats -- only for external usage
// real stats will be recalculated on player login
// check if stat saving is enabled and if char level is high enough
/*********************************************************/
/***               FLOOD FILTER SYSTEM                 ***/
/*********************************************************/
// ignore chat spam protection for GMs in any mode
// prevent overwrite mute time, if message send just before mutes set, for example.
/*********************************************************/
/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
/*********************************************************/
// Unk
// Unk
/*bool IsInGroup*/)
/*bool IsInGroup,*/ int32 forcedDifficulty)
/*mapid*/)
/// Reset all solo instances and optionally send a message on success for each
// method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN
// we assume that when the difficulty changes, all instances that can be reset will be
// the "reset all instances" method can only reset normal maps
// if the map is loaded, reset it
// since this is a solo instance there should not be any players inside
// the following should remove the instance save from the manager and delete it as well
/*reasons for instance reset failure:
// 1>: There are players inside the instance.
/*********************************************************/
/***              Update timers                        ***/
/*********************************************************/
///checks the 15 afk reports per 5 minutes limit
//there may be a guardian in slot
//SF_LOG_ERROR("entities.player", "Player::GetPet: Pet %u not exist.", GUID_LOPART(pet_guid));
//const_cast<Player*>(this)->SetPetGUID(0);
//returning of reagents only for players, so best done here
//for succubus, voidwalker, felhunter and felguard credit soulshard when despawn reason other than death (out of range, logout)
//warlock pets except imp are removed(?) when logging out
// only if current pet in slot
// cooldowns count
// spells count
// CooldownCount
// if not addon data
// whispers should always be readable
// rest stuff shouldn't happen in case of addon message
// announce afk or dnd message
//ASSERT deleted, because items can be added before loading
// Spell Count
// Cooldown Count
// action bar loop
// category cooldown
// spell ID
// spell category
// spell cooldown
// spell ID
// Spell data loop
// Creature Family
// Creature Specialization need implementation
// flags ??
// cooldowns count
// spells count
// CooldownCount
// spellHistoryCount
// spells count
// CooldownCount
// category cooldown
// spell ID
// spell category
// spell cooldown
// category cooldown
// spell ID
// spell category
// spell cooldown
// Pet Family (0 for all vehicles)
// Creature Specialization need implementation
// Duration
// React State
// Command State
// DisableActions (set for all vehicles)
//CreatureInfo const* cinfo = charm->ToCreature()->GetCreatureTemplate();
//if (cinfo && cinfo->type == CREATURE_TYPE_DEMON && getClass() == CLASS_WARLOCK)
// cooldowns count
// spells count
// CooldownCount
// cooldowns count
// spells count
// CooldownCount
// Mod out of charges
// +duration to infinite duration spells making them limited
// count of mods per one mod->op
// count of different mod->op's in packet
// mods bound to aura will be removed in AuraEffect::~AuraEffect
// Restore spellmods in case of failed cast
// spellmods without aura set cannot be charged
// Restore only specific owner aura mods
// check if mod affected this spell
// first, check if the mod aura applied at least one spellmod to this spell
// secondly, check if the current mod is one of the spellmods applied by the mod aura
// remove from list
// add mod charges back to mod
// Do not set more spellmods than avalible
// Skip this check for now - aura charges may change due to various reason
/// @todo trac these changes correctly
//ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
// spellmods without aura set cannot be charged
// check if mod affected this spell
// remove from list
// don't handle spells with proc_event entry defined
// this is a temporary workaround, because all spellmods should be handled like that
// send Proficiency
// this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
// and SendPetitionQueryOpcode reads data from the DB
// send update if charter owner in game
// Prevent resting on max level
// update data for client
// Set Reststate = Rested
// Set Reststate = Normal
//RestTickUpdate
/*= NULL*/, uint32 spellid /*= 0*/)
// not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
// taximaster case
// not let cheating with start flight mounted
// not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
// cast case or scripted call case
// starting node too far away (cheat?)
// check node starting pos data set case if provided
// node must have pos if taxi master case (npc != NULL)
// Prepare to flight start now
// stop combat at start taxi flight if any
// stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
// clean not finished taxi path if any
// 0 element current node
// fill destinations path tail
// get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
//
// Hack-Fix for Alliance not being able to use Acherus taxi. There is
// only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
// change but I couldn't find a suitable alternative. OK to use class because only DK
// can use this taxi.
// in spell case allow 0 model
//Checks and preparations done, DO FLIGHT
// prevent stealth flight
//RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);
/*= 0*/)
// not destinations, clear source node
// search appropriate start path node
// skip nodes at another map
// Missing flags
// Not send cooldown for this spells
// in m.secs
// 0, for example
// update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
// case for new honor system
// numbered from 1 at client
// cheating attempt
// store diff item (cheating)
// Find correct error
// Not implemented
// Find correct error
// Find correct error
// check for personal arena rating requirement
// probably not the proper equip err
// Find correct error
// Find correct error
// Find correct error
// currencies have no price defined, can only be bought with ExtendedCost
// Return true is the bought item has a max count to force refresh of window by caller
// cheating attempt
// cheating attempt
// store diff item (cheating)
// check current item amount if it limited
// Can only buy full stacks for extended cost
// Find correct error
// check for personal arena rating requirement
// probably not the proper equip err
// Find correct error
// Find correct error
// Find correct error
//Assume price cannot be negative (do not know why it is int32)
//it should not exceed MAX_MONEY_AMOUNT
// reputation discount
// bought
// returns the maximal personal arena rating that can be used to purchase items requiring this condition
// the personal rating of the arena team must match the required limit as well
// so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
// GMs never get homebind timer online
// instance valid, but timer not reset
// hide reminder
// instance is valid, reset homebind timer
// teleport to nearest graveyard
// instance is invalid, start homebind timer
// send message to player
/// @todo should we always synchronize UNIT_FIELD_SHAPESHIFT_FORM, 1 of controller and controlled?
// no, we shouldn't, those are checked for affecting player by client
// in hostile area
// in friendly area
// start toggle-off
// init cooldown values
// some special item spells without correct cooldown in SpellInfo
// cooldown information stored in item prototype
// This used in same way in WorldSession::HandleItemQuerySingleOpcode data sending to client.
// if no cooldown found above then base at DBC data
// overwrite time for selected category
// use +MONTH as infinity mark for spell cooldown (will checked as MONTH/2 at save ans skipped)
// but not allow ignore until reset or re-login
// shoot spells used equipped item cooldown values already assigned in GetAttackTime(RANGED_ATTACK)
// prevent 0 cooldowns set by another way
// Now we have cooldown data (if found any), time to apply mods
// Apply SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN modifiers
// Note: This aura applies its modifiers to all cooldowns of spells with set category, not to category cooldown only
// replace negative cooldowns by 0
// no cooldown after applying spell mods
// self spell cooldown
// category spells
// skip main spell, already handled above
/*= 0*/, Spell* spell /*= NULL*/, bool setCooldown /*= true*/)
// start cooldowns at server side, if any
// Send activate cooldown timer (possible 0) at client side
// no potion used i combat or still in combat
// Call not from spell cast, send cooldown event for item spells if no in combat
// spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
// from spell cases (m_lastPotionId set in Spell::SendSpellCooldown)
//slot to be excluded while counting
//counting current equipped gem colors
// if have <CompareColor> use them as count, else use <value> from Condition
// requires less <color> than (<value> || <comparecolor>) gems
// requires more <color> than (<value> || <comparecolor>) gems
// requires at least <color> than (<value> || <comparecolor>) gems
//cycle all equipped items
//enchants for the slot being socketed are handled by Player::ApplyItemMods
//was enchant active with/without item?
//should it now be?
// ignore item gem conditions
//if state changed, (dis)apply enchant
//if false -> then toggled off if was on| if true -> toggled on if was off AND meets requirements
//cycle all equipped items
//enchants for the slot being socketed are handled by WorldSession::HandleSocketOpcode(WorldPacket& recvData)
//if item has no sockets or no item is equipped go to next item
//cycle all (gem)enchants
//if no enchant go to next enchant(slot)
//only metagems to be (de)activated, so only enchants with condition
// Taxi path store
// On taxi we don't need check for dungeon
// Mount spell id storing
// If map is dungeon find linked graveyard
// If new entry point is not BG or arena set it
// In error cases use homebind position
// call after remove to be sure that player resurrected for correct cast
//lets check if player was teleported from BG and schedule delayed Deserter spell cast
// Deserter
// check Deserter debuff
// a player can complain about 15 people per 5 minutes
///This player has been blamed to be inactive in a battleground
// Battleground also must be in progress!
// check if player has 'Idle' or 'Inactive' debuff
// 3 players have to complain to apply debuff
// cast 'Idle' spell
// Always can see self
// Always can see self
// Visible units, always are visible for all players
// GMs are visible for higher gms (or players are visible for gms)
// non faction visibility non-breakable for non-GMs
// non-gm stealth/invisibility not hide from global player lists
/*v*/)
/*v*/)
// @HACK: This is to prevent objects like deeprun tram from disappearing when player moves far from its spawn point while riding it
/*t*/, Player* /*p*/) { }
// target aura duration for caster show only if target exist at caster client
// send data at target visibility change (adding to client)
// Update fields of triggers, transformed units or unselectable units (values dependent on GM state)
//if (visibleNow.size() < 30 || target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsVehicle())
// updates visibility of all objects around point of view for current player
// send gathered data
/*= true*/)
// without combo points lost (duration checked in aura)
// Spells will always add value to m_comboPoints eventualy, so it must be cleared first
// without combopoints lost (duration checked in aura)
// never use SetGroup without a subgroup unless you specify NULL for group
/// Pass 'this' as argument because we're not stored in ObjectAccessor yet
// guild bank list wtf?
// Homebind
// SMSG_SET_PROFICIENCY
// SMSG_SET_PCT_SPELL_MODIFIER
// SMSG_SET_FLAT_SPELL_MODIFIER
// SMSG_UPDATE_AURA_DURATION
// Bitfields have wrong order
// IneligibleForLoot
// HasRestrictedLevel
// HasRestrictedMoney
// HasGroupSize
// IsOnTournamentRealm
// LastWeeklyReset (not instance reset)
//if (HasGroupSize)
//    data << uint32(0);
//if (HasRestrictedLevel)
//    data << uint32(20);                                       // RestrictedLevel (starter accounts)
//if (IneligibleForLoot)
//    data << uint32(0);                                        // EncounterMask
//if (HasRestrictedMoney)
//    data << uint32(100000);                                   // RestrictedMoney (starter accounts)
// Count
// game speed
// SMSG_SET_FORCED_REACTIONS
// SMSG_UPDATE_TALENT_DATA x 2 for pet (unspent points and talents in separate packets...)
// SMSG_PET_GUIDS
// SMSG_UPDATE_WORLD_STATE
// SMSG_POWER_UPDATE
// update zone
// also call SendInitWorldStates();
// LOGINEFFECT
// set some aura effects that send packet to player client after add player to map
// SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
// same auras state lost at far teleport, send it one more time in this case also
// manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
// must be after add to map
// must be after add to map
// raid downscaling - send difficulty to player
// transfer abort reason
// type of warning, based on the time remaining until reset
// difficulty
// is locked
// is extended, ignored if prev field is 0
// no spell
// wrong triggering type (note: ITEM_SPELLTRIGGER_ON_NO_DELAY_USE not have cooldown)
// Don't replace longer cooldowns by equip cooldown if we have any.
// not need after this call
// make full copy of map (spells removed and marked as deleted at another spell remove
// and we can't use original map for safe iterative with visit each spell at loop end
// skip server-side/triggered spells
// skip wrong class/race skills
// skip other spell families
// skip spells with first rank learned as talent (and all talents then also)
// skip broken spells
// only iter->first can be accessed, object by iter->second can be deleted already
// learn default race/class spells
// will send in INITIAL_SPELLS in list anyway at map add
// but send in normal spell in game learn case
// skip quests without rewarded spell
// if RewSpellCast = -1 we remove aura do to SrcSpell from player.
// check learned spells state
// skip quests with not teaching spell or already known spell
// prevent learn non first rank unknown profession and second specialization for same profession)
// not have first rank learned (unlearned prof?)
// specialization
// search other specialization for same prof
// compare only specializations
// compare same chain spells
// learn spells received from quest completing
// Check race if set
// Check class if set
// need unlearn spell
// need learn
// speedup things
/*! Blizz sends certain movement packets sometimes even before CreateObject
// Is AURA_UPDATE_ALL
// Aura Count
// Not remove
// Effect Count
// Effect Count
// HasCasterGuid
// Unk effect count
// HasDuration
// HasMaxDuration
// send stack amount for aura which could be stacked (never 0 - causes incorrect display) or charges
// stack amount has priority over charges (checked on retail with spell 50262)
/*if (!GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx))
// last daily quest time
//for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
//    SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, 0);
// Dungeon Finder Quests.
// DB data deleted in caller
// DB data deleted in caller
// DB data deleted in caller
// DB data deleted in caller
// get a template bg instead of running one
// limit check leel to dbc compatible level range
// skip wrong race skills
// skip wrong class skills
// check if this unit requires quest specific flags
//! This code doesn't look right, but it was logically converted to condition system to do the exact
//! same thing it did before. It definitely needs to be overlooked for intended functionality.
// expire and auto declined
// stop taxi flight at summon
// drop flag at summon
// this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
/*= false*/)
// unequip offhand weapon if player doesn't have dual wield anymore
// need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
// deletes item from character's inventory
// recursive and not have transaction guard into self, item not in inventory and can be save standalone
// scan other equipped items for same requirements (mostly 2 daggers/etc)
// for optimize check 2 used cases only
// tabard not have dependent spells
// shields can be equipped to offhand slot
// ranged slot can have some armor subclasses
/*if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
// don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
// Check no reagent use mask
// NEED FLAG CONFIRMATION
// skip passive (passive item dependent spells work in another way) and not self applied auras
// skip if not item dependent or have alternative item
// no alt item, remove aura, restart check
// currently casted spells can be dependent from item
// search priceless resurrection possibilities
// Soulstone Resurrection                           // prio: 3 (max, non death persistent)
// rank 1
// rank 2
// rank 3
// rank 4
// rank 5
// rank 6
// rank 7
// Twisting Nether                                  // prio: 2 (max)
// Reincarnation (passive spell)  // prio: 1
// Used in triggers for check "Only to targets that grant experience or honor" req
// Victim level less gray level
// member (alive or dead) or his corpse at req. distance
// level must be allowed to get RaF bonus
// level difference must be small enough to get RaF bonus, UNLESS we are lower level
// prepare data for near group iteration
// member (alive or dead) or his corpse at req. distance
// quest objectives updated only for alive group member or dead but with not released body
// if (!group)
/// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
// Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
// remove auras from spells with area limitations
// use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
// some auras applied at subzone enter
// Ulduar
// 0..2 full period
// should be ceil(x)-1 but not floor(x)
// full and partly periods 1..3
//! corpse reclaim delay 30 * 1000ms or longer at often deaths
// IsHostileTo check duel and controlled by enemy
/// @todo Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
/* Missing support for these types
//we must move references from m_group to m_originalGroup
//remove existing reference
// never use SetOriginalGroup without a subgroup unless you specify NULL for group
// All liquids type - check under water position
// Allow travel in dark water on taxi or transport
// in lava check, anywhere in lava level
// in slime check, anywhere in slime level
// farsight dynobj or puppet may be very far away
//must immediately set seer back otherwise may crash
//WorldPacket data(SMSG_CLEAR_FAR_SIGHT_IMMEDIATE, 0);
//GetSession()->SendPacket(&data);
// It is possible to call this method with a null pointer, only skipping faction check.
// BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
// Note: Mount, stealth and invisibility will be removed when used
// Damage immune
// Still has recently held flag debuff
// Alive
// not stealthed
// not invisible
// live player
// max level in this dbc
// shouldn't happen
// full price
// +1/2 of price
// +3/4 of price
// +5/6 of price
// total immunity
// total immunity
// physical damage immunity
// magic immunity
//This should only called in Player::Update
//kill self if charm aura has infinite duration
// Runes cooldown are now affected by player's haste from equipment ...
// ... and some auras.
// If rune was converted by a non-pasive aura that still active we should keep it converted
// Don't drop passive talents providing rune convertion
// passed cooldown time (0-255)
// rune type
// mask (0x00-0x3F probably)
/*0*/ RUNE_BLOOD,
/*1*/ RUNE_BLOOD,
/*2*/ RUNE_UNHOLY,
/*3*/ RUNE_UNHOLY,
/*4*/ RUNE_FROST,
/*5*/ RUNE_FROST
// init base types
// init current types
// reset cooldowns
// set a base regen timer equal to 10 sec
// questitems use the blocked field for other purposes
//freeforall is 1 if everyone's supposed to get the quest item.
//freeforall case, notify only one player of the removal
//not freeforall, notify everyone
//if only one person is supposed to loot the item, then set it to looted
// LootItem is being removed (looted) from the container, delete it from the DB.
// 1 talent point for every 15 levels
// continent checked in SpellInfo::CheckLocation at cast and area update
// Cold Weather Flying
//                                                           0      1      2
// SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));
// set fixed skill ranges
// 300..300
// 1..1, grey monolite bar
// client limit
// special settings
// 270 at starting level 55
// skill mast be known and then > 0 in any case
// proto based limitations
// check unique-equipped on gems
// include for check equip another gems with same limit category for not equipped item (and then not counted)
// check unique-equipped on item
// there is an equip limit on this item
// check unique-equipped limit
// NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case
// there is an equip limit on this item
// calculate total z distance of the fall
//SF_LOG_DEBUG("misc", "zDiff = %f", z_diff);
//Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
// 14.57 can be calculated by resolving damageperc formula below to 0
//Safe fall, fall height reduction
//Prevent fall damage from being more than the player maximum health
// Gust of Wind
// recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
//Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
// No fly zone - Parachute
/* = 0*/)
/*= 0*/, uint64 miscValue2 /*= 0*/, bool evenIfCriteriaComplete /* = false*/)
/*= 0*/, uint64 miscValue2 /*= 0*/, uint64 miscValue3 /*= 0*/, Unit* unit /*= NULL*/)
// Update only individual achievement criteria here, otherwise we may get multiple updates
// from a single boss kill
// prevent learn talent for different class (cheating)
// check if we have enough talent points
// Check if player doesnt have any spell in selected collumn
// spell not set in talent.dbc
// already known
//TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
//if (!talentTabInfo)
// not hunter pet
// prevent learn talent for different family (cheating)
/*if (!((1 << pet_family->petTalentType) & talentTabInfo->petTalentMask))
// find current max talent rank (0~5)
// 0 = not learned any rank
/*for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
// we already have same or higher talent rank learned
// check if we have enough talent points
// Check if it requires another talent
// Find out how many points we have in this field
/*
// spell not set in talent.dbc
// already known
// learn! (other talent ranks will unlearned at learning)
// update free talent points
// not resummon in not appropriate state
/*+in flight*/
// talent group index (0 or 1)
// GlyphProperties.dbc
// Talent.dbc
// [PH], unspentTalentPoints
// [PH], talentIdCount
// put real points
/*
// skip another tab talents
// find max talent rank (0~4)
// not learned talent
// Talent.dbc
// talentMaxRank (0-4)
// put real count
// slotUsedMask < 0x80000
// item entry
// enchantmentMask < 0x1000
// enchantmentId?
// unknown
// item creator
// seed?
// something wrong...
// nothing do
/* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell */
/*= false*/)
// ClearOnHold 
// Spell Count
// Spell ID
// this may be called during Map::Update
// after decrement+unlink, ++m_mapRefIter will continue correctly
// when the first element of the list is being removed
// nocheck_prev will return the padding element of the RefManager
// instead of NULL in the case of prev
// SELECT spec, glyph1, glyph2, glyph3, glyph4, glyph5, glyph6, glyph7, glyph8, glyph9 FROM character_glyphs WHERE guid = '%u'
// SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS, "SELECT spell, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
// Copy spec data
// make sure the button list is cleaned up
// Delete spec data for removed spec.
// TO-DO: We need more research to know what happens with warlock's reagent
/*RemoveAllAurasOnDeath();
//RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
//ExitVehicle(); // should be impossible to switch specs from inside a vehicle..
// Let client clear his current Actions
// m_actionButtons.clear() is called in the next _LoadActionButtons
/*TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
// unlearn only talents for character class
// some spell learned by one class as normal spells or know at creation but another class learn it as talent,
// to prevent unexpected lost normal learned spell skip another class talents
// skip non-existant talent ranks
// removes the talent, and all dependant, learned, and chained spells..
// search through the SpellInfo for valid trigger spells
// and remove any spells that the talent teaches
// if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
//PlayerTalentMap::iterator plrTalent = m_talents[m_activeSpec]->find(talentInfo->RankID[rank]);
//if (plrTalent != m_talents[m_activeSpec]->end())
//    plrTalent->second->state = PLAYERSPELL_REMOVED;
/*
// set glyphs
// remove secondary glyph
// learn only talents for character class
// add the talent to the PlayerSpellMap
/*
// set glyphs
// apply primary glyph
// Mana must be 0 even if it isn't the active power type.
// if (!sTalentTabStore.LookupEntry(GetTalentSpecialization(GetActiveSpec())))
//    ResetTalents(true);
// Schedule next sync in 10 sec
// slot count placeholder
// unk1
// enchant count placeholder
// unk2
// if (unk2)
// enchantData << uint16(0);
// enchantmentId
// slot
// if (unk1)
// enchantData << uint32(0);
// slot
// glyph count placeholder
// talent count placeholder
// GlyphProperties.dbc
// Talent.dbc
// seconds
// This function call unsets ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
// Formerly refundable item got traded
// item cost data
// Flags ?
// money cost
// currency cost data
/// @todo Send to mailbox if no space
// item cost data
// money cost
// item refund has expired
// Formerly refundable item got traded
// item-> will be invalidated in DestroyItem
// Save all relevant data to DB to prevent desynchronisation exploits
// Delete any references to the refund data
// Destroy item
// Grant back extendedcost items
/// Already checked before
// Grant back currencies
// Grant back money
// Saved in SaveInventoryAndGoldToDB
//QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());
// don't check tabard, ranged, offhand or shirt
/*i == EQUIPMENT_SLOT_RANGED ||*/ i == EQUIPMENT_SLOT_OFFHAND || i == EQUIPMENT_SLOT_BODY)
// unused item
// 99% sure about this
//! Dismounting case - use basic default model data
// Remove Demonic Sacrifice auras (known pet)
// petentry == 0 for hunter "call pet" (current pet summoned if any)
/*GetPhaseMask(),*/ entry, pet_number))
// this enables pet details window (Shift+P)
// cast can't be helped in this case
// Remove Demonic Sacrifice auras (known pet)
//ObjectAccessor::UpdateObjectVisibility(pet);
/*= NULL*/)
// Fallback here
//! Anti-cheat checks. Please keep them in seperate if () blocks to maintain a clear overview.
//! Might be subject to latency, so just remove improper flags.
/*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
//! Cannot hover without SPELL_AURA_HOVER
//! Cannot ascend and descend at the same time
//! Cannot move left and right at the same time
//! Cannot strafe left and right at the same time
//! Cannot pitch up and down at the same time
//! Cannot move forwards and backwards at the same time
//! Cannot walk on water without SPELL_AURA_WATER_WALK
//! Cannot feather fall without SPELL_AURA_FEATHER_FALL
/*! Cannot fly if no fly auras present. Exception is being a GM.
// Client first checks if spline elevation != 0, then verifies flag presence
/*
// DELETE FROM character_research_digsites WHERE guid = ? AND digsiteId = ?
// INSERT INTO character_research_digsites (guid, digsiteId, currentFindGUID, remainingFindCount) VALUES (?, ?, ?, ?)
// DELETE FROM character_research_digsites WHERE guid = ? AND digsiteId = ?
// SELECT digsiteId, currentFindGUID, remainingFindCount FROM character_research_digsites WHERE guid = ?
// Client needs this
// we need to spawn a new digsite before the old digsite is deleted, so there won't be a chance that the old digsite will be spawned again
// Patch 4.1.0: Players now have a much smaller chance of getting a dig site for a race for which they have completed all rare finds.
// check if digsite is already active
// SELECT projectId, researchCount, firstResearchTimestamp FROM character_research_history WHERE guid = ?
// SELECT projectId FROM character_research_projects WHERE guid = ?
// DELETE FROM character_research_history WHERE guid = ?
// INSERT INTO character_research_history (guid, projectId, researchCount, firstResearchTimestamp) VALUES (?, ?, ?, ?)
// DELETE FROM character_research_projects WHERE guid = ?
// INSERT INTO character_research_projects (guid, projectId) VALUES (?, ?)
// project id
// new project will be selected in UpdateResearchProjects
// rare artifact can be completed only once
// common artifact can be completed again only if player has completed all available common artifacts
// If nothing selected yet - project is taken from equal-chanced part
// this branch should not be available
// branch not found
// try to select new project
// branch found, but without project
// try to select new project
// no project selected, remove branch
// archaeology has been unlearned, remove all active research projects and research history
/*= false*/)
// unk bool
// to set default map swaps
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// check client limits
// not exist
// not exist
// DB and client size limitation
// 0x1 = Friendlist update. 0x2 = Ignorelist update. 0x4 = Mutelist update.
// friends count
// player guid
// player flag (0x1 = Friend, 0x2 = Ignored, 0x4 = Muted)
// string note
// if IsFriend()
// online/offline/etc?
// if online
// player area
// player level
// player class
// PLAYER see his team only and PLAYER can't see MODERATOR, GAME MASTER, ADMINISTRATOR characters
// MODERATOR, GAME MASTER, ADMINISTRATOR can see all
// player can see member of other team only if CONFIG_ALLOW_TWO_SIDE_WHO_LIST
// client's friends list and ignore list limit
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// remove self
// remove self
// client requires SMSG_TOTEM_CREATED to be sent before adding to world and before removing old totem
// set display id depending on caster's race
// Get spell cast by totem
// If spell has cast time -> its an active totem
// Some totems can have both instant effect and passive spell
// clear owner's totem slot
// remove aura all party members too
/// @todo possibly all negative auras immune?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// initialize waypoints
// Set current waypoint
// Desired outcome: _currentFrame->DepartureTime < timer < _nextFrame->ArriveTime
// ... arrive | ... delay ... | departure
//      event /         event /
// its a stop frame and we are waiting
// departure event
// found current waypoint
// not waiting anymore
// Enable movement
// Departure event
// Update more in new map thread
// Set position
// static passenger can remove itself in case of grid unload
/// @HACK - transport models are not added to map's dynamic LoS calculations
///         because the current GameObjectModel cannot be moved without recreating
/* There are four possible scenarios that trigger loading/unloading passengers:
// 1. and 2.
// 3.
// 4. is handed by grid unload
// Creatures on transport
// GameObjects on transport
// also removes from _staticPassengers
// Clear events flagging
// Set frames
// calculate from nearest stop, less confusing calculation...
// pets should be teleported with player
// Teleport players, they need to know it
// transport teleported but passenger not yet (can happen for players)
// if passenger is on vehicle we have to assume the vehicle is also on transport
// and its the vehicle that will be updating its passengers
// Do not use Unit::UpdatePosition here, we don't want to remove auras
// as if regular movement occurred
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// If amount is negative, change sign and value of apply.
// Make sure we do not get uint32 overflow.
/*#######################################
// value = ((base_value * base_pct) + total_value) * total_pct
//SPELL_AURA_MOD_RESISTANCE_OF_INTELLECT_PERCENT, only armor currently
// Update ratings in exist SPELL_AURA_MOD_RATING_FROM_STAT and only depends from stat
// For speed just update for client
// Magic damage modifiers implemented in Unit::SpellDamageBonusDone
// This information for client side use only
// Get healing bonus for all schools
// Get damage bonus for all schools
// calls UpdateAttackPowerAndDamage() in UpdateArmor for SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR
// base armor (from items)
// armor percent from items
//add dynamic flat mods
// armor dependent auras update for SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR
// Taken from PaperDollFrame.lua - 4.3.4.15595
// Directly taken from client, SHAPESHIFT_FLAG_AP_FROM_STRENGTH ?
//add dynamic flat mods
// always: ((*i)->GetModifier()->m_miscvalue == 1 == SPELL_SCHOOL_MASK_NORMAL)
//UNIT_FIELD_(RANGED)_ATTACK_POWER field
//update pet's AP
//automatically update weapon damage after attack power modification
// At ranged attack change for hunter pet
//allow update offhand damage only if player knows DualWield Spec and has equipped offhand weapon
// At melee attack power change for DK pet
// At melee attack power change for Shaman feral spirit
//check if player is druid and in cat or bear forms
//check if player not in form but still can't use (disarm case)
//cannot use ranged/off attack, set values to 0
/*
//add ammo DPS to ranged damage
// No block
// Base value
// Increase from SPELL_AURA_MOD_BLOCK_PERCENT aura
// Increase from rating
// Modify crit from weapon skill and maximized defense skill of same level victim difference
/*
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// DK
// Shaman
// Mage
// Warlock
// Monk
// Druid
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// DK
// Shaman
// Mage
// Warlock
// Monk
// Druid
// No parry
// Parry from rating
// Parry from SPELL_AURA_MOD_PARRY_PERCENT aura
// apply diminishing formula to diminishing parry chance
// Warrior
// Paladin
// Hunter
// Rogue
// Priest
// DK
// Shaman
// Mage
// Warlock
// Monk
// Druid
// Dodge from SPELL_AURA_MOD_DODGE_PERCENT aura
// Dodge from rating
// apply diminishing formula to diminishing dodge chance
// For normal school set zero crit chance
// For others recalculate it from:
// Crit from Intellect
// Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// Increase crit by school from SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL
// Increase crit from spell crit ratings
// Store crit value
// Store Rating Value
// item neutral spell
// item dependent spell
// base regen since pandaria is 2% aka 6000 MP @90.
// Mana regen from spirit
// Apply PCT bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT aura on spirit base regen
//Apply FLAT bonus from SPELL_AURA_MOD_POWER_REGEN 
// mp5
// Set regen rate in cast state apply only on spirit based regen
/*#######################################
/*stat*/)
//UNIT_FIELD_(RANGED)_ATTACK_POWER field
//UNIT_FIELD_(RANGED)_ATTACK_POWER_MULTIPLIER field
//automatically update weapon damage after attack power modification
//float att_speed = float(GetAttackTime(attType))/1000.0f;
/* difference in AP between current attack power and base value from DB */
/*#######################################
// value = ((base_value * base_pct) + total_value) * total_pct
// Handle Death Knight Glyphs and Talents
// Default Owner's Stamina scale
// Default Owner's Strength scale
// Check just if owner has Ravenous Dead since it's effect is not an aura
// Then get the SpellProto and add the dummy effect value
// Ravenous Dead edits the original scale
// Glyph of the Ghoul
// Glyph of the Ghoul adds a flat value to the scale mod
//warlock's and mage's pets gain 30% of owner's intellect
/*
// hunter and warlock pets gain 40% of owner's resistance
// hunter pets gain 35% of owner's armor value, warlock pets gain 100% of owner's armor
// imp's attack power
//hunter pets benefit from owner's attack power
//Hunter contribution modifier
//ghouls benefit from deathknight's attack power (may be summon pet or not)
//wolf benefit from shaman's attack power
// Glyph of Feral Spirit
//demons benefit from warlocks shadow or fire damage
//water elementals benefit from mage's frost damage
//in BASE_VALUE of UNIT_MOD_ATTACK_POWER for creatures we store data of meleeattackpower field in DB
//UNIT_FIELD_(RANGED)_ATTACK_POWER field
//UNIT_FIELD_(RANGED)_ATTACK_POWER_MULTIPLIER field
//automatically update weapon damage after attack power modification
//force of nature
//greater fire elemental
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// MOVE_WALK
// MOVE_RUN
// MOVE_RUN_BACK
// MOVE_SWIM
// MOVE_SWIM_BACK
// MOVE_TURN_RATE
// MOVE_FLIGHT
// MOVE_FLIGHT_BACK
// MOVE_PITCH_RATE
// MOVE_WALK
// MOVE_RUN
// MOVE_RUN_BACK
// MOVE_SWIM
// MOVE_SWIM_BACK
// MOVE_TURN_RATE
// MOVE_FLIGHT
// MOVE_FLIGHT_BACK
// MOVE_PITCH_RATE
// Used for prepare can/can`t triggr aura
// Define can trigger auras
// Define can't trigger auras (need for disable second trigger)
// Triggered always, even from triggered spells
// Prepare lists
// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
// implement 50% base damage from offhand
// remove aurastates allowing special moves
////////////////////////////////////////////////////////////
// Methods of class GlobalCooldownMgr
////////////////////////////////////////////////////////////
// Methods of class Unit
// set current spells as deletable
// WARNING! Order of execution here is important, do not change.
// Spells must be processed with event system BEFORE they go to _UpdateSpells.
// Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
// If this is set during update SetCantProc(false) call is missing somewhere in the code
// Having this would prevent spells from being proced, so let's crash
// update combat timer only for players and pets (only pets with PetAI)
// Check UNIT_STATE_MELEE_ATTACKING or UNIT_STATE_CHASE (without UNIT_STATE_FOLLOW in this case) so pets can reach far away
// targets without stopping half way there and running off.
// These flags are reset after target dies or another command is given.
// m_CombatTimer set at aura start and it will be freeze until aura removing
// not implemented before 3.0.2
// update abilities available only for fraction of time
// sometimes bugged for players
// caster is friendly to Aura caster => No restrictions
// caster has some aura that target not
// target has some aura that caster not
//Avoid self interrupt of channeled Crowd Control spells like Seduction
//Avoid self interrupt of channeled Crowd Control spells like Seduction
// Hook for OnDamage Event
// Signal to pets that their owner was attacked
// Signal the pet it was attacked so the AI can respond if needed
// interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
// We're going to call functions which can modify content of the list during iteration over it's elements
// Let's copy the list so we can prevent iterator invalidation
// copy damage to casters of this aura
// Check if aura was removed during iteration - we don't need to work on such auras
// check damage school mask
/// @todo check packets if damage is done by victim, or by attacker of victim
// Rage from Damage made (only from direct weapon damage)
// Rage from absorbed damage
// duel ends when player has 1 or less hp
// prevent kill only if killed in duel and killed by opponent or opponent controlled creature
// prevent kill only if killed in duel and killed by opponent or opponent controlled creature
// in bg, count dmg if victim is also a player
// victim is a player
// random durability for items (HIT TAKEN)
// Rage from damage received
// random durability for items (HIT DONE)
// does not support creature push_back
// last damage from duel opponent
// In this case victim==mount
// beg
/// @todo this is a workaround - not needed anymore, but required for some scripts :(
/*= TRIGGER_NONE*/, Item* castItem /*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)
/*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)
// Obsolete func need remove, here only for comotability vs another patches
// Per-school calc
// Melee and Ranged Spells
// Physical Damage
// Get blocked status
// Calculate crit bonus
// Apply crit_damage bonus for melee spells
// Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
// Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS
// Spell weapon based damage CAN BE crit & blocked at same time
// double blocked amount if block is critical
// double blocked percent
// Magical Attacks
// If crit add critical bonus
// Script Hook For CalculateSpellDamageTaken -- Allow scripts to change the Damage post class mitigation calculations
// Calculate absorb resist
// Call default DealDamage
/// @todo for melee need create structure as in
// Select HitInfo/procAttacker/procVictim flag based on attack type
// Physical Immune check
// Add melee damage bonus
// Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
// Calculate armor reduction
// Crit bonus calc
// Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
// Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS
// 30% damage blocked, double blocked amount if block is critical
// 150% normal damage
// Always apply HITINFO_AFFECTS_VICTIM in case its not a miss
// Calculate absorb resist
// Calculate absorb & resists
// Impossible get negative result but....
// Hmmmm dont like this emotes client must by self do all animations
// Get attack timers
// Reduce attack time
// Call default DealDamage
// If this is a creature and it attacks from behind it has a probability to daze it's victim
// -probability is between 0% and 40%
// 20% base chance
// there is a newbie protection, at level 10 just 7% base chance; assuming linear function
// Do effect if any damage done to target
// We're going to call functions which can modify content of the list during iteration over it's elements
// Let's copy the list so we can prevent iterator invalidation
// Damage shield can be resisted...
// ...or immuned
// No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that
/// @todo Move this to a packet handler
// Damage
// Overkill
// FIX ME: Send resisted damage, both fully resisted and partly resisted
// only physical spells damage gets reduced by armor
// there are spells with no specific attribute but they have "ignores armor" in tooltip
// bleeding effects are not reduced by armor
/*attackType*/)
// bypass enemy armor by SPELL_AURA_BYPASS_ARMOR_FOR_CASTER
// Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura
// Magic damage, check for resists
// Ignore spells that can't be resisted
// Resistance can't be lower then 0
/*= NULL*/)
// Ignore Absorption Auras
// We're going to call functions which can modify content of the list during iteration over it's elements
// Let's copy the list so we can prevent iterator invalidation
// absorb without mana cost
// Check if aura was removed during iteration - we don't need to work on such auras
// get amount which can be still absorbed by the aura
// aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety
// Apply absorb mod auras
// absorb must be smaller than the damage itself
// Check if our aura is using amount to count damage
// Reduce shield amount
// Aura cannot absorb anything more - remove it
// absorb by mana cost
// Check if aura was removed during iteration - we don't need to work on such auras
// check damage school mask
// get amount which can be still absorbed by the aura
// aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety
// absorb must be smaller than the damage itself
// lower absorb amount by talents
// take case when mana has ended up into account
// Check if our aura is using amount to count damage
// split damage auras - only when not damaging self
// We're going to call functions which can modify content of the list during iteration over it's elements
// Let's copy the list so we can prevent iterator invalidation
// Check if aura was removed during iteration - we don't need to work on such auras
// check damage school mask
// Damage can be splitted only if aura has an alive caster
// absorb must be smaller than the damage itself
// Need remove expired auras after
// absorb without mana cost
// Max Amount can be absorbed by this aura
// Found empty aura (impossible but..)
// currentAbsorb - damage can be absorbed by shield
// If need absorb less damage
// Reduce shield amount
// Need remove it later
// Remove all expired absorb auras
// ignore ranged case
// melee attack spell casted at main hand attack only - no normal melee dmg dealt
// attack can be redirected to another target
// Send log damage message to client
//TriggerAurasProcOnEvent(damageInfo);
// This is only wrapper
// Miss chance based on melee
//float miss_chance = MeleeMissChanceCalc(victim, attType);
// Critical hit chance
// stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)
// Useful if want to specify crit & miss chances for melee, else it could be removed
// bonus from skills is 0.04%
// always crit against a sitting target (except 0 crit chance)
// Dodge chance
// only players can't dodge if attacker is behind
// Reduce dodge chance by attacker expertise rating
// Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
// check if unit _can_ dodge
// parry & block chances
// check if attack comes from behind, nobody can parry or block if attacker is behind
// Reduce parry chance by attacker expertise rating
// check if unit _can_ parry
// check if unit _can_ block
// Critical chance
// Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
// cap possible value (with bonuses > max skill)
// mobs can score crushing blows if they're 4 or more levels above victim
// can be from by creature (if can) or from controlled player that considered as creature
// when their weapon skill is 15 or more above victim's defense skill
// tmp = mob's level * 5 - player's current defense skill
// add 2% chance per lacking skill point, min. is 15%
// Just for good manner
/*attackType*/)
// These spells can't be blocked
// Check creatures flags_extra for disable block
// Melee based spells hit result calculations
// Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore
// resist and deflect chances
// Check damage class instead of attack type to correctly handle judgements
// - they are meele, but can't be dodged/parried/deflected because of ranged dmg class
// Roll miss
// Chance resist mechanic (select max value from every mechanic spell effect)
// Get effects mechanic and chance
// Roll chance
// Same spells cannot be parry/dodge
// Chance resist mechanic
// Ranged attacks can only miss, resist and deflect
// only if in front
// Check for attack from behind
// Can`t dodge from behind in PvP (but its possible in PvE)
// Can`t parry or block
// Only deterrence as of 3.3.5
// Check creatures flags_extra for disable parry
// Check creatures flags_extra for disable block
// Ignore combat result aura
// Roll dodge
// Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
// Reduce dodge chance by attacker expertise rating
// Roll parry
// Reduce parry chance by attacker expertise rating
/// @todo need use unit spell resistances in calculations
// Can`t miss on dead target (on skinning for example)
// PvP - PvE spell misschances per leveldif > 2
// Base hit chance from attacker and victim levels
// Spellmod from SPELLMOD_RESIST_MISS_CHANCE
// Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will ignore target's avoidance effects
// Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
// Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
// Chance resist mechanic (select max value from every mechanic spell effect)
// Roll chance
// cast by caster in front of victim
// Calculate spell hit result can be:
// Every spell can: Evade/Immune/Reflect/Sucesful hit
// For melee based spells:
//   Miss
//   Dodge
//   Parry
// For spells
//   Resist
// Check for immune
// All positive spells can`t miss
/// @todo client not show miss log for this spells - so need find info for this in dbc and use it!
// prevent from affecting enemy by "positive" spell
// Check for immune
// Return evade for units in evade mode
// Try victim reflect spell
// Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
// is player but has no block ability or no not broken shield equipped
// Just for good manner
// flat aura mods
// remove finished spells from current pointers
// remove pointer
// m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
// need shift to next for allow update if need into aura update
// remove expired auras - do that after updates(used in scripts?)
// check "realtime" interrupts
// don't cancel spells which are affected by a SPELL_AURA_CAST_WHILE_WALKING effect
// cancel wand shoot
// apply delay (Auto Shot (spellID 75) not affected)
// castroutine
// Check if able to cast
// we want to shoot
// all went good, reset attack
// NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells
// avoid breaking self
// break same type spell if it is not delayed
// special breakage effects:
// generic spells always break channeled not delayed spells
// autorepeat breaking
// break autorepeat if not Auto Shot
// channel spells always break generic non-delayed and any channeled spells
// it also does break autorepeat if not Auto Shot
// only Auto Shoot does not break anything
// generic autorepeats break generic non-delayed and channeled non-delayed spells
// special action: set first cast flag
// other spell types don't break anything now
// current spell (if it is still here) may be safely deleted now
// set new current spell
//SF_LOG_DEBUG("entities.unit", "Interrupt spell for unit %u.", GetEntry());
// for example, do not let self-stun aura interrupt itself
// send autorepeat cancel message for autorepeat spells
/*= true*/)
// We don't do loop here to explicitly show that melee spell is excluded.
// Maybe later some special spells will be excluded too.
// if skipInstant then instant spells shouldn't count as being casted
// generic spells are casted when they are not finished and not delayed
// channeled spells may be delayed, but they are still considered casted
// autorepeat spells may be finished or delayed, but they are still considered casted
// generic spells are interrupted if they are not finished or delayed
// autorepeat spells are interrupted if they are not finished or delayed
// channeled spells are interrupted if they are not finished, even if they are delayed
/*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/)
// Check if these can stack anyway
// passive and Incanter's Absorption and auras with different type can stack with themselves any number of times
// check if cast item changed
// find current aura from spell and change it's stackamount, or refresh it's duration
// effect masks do not match
// extremely rare case
// let's just recreate aura
// update basepoints with new values - effect amount will be recalculated in ModStackAmount
// correct cast item guid if needed
// try to increase stack amount
/* @HACK: Player is not in world during loading auras.
// register single target aura
// remove other single target auras
// creates aura application instance and registers it in lists
// aura application effects are handled separately to prevent aura list corruption
// can't apply aura on unit which is going to be deleted - to not create a memory leak
// aura musn't be removed
// aura mustn't be already applied on target
// ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
// handles effects of aura application
// should be done after registering aura in lists
// Update target aura state flag
// Sitdown on apply aura req seated
// apply effects of the aura
// removes aura application from lists and unapplies effects
// dead loop is killing the server probably
// Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove
// Get mask of all aurastates from remaining auras
// remove effects of the spell - needs to be done after removing aura from lists
// all effect mustn't be applied
// Remove totem at next update if totem loses its aura
// Remove aurastates only if were not found
// only way correctly remove all auras from list
//if (removedAuras != m_removedAurasCount) new aura may be added
// aura can be removed from unit only if it's applied on it, shouldn't happen
// passive spell special case (only non stackable with ranks)
// All aura base removes should go threw this function!
// if unit currently update aura list then make safe update iterator shift to next
// Unregister single target aura
// Do not remove aura which is already being removed
// Remove aura - for Area and Target auras
// we've special situation here, RemoveAura called while during aura removal
// this kind of call is needed only when aura effect removal handler
// or event triggered by it expects to remove
// not yet removed effects of an aura
// remove remaining effects of an aura
// no need to remove
/*= 1*/)
// Call OnDispel hook on AuraScript
// Call AfterDispel hook on AuraScript
// Cast duration to unsigned to prevent permanent aura's such as Righteous Fury being permanently added to caster
// single target state must be removed before aura creation to preserve existing single target aura
// created aura must not be single target aura,, so stealer won't loose it on recast
// bring back single target aura status to the old aura
// FIXME: using aura->GetMaxDuration() maybe not blizzlike but it fixes stealing of spells like Innervate
// single target auras from other casters
// single target auras at other targets
// interrupt auras
// interrupt channeled spell
// make sure that all area auras not applied on self are removed - prevent access to deleted pointer later
// things linked on aura remove may apply new area aura - so start from the beginning
// remove area auras owned by others
// this may be a dead loop if some events on aura remove will continiously apply aura on remove
// we want to have all auras removed, so use your brain when linking events
// in join, remove positive buffs, on end, remove negative
// used to remove positive visible auras in arenas
// don't remove stances, shadowform, pally/hunter auras
// don't remove passive auras
// not negative death persistent auras
// used just after dieing to remove all visible auras
// and disable the mods for the passive ones
// update for out of range group members (on 1 slot use)
// we should not be able to dispel diseases if the target is affected by unholy blight
// don't try to remove passive auras
// do not remove positive auras if friendly target
//               negative auras if non-friendly target
// The charges / stack amounts don't count towards the total number of auras that can be dispelled.
// Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
// Polymorph instead of 1 / (5 + 1) -> 16%.
// Frost Fever and Blood Plague
// Crypt Fever and Ebon Plague
// Get auras with disease dispel type by caster
// Get auras by caster
// Check if the Aura Effect has a the Same Effect Stack Rule and if so, use the highest amount of that SpellGroup
// If the Aura Effect does not have this Stack Rule, it returns false so we can add to the multiplier as usual
// Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier
// Need disable spell use for owner
// note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
// GO created by some spell
// Need activate spell use for owner
// note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
// remove references to unit
// we guess size
// Unk
// Unk
// HasPowerData
// No floats
// Not much to do if no flags are set.
// Now go on with a victim's events'n'auras
// Not much to do if no flags are set or there is no victim
// SpellPeriodicAuraLogInfo
// PeriodicAuraLogEffectDebugInfo
// overkill
// amount
// resist
// absorb
// power
// auraId
// for (PeriodicAuraLogEffectDebugInfo : DebugInfo)
// debuginfo
// debuginfo { float, float }
// bool - log format: 0-default, 1-debug
// bool - log format: 0-default, 1-debug
// we guess size
// Needs to be flushed because data.wpos() wouldnt return the correct placeholder
// Placeholder
// Full damage
// Overkill
// Sub damage count
// School of sub damage
// sub damage
// Sub Damage
// Absorb
// Resist
// Unknown attackerstate
// Melee spellid
//! Probably used for debugging purposes, as it is not known to appear on retail servers
// Blizz - Weird and Lazy people....
/*SwingType*/, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
/*damage*/, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 /*procEx*/, uint32 cooldown)
// Get triggered aura spell info
// Get effect index used for the proc
// Power amount required to proc the spell
// Power type required to proc
// Set trigger spell id, target, custom basepoints
/* Try handle unknown trigger spells or with invalid power amount or misc value
// All ok. Check current trigger spell
// Not cast unknown spell
// SF_LOG_ERROR("Unit::HandleAuraProcOnPowerAmount: Spell %u have 0 in EffectTriggered[%d], not handled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
// not allow proc extra attack spell at extra attack
// Custom requirements (not listed in procEx) Warning! damage dealing after this
// Custom triggered spells
// Eclipse Mastery Driver Passive
// Do not proc if proc spell isnt starfire and starsurge
// Do not proc if proc spell isnt wrath and starsurge
// try detect target manually if not set
//victim may be NULL
// for random trigger, will be one of the triggered spell to avoid repeatable triggers
// otherwise, it's the triggered_spell_id by default
// Unstable Power
// Need remove one 24659 aura
// Restless Strength
// Need remove one 24662 aura
// Mark of Malice
// Cast finish spell at last charge
// Twisted Reflection (boss spell)
// Vampiric Aura (boss spell)
// 300%
// Aura of Madness (Darkmoon Card: Madness trinket)
//=====================================================
// 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)
// 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)
// 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)
// 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)
// 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)
// 41005 Manic: +35 haste (spell, melee and ranged) (All classes)
// 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)
// 41011 Martyr Complex: +35 stamina (All classes)
// 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
// 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
// Select class defined buff
// 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
// 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
// 39511, 40997, 40998, 41002, 41005, 41011
// 39511, 40997, 40998, 41002, 41005, 41011
// 40999, 41002, 41005, 41009, 41011, 41406, 41409
// 40999, 41002, 41005, 41009, 41011, 41406, 41409
// 40999, 41002, 41005, 41009, 41011, 41406, 41409
// 40999, 41002, 41005, 41009, 41011, 41406, 41409
// 40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409
/// @todo It should be moved to database, shouldn't it?
// Sunwell Exalted Caster Neck (??? neck)
// cast ??? Light's Wrath if Exalted by Aldor
// cast ??? Arcane Bolt if Exalted by Scryers
// old unused version
// Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)
// cast 45479 Light's Wrath if Exalted by Aldor
// cast 45429 Arcane Bolt if Exalted by Scryers
// Get Aldor reputation rank
// Get Scryers reputation rank
// triggered at positive/self casts also, current attack target used then
// Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)
// cast 45480 Light's Strength if Exalted by Aldor
// cast 45428 Arcane Strike if Exalted by Scryers
// Get Aldor reputation rank
// Get Scryers reputation rank
// Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)
// cast 45431 Arcane Insight if Exalted by Aldor
// cast 45432 Light's Ward if Exalted by Scryers
// Get Aldor reputation rank
// Get Scryers reputation rank
// Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)
// cast 45478 Light's Salvation if Exalted by Aldor
// cast 45430 Arcane Surge if Exalted by Scryers
// Get Aldor reputation rank
// Get Scryers reputation rank
// Kill command
// Remove aura stack from pet
// reduce the owner's aura stack
// Vampiric Touch (generic, used by some boss)
// Shadowfiend Death (Gain mana if pet dies with Glyph of Shadowfiend)
// Glyph of Shadowfiend (need cast as self cast for owner, no hidden cooldown)
// Divine purpose
// Roll chane
// Remove any stun effect on target
// Purified Shard of the Scale - Onyxia 10 Caster Trinket
// Shiny Shard of the Scale - Onyxia 25 Caster Trinket
// Deathbringer's Will Normal
// shouldn't happen
// Deathbringer's Will Heroic
// shouldn't happen
// Boom aura (321 Boombot)
// Scrapbot
// Achievement criteria marker
// Enter vehicle XT-002 (Scrapbot)
// Todo: Check if this amount is blizzlike
// Hot Streak & Improved Hot Streak
// Count spell criticals in a row in second aura
// not enough or Hot Streak spell
// Crititcal counted -> roll chance
// Incanter's Regalia set (add trigger chance to Mana Shield)
// Seed of Corruption
// if damage is more than need or target die from damage deal finish spell
// remember caster before aura delete
// Remove aura (before cast for prevent infinite loop handlers)
// Cast finish spell (triggeredByAura already not exist!)
// no hidden cooldown
// Damage counting
// Seed of Corruption (Mobs cast) - no die req
// if damage is more than need deal finish spell
// remember caster before aura delete
// Remove aura (before cast for prevent infinite loop handlers)
// Cast finish spell (triggeredByAura already not exist!)
// no hidden cooldown
// Damage counting
// Shadowflame (Voidheart Raiment set bonus)
// Pet Healing (Corruptor Raiment or Rift Stalker Armor)
// heal amount
// Shadowflame Hellfire (Voidheart Raiment set bonus)
// Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)
// Shadow Word: Pain
// Renew
// Oracle Healing Bonus ("Garments of the Oracle" set)
// heal amount
// Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set
// heal amount
// Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)
// Priest T10 Healer 2P Bonus
// Flash Heal
// Glyph of Bloodletting
// try to find spell Rip on the target
// Rip's max duration, note: spells which modifies Rip's duration also counted
// just Rip's max duration without other spells
// add possible auras' and Glyph of Shred's max duration
// Glyph of Bloodletting        -> +6 seconds
// Rip Duration/Lacerate Damage -> +4 seconds
// if min < max -> that means caster didn't cast 3 shred yet
// so set Rip's duration and max duration
// if not found Rip
// Leader of the Pack
// Regenerate 4% mana
// Healing Touch (Dreamwalker Raiment set)
// mana back
// Healing Touch Refund (Idol of Longevity trinket)
// Mana Restore (Malorne Raiment set / Malorne Regalia set)
// Druid Tier 6 Trinket
// Starfire
// Rejuvenation
// Mangle (Bear) and Mangle (Cat)
// Item - Druid T10 Balance 4P Bonus
// Wrath & Starfire
// Add remaining ticks to damage done
// Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
// Proc only from normal Rejuvenation
// Judgements of the Wise
// Sacred Shield
// Item - Paladin T8 Holy 4P Bonus
// Holy Power (Redemption Armor set)
// Set class defined buff
// Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
// Increases the friendly target's spell damage and healing by up to $s1 for $d.
// Increases the friendly target's attack power by $s1 for $d.
// Increases the friendly target's armor
// effect 2 used by seal unleashing code
// At melee attack or Hammer of the Righteous spell damage considered as melee attack
// spells with SPELL_DAMAGE_CLASS_MELEE excluding Judgements
// On target with 5 stacks of Censure direct damage is done
// Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)
// Flash of light/Holy light
// Judgement (any)
// Item - Paladin T8 Holy 2P Bonus
// Tiny Abomination in a Jar
// Tiny Abomination in a Jar (Heroic)
// default main hand attack
// roll if offhand
// Item - Icecrown 25 Normal Dagger Proc
// Item - Icecrown 25 Heroic Dagger Proc
// Totemic Power (The Earthshatterer set)
// Set class defined buff
// Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
// Increases the friendly target's spell damage and healing by up to $s1 for $d.
// Increases the friendly target's attack power by $s1 for $d.
// Increases the friendly target's armor
// Lesser Healing Wave (Totem of Flowing Water Relic)
// Windfury Weapon (Passive) 1-8 Ranks
// custom cooldown processing case
// Now compute real proc chance...
// Now amount of extra power stored in 1 effect of Enchant spell
// Value gained from additional AP
// apply cooldown before cast to prevent processing itself
// Attack Twice
// Shaman Tier 6 Trinket
// Lightning Bolt
// Lesser Healing Wave
// Stormstrike
// Spirit Hunt
// Cast on owner
// Cast on spirit wolf
// Shaman T8 Elemental 4P Bonus
// Electrified
// Shaman T9 Elemental 4P Bonus
// Lava Burst
// Item - Shaman T10 Restoration 4P Bonus
// Chain Heal
// Add remaining ticks to healing done
// Item - Shaman T10 Elemental 2P Bonus
// Lightning Bolt & Chain Lightning
// Item - Shaman T10 Elemental 4P Bonus
// try to find spell Flame Shock on the target
// is it blizzlike to change max duration for FS?
// if not found Flame Shock
// Frozen Power
// Flametongue Weapon (Passive)
// 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%
// Enchant on Off-Hand and ready?
// Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed
// Enchant on Main-Hand and ready?
// Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed
// If not ready, we should  return, shouldn't we?!
// Static Shock
// Lightning Shield
// custom cooldown processing case
// Blood-Caked Blade
// Dancing Rune Weapon
// 1 dummy aura for dismiss rune blade
// Find Rune Weapon
// Unholy Blight
//Glyph of Unholy Blight
// Threat of Thassarian
// Must Dual Wield
// Chance as basepoints for dummy aura
// Obliterate
// Frost Strike
// Plague Strike
// Death Strike
// Rune Strike
// Blood Strike
// Runic Power Back on Snare/Root
// only for spells and hit/crit (trigger start always) and not start from self casted spells
// Need snare or root mechanic
// Guard Dog
// Silverback
// if not handled by custom case, get triggered spell from dummySpell proto
// processed charge only counting case
/*
// Used in case when access to whole aura is needed
// All procs should be handled like this...
/*damage*/, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown, bool * handled)
// Nevermelting Ice Crystal
// Gaseous Bloat
// Ball of Flames Proc
// Discerning Eye of the Beast
// 59914 already has correct basepoints in DBC, no need for custom bp
// Swift Hand of Justice
// Judgements of the Just
// Glyph of Divinity
// Check if we are the target and prevent mana gain
// Lookup base amount mana restore
// value multiplied by 2 because you should get twice amount
// Empowered Fire
// Blood of the North
// Reaping
// Death Rune Mastery
/// @todo move those to spell scripts
// Convert recently used Blood Rune to Death Rune
// can't proc from death rune use
// Reset amplitude - set death rune remove timer to 30s
// Mark aura as used
// Bone Shield cooldown
// Item - Warrior T10 Protection 4P Bonus
// Recklessness
//! Possible hack alert
//! Don't drop charges on proc, they will be dropped on SpellMod removal
//! Before this change, it was dropping two charges per attack, one in ProcDamageAndSpellFor, and one in RemoveSpellMods.
//! The reason of this behaviour is Recklessness having three auras, 2 of them can not proc (isTriggeredAura array) but the other one can, making the whole spell proc.
// Get triggered aura spell info
// Basepoints of trigger aura
// Set trigger spell id, target, custom basepoints
// Try handle unknown trigger spells
// Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
// Pct value stored in dummy
// Darkmoon Card: Greatness
// strength
// agility
// intellect
// spirit
// Blood Reserve
// Death's Choice, Item - Coliseum 25 Normal Melee Trinket
// strength
// agility
// Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket
// strength
// agility
// Mana Drain Trigger
// On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
// Evasive Maneuvers
// Remove a Evasive Charge
// Druid Forms Trinket
// Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)
// Piercing Shots
// Rank 1
// Rank 2
// Rank 3
// Item - Hunter T9 4P Bonus
// Soul Preserver
// Lightning Capacitor
// Thunder Capacitor
// Item - Coliseum 25 Normal Caster Trinket
// Item - Coliseum 25 Heroic Caster Trinket
// Item - Death Knight T10 Melee 4P Bonus
// Rogue T10 2P bonus, should only proc on caster
// All ok. Check current trigger spell
// Don't cast unknown spell
// SF_LOG_ERROR("entities.unit", "Unit::HandleProcTriggerSpell: Spell %u has 0 in EffectTriggered[%d]. Unhandled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
// not allow proc extra attack spell at extra attack
// Custom requirements (not listed in procEx) Warning! damage dealing after this
// Custom triggered spells
// Deep Wounds
// now compute approximate weapon damage by formula from wowwiki.com
// dunno if it's really needed but will prevent any possible crashes
// Persistent Shield (Scarab Brooch trinket)
// This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
// Unyielding Knights (item exploit 29108\29109)
// Proc only if your target is Grillok
// Deflection
// Cheat Death
// When your health drops below 20%
// Greater Heal Refund (Avatar Raiment set)
// Doesn't proc if target already has full health
// If your Greater Heal brings the target to full health, you gain $37595s1 mana.
// Bonus Healing (Crystal Spire of Karabor mace)
// If your target is below $s1% health
// Decimation
// Can proc only if target has hp below 25%
// Deathbringer Saurfang - Blood Beast's Blood Link
// Professor Putricide - Ooze Spell Tank Protection
// EffectImplicitTarget is self
// Evasive Maneuvers (Commendation of Kael`thas trinket)
// Item - Icecrown 25 Normal Tank Trinket 1
// Item - Icecrown 25 Heroic Tank Trinket 1
// Item - Chamber of Aspects 25 Normal Tank Trinket
// Item - Chamber of Aspects 25 Heroic Tank Trinket
// Procs only if damage takes health below $s1%
// Custom basepoints/target for exist spell
// dummy basepoints or other customs
// Auras which should proc on area aura source (caster in this case):
// Cast positive spell on enemy target
// Curse of Mending
// Curse of Mending
// Temptation
// Improved Lay on Hands (cast on target)
// Finish movies that add combo
// Seal Fate (Netherblade set)
// Ruthlessness
// Need add combopoint AFTER finish movie (or they dropped in finish phase)
// Item - Druid T10 Balance 2P Bonus
// Enlightenment (trigger only from mana cost spells)
// Slam! (Bloodsurge proc)
// Sudden Death
// Item - Warrior T10 Melee 4P Bonus
// Extra Charge!
// Slam GCD Reduced
// Execute GCD Reduced
// Maelstrom Weapon
// has rank dependant proc chance, ignore too often cases
// PPM = 2.5 * (rank of talent),
// 5 rank -> 100% 4 rank -> 80% and etc from full rate
// Item - Shaman T10 Enhancement 4P Bonus
// Glyph of Death's Embrace
// Proc only from healing part of Death Coil. Check is essential as all Death Coil spells have 0x2000 mask in SpellFamilyFlags
// Savage Defense
// Body and Soul
// Proc only from PW:S cast
// Culling the Herd
// check if we're doing a critical hit
// check if we're procced by Claw, Bite or Smack (need to use the spell icon ID to detect it)
// try detect target manually if not set
/*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 cooldown)
// Dreamwalker Raiment 2 pieces bonus
// Chance 50%
// Dreamwalker Raiment 6 pieces bonus
// Blessing of the Claw
// not processed
// standard non-dummy case
// prevent repeating spam same faction problem
// function based on function Unit::UnitReaction from 13850 client
// always friendly to self
// always friendly to charmer or owner
// always friendly to other unit controlled by player, or to the player himself
// duel - always hostile to opponent
// same group - checks dependant only on our faction - skip FFA_PVP for example
// return true to allow config option AllowTwoSide.Interaction.Group to work
// however client seems to allow mixed group parties, because in 13850 client it works like:
// return GetFactionReactionTo(GetFactionTemplateEntry(), target);
// check FFA_PVP
// check contested flags
// if faction has reputation, hostile state depends only from AtWar state
// do checks dependant only on our faction
// always neutral when no template entry found
// check contested flags
// CvP case - check reputation, don't allow state higher than neutral when at war
// common faction based check
// neutral by default
// If someone wants to help, who to give them
// dead units can neither attack nor be attacked
// player cannot attack in mount state
// nobody can attack GM in GM-mode
// remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
// switch to melee attack from ranged/magic
// switch target
// Set our target
// set position before any AI calls/assistance
//if (GetTypeId() == TYPEID_UNIT)
//    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
// should not let player enter combat by right clicking target - doesn't helps
// delay offhand weapon attack to next attack time
// Let the pet know we've started attacking someting. Handles melee attacks only
// Spells such as auto-shot and others handled in WorldSession::HandleCastSpellOpcode
// Clear our target
// reset only at real combat stop
// melee and ranged forced attack cancel
// enrage aura state triggering continues auras
// Check per caster aura state
// If aura with aurastate by caster not found return false
// Update owner dependent fields
// if player cannot see this unit yet, he will receive needed data with create object
// Can only have one pet. If a new one is summoned, dismiss the old one.
// remove existing minion pet
// PvP, FFAPvP
// FIXME: hack, speed must be set only at follow
// Ghoul pets have energy instead of mana (is anywhere better place for this code?)
// Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again
// All summoned by totem minions must disappear when it is removed.
// Remove infinity cooldown
//if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
// Check if there is another minion
// do not use this check, creature do not have charm guid
//if (GetCharmGUID() == (*itr)->GetGUID())
//ASSERT((*itr)->GetOwnerGUID() == GetGUID());
// show another pet bar if there is no charm bar
// minion, actually
// minion, actually
// i think this is safe because i have never heard that a despawned minion will trigger a same minion
/// @todo maybe we can use this flag to check if controlled by player
// PvP, FFAPvP
// Hook for OnHeal Event
// use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)
// Patch 1.2 notes: Spell Reflection no longer reflects abilities
/// @todo handle this charge drop by proc in cast phase on explicit target
// Sequence: charmed, pet, other guardians
// possessed pet and vehicle
// Should we enable this also for charmed units?
// When there is no group check pet presence
// We are pet now, return owner
// No pet, no group, nothing to return
// We are owner now, return pet
// reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)
// IsHostileTo check duel and controlled by enemy
// Push player's pet to vector
// only called in Player::SetSeer
// so move it to Player?
// only called in Player::SetSeer
/*+ SpellCastLogData.size()*/);
// Absorbed
// OverHeal
// SpellID
// Health
// Crit
// SpellCastLogData 
//if (SpellCastLogData ) Write 21Bits
// CritRollMade
// CritRollNeeded
//if (SpellCastLogData )
//if (88) Float CritRollNeeded
//if (72) Float CritRollMade
// calculate heal absorb and reduce healing
//bool hasPower = false;
// hasPower
//if (hasPower)
//    data.WriteBits(count, 21);
/*if (hasPower)
// needs to be called after sending spell log
// Some spells don't benefit from done mods
// small exception for Deep Wounds, can't find any general rule
// should ignore ALL damage mods, they already calculated in trigger spell
// Deep Wounds
// For totems get damage bonus from owner
// Done total percent damage auras
// Pet damage?
// Some spells don't benefit from pct done mods
//prevent apply mods from weapon specific case to non weapon specific spells (Example: thunder clap and two-handed weapon specialization)
// Add flat bonus from spell damage versus
// bonus against aurastate
// Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
// done scripted mod (take it from owner)
// Molten Fury
// Death's Embrace damage effect
// Health at 25% or less (25% stored at effect 2 of the spell)
// Death's Embrace heal effect
// Soul Siphon
// effect 1 m_amount
// effect 0 m_amount
// count affliction effects and calc additional damage in percentage
// Starfire Bonus
// Increased Shock Damage
// Increased Lightning Damage
// Improved Moonfire
// Increased Lightning Damage
// Improved Consecration / Libram of Resurgence
// Idol of the Shooting Star
// Increased Lightning Damage
// Totem of Hex
// Custom scripted damage
// Ice Lance
// Torment the weak
// Smite
// Glyph of Smite
// Fire and Brimstone
// Drain Soul - increased damage for targets under 25 % HP
// Shadow Bite (30% increase from each dot)
// Done fixed damage bonus auras
// Pets just add their bonus damage to their spell damage
// note that their spell damage is just gain of their own auras
// Check for table values
// Default calculation
// apply spellmod to Done damage (flat and pct)
// get all auras from caster that allow the spell to ignore resistance (sanctified wrath)
// from positive and negative SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN
// multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
//.. taken pct: dummy auras
// Cheat Death
// From caster spells
// Mod damage from spell mechanic
// Check for table values
// Default calculation
// level penalty still applied on Taken bonus - is it blizzlike?
// -1 == any item class (not wand then)
// 0 == any inventory type (not wand then)
// Base value
// Check if we are ever using mana - PaperDollFrame.lua
// spellpower from intellect
// Damage bonus from stats
// stat used stored in miscValueB for this aura
// ... and attack power
//! Mobs can't crit with spells. Player Totems can
//! Fire Elemental (from totem) can too - but this part is a hack and needs more research
// not critting spell
// We need more spells to find a general way (if there is any)
// Earth Shield
// Lifebloom Final Bloom
// Divine Hymn
// Item - Bauble of True Blood 10m
// Item - Bauble of True Blood 25m
// For other schools
// taken
// Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
// Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
// scripted (increase crit chance ... against ... target by x%
// Shatter
// Glyph of Shadowburn
// Renewed Hope
// Custom crit by class
// Glyph of Fire Blast
// Improved Faerie Fire
// cumulative effect - don't break
// Starfire
// Improved Insect Swarm
// Shiv-applied poisons can't crit
// Flash of light
// Sacred Shield
// Exorcism
// Lava Burst
// Custom crit by class
// Rend and Tear - bonus crit chance for Ferocious Bite on bleeding targets
/// Intentional fallback. Calculate critical strike chance for both Ranged and Melee spells
// percent done
// only players use intelligence for critical chance computations
/*victim*/)
// Calculate critical bonus
// for melee based spells is 100%
/// @todo write here full calculation for melee/ranged spells
// for spells is 50%
// adds additional damage to critBonus (from talents)
/*spellProto*/, uint32 damage, Unit* /*victim*/)
// Calculate critical bonus
// For totems get healing bonus from owner (statue isn't totem in fact)
// No bonus healing for potion spells
// Healing done percent
// done scripted mod (take it from owner)
// Increased Rejuvenation Healing
// Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind
// Test of Faith
// Nourish Heal Boost
// Done fixed damage bonus auras
// Check for table values
// No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
// Default calculation
// As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
// Bonus healing does not apply to these spells
// use float as more appropriate for negative values and percent applying
// apply spellmod to Done amount
// Healing taken percent
// Tenacity increase healing % taken
// Healing Done
// Taken fixed damage bonus auras
// Nourish cast
// Rejuvenation, Regrowth, Lifebloom, or Wild Growth
// increase healing by 20%
// Check for table values
// No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
// Default calculation
// As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
// Bonus healing does not apply to these spells
// Healing bonus of spirit, intellect and strength
// Base value
// Check if we are ever using mana - PaperDollFrame.lua
// spellpower from intellect
// Healing bonus from stats
// stat used dependent from misc value (stat index)
// ... and attack power
// If m_immuneToSchool type contain this school type, IMMUNE damage.
// If m_immuneToDamage type contain magic, IMMUNE damage.
// If m_immuneToSchool type contain this school type, IMMUNE damage.
// If m_immuneToDamage type contain magic, IMMUNE damage.
// Single spell immunity.
// Spells that don't have effectMechanics.
// State/effect immunities applied by aura expect full spell immunity
// Ignore effects with mechanic, they are supposed to be checked separately
//Return immune only if the target is immune to all spell effects.
// If m_immuneToEffect type contain this effect type, IMMUNE effect.
// Check for immune to application of harmful magical effects
// Magic debuff
// Check school
// Harmful
// Done fixed damage bonus auras
// ..done
// ..done
// SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
// ..done (base at attack power for marked target and base at attack power for creature type)
// ..done (base at attack power and creature type)
// ..done (base at attack power and creature type)
// Can be negative
// Done total percent damage auras
// Some spells don't benefit from pct done mods
// bonus against aurastate
// Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
// done scripted mod (take it from owner)
// Unit* owner = GetOwner() ? GetOwner() : this;
// AuraEffectList const& mOverrideClassScript = owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
// apply spellmod to Done damage
// bonus result can be negative
// get all auras from caster that allow the spell to ignore resistance (sanctified wrath)
// ..taken
// Taken total percent damage auras
// ..taken
// .. taken pct (special attacks)
// From caster spells
// Mod damage from spell mechanic
// Shred, Maul - "Effects which increase Bleed damage also increase Shred damage"
// .. taken pct: dummy auras
// Cheat Death
// .. taken pct: class scripts
//*AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
/*AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
//{
//    switch ((*i)->GetMiscValue())
//    {
//    }
//}*/
// bonus result can be negative
// Create dispel mask by dispel type
// Dispel all existing auras vs current dispel type
// Dispel aura
// normalized proc chance for weapon attack speed
// (odd formula...)
// proc per minute chance calculation
// Apply chance modifer aura
// result is chance in percents (probability = Speed_in_sec * (PPM / 60))
// mount as a vehicle
// mounts can also have accessories
// unsummon pet
// don't unsummon pet in arena but SetFlag UNIT_FLAG_STUNNED to disable pet's interface
// dismount as a vehicle
// Remove vehicle from player
// only resummon old pet if the player is already added to a map
// this prevents adding a pet to a not created map which would otherwise cause a crash
// (it could probably happen when logging in after a previous crash)
// unknown flags, checked in 4.2.2 14545 client
// check for duel
// PetAI has special handler before AttackStart()
// only alive units can be in combat
// Set home position at place of engaging combat for escorted creatures
// unit has engaged in combat, remove immunity so players can fight back
// Player's state will be cleared in Player::UpdateContestedPvP
// set immunity state to the one from db on evade
// function based on function Unit::CanAttack from 13850 client
// can't attack self
// can't attack unattackable units or GMs
// can't attack own vehicle or passenger
// can't attack invisible (ignore stealth for aoe spells) also if the area being looked at is from a spell use the dynamic object created instead of the casting unit.
// can't attack dead
// can't attack untargetable
// check flags
// check if this is a world trigger cast - GOs are using world triggers to cast their spells, so we need to ignore their immunity flag here, this is a temp workaround, needs removal when go cast is implemented properly
// CvC case - can attack each other only when one of them is hostile
// PvP, PvC, CvP case
// can't attack friendly targets
// Not all neutral creatures can be attacked
// check duel - before sanctuary checks
// PvP case - can't attack when attacker or target are in sanctuary
// however, 13850 client doesn't allow to attack when one of the unit's has sanctuary flag and is pvp
// additional checks - only PvP case
// function based on function Unit::CanAssist from 13850 client
// can assist to self
// can't assist unattackable units or GMs
// can't assist own vehicle or passenger
// can't assist invisible
// can't assist dead
// can't assist untargetable
// can't assist non-friendly targets
// PvP case
// can't assist player which is dueling someone
// can't assist player in ffa_pvp zone from outside
// can't assist player out of sanctuary from sanctuary if has pvp enabled
// PvC case - player can assist creature only if has specific type flags
// !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) &&
// returns negative amount on power reduction
// returns negative amount on power reduction
// Always seen by owner
// Only apply debuffs
// Use on mount auras
// not sure if good for pet
// for some spells this mod is applied on vehicle owner
// Use not mount (shapeshift for example) auras (should stack)
// Update speed for vehicle if available
// now we ready for speed calculation
// Set creature speed rate
// Must check for owner or crash on "Tame Beast"
// For every yard over 5, increase speed by 0.01
//  to help prevent pet from lagging behind and despawning
// base speed is 100% of owner speed
// pets derive speed from owner when not in combat
// at this point, MOVE_WALK is never reached
// Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need
/// @todo possible affect only on MOVE_RUN
// Use speed from aura
// for creature case, we check explicit if mob searched for assistance
// best guessed value, so this will be 33% reduction. Based off initial speed, mob can then "run", "walk fast" or "walk".
// Apply strongest slow aura mod to speed
// Update speed only on change
// register forced speed changes for WorldSession::HandleForceSpeedChangeAck
// and do it only for real sent packets and use run for run/mounted as client expected
// any combo points pointed to unit lost at it death
// Exit vehicle before calling RemoveAllControlled
// vehicles use special type of charm that is not removed by the next function
// triggering an assert
// remove aurastates allowing special moves
// Only clear MotionMaster for entities that exists in world
// Avoids crashes in the following conditions :
//  * Using 'call pet' on dead pets
//  * Using 'call stabled pet'
//  * Logging in with dead pets
// without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
// do not why since in IncreaseMaxHealth currenthealth is checked
// players in instance don't have ZoneScript, but they have InstanceScript
// clear skinnable for creature and player (at battleground)
/*########################################
// only creatures can have threat list
// only alive units can have threat list
// totems can not have threat list
// vehicles can not have threat list
//if (ToCreature()->IsVehicle())
//    return false;
// summons can not have a threat list, unless they are controlled by a creature
//======================================================================
//======================================================================
// Only mobs can manage threat lists
//======================================================================
//======================================================================
//m_ThreatManager.tauntApply(taunter);
//======================================================================
// might have more taunt auras remaining
//======================================================================
// function provides main threat functionality
// next-victim-selection algorithm and evade mode are called
// threat list sorting etc.
// First checking if we have some taunt on us
// The last taunt aura caster is alive an we are happy to attack him
// We do not have last taunt aura caster but we have more taunt auras,
// so find first available target
// Auras are pushed_back, last caster will be on the end
// No taunt aura or taunt aura caster is dead standard target selection
// We have player pet probably
// Case where mob is being kited.
// Mob may not be in range to attack or may have dropped target. In any case,
//  don't evade if damage received within the last 10 seconds
// Does not apply to world bosses to prevent kiting to cities
// last case when creature must not go to evade mode:
// it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list
// for example at owner command to pet attack some far away creature
// Note: creature does not have targeted movement generator but has attacker in this case
/// @todo a vehicle may eat some mob, so mob should not evade
// search nearby enemy before enter evade mode
// enter in evade mode in other case
//======================================================================
//======================================================================
//======================================================================
// function uses real base points (typically value - 1)
// don't mod permanent auras duration
// cut duration only of negative effects
// Find total mod value (negative bonus)
// Find max mod (negative bonus)
// Check if mods applied before were weaker
// Select strongest negative mod
// there are only negative mods currently
// else positive mods here, there are no currently
// when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue
// Mixology - duration boost
// Glyphs which increase duration of selfcasted buffs
// Glyph of Thorns
// called from caster
// cooking with Chef Hat.
// If last spell was casted more than 15 seconds ago - reset the count.
// or else increase the count.
// Checking for existing in the table
// test pet/charm masters instead pets/charmeds
// Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)
// Some diminishings applies to mobs too (for example, Stun)
// Checking for existing in the table
// Remember time after last aura from group removed
/*#######################################
// value = ((base_value * base_pct) + total_value) * total_pct
// group update
// group update
// group update
// 1 update
// group update
// group update
/// This is here because hunter pets are of the warrior class.
/// With the current implementation, the core only gives them
/// POWER_RAGE, so we enforce the class to hunter so that they
/// effectively get focus power.
// cleanup
// Remove applied auras with SPELL_AURA_CONTROL_VEHICLE
// This needs to be before RemoveFromWorld to make GetCaster() return a valid pointer on aura removal
// A unit may be in removelist and not in world, but it is still in grid
// and may have some references during delete
// non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
// remove different non-standard movement generators.
// disabled AI must be primary AI
// the first 3 SpellOrActions are attack, follow and stay
// middle 4 SpellOrActions are spells/special attacks/abilities
// last 3 SpellOrActions are reactions
// charmed players don't have spells
// new spell rank can be already listed
// or use empty slot in other case
// non critical, will reset to default
// use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion
// check correctness
// List of auras that CAN be trigger but may not exist in spell_proc_event
// in most case need for drop charges
// in some types of aura need do additional check
// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
// Aura does not have charges but needs to be removed on trigger
// Aura does not have charges but needs to be removed on trigger
// Savage Defense untested
// Check victim state
// On block
// On absorb
// On crit
// Player is loaded now - do not allow passive spell casts to proc
// For melee/ranged based attack need update skills and set some Aura states if victim present
// If exist crit/parry/dodge/block need update aura state (for victim and attacker)
// for victim
// if victim and dodge attack
// Update AURA_STATE on dodge
// skip Rogue Riposte
// if victim and parry attack
// For Hunters only Counterattack (skip Mongoose bite)
// if and victim block attack
// For attacker
// Overpower on victim dodge
// Fill procTriggered list
// Do not allow auras to proc from effect triggered by itself
// Defensive procs are active on absorbs (so absorption effects are not a hindrance)
// only auras that has triggered spell should proc from fully absorbed damage
// do checks using conditions table
// AuraScript Hook
// Triggered spells not triggering additional spells
// Skip this auras
// If not trigger by default and spellProcEvent == NULL - skip
// Some spells must always trigger
// Nothing found
// Note: must SetCantProc(false) before return
// Handle effects proceed this time
// look for aura in auras list, it may be removed while proc event processing
// no more charges to use, prevent proc
// For players set spell cooldown if need
// Note: must SetCantProc(false) before return
// "handled" is needed as long as proc can be handled in multiple places
// Don`t drop charge or add cooldown for not started trigger
// target has to be valid
// this function is part of the new proc system
// Skip melee hits or instant cast spells
// Skip Melee hits and spells ws wrong school
// School check
// Skip Melee hits and targets with magnet aura
// Magnet
// Skip melee hits and spells ws wrong school or zero cost
// Cost check
// School check
// Compare mechanic
// Compare mechanic
// Compare casters
// CC Auras which use their amount amount to drop
// Are there any more auras which need this?
// chargeable mods are breaking on hit
// Spell own direct damage at apply wont break the CC
// called from spellcast, should not have ticked yet
// No damage left
//case SPELL_AURA_ADD_FLAT_MODIFIER:
//case SPELL_AURA_ADD_PCT_MODIFIER:
// HandleSpellModAuraProc
//break;
// nothing do, just charges counter
// switch (triggeredByAura->GetAuraType())
// for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
// if (!handled)
// Remove charge (aura can be removed by triggers)
// Cleanup proc requirements
// use provided list of auras which can proc
// or generate one on our own
// prepare data for self trigger
// prepare data for target trigger
///----------Pet responses methods-----------------
///----------End of Pet responses methods----------
// not need send any packets if not in world or not moving
// try to receive model from transform auras
// iterate over already applied transform auras - from newest to oldest
// prefer negative auras
// transform aura was found
// we've found shapeshift
// no auras found - set modelid to default
// recheck for safe
// remove also guid from m_ComboPointHolders;
// or remove manually
// remove current target
// remove not LoS targets
// no appropriate targets
// select random
// Not apply this to creature casted spells with casttime == 0
// -5% per additional effect
// Combined Spells with Both Over Time and Direct Damage
// mainly for DoTs which are 3500 here otherwise
// Portion to Over Time
// Area Effect Spells receive only half of bonus
// 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
// -5% of total per any additional effect
// slot not found, return
// Damage over Time spells bonus calculation
// Distribute Damage over multiple effects, reduce by AoE
// As wowwiki says: C = (Cast Time / 3.5)
// fist attack
// call MoveInLineOfSight for nearby contested guards
// call MoveInLineOfSight for nearby contested guards
// this enables pet details window (Shift+P)
//pet->InitLevelupSpellsForLevel();
// let the aura be handled by new proc system if it has new entry
// Get proc Event Entry
// Get EventProcFlag
// if exist get custom spellProcEvent->procFlags
// else get from spell proto
// Continue if no trigger exist
// Additional checks for triggered spells (ignore trap casts)
// Check spellProcEvent data requirements
// In most cases req get honor or XP from kill
// Shadow Word: Death - can trigger from every kill
// Aura added by spell can`t trigger from self (prevent drop charges/do triggers)
// But except periodic and kill triggers (can triggered from self)
// Check if current equipment allows aura to proc
// Check if player is wearing shield
// Get chance from spell
// If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
// If PPM exist calculate chance from PPM
// Apply chance modifer aura
// aura can be deleted at casts
// Currently only Prayer of Mending
// jumps
// current aura expire
// will removed at next charges decrease
// next target selection
// heal
// aura can be deleted at casts
// shiver
//animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
// shiver
// Cold Stare
// jumps
// current aura expire
// will removed at next charges decrease
// next target selection
// Prevent killing unit twice (and giving reward from kill twice)
// find player: owner of controlled `this` or `this` itself maybe
// Reward player, his pets, and group/raid members
// call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
// send event PARTY_KILL
// update creature loot recipient to the allowed looter.
// Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim
// Proc auras on death - must be before aura/combat remove
// update get killing blow achievements, must be done before setDeathState to be able to require auras on target
// and before Spirit of Redemption as it also removes auras
// if talent known but not triggered (check priest class for speedup check)
// save value before aura remove
// Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)
// restore for use at real death
// FORM_SPIRITOFREDEMPTION and related auras
// Inform pets (if any) when player kills target)
// MUST come after victim->setDeathState(JUST_DIED); or pet next target
// selection will get stuck on same target and break pet react state
// 10% durability loss on death
// clean InHateListOf
// remember victim PvP death for corpse type and corpse reclaim delay
// at original death (not at SpiritOfRedemtionTalent timeout)
// only if not player and not controlled by player pet. And not at BG
// Durability loss is calculated more accurately again for each item in Player::DurabilityLoss
// durability lost message
// Call KilledUnit for creatures
// last damage from non duel opponent or opponent controlled creature
// creature died
// Call KilledUnit for creatures, this needs to be called after the lootable flag is set
// Call creature just died function
// Dungeon specific stuff, only applies to players killing creatures
/// @todo do instance binding anyway if the charmer/owner is offline
// the reset time is set but not added to the scheduler
// until the players leave the instance
// outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
// handle player kill only if not suicide (spirit of redemption for example)
//if (victim->GetTypeId() == TYPEID_PLAYER)
//    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
//        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
// battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
// achievement stuff
// Hook for OnPVPKill Event
// SendAutoRepeatCancel ?
// SendAutoRepeatCancel ?
// Creature specific
// don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)
// prevent moving if it also has root effect
/*= false*/)
// MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)
// this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before
// setting MOVEMENTFLAG_ROOT
// caster == NULL processed in MoveFleeing
// dismount players when charmed
//if (HasUnitState(UNIT_STATE_UNATTACKABLE))
//    return false;
// Already charmed
/// @todo CombatStop(true) may cause crash (interrupt spells)
// Charmer stop charming
// Charmed stop charming
// StopCastingCharm may remove a possessed pet?
// charm is set by aura, and aura effect remove handler was called during apply handler execution
// prevent undefined behaviour
// Set charmed
// charm is set by aura, and aura effect remove handler was called during apply handler execution
// prevent undefined behaviour
// Pets already have a properly initialized CharmInfo, don't overwrite it.
// to prevent client crash
// just to enable stat window
// if charmed two demons the same session, the 2nd gets the 1st one's name
// cast can't be helped
// one aura overrides another?
//        SF_LOG_FATAL("entities.unit", "Unit::RemoveCharmedBy: this: " UI64FMTD " true charmer: " UI64FMTD " false charmer: " UI64FMTD,
//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());
//        ASSERT(false);
/// @todo CombatStop(true) may cause crash (interrupt spells)
// Creature will restore its old AI on next update
// Vehicle should not attack its passenger after he exists the seat
// If charmer still exists
// a guardian should always have charminfo
// normal creature
/*= false*/)
/*= false*/)
// IsHostileTo check duel and controlled by enemy
// player mounted on multi-passenger mount is also classified as vehicle
// Don't consider resilience if not in PvP - player or pet
// Melee based spells can be miss, parry or dodge on this step
// Crit or block - determined on damage calculation phase! (and can be both in some time)
//calculate miss chance
// Calculate hit chance
// Spellmod from SPELLMOD_RESIST_MISS_CHANCE
// Limit miss chance from 0 to 60%
// we can lost access to caster or target
// modify hostile references for new phasemask, some special cases deal with hostile references themselves
// modify threat lists for new phasemask
// merge expects sorted lists
// modify threat lists for new phasemask
// merge expects sorted lists
// call MoveInLineOfSight for nearby creatures
// Player's pet get resilience from owner
// Based on Hair color
// Violet
// Light Blue
// Green
// Light Green
// Dark Green
// White
// original - Dark Blue
// Red
// Yellow
// Blue
// Purple
// original - white
// Based on Skin color
// Male
// Brown
// Black
// yellow
// White
// original - Gray
// Female
// Brown
// Black
// yellow
// White
// original - Gray
// Based on Skin color
// Male
// White
// Completly White
// Light Brown
// Brown
// Dark
// Dark Grey
// original - Grey
// Female
// White
// Light Brown
// Brown
// Dark
// original - Grey
// Based on Hair color
// Green
// Light Green
// Dark Green
// 29415?
// Dark Blue
// White
// Light Blue
// original - Violet
// Red
// Yellow
// Purple
// White
// original - Blue
// Based on Skin color
// Male
// Brown
// Black
// Yellow
// White
// original - Gray
// Female
// Brown
// Black
// yellow
// White
// original - Gray
// Based on Skin color
// Male
// Dark (Black)
// White
// Light Brown/Grey
// Completly White
// original - Brown
// Female
// Dark (Black)
// White
// Light Brown/Grey
// Completly White
// original - Brown
//! Glyph of Arctic Wolf
// Take the alliance modelid as default
// If the player is horde but there are no values for the horde modelid - take the alliance modelid
// fire
// earth
// water
// air
// fire
// earth
// water
// air
// fire
// earth
// water
// air
// fire
// earth
// water
// air
// fire
// earth
// water
// air
// fire
// earth
// water
// air
// fire
// earth
// water
// air
//! First check simple relations from clicker to clickee
//! Check database conditions
// if (!spellEntry) should be checked at npc_spellclick load
// This can happen during Player::_LoadAuras
// Must be called only from aura handler
// Don't change if current and new seat are identical
// The second part of the check will only return true if seatId >= 0. @Vehicle::GetNextEmptySeat makes sure of that.
// Make sure there is only one ride vehicle aura on target cast by the unit changing seat
// Unit riding a vehicle must always have control vehicle aura on target
/*exitPosition*/)
//! This function can be called at upper level code to initialize an exit from the passenger's side.
//! The following call would not even be executed successfully as the
//! SPELL_AURA_CONTROL_VEHICLE unapply handler already calls _ExitVehicle without
//! specifying an exitposition. The subsequent call below would return on if (!m_vehicle).
/*_ExitVehicle(exitPosition);*/
//! To do:
//! We need to allow SPELL_AURA_CONTROL_VEHICLE unapply handlers in spellscripts
//! to specify exit coordinates and either store those per passenger, or we need to
//! init spline movement based on those coordinates in unapply handlers, and
//! relocate exiting passengers based on Unit::moveSpline data. Either way,
//! Coming Soon(TM)
/// It's possible m_vehicle is NULL, when this function is called indirectly from @VehicleJoinEvent::Abort.
/// In that case it was not possible to add the passenger to the vehicle. The vehicle aura has already been removed
/// from the target in the aforementioned function and we don't need to do anything else at this point.
// This should be done before dismiss, because there may be some aura removal
// If the player is on mounted duel and exits the mount, he should immediatly lose the duel
// SMSG_MOVE_GRAVITY_ENABLE
// SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT
// Exit position not specified
// This should use passenger's current position, leaving it as it is now
// because we calculate positions incorrect (sometimes under map)
// Creatures without inhabit type air should begin falling after exiting the vehicle
// Vehicle just died, we die too
// If for other reason we as minion are exiting the vehicle (ejected, master dismounted) - unsummon
// Approximation
/*= false*/)
/*= NULL*/)
// Fallback here
// this should be renamed
/*
// SMSG_MOVE_UPDATE_TELEPORT is sent to nearby players to signal the teleport
// SMSG_MOVE_TELEPORT is sent to self in order to trigger CMSG_MOVE_TELEPORT_ACK and update the position server side
// This oldPos actually contains the destination position if the Unit is a Player.
// Relocate the unit to its new position in order to build the packets correctly.
// Send the SMSG_MOVE_TELEPORT packet to self.
// Relocate the player/creature to its old position, so we can broadcast to nearby players correctly
// Broadcast the packet to everyone except self.
// prevent crash when a bad coord is sent by the client
// move and update visible state if need
// code block for underwater state update
//! Only server-side orientation update, does not broadcast to client
//! Only server-side height update, does not broadcast to client
// baseRage means damage taken when attacker = false
// talent who gave more rage on attack
// Calculate rage from health and damage taken
//! ToDo: Check formula
// Berserker Rage effect
// melee and ranged forced attack cancel
// resist value will never be negative here
//! At this point a new spline destination is enabled because of Unit::StopMoving()
// It makes no sense to target global orientation
// never face when already moving
/// @todo figure out under what conditions creature will move towards object instead of facing it where it currently is.
// when on transport, GetAngle will still return global coordinates (and angle) that needs transforming
///@ TODO: Find proper opcode for walk mode setting in player mind controlling a player case
/*= false*/)
/*= false */)
/*= false */)
/*= false*/)
//! No need to check height on ascent
/*
//else if (GetTypeId() == TYPEID_PLAYER)
//    valCount = PLAYER_END_NOT_SELF;
// Check per caster aura states to not enable using a spell in client if specified aura is not by target
// FIXME: Some values at server stored in float format but must be sent to client in uint32 format
// convert from float to uint32 and send
// there are some float values which may be negative or can't get negative due to other checks
// Gamemasters should be always able to select units - remove not selectable flag
// use modelid_a if not gm, _h if gm for CREATURE_FLAG_EXTRA_TRIGGER creatures
// this also applies for transform auras
// Modelid1 is a visible model for gms
// world visible trigger's model
// Modelid2 is an invisible model for players
// world invisible trigger's model
// hide lootable animation for unallowed players
// unit UNIT_DYNFLAG_TRACK_UNIT should only be sent to caster of SPELL_AURA_MOD_STALKED auras
// FG: pretend that OTHER players in own group are friendly ("blue")
// Allow targetting opposite faction in party when enabled in config
// this flag is at uint8 offset 1 !!
/*| UNIT_BYTE2_FLAG_AURAS | UNIT_BYTE2_FLAG_UNK5*/) << 8)); // this flag is at uint8 offset 1 !!
// pretend that all other HOSTILE players have own faction, to allow follow, heal, rezz (trade wont work)
// send in current format (float as float, uint32 as uint32)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Set or remove correct flags based on available seats. Will overwrite db data (if wrong).
/// @Uninstall must be called before this.
/**
// We might have aura's saved in the DB with now invalid casters - remove
// only install minions on evade mode
/**
/// @Prevent recursive uninstall call. (Bad script in OnUninstall/OnRemovePassenger/PassengerBoarded hook.)
/**
/*= false*/)
/**
// This couldn't be done in DB, because some spells have MECHANIC_NONE
// Vehicles should be immune on Knockback ...
// Mechanical units & vehicles ( which are not Bosses, they have own immunities in DB ) should be also immune on healing ( exceptions in switch below )
// Heal & dispel ...
// ... Shield & Immunity grant spells ...
// ... Resistance, Split damage, Change stats ...
// Different immunities for vehicles goes below
// code below prevents a bug with movable cannons
// Strand of the Ancients
// Wintergrasp
// Isle of Conquest
// why we need to apply this? we can simple add immunities to slow mechanic in DB
/**
/// Setting to_Abort to true will cause @VehicleJoinEvent::Abort to be executed on next @Unit::UpdateEvents call
/// This will properly "reset" the pending join process for the passenger.
/// Update vehicle pointer in every pending join event - Abort may be called after vehicle is deleted
// Passengers always cast an aura with SPELL_AURA_CONTROL_VEHICLE on the vehicle
// We just remove the aura and the unapply handler will make the target leave the vehicle.
// We don't need to iterate over Seats
// Following the above logic, this assertion should NEVER fail.
// Even in 'hacky' cases, there should at least be VEHICLE_SPELL_RIDE_HARDCODED on us.
// SeatMap::const_iterator itr;
// for (itr = Seats.begin(); itr != Seats.end(); ++itr)
//    ASSERT(!itr->second.passenger);
/**
/**
/**
// Make sure we don't loop indefinetly
/**
/// @Prevent adding accessories when vehicle is uninstalling. (Bad script in OnUninstall/OnRemovePassenger/PassengerBoarded hook.)
/// If for some reason adding accessory to vehicle fails it will unsummon in
/// @VehicleJoinEvent::Abort
/**
/// @Prevent adding passengers when vehicle is uninstalling. (Bad script in OnUninstall/OnRemovePassenger/PassengerBoarded hook.)
// The seat selection code may kick other passengers off the vehicle.
// While the validity of the following may be arguable, it is possible that when such a passenger
// exits the vehicle will dismiss. That's why the actual adding the passenger to the vehicle is scheduled
// asynchronously, so it can be cancelled easily in case the vehicle is uninstalled meanwhile.
// no specific seat requirement
// no available seat
/**
// Remove UNIT_FLAG_NOT_SELECTABLE if passenger did not have it before entering vehicle
// only for flyable vehicles
/**
// not sure that absolute position calculation is correct, it must depend on vehicle pitch angle
/**
/**
/**
/**
/**
/**
/**
/**
/**
// drop flag
// SMSG_CLIENT_CONTROL
// SMSG_BREAK_TARGET
// SMSG_MOVE_GRAVITY_DISABLE
// SMSG_FORCE_ROOT - In some cases we send SMSG_SPLINE_MOVE_ROOT here (for creatures)
// also adds MOVEMENTFLAG_ROOT
// Actually quite a redundant hook. Could just use OnAddPassenger and check for unit typemask inside script.
/**
/// Check if the Vehicle was already uninstalled, in which case all auras were removed already
/// @SPELL_AURA_CONTROL_VEHICLE auras can be applied even when the passenger is not (yet) on the vehicle.
/// When this code is triggered it means that something went wrong in @Vehicle::AddPassenger, and we should remove
/// the aura manually.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Get the event information
// if the state is conditions or nextphase, then the event should be active
// finished world events are inactive
// if inactive world event, check the prerequisite events
// if prereq not in nextphase or finished state, then can't start this one
// if not in nextphase state for long enough, can't start this one
// all prerequisite events are met
// but if there are no prerequisites, this can be only activated through gm command
// for NEXTPHASE state world events, return the delay to start the next event, so the followup event will be checked correctly
// for CONDITIONS state world events, return the length of the wait period, so if the conditions are met, this check will be called again to set the timer as NEXTPHASE event
// outdated event: we return max
// never started event, we return delay before start
// in event, we return the end of it
// we return the delay before it ends
// not in window, we return the delay before next start
// In case the end is before next check
// set to conditions phase
// add to active events
// add spawns
// check if can go to next state
// save to db
// force game event update to set the update timer if conditions were met from a command
// this update is needed to possibly start events dependent on the started one
// or to scedule another update where the next event will be started
// if finished world event, then only gm command can stop it
// reset conditions
//                                               0           1                           2                         3          4       5        6            7            8
// length>0 is validity check
//                                                       0       1        2
//                                                   0             1
//                                                 0        1
//                                                0         1
//                                                       0           1                       2                                 3                                     4
//                                               0     1      2
//                                               0     1      2
//                                                 0       1         2             3
//                                                  0          1            2             3                      4
//                                                      0           1         2
//                                                0       1        2
//                                                  0          1
/// @todo Change to uint8
//                                               0           1     2     3         4         5             6
// get the event npc flag for checking if the npc will be vendor during the event or not
// get creature entry
// check validity with event's npcflag
//                                                   0         1
//                                                               0                         1
// Id starts with 1 and vector with 0, thus increment
// return the next event delay in ms
// return the next event delay in ms
// 1 day
// must do the activating first, and after that the deactivating
// so first queue it
//SF_LOG_ERROR("sql.sql", "Checking event %u", itr);
// if the world event is in NEXTPHASE state, and the time has passed to finish this event, then do so
// set this event to finished, null the nextstart time
// save the state of this gameevent
// queue for deactivation
// go to next event, this no longer needs an event update timer
// changed, save to DB the gameevent state, will be updated in next update cycle
//SF_LOG_DEBUG("misc", "GameEvent %u is active", itr->first);
// queue for activation
//SF_LOG_DEBUG("misc", "GameEvent %u is not active", itr->first);
// spawn all negative ones for this event
// now activate the queue
// a now activated event can contain a spawn of a to-be-deactivated one
// following the activate - deactivate order, deactivating the first event later will leave the spawn in (wont disappear then reappear clientside)
// start the event
// returns true the started event completed
// in that case, initiate next update in 1 second
// Add 1 second to be sure event has started/stopped at next call
//! Run SAI scripts with SMART_EVENT_GAME_EVENT_END
// un-spawn positive event tagged objects
// spawn negative event tagget objects
// restore equipment or model
// Remove quests that are events only to non event npc
// update npcflags in this event
// remove vendor items
// update bg holiday
//! Run SAI scripts with SMART_EVENT_GAME_EVENT_END
// spawn positive event tagget objects
// un-spawn negative event tagged objects
// Change equipement or model
// Add quests that are events only to non event npc
// update npcflags in this event
// add vendor items
// update bg holiday
// check for seasonal quest reset.
// go through the creatures whose npcflags are changed in the event
// get the creature data from the low guid to get the entry, to be able to find out the whole guid
// if we found the creature, modify its npcflag
// reset gossip options, since the flag change might have added / removed some
//cr->ResetGossipOptions();
// if we didn't find it, then the npcflag will be updated when the creature is loaded
// Add to correct cell
// Spawn if necessary (loaded grids only)
// We use spawn coords to spawn
//SF_LOG_DEBUG("misc", "Spawning creature %u", *itr);
// Add to correct cell
// Spawn if necessary (loaded grids only)
// this base map checked as non-instanced and then only existed
// We use current coords to unspawn, not spawn coords since creature can have changed grid
//SF_LOG_DEBUG("misc", "Spawning gameobject %u", *itr);
/// @todo find out when it is add to map
// check if it's needed by another event, if so, don't remove
// Remove the creature from grid
// check if it's needed by another event, if so, don't remove
// Remove the gameobject from grid
// Remove the creature from grid
// Update if spawned
// If not spawned
///@todo: verify this line
// now last step: put in data
// just to have write access to it
// Add the pair(id, quest) to the multimap
// Remove the pair(id, quest) from the multimap
// iterator is now no more valid
// but we can exit loop since the element is found
// Add the pair(id, quest) to the multimap
// Remove the pair(id, quest) from the multimap
// iterator is now no more valid
// but we can exit loop since the element is found
// translate the quest to event and condition
// quest is registered
// the event is not active, so return, don't increase condition finishes
// not in correct phase, return
// condition is registered
// increase the done count, only if less then the req
// check max limit
// save the change to db
// check if all conditions are met, if so, update the event state
// changed, save to DB the gameevent state
// force update events to set timer
// return false if a condition doesn't match
// set the phase
// set the followup events' start time
//! Iterate over every supported source type (creature and gameobject)
//! Not entirely sure how this will affect units in non-loaded grids.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// Global definitions for the hashmap storage
/*fake*/)
/*typeSpecifier*/)
/// @todo more works need to be done for corpse and other world object
// Critical section
/// @todo Fix this
// build mapid*cellid -> guid_set map
// Critical section
// build mapid*cellid -> guid_set map
// We need this check otherwise a corpose may be added to a grid twice
// verify, if the corpse in our instance (add only corpses which are)
/*=false*/)
//in fact this function is called from several places
//even when player doesn't have a corpse, not an error
// Map can be NULL
// remove corpse from player_guid -> corpse map and from current map
// remove corpse from DB
// create the bones only if the map and the grid is loaded at the corpse's location
// ignore bones creating option in case insignia
// Create bones, don't change Corpse
// don't overwrite guid and object type
// bones->m_time = m_time;                              // don't overwrite time
// bones->m_type = m_type;                              // don't overwrite type
// add bones in grid store if grid loaded where corpse placed
// all references to the corpse should be removed at this point
/*diff*/)
// here we allocate a std::vector with a size of 0x10000
// clean the string
/// Define the static members of HashMapHolder
/*fake*/);
/*fake*/);
/*fake*/);
/*fake*/);
/*fake*/);
/*fake*/);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// TrinityCore only
// Remove realmname for now
// Check summoners for party
// This only applies to players
// need for reload case
// need for reload case
// need for reload case
//                                                 0              1                 2                  3                 4            5           6        7         8
//                                           9       10      11       12           13           14        15     16      17        18        19         20         21
//                                             22     23     24     25     26       27           28             29              30               31            32          33          34
//                                             35         36         37             38             39          40           41              42          43
//                                            44           45        46         47            48          49          50           51           52           53         54
//                                          55      56      57      58      59      60      61      62          63           64        65       66       67         68
//                                             69          70         71         72            73            74          75           76          77          78           79          80
//                                            81           82          83               84                85           86
// Checking needs to be done after loading because of the difficulty self referencing
//                                                0       1       2      3       4       5      6
// bool to allow continue outside this loop
// will be set to true at the end of this loop again
// used later for scale
// must exist or used hidden but used in data horse case
/// if not set custom creature scale then load scale from CreatureDisplayInfo.dbc
//                                                0       1       2      3       4       5      6
// select a random element
//                                                 0     1       2           3           4
/*= NULL*/)
// Load creature model (display id)
/*= NULL*/)
// If a model for another gender exists, 50% chance to use it
// Model ID changed
// Checks
//                                                 0        1          2
// they must have a possibility to meet (normal/heroic difficulty)
// they must have a possibility to meet (normal/heroic difficulty)
// they must have a possibility to meet (normal/heroic difficulty)
// they must have a possibility to meet (normal/heroic difficulty)
// we're removing the linking
// they must have a possibility to meet (normal/heroic difficulty)
// needed for reload case
//                                               0           1             2        3      4           5           6           7            8           9
//                                               0              1   2    3        4             5           6           7           8            9              10
//   11               12         13       14            15            16                17                18          19             20                 21             22                    23
// Build single time for check spawnmask
// -1 random, 0 no equipment,
// Add to grid if not managed by the game event or pool system
// Spawn if necessary (loaded grids only)
// We use spawn coords to spawn
// Spawn if necessary (loaded grids only)
// We use spawn coords to spawn
/*team*/, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay)
// Only used for extracting creature base stats
// Spawn if necessary (loaded grids only)
// We use spawn coords to spawn
//                                                0                1   2    3           4           5           6
//   7          8          9          10         11             12            13     14         15         16          17           18
// build single time for check spawnmask
// if not this is to be managed by GameEvent System or Pool system
// name must be checked to correctness (if received) before call this function
// prevent DB access for online player
// prevent DB access for online player
// prevent DB access for online player
// need for reload case
// get the right store here
// all items but shields
// shields
// INVTYPE_NON_EQUIP
// INVTYPE_HEAD
// INVTYPE_NECK
// INVTYPE_SHOULDERS
// INVTYPE_BODY
// INVTYPE_CHEST
// INVTYPE_WAIST
// INVTYPE_LEGS
// INVTYPE_FEET
// INVTYPE_WRISTS
// INVTYPE_HANDS
// INVTYPE_FINGER
// INVTYPE_TRINKET
// INVTYPE_WEAPON
// INVTYPE_SHIELD
// INVTYPE_RANGED
// INVTYPE_CLOAK
// INVTYPE_2HWEAPON
// INVTYPE_BAG
// INVTYPE_TABARD
// INVTYPE_ROBE
// INVTYPE_WEAPONMAINHAND
// INVTYPE_WEAPONOFFHAND
// INVTYPE_HOLDABLE
// INVTYPE_AMMO
// INVTYPE_THROWN
// INVTYPE_RANGEDRIGHT
// INVTYPE_QUIVER
// INVTYPE_RELIC
// ITEM_SUBCLASS_WEAPON_AXE
// ITEM_SUBCLASS_WEAPON_AXE2
// ITEM_SUBCLASS_WEAPON_BOW
// ITEM_SUBCLASS_WEAPON_GUN
// ITEM_SUBCLASS_WEAPON_MACE
// ITEM_SUBCLASS_WEAPON_MACE2
// ITEM_SUBCLASS_WEAPON_POLEARM
// ITEM_SUBCLASS_WEAPON_SWORD
// ITEM_SUBCLASS_WEAPON_SWORD2
// ITEM_SUBCLASS_WEAPON_Obsolete
// ITEM_SUBCLASS_WEAPON_STAFF
// ITEM_SUBCLASS_WEAPON_EXOTIC
// ITEM_SUBCLASS_WEAPON_EXOTIC2
// ITEM_SUBCLASS_WEAPON_FIST_WEAPON
// ITEM_SUBCLASS_WEAPON_MISCELLANEOUS
// ITEM_SUBCLASS_WEAPON_DAGGER
// ITEM_SUBCLASS_WEAPON_THROWN
// ITEM_SUBCLASS_WEAPON_SPEAR
// ITEM_SUBCLASS_WEAPON_CROSSBOW
// ITEM_SUBCLASS_WEAPON_WAND
// ITEM_SUBCLASS_WEAPON_FISHING_POLE
// epic item disenchant ilvl range 66-99 (classic)
// skip to epic item disenchant ilvl range 90-199 (TBC)
// epic item disenchant ilvl range 90-199 (TBC)
// cache item damage
// Load missing items from item_template AND overwrite data from Item-sparse.db2 (item_template is supposed to contain Item-sparse.adb data)
//                                               0      1      2         3                      4     5          6        7      8           9       10        11        12        13        14
//                                        15             16              17             18         19             20             21                 22
//                                        23                 24                25                         26                      27        28         29
//                                        30          31           32           33           34          35           36           37
//                                        38          39           40           41           42          43           44           45
//                                        46          47           48           49           50          51           52           53
//                                        54          55           56           57           58          59           60           61
//                                        62          63           64           65           66           67            68            69
//                                        70                       71          72     73
//                                        74         75              76              77               78               79
//                                        80         81              82              83               84               85
//                                        86         87              88              89               90               91
//                                        92         93              94              95               96               97
//                                        98         99              100             101              102              103
//                                        104      105          106       107         108           109         110     111
//                                        112     113             114           115      116   117  118        119
//                                        120            121              122            123              124            125              126
//                                        127            128                  129       130                131        132
//                                        133                     134
// cache item damage
// Check if item templates for DBC referenced character start outfit are present
// needed for reload case
//                                                  0             1              2          3           4             5
// needed for reload case
//                                                  0             1             2          3           4             5
//                                                 0               1      2   3     4    5    6    7     8    9
// hardcoded level maximum
// make result loading percent "expected" correct in case disabled detail mode for example.
// data for level 1 stored in [0] array element, ...
// Fill gaps and check integrity
// fatal error if no level 1 data
// fill level gaps
// data for level 1 stored in [0] array element, ...
// Load playercreate
//                                                0     1      2    3        4          5           6
// zone
// accept DB data only for valid position (and non instanceable)
// Load playercreate items
//                                                0     1      2       3
// Load playercreate spells
// We need something better here, the check is not accounting for spells used by multiple races/classes but not all of them.
// Either split the masks per class, or per race, which kind of kills the point yet.
// else if (raceMask != 0 && classMask != 0)
//     SF_LOG_ERROR("sql.sql", "Racemask/classmask (%u/%u) combination was found containing an invalid race/class combination (%u/%u) in `playercreateinfo_spell` (Spell %u), ignoring.", raceMask, classMask, raceIndex, classIndex, spellId);
// Load playercreate actions
//                                                0     1      2       3       4
// Loading levels data (class/race dependent)
//                                                 0     1      2      3    4    5    6    7
// hardcoded level maximum
// make result loading percent "expected" correct in case disabled detail mode for example.
// Fill gaps and check integrity
// skip non existed races
// skip non existed classes
// skip expansion races if not playing with expansion
// skip expansion classes if not playing with expansion
// skip expansion classes / races if not playing with expansion
// fatal error if no level 1 data
// fill level gaps
// Loading xp per level data
//                                                 0    1
// hardcoded level maximum
// make result loading percent "expected" correct in case disabled detail mode for example.
//PlayerXPperLevel
// fill level gaps
// Load playercreate cast spell
// base data (last known level)
// if conversion from uint32 to uint8 causes unexpected behaviour, change lvl to uint32
// For reload case
// create multimap previous quest for each existed quest
// some quests can have many previous maps set by NextQuestId in previous quest
// for example set of race quests can lead to single not race specific quest
// Post processing
// skip post-loading checks for disabled quests
// additional quest integrity checks (GO, creature_template and item_template must be loaded already)
// at auto-reward can be rewarded only RewardChoiceItemId[0]
// no changes, quest ignore this data
// no changes needed, sending -1 in SMSG_QUEST_QUERY_RESPONSE is valid
// client quest log visual (area case)
// no changes, quest not dependent from this value but can have problems at client
// client quest log visual (sort case)
// no changes, quest not dependent from this value but can have problems at client (note some may be 0, we must allow this so no check)
//check for proper RequiredSkillId value (skill case)
//override, and force proper value here?
// RequiredClasses, can be 0/CLASSMASK_ALL_PLAYABLE to allow any class
// RequiredRaces, can be 0/RACEMASK_ALL_PLAYABLE to allow any race
// RequiredSkillId, can be 0
// no changes, quest can't be done for this requirement
// else Skill quests can have 0 skill level, this is ok
// no changes, quest can't be done for this requirement
// no changes, quest can't be done for this requirement
// no changes, quest can't be done for this requirement
// no changes, quest can't be done for this requirement
// warning
// warning
// quest can't reward this title
// quest can't be done for this requirement
// quest can't be done for this requirement
// quest can't be done for this requirement
// no changes, quest can't be done for this requirement
// no changes, quest ignore this data
// no changes, quest will not reward this
// no changes, quest can't be done
// no changes, quest ignore this data
// no changes, quest will not reward this item
// no changes
// no changes, quest ignore this data
// quest will not reward this
// no changes, quest ignore this data
// no spell reward will display for this quest
// no spell reward will display for this quest
// no spell reward will display for this quest
// no spell will be casted on player
// no spell will be casted on player
// no spell will be casted on player
// no mail will send to player
// no mail will send to player
// no mail will send to player
// no mail will send to player
// no changes, quest can't be done for this requirement
// prevent incorrect work of quest
// prevent incorrect work of quest
// no sound will be played
// no sound will be played
// no changes, quest can't be done for this requirement
// fill additional data stores
// check QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT for spell with SPELL_EFFECT_QUEST_COMPLETE
// some quest referenced in spells not exist (outdated spells)
// this will prevent quest completing without objective
// need for reload case
// function cannot be called when scripts are in use.
// need for reload support
//                                                 0    1       2         3         4          5    6  7  8  9
// generic command args check
// this will prevent quest completing without objective
// continue; - quest objective requirement set and command can be allowed
// 1 bits (0, 1)
// targeting type
// 1 bit (0, 1)
// check ids
//check for correct spellEffect
// Load all possible script entries from gameobjects
// Load all possible script entries from spells
// Then check if all scripts are in above list of possible script entries
//Load WP Scripts
// need for reload case
//                                                 0      1       2
// need for reload case
//                                                0     1       2        4
//                                                 0         1            2                3
// need for reload case
//not very fast function but it is called only once a day, or on starting-up
// Delete all old mails without item and without body immediately, if starting server
// any mails need to be returned or deleted
/*messageId*/, MailItemInfoVec> itemsCache;
// this code will run very improbably (the time is between 4 and 5 am, in game is online a player, who has old mail
// his in mailbox and he has already listed his mails)
// Delete or return mail
// read items from cache
// if it is mail from non-player, or if it's already return mail, it shouldn't be returned, but deleted
// mail open and then not returned
// Mail will be returned
// Update receiver in mail items for its proper delivery, and in instance_item for avoid lost item at sender delete
// need for reload case
// this will prevent quest completing without objective
// continue; - quest modified to required objective and trigger can be allowed.
// need for reload case
// need for reload case
// dk flight
// skip not taxi network nodes
/* = false */)
// select mount creature id
// Fix for Alliance not being able to use Acherus taxi
// only one mount type for both sides
// Simply reverse the selection. At least one team in theory should have a valid mount ID to choose.
// minfo is not actually used but the mount_id was updated
// need for reload case
//                                                0       1         2
// Crossroads
// Westfall
// search for zone associated closest graveyard
// Simulate std. algorithm:
//   found some graveyard associated to (ghost_zone, ghost_map)
//
//   if mapId == graveyard.mapId (ghost in plain zone or city or battleground) and search graveyard at same map
//     then check faction
//   if mapId != graveyard.mapId (ghost in instance) and search any graveyard associated
//     then check faction
// not need to check validity of map object; MapId _MUST_ be valid here
// at corpse map
// at entrance map for corpse map
// some where other
// skip enemy faction graveyard
// team == 0 case can be at call from .neargrave
// find now nearest graveyard at other map
// if find graveyard at different map from where entrance placed (or no entrance data), use any first
// not have any corrdinates for check distance anyway
// at entrance map calculate distance (2D);
// find now nearest graveyard at same map
/*= true*/)
// add link to loaded data
// add link to DB
/*= false*/)
//SF_LOG_ERROR("sql.sql", "Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.", zoneId, team);
// skip not matching safezone id
// skip enemy faction graveyard at same map (normal area, city, or battleground)
// team == 0 case can be at call from .neargrave
// no match, return
// remove from links
// remove link from DB
// need for reload case
//                                                        0            1                  2                  3                  4                   5
// need for reload case
//                                               0      1           2          3          4     5      6             7             8                      9                  10
/*
/**
// Cleanup other tables from not existed guids ( >= _hiItemGuid)
// One-time query
// One-time query
// One-time query
// One-time query
// need for reload case
// prevent client and server unexpected work
// 0/1 correct values
// 0/1 correct values
//                                                 0      1      2        3       4             5          6      7       8     9        10         11          12
//                                            13          14          15       16     17     18     19     20     21     22     23     24     25      26      27      28
//                                          29      30      31      32      33      34      35      36      37      38      39      40      41      42      43      44
//                                          45      46      47       48       49        50
// Checks
//0
//1
//2
//3
// linked trap
//6
//7
//8
// linked trap
//10
// pageId
// linked trap
//12
//13
//15
//18
//22
// always must have spell
//24
//25
//26
//32
//                                                0     1      2
//        0     1     2     3            4      5          6          7       8       9      10        11    12          13          14          15         16
// SELECT posX, posY, posZ, orientation, mapId, displayId, itemCache, bytes1, bytes2, flags, dynFlags, time, corpseType, instanceId, phaseMask, corpseGuid, guid FROM corpse WHERE corpseType <> 0
// for reload case
//                                0          1             2                  3                  4                 5                      6             7
// For reload case
//                                                0            1                     2
//   3             4             5                   6             7             8                   9
// for reload case
//                                0         1        2       3        4       5       6         7        8      9        10       11     12        13       14     15
// need for reload case
//                                                  0   1  2   3      4     5       6
// need for reload case
//                                               0        1   2         3      4               5        6     7
//                                                0       1   2  3
// The first result should have the highest questId
//                                                0          1         2            3
// all spellclick data loaded, now we check if there are creatures with NPC_FLAG_SPELLCLICK but with no data
// NOTE: It *CAN* be the other way around: no spellclick flag but with spellclick data, in case of creature-only vehicle accessories
// remove mapid*cellid -> guid_set map
// remove mapid*cellid -> guid_set map
// corpses are always added to spawn mode 0 and they are spawned by their instance id
// corpses are always added to spawn mode 0 and they are spawned by their instance id
// need for reload case
// need for reload case
// any language
// extended-Latin
// East-Asian
// Cyrillic
// basic-Latin at create, any at login
// any language, ignore realm
// realm zone specific
// basic Latin
// need for reload case
// collect GO entries for GO that must activated
// scan GO chest with loot including quest items
// find quest loot for GO
//quests objects
//quests objects
// some string can have negative indexes range
// real range (max+1, min+1) exaple: (-10, -1000) -> -999...-10+1
// cleanup affected map part for reloading case
// error only in case internal strings
// for reload case
// get main part of the name
// prepare flags
// check declined names
// this allows calculating base reputations to offline players, just by race and class
// not set skills for professions and racial abilities
//not found in dbc
//only GENERIC(DND)
// for reload case
//                                                0       1           2           3           4        5     6
// explicit name case
// converting string that we try to find to lower case
// Alternative first GameTele what contains wnameLow as substring in case no GameTele location found
// explicit name case
// converting string that we try to find to lower case
// find max id
// use next
// explicit name case
// converting string that we try to find to lower case
// for reload case
//                                                 0        1             2            3
// calculate learned spell for profession case when stored cast-spell
// player must be able to cast spell on himself
// For reload case
// find all items from the reference vendor
// if item is a negative, its a reference
// For reload case
// if item is a negative, its a reference
//      0        1   2            3            4          5                     6               7              8          9          10
/*= true*/)
/*= true*/)
// not applicable to currencies
// later checks for non-empty lists
// use binary search to find the script name in the sorted vector
// assume "" is the first element
// MAX_DB_SCRIPT_STRING_ID is max allowed negative value for scripts (scrpts can use only more deep negative values
// start/end reversed for negative values
//                                                 0      1           2                   3                7         8
//                                               0       1
//                                               0       1
//                                               0               1
//                                               0       1
/*
//                                               0       1            2
// Give preference to GUID-based accessories
// Otherwise return entry-based
/*
//                                                   0       1                 3                      4
//                                                0        1         2        3           4           5
//                                                   0              1              2
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Only check grid activity every (grid_expiry/10) ms, because it's really useless to do it every cycle
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// creature in unloading grid can have respawn point in another grid
// if it will be unloaded then it will not respawn in original grid until unload/load original grid
// move to respawn point to prevent this case. For player view in respawn grid this will be normal respawn.
// gameobject in unloading grid can have respawn point in another grid
// if it will be unloaded then it will not respawn in original grid until unload/load original grid
// move to respawn point to prevent this case. For player view in respawn grid this will be normal respawn.
// for loading world object at grid loading (Corpses)
/// @todo to implement npc on transport, also need to load npcs at grid loading
/*obj*/, CellCoord const& /*cellCoord*/) { }
/*map*/, T *obj)
//SF_LOG_INFO("misc", "DEBUG: LoadHelper from table: %s for (guid: %u) Loading", table, guid);
/// @todo this is a hack
// corpse's map should be reset when the map is unloaded
// but it may still exist when the grid is unloaded but map is not
// in that case map == currMap
// corpses are always added to spawn mode 0 and they are spawned by their instance id
//Load creatures and game objects
//Load corpses (not bones)
// if option set then object already saved at this moment
//Some creatures may summon other temp summons in CleanupsBeforeDelete()
//So we need this even after cleaner (maybe we can remove cleaner)
//Example: Flame Leviathan Turret 33139 is summoned when a creature is deleted
/// @todo Check if that script has the correct logic. Do we really need to summons something before deleting?
///- object will get delinked from the manager when deleted
// stop any fights at grid de-activation and remove dynobjects created at cast by creatures
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// at this moment i_clientGUIDs have guids that not iterate at grid level checks
// but exist one case when this possible and object not out of range: transports
//cell.SetNoCreate(); need load cells around viewPoint or player, that's why its commented
// Send packet to all who are sharing the player's vision
// Send packet to all who are sharing the creature's vision
// Send packet back to the caster if the caster has vision of dynamic object
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// it is undefined whether objectmgr (which stores the groups) or instancesavemgr
// will be unloaded first so we must be prepared for both cases
// this may unload some instance saves
// Sub group counters clean up
// Store group in database
// If the leader can't be added to a new group because it appears full, something is clearly wrong.
// group leader not exist
// skip non-existed member
// update quest related GO states (quest activity dependent from raid membership)
// What message error should we send?
// update quest related GO states (quest activity dependent from raid membership)
// Get first not-full group
// We are raid group and no one slot is free
// if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
//if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
//if player is not in group, then call set group
// if the same group invites the player back, cancel the homebind timer
// reset targetIcons for non-raid-groups
// insert into the table if we're not a battleground group
// reset the new member's instances, unless he is currently in one of them
// including raid/heroic instances that they are not permanently bound to!
// quest related GO state dependent from raid membership
// Broadcast new player group member fields to rest of the group
// Broadcast group members' fields to player
/*= GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /*= 0*/, const char* reason /*= NULL*/)
// LFG group vote kick handled in scripts
// remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
// Battleground group handling
// Regular group
// quest related GO state dependent from raid membership
// Remove player from group in DB
// Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
// Remove player from loot rolls
// Update subgroups
// Pick new leader if necessary
// If group size before player removal <= 2 then disband it
// Don't allow switching leader to offline players
// Remove the groups permanent instance bindings
// Do not unbind saves of instances that already had map created (a newLeader entered)
// forcing a new instance with another leader requires group disbanding (confirmed on retail)
// Copy the permanent binds from the new leader to the group
// Update the group leader
/* = false */)
//we cannot call _removeMember because it would invalidate member iterator
//if we are removing player from battleground raid
//we can remove player who is in battleground from his original group
// quest related GO state dependent from raid membership
//we already removed player from group and in player->GetGroup() is his original group, send update
/*********************************************************/
/***                   LOOT SYSTEM                     ***/
/*********************************************************/
// guid of rolled item
// 3.3.3 mapid
// itemslot
// the itemEntryId for the item that shall be rolled for
// randomSuffix
// item random property ID
// items in stack
// the countdown time to choose "need" or "greed"
// roll type mask
// maybe the number of players rolling for it???
// guid of rolled item
// 3.3.3 mapid
// itemslot
// the itemEntryId for the item that shall be rolled for
// randomSuffix
// item random property ID
// items in stack
// the countdown time to choose "need" or "greed"
// roll type mask
// maybe the number of players rolling for it???
// guid of the item rolled
// slot
// the itemEntryId for the item that shall be rolled for
// randomSuffix
// Item random property ID
// 0: "Need for: [item name]" > 127: "you passed on: [item name]"      Roll number
// 0: "Need for: [item name]" 0: "You have selected need for [item name] 1: need roll 2: greed roll
// 1: "You automatically passed on: %s because you cannot loot that item." - Possibly used in need befor greed
// guid of the item rolled
// slot
// the itemEntryId for the item that shall be rolled for
// randomSuffix
// Item random property
// guid of the player who won.
// rollnumber realted to SMSG_LOOT_ROLL
// rollType related to SMSG_LOOT_ROLL
// Guid of the item rolled
// Item loot slot
// The itemEntryId for the item that shall be rolled for
// Item random property ID
// Item random suffix ID
// notify group members which player is the allowed looter for the given creature
//SF_LOG_DEBUG("misc", "Group::GroupLoot: missing item prototype for item with id: %d", i->itemid);
//roll for over-threshold item if it's one-player loot
//a vector is filled with only near party members
// can't broadcast the pass now. need to wait until all rolling players are known.
// If there is any "auto pass", broadcast the pass now.
//SF_LOG_DEBUG("misc", "Group::GroupLoot: missing item prototype for item with id: %d", i->itemid);
//a vector is filled with only near party members
//roll for over-threshold item if it's one-player loot
// can't broadcast the pass now. need to wait until all rolling players are known.
//Broadcast Pass and Send Rollstart
//Broadcast Pass and Send Rollstart
/*loot*/, WorldObject* pLootedObject)
// this condition means that player joins to the party after roll begins
// Player choose pass
// player choose Need
// player choose Greed
// player choose Disenchant
//called when roll timer expires
//i don't have to edit player votes, who didn't vote ... he will pass
// is loot already deleted ?
//end of the roll
// Disenchant
// remove is_blocked so that the item is lootable by all players
// clean other icons
// if MemberSlot wasn't provided
// has dungeon and raid difficulty
// has loot mode
//if (hasLootMode)
// is LFG
/*if (isLFGGroup())
//if (hasInstanceDifficulty)
// raid Difficulty
// dungeon Difficulty
/*if (isLFGGroup())
//if (hasLootMode)
// group type (flags in 3.3)
/*data << uint8(m_groupType);                         // group type (flags in 3.3)
// FIXME - Dungeon save status? 2 = done
// 4.x new
// 3.3, value increases every time this packet gets sent
// guid
// online-state
// groupid
// See enum GroupMemberFlags
// Lfg Roles
// leader guid
// loot method
// looter guid
// loot threshold
// Dungeon Difficulty
// Raid Difficulty
// Allows setting sub groups both for online or offline members
// Only raid groups have sub groups
// Check if player is really in the raid
// Abort if the player is already in the target sub group
// Update the player slot with the new sub group setting
// Increase the counter of the new sub group..
// ..and decrease the counter of the previous one
// Preserve new sub group in database for non-raid groups
// In case the moved player is online, update the player object with the new sub group references
// If player is in BG raid, it is possible that he is also in normal raid - and that normal raid is stored in m_originalGroup reference
// Broadcast the changes to the group
// Retrieve the next Round-Roubin player for the group
//
// No update done if loot method is Master or FFA.
//
// If the RR player is not yet set for the group, the first group member becomes the round-robin player.
// If the RR player is set, the next player in group becomes the round-robin player.
//
// If ifneed is true,
//      the current RR player is checked to be near the looted object.
//      if yes, no update done.
//      if not, he loses his turn.
// round robin style looting applies for all low
// quality items in each loot method except free for all and master loot
// not update if only update if need and ok
// search next after current
// search from start
/*MaxPlayerCount*/, bool isRated, uint32 arenaSlot)
// check if this group is LFG group
// shouldn't happen
// check for min / max count
// no MinPlayerCount for battlegrounds
// ERR_GROUP_JOIN_BATTLEGROUND_TOO_MANY handled on client side
// get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
// no reference found, can't join this way
// check every member of the group to be able to join
// offline member? don't let join
// don't allow cross-faction join as group
// not in the same battleground level braket, don't let join
// don't let join if someone from the group is already in that bg queue
// not blizz-like
// don't let join if someone from the group is in bg queue random
// don't let join to bg queue random if someone from the group is already in bg queue
// check for deserter debuff in case not arena queue
// check if member can join any more battleground queues
// not blizz-like
// check if someone in party is using dungeon system
// only check for MinPlayerCount since MinPlayerCount == MaxPlayerCount for arenas...
//===================================================
//============== Roll ===============================
//===================================================
// called from link()
// method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
// we assume that when the difficulty changes, all instances that can be reset will be
// the "reset all instances" method can only reset normal maps
// if the map is loaded, reset it
// do not reset the instance, just unbind if others are permanently bound to it
// i don't know for sure if hash_map iterators
// this unloads the instance save unless online players are bound to it
// (eg. permanent binds or GM solo binds)
// some instances only have one difficulty
// save can become invalid
// FG: HACK: force flags update on group leave - for values update hack
// -- not very efficient but safe
// Assistants, main assistants and main tanks are only available in raid groups
// Check if player is really in the raid
// Do flag specific actions, e.g ensure uniqueness
// Remove main assist flag from current if any.
// Remove main tank flag from current if any.
// This should never happen
// Switch the actual flag
// Preserve the new setting in the db
// Broadcast the changes to the group
/*
// Sub group counters initialization
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Allocate space if necessary.
// Delete all groups whose leader does not exist
// Delete all groups with less than 2 members
//                                                        0              1           2             3                 4      5          6      7         8       9
//  10         11          12         13              14            15         16           17
// Get the ID used for storing the group in the database and register it in the pool.
// Increase the next available storage ID
// Delete all rows from party_member and party_instance with no group
// Delete all members that does not exist
//                                                    0        1           2            3       4
//                                                   0           1        2              3             4             5            6
// group will never be NULL (we have run consistency sql's before loading)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// called from link()
// called from unlink()
//getTarget()->DelinkMember(this);
// called from invalidate()
//getTarget()->DelinkMember(this);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// LogHolder
// Cleanup
// Adds event loaded from database to collection
// Adds new event happened in game.
// If maximum number of events is reached, oldest event is removed from collection.
// Check max records limit
// Add event to list
// Save to DB
// Writes information about all events into packet.
// Next guid was not initialized. It means there are no records for this holder in DB yet.
// Start from the beginning.
// EventLogEntry
// Event type
// Event timestamp
// New Rank
// BankEventLogEntry
/*content*/) const
// Not yet implemented used for guild achievements
// 1 sticky
// RankInfo
// Prevent loss of leader rights
/* = false */)
// Prevent loss of leader rights
// Prevent loss of leader rights
// Prevent loss of leader rights
// BankTab
// Deletes contents of the tab from the world (and from DB if necessary)
// DB and client size limitation
// Sets/removes contents of specified slot.
// If pItem == NULL contents are removed.
// Not in inventory and can be saved standalone
// Member
// Update rank information in player's field, if he is online.
// Loads member's data from database.
// If member has broken fields (level, class) returns false.
// In this case member has to be removed from guild.
// characters.level
// characters.class
// characters.zone
// characters.account
// characters.logout_time
// Validate player fields. Returns false if corrupted fields are found.
// Decreases amount of money/slots left for today.
// If (tabId == GUILD_BANK_MAX_TABS) decrease money amount.
// Otherwise decrease remaining items amount for specified tab.
/* = false*/)
// Get amount of money/slots left for today.
// If (tabId == GUILD_BANK_MAX_TABS) return money amount.
// Otherwise return remaining items amount for specified tab.
// Guild master has unlimited amount.
// EmblemInfo
// MoveItemData
// PlayerMoveItemData
// Anti-WPE protection. Do not move non-empty bags to bank.
// Bound items cannot be put into bank.
/*pOther*/, uint32 splitedAmount)
// Bank -> Char
// BankMoveItemData
// Do not check rights if item is being swapped within the same bank tab
// Do not check rights if item is being swapped within the same bank tab
// Decrease amount of player's remaining items (if item is moved to different tab or to player)
// Bank -> Bank
// Char -> Bank
/// @todo Move this to scripts
// Tries to reserve space for source item.
// If item in destination slot exists it must be the item of the same entry
// and stack must have enough space to take at least one item.
// Returns false if destination item specified and it cannot be used to reserve space.
// Make sure source and destination items match and destination item has space for more stacks.
// Let's not be greedy, reserve only required space
// Reserve space
// Skip slot already processed in CanStore (when destination slot was specified)
// If merge skip empty, if not merge skip non-empty
// Soulbound items cannot be moved
// Make sure destination bank tab exists
// Slot explicitely specified. Check it.
// Ignore swapped item (this slot will be empty after move)
// Slot was not specified or it has not enough space for all the items in stack
// Search for stacks to merge with
// Search free slot for item
// Guild
// Cleanup
// Creates new guild with default data and saves it to database.
// Check if guild with such name already exists
// Create default ranks
// Add guildmaster
// Disbands guild and deletes all related data from database
// Call scripts before guild data removed from database
// Remove all members
// Free bank tab used memory and delete items stored in them
//HandleRoster();
/*= NULL*/)
// Guess size
// Can Scroll of Ressurect
// Has Authenticator
// for (2 professions)
// Gender
// Guess size
// HasData
// if (hasData)
//if (hasData)
// Player must have rights to set MOTD
// Player must have rights to set guild's info
// "Only guild leaders can create emblems."
// "You can't afford to do that."
// "Guild Emblem saved."
// Remover name denoted
// Fake bit
// Only the guild master can throne a new guild master
// Old GM must be a guild member
// Same for the new one
// 3 ranks down from gum is the requirements
// Player must have rights to set public/officer note
// Only leader can modify ranks
// Do not get money for bank tabs that the GM bought, we had to buy them already.
// This is just a speedup check, GetGuildBankTabPrice will return 0.
// 7th tab is actually the 6th
// Should not happen, this is checked by client
/// Hack to force client to update permissions
// Do not show invitations from ignored players
// Invited player cannot be in another guild
// Invited player cannot be invited
// Inviting player must have rights to invite
// Auto decline invite
// If leader is leaving
// Leader cannot leave if he is not the last member
// Guild is disbanded if leader leaves.
// Player must have rights to remove members
// Guild masters cannot be removed
// Do not allow to remove player with the same rank or higher
// After call to DeleteMember pointer to member becomes invalid
// Player must have rights to promote
// Promoted player must be a member of guild
// Player cannot promote himself
// Player can demote only lower rank members
// Lowest rank cannot be demoted
// Allow to promote only to lower rank than member's rank
// member->GetRankId() + 1 is the highest rank that current player can promote to
// Promoted player must be a member of guild
// Player cannot promote himself
// Only leader can add new rank
// Cannot remove rank if total count is minimum allowed by the client or is not leader
// Delete bank rights for rank
// Delete rank
/*=false*/)
// Call script after validation and before money transfer.
// clamp amount to MAX_MONEY_AMOUNT, Players can't hold more than that anyway
// Not enough money in bank
// Check if we have enough slot/money today
// Call script after validation and before money transfer.
// Add money to player (if required)
// Update remaining money amount
// Remove money from bank
// Log guild bank event
// Only leader can disband guild
// Make sure player is a member of the guild and that he is in a group.
// Needed guild members
// Guild XP multiplier
// Current guild members
// Is guild group
// Not yet implemented used for guild achievements
// 1 sticky
// GUILD_BANK_MAX_TABS send by client for money log
// has Cash Flow perk
/*
// bank withdrawal reset
// Send to self separately, player is not in world yet and is not found by _BroadcastEvent
// tells the client to request bank withdrawal limit
// Loading methods
// tabId              rights                slots
// rankId
// guild id
// guid
// timestamp
// event type
// player guid 1
// player guid 2
// rank
// guild id
// guid
// timestamp
// tab id
// event type
// player guid
// item or money
// itam stack count
// dest tab id
// guild id
// guid
// timestamp //64 bits?
// type
// player guid
// Flags
// value
// Validates guild data loaded from database. Returns false if guild should be deleted.
// Validate ranks data
// GUILD RANKS represent a sequence starting from 0 = GUILD_MASTER (ALL PRIVILEGES) to max 9 (lowest privileges).
// The lower rank id is considered higher rank - so promotion does rank-- and demotion does rank++
// Between ranks in sequence cannot be gaps - so 0, 1, 2, 4 is impossible
// Min ranks count is 2 and max is 10.
// Validate members' data
// Repair the structure of the guild.
// If the guildmaster doesn't exist or isn't member of the guild
// attempt to promote another member.
// If no more members left, disband guild
// Check config if multiple guildmasters are allowed
// Broadcasts
// count placeholder
// not sure if needed, maybe client checks it as well
// Members handling
// Player cannot be in guild
// Remove all player signs from another petitions
// This will be prevent attempt to join many guilds and corrupt guild data integrity
// If rank was not passed, assign lowest possible rank
// Player must exist
// Call scripts if member was succesfully added (and stored to database)
// Guild master can be deleted when loading guild and guid doesn't exist in characters table
// or when he is removed from guild by gm command
// If player not online data in data field will be loaded from guild tabs no need to update it !!
// If leader does not exist (at guild loading with deleted leader) do not send broadcasts
// Call script on remove before member is actually removed from guild (and database)
// If player not online data in data field will be loaded from guild tabs no need to update it !!
// Validate rank (allow only existing ranks)
// Bank (items move)
// Bank tabs
// Private methods
// Next free id
// Ranks represent sequence 0, 1, 2, ... where 0 means guildmaster
// Updates the number of accounts that are in the guild
// Player may have many characters in the guild, but with the same account
// We use a set to be sure each element will be unique
// Detects if player is the guild master.
// Check both leader guid and player's rank (otherwise multiple feature with
// multiple guild masters won't work)
// Check if there is enough money in bank.
// Leader always has full rights
// Add new event log record
// Add new bank event log record
// not logging moves within the same tab
// 1. Initialize source item
// No source item
// 2. Check source item
// Source item or splited amount is invalid
/*
//return; // Commented out for now, uncomment when it's verified that this causes a crash!!
// */
// 3. Check destination rights
// Player has no rights to store item in destination
// 4. Check source withdraw rights
// Player has no rights to withdraw items from source
// 5. Check split
// 5.1. Clone source item
// Item could not be cloned
// 5.2. Move splited item to destination
// 6. No split
// 6.1. Try to merge items in destination (pDest->GetItem() == NULL)
// Item could not be merged
// 6.2. Try to swap items
// 6.2.1. Initialize destination item
// 6.2.2. Check rights to store item in source (opposite direction)
// Player has no rights to store item in source (opposite direction)
// Player has no rights to withdraw item from destination (opposite direction)
// 6.2.3. Swap items (pDest->GetItem() != NULL)
// 7. Send changes
// 1. Can store source item in destination
// 2. Can store destination item in source
// GM LOG (@todo move to scripts)
// 3. Log bank events
// 4. Remove item from source
// 5. Remove item from destination
// 6. Store item in destination
// 7. Store item in source
// B ->
// B -> B
// Same tab - add destination slots to collection
// Different tabs - send second message
// C -> B
// guess size
// item withdrawal limit placeholder
// not a full update
// tab count (doesn't need to be sent here)
// item count
// Locked
// Size size - mods
// ITEM_FIELD_STACK_COUNT
// Spell charges
// SuffixFactor
// Shouldn't happen, just in case
// Locked
// Size size - mods
// ITEM_FIELD_STACK_COUNT
// Spell charges
// SuffixFactor
// 1 == higher, 0 = lower?
/// @todo: Award reputation and count activity for player
// SMSG_GUILD_XP_GAIN is always sent, even for no gains
// Ding, mon!
// Find all guild perks to learn
// Notify all online players that guild level changed and learn perks
/* = NULL */) const
// XP missing for next level
//SendGuildXP(player->GetSession());
// tells the client to request bank withdrawal limit
// size, we are only sending 1 news here
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//                                                           0                1             2                  3             4           5             6         7
//                                                      0         1           2            3           4         5         6
// Notify the applicant his submittion has been added
// Notify the guild master and officers the list changed
// Notify the guild master and officers the list changed
// Notify the applicant his submittion has been removed
// Notify the guild master and officers the list changed
// Notify the applicant his submition has been removed
// Notify the guild master the list changed (even if he's not a GM any more, not sure if needed)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Guild collection
// Full guids are only used when receiving/sending data to client
// everywhere else guild id is used
// 1. Load all guilds
//          0          1       2             3              4              5              6
//   7                  8       9       10            11          12        13                14                 15
// 2. Load all guild ranks
// Delete orphaned guild rank entries before loading the valid ones
//                                                         0    1      2       3                4
// 3. Load all guild members
// Delete orphaned guild member entries before loading the valid ones
//           0           1        2            3      4        5       6       7       8       9       10
//    11      12      13       14      15       16       17      18         19
// 4. Load all guild bank tab rights
// Delete orphaned guild bank right entries before loading the valid ones
//      0        1      2    3        4
// 5. Load all event logs
//          0        1        2          3            4            5        6
// 6. Load all bank event logs
// Remove log entries that exceed the number of allowed entries per guild
//          0        1      2        3          4           5            6               7          8
// 7. Load all news event logs
//      0        1        2          3           4      5      6
// 8. Load all guild bank tabs
// Delete orphaned guild bank tab entries before loading the valid ones
//         0        1      2        3        4
// 9. Fill all guild bank tabs
// Delete orphan guild bank items
//          0            1                2      3         4        5      6             7                 8           9           10
//   11       12     13      14         15
// 10. Load guild achievements
// 11. Validate loaded guild data
//                                                 0         1
// fill level gaps
//                                                 0     1         2         3      4
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// broken addon packet, can't be received from real client
// get real size of the packed structure
// empty addon packet, nothing process, can't be received from real client
// temp value because ZLIB only excepts uLongf
// get the position of the pointer in the structure
// resize target for zlib action
// addons count?
// check next addon data format correctness
// recheck next addon data format correctness
// If addon is Standard addon CRC
// String, 256 (null terminated?)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 0 = ERR_ARENA_NO_TEAM_II, 1 = ERR_ARENA_EXPIRED_CAIS, 2 = ERR_LFG_CANT_USE_BATTLEGROUND
// team type (2=2v2, 3=3v3, 5=5v5), can be used for custom types...
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//void called when player click on auctioneer npc
//NPC guid
// remove fake death
//this void causes that auction window is opened
// 1 - AH enabled, 0 - AH disabled
//call this method when player bids, creates, or deletes auction
// bag result
/*data << uint32(auction ? auction->Id : 0);
//this function sends notification, if bidder is online
// this void causes on client to display: "Your auction sold"
// mail delay
// sold
//this void creates new auction and adds auction to some auctionhouse
// 32 slots, value sent as 5 bits
///@TODO - HARDCODED DB GUID, BAD BAD BAD
// Required stack size of auction matches to current item stack size, just move item to auctionhouse
// Required stack size of auction does not match to current item stack size, clone item and set correct stack size
// Item stack count equals required count, ready to delete item - cloned item will be used for auction
// Item stack count is bigger than required count, update item stack count and save to database - cloned item will be used for auction
// this function is called when client bids or buys out auction
// check for cheaters
// remove fake death
//you cannot bid your own auction:
// impossible have online own another character (use this for speedup check in case online owner)
/*Player* auction_owner = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER));
//you cannot bid your another character auction:
// cheating
// price too low for next bid if not buyout
// client already test it but just in case ...
// client already test it but just in case ...
// mail to last bidder and return money
//buyout:
//buyout for bidded auction ..
//- Mails must be under transaction control too to prevent data loss
//this void is called when auction_owner cancels his auction
// remove fake death
// If we have a bidder, we have to send him the money he paid
//player doesn't have enough money, maybe message needed
// item will deleted or added to received mail list
//this code isn't possible ... maybe there should be assert
//inform player, that auction is removed
// Now remove the auction
//called when player lists his bids
// page of auctions
// count of outbidded auctions
// not used in fact (this list not have page control in client)
/*if (recvData.size() != (16 + outbiddedCount * 4))
// remove fake death
// guess size
// amount place holder
// add count to placeholder
//this void sends player info about his auctions
// not used in fact (this list not have page control in client)
// remove fake death
// guess size
// amount place holder
//this void is called when player clicks on search button
// start, used for page control listing by 50 elements
// this block looks like it uses some lame byte packing or similar...
// sorts currently unhandled
// remove fake death
//SF_LOG_DEBUG("misc", "Auctionhouse search (GUID: %u TypeId: %u)",, list from: %u, searchedname: %s, levelmin: %u, levelmax: %u, auctionSlotID: %u, auctionMainCategory: %u, auctionSubCategory: %u, quality: %u, usable: %u",
//  GUID_LOPART(guid), GuidHigh2TypeId(GUID_HIPART(guid)), listfrom, searchedname.c_str(), levelmin, levelmax, auctionSlotID, auctionMainCategory, auctionSubCategory, quality, usable);
// guess size
// amount place holder
// converting string that we try to find to lower case
// count
/*for (uint32 i = 0; i < count; ++i)
// string
// string
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Add local realm
// Send current realmId
// Home realm
// Unknown
// Unknown
// Auth response ?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//This send to player windows for invite player to join the war
//Param1:(guid) the guid of Bf
//Param2:(ZoneId) the zone where the battle is (4197 for wg)
//Param3:(time) Time in second that the player have for accept
// Zone Id
// Invite lasts until
//Sending the packet to player
//This send invitation to player to join the queue
// unk
// Has Warmup
// unk
// unk
// unk
// unk
// unk
// Warmup
//Sending packet to player
//This send packet for inform player that he join queue
//Param1:(guid) the guid of Bf
//Param2:(ZoneId) the zone where the battle is (4197 for wg)
//Param3:(CanQueue) if able to queue
//Param4:(Full) on log in is full
// Logging In, VERIFYME
// if (hasSecondGuid) 7 3 0 4 2 6 1 5
// if (hasSecondGuid) 2 5 3 0 4 6 1 7
// Accepted
//This is call when player accept to join war
// unk
// Clear AFK
// unk
// Relocated
// BattleStatus
// Reason
//Send by client when he click on accept for queue
//Send by client on clicking in accept or refuse of invitation windows for join game
//TODO: PLAYER_FIELD_PVP_INFO, Updatefield Data 8*3 = size 24
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// it's not battlemaster
// Stop the npc if moving
// temp, must be gossip message...
// blacklistedMapIds
// As Group
// Need to set this as group role later
//extract from guid
//SF_LOG_DEBUG("network", "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from (GUID:"UI64FMTD" TypeId:%u)", guid, bgTypeId_);
// can do this, since it's battleground, not arena
// ignore if player is already in BG
// get bg instance or bg template if instance not found
// expected bracket entry
// check queue conditions
// check Deserter debuff
// player is already in random queue
// player is already in queue, can't start random queue
// check if already in queue
// player is already in this queue
// check if has free queue slots
// add joined time data
// send status packet (in queue)
// this should never happen
// add to queue
// add joined time data
// send status packet (in queue)
/*recvData*/)
// can't be received if player not in battleground
/*recvData*/)
// Prevent players from sending BuildPvpLogDataPacket in an arena except for when sent in BattleGround::EndBattleGround.
// id from DBC
// enter battle 0x1, leave queue 0x0
//we must use temporary variable, because GroupQueueInfo pointer can be deleted in BattlegroundQueue::RemovePlayer() function
// if action == 1, then instanceId is required
// BGTemplateId returns BATTLEGROUND_AA when it is arena queue.
// Do instance id search as there is no AA bg instances.
// get real bg type
// expected bracket entry
//some checks if player isn't cheating - it is not exactly cheating, but we cannot allow it
//if player is trying to enter battleground (not arena!) and he has deserter debuff, we must just remove him from queue
//send bg command result to show nice message
//if player don't match battleground max level, then do not allow him to enter! (this might happen when player leveled up during his waiting in queue
// cheating?
// resurrect the player
// stop taxi flight at port
// remove battleground queue status from BGmgr
// this is still needed here if battleground "jumping" shouldn't add deserter debuff
// also this is required to prevent stuck at old battleground after SetBattlegroundId set to new
// set the destination instance id
// set the destination team
// bg->HandleBeforeTeleportToBattleground(_player);
// add only in HandleMoveWorldPortAck()
// bg->AddPlayer(_player, team);
// leave queue
// if player leaves rated arena match before match start, it is counted as he played but he lost
/*
// must be called this way, because if you move this call to queue->removeplayer, it causes bugs
// player left queue, we should update it - do not update Arena Queue
/*recvData*/)
// not allow leave battleground in combat
/*recvData*/)
// empty opcode
// we must update all queues here
//i cannot check any variable from player class because player class doesn't know if player is in 2v2 / 3v3 or 5v5 arena
//so i must use bg pointer to get that information
// this line is checked, i only don't know if GetElapsedTime() is changing itself after bg end!
// send status in Battleground
//we are sending update to player about queue - he can be invited there!
//get GroupQueueInfo for queue status
// send status invited to Battleground
// expected bracket entry
// send status in Battleground Queue
// 2v2, 3v3 or 5v5
// ignore if we already in BG or BG queue
//check existance
// no group found, error
/*
// check real arenateam existence only here (if it was moved to group->CanJoin .. () then we would ahve to get it twice)
// add to queue
// add joined time data
// send status packet (in queue)
/*recvData*/)
// triggers PVP_TYPES_ENABLED lua event
/*recvData*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// TODO: finish this...
// TODO: check for invalid characters, ect...
// has names
// TODO: finish declined names
// allowed?
// this check is also done clientside
// sever handles slot swapping, find source slot and replace it with the destination slot
// list of flags the client can currently change
// TODO: check if Battle Pet is correct level for ability
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// MarketID might be Result
// ItemID
// Result might be MarketID
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// HasBattlePayProduct
// Revoked
// if (unkBool)
// {
// HasBattlepayDisplayInfo
// if (HasBattlepayDisplayInfo)
// {
// bool11
// }
// }
// if (unkBool)
// {
// if (bool11)
//data << int32(0);
// }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*recvData*/)
// Average size if no instance
// Reset placeholder
// Holidays -> fuck that shit... Necessary to find out when this should be sent
// Lockout placeholder
// zone time
// offset => found it different only once
// Constant date, unk (28.12.2005 07:00)
// server time
// always 100, necesary? Not find the way how to change it
// Skip InviteId
// Skip flags
// Invitee is online
// Invitee offline, get data from database
// we probably can invite them, but we have to send them some different info about that invite
// we probably can invite them, but we have to send them some different info about that invite
// i think we still should be able to remove self from locked events
// correct?
// correct?
// correct?
// what to do with complains?
/*recvData*/)
/*
// http://www.wowwiki.com/Instance_Lock_Extension
// SendCalendarRaidLockoutUpdated(save);
// ----------------------------------- SEND ------------------------------------
// New remaining time? => found only same values as the possible old time
// Old remaining time? => found only same values as the possible new time
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// for normalizePlayerName
// unknown bit
// unknown bit
// channel id?
// this should be OK because the 2 function _were_ the same
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Sended before SMSG_ENUM_CHARACTERS_RESULT
// must be procceded before BuildEnumData, because of unsetting bosted character guid
// factionChangeRestrictions - raceId / mask loop
// Do not allow banned characters to log in
// This can happen if characters are inserted into the database manually. Core hasn't loaded name data yet.
// Sucess
// Success
// Sended after SMSG_ENUM_CHARACTERS_RESULT
/*recvData*/)
// remove expired bans
/// get all the data necessary for loading all characters (along with their pets) on the account
// returned with diff.values in all cases
/*
// prevent character creating Expansion class without Expansion account
// prevent character creating with invalid name
// check name limitations
// speedup check for heroic class disabled case
// speedup check for heroic class disabled case
// Delete existing if any, to make the callback chain reset to stage 0
/** This is a series of callbacks executed consecutively as a result from the database becomes available.
// SELECT SUM(x) is MYSQL_TYPE_NEWDECIMAL - needs to be read as string
// SQL's COUNT() returns uint64 but it will always be less than uint8.Max
// Will jump to case 3
// need to check team only for first character
/// @todo what to if account already has characters of both races?
// search same race for cinematic or same class if need
/// @todo check if cinematic already shown? (already logged in?; cinematic field)
// Player not create (race/class/etc problem?)
// not show intro
// First login
// Player created, save it now
// can't delete loaded character
// is guild leader
// prevent deleting other players' characters using cheating tools
// optimize GetPlayerDump call
//sGuildFinderMgr->RemoveAllMembershipRequestsFromPlayer(guid);
//WorldObject* player = ObjectAccessor::GetWorldObject(*GetPlayer(), playerGuid);
// delete all unprocessed queries
// TODO: Do something with this packet
// for send server info and strings (config)
// "GetAccountId() == db stored account id" checked in LoadFromDB (prevent login not own character using cheating tools)
// disconnect client, player no set to session and it will not deleted or saved at kick
// delete it manually
// delete all unprocessed queries
// load player specific part before send times
// Scroll of Resurrection per day?
// Scroll of Resurrection current
// ingame shop status (0 - "The Shop is temporarily unavailable.")
// Recruit a Friend button
// server supports voice chat
// show ingame shop icon
// Scroll of Resurrection button
// excessive play time warning
// ingame shop parental control (1 - "Feature has been disabled by Parental Controls.")
// feedback system (bug, suggestion and report systems)
// excessive play time warning after period(in seconds)
// Send MOTD
// new in 2.0.1
// send server info
// Old season
// Current season
//QueryResult* result = CharacterDatabase.PQuery("SELECT guildid, rank FROM guild_member WHERE guid = '%u'", pCurrChar->GetGUIDLow());
// clear guild related fields in case wrong data about non existed membership
//Show cinematic at the first time that player login
// send new char string if not empty
//SF_LOG_DEBUG("Player %s added to Map.", pCurrChar->GetName().c_str());
// remove wrong guild data
// announce group about member online (must be after add to player list to receive announce to self)
//pCurrChar->groupInfo.group->SendInit(this); // useless
// friend status
// Place character in world (and load zone) before some object loading
// setting Ghost+speed if dead
// not blizz like, we must correctly save and load player instead...
// auras SPELL_AURA_INCREASE_SPEED(+speed in wisp form), SPELL_AURA_INCREASE_SWIM_SPEED(+swim speed in wisp form), SPELL_AURA_TRANSFORM (to wisp form)
// auras SPELL_AURA_GHOST, SPELL_AURA_INCREASE_SPEED(why?), SPELL_AURA_INCREASE_SWIM_SPEED(why?)
// reset for all pets before pet loading
// Load pet if any (if player not alive and in taxi flight or another then pet will remember as temporary unsummoned)
// Set FFA PvP for non GM in non-rest mode
// Apply at_login requests
// original talents send already in to SendInitialPacketsBeforeAddToMap, resend reset state
// show time before shutdown if shutdown planned.
//I think this function is never used :/ I dunno, but i guess this opcode not exists
/*recvData*/)
/*recvData*/)
/*recvData*/)
// unknown, bool?
// unknown, bool?
// Name size
// New Name
// prevent character rename to invalid name
// check name limitations
// Ensure that the character belongs to the current account, that rename at login is enabled
// and that there is no character with the desired new name
// Update name and at_login flag in the db
// Removed declined name from db
// not accept declined names for unsupported languages
// name already stored as only single alphabet using
// OK
// it isn't free
// stand up
// Name size
// New Name
// prevent character rename to invalid name
// check name limitations
// character with this name already exist
// client set slots amount
// equipment manager sends "1" (as raw GUID) for slots set to "ignore" (don't touch slot at equip set)
// ignored slots saved as bit mask because we have no free special values for Items[i]
// cheating check 1
// cheating check 2
// Container Slot
// Slot
// check if item slot is set to "ignored" (raw value == 1), must not be unequipped then
//Container Slot and Slot not used.
// 4 - equipment swap failed - inventory is full
// get the players old (at this moment current) race
// prevent character rename to invalid name
// check name limitations
// character with this name already exist
// Search each faction is targeted
// Switch Languages
// delete all languages first
// Now add them back
// Faction specific languages
// Race specific languages
// Delete all Flypaths
// Update Taxi path
// this doesn't seem to be 100% blizzlike... but it can't really be helped.
// Reset guild
// Delete Friend List
// Reset homebind and position
// Achievement conversion
// Item conversion
// Delete all current quests
// Quest conversion
// Mark all rewarded quests as "active" (will count for completed quests achievements)
// Disable all old-faction specific quests
// Spell conversion
// Reputation conversion
// select old standing set in db
// old base reputation
// new base reputation
// final reputation shouldnt change
// Title conversion
// new team
// use index of the new title
// use index of the new title
// unset any currently chosen title
// unk
/*recvData*/)
// Only players that has not yet gained any experience can use this
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//SF_LOG_DEBUG("misc", "CHAT: packet received. type %u, lang %u", type, lang);
// no language sent with emote packet.
// prevent talking at unknown language (cheating)
// also check SPELL_AURA_COMPREHEND_LANGUAGE (client offers option to speak in that language)
// LANG_ADDON is only valid for the following message types
// Disabled addon channel?
// LANG_ADDON should not be changed nor be affected by flood control
// send in universal language if player in .gm on mode (ignore spell effects)
// send in universal language in two side iteration allowed mode
// allow two side chat at group channel if two side group allowed
// allow two side chat at guild channel if two side guild allowed
// but overwrite it by SPELL_AURA_MOD_LANGUAGE auras (only single case used)
// Prevent warnings
// Strip invisible characters for non-addon messages
// If player is a Gamemaster and doesn't accept whisper, we auto-whitelist every player that the Gamemaster is talking to
// We also do that if a player is under the required level for whispers.
// if player is in battleground, he cannot say to battleground members by /p
// if player is in battleground, he cannot say to battleground members by /ra
//in battleground, raid warning is sent only to players in battleground - code is ok
// battleground raid is always in Player->GetGroup(), never in GetOriginalGroup()
// Already AFK
// Remove AFK
// Update message
// New AFK mode
// Already DND
// Remove DND
// Update message
// New DND mode
// Logging enabled?
// Weird way to log stuff...
// Disabled addon channel?
// Messages sent to "RAID" while in a party will get delivered to "PARTY"
// namespace Skyfire
// Only allow text-emotes for "dead" entities (feign death included)
//Send scripted event call
//SF_LOG_DEBUG("network", "WORLD: Received CMSG_CHAT_IGNORED");
// probably related to spam reporting
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// stop attack state at client
// stop attack state at client
//! Client explicitly checks the following before sending CMSG_ATTACKSWING packet,
//! so we'll place the same check here. Note that it might be possible to reuse this snippet
//! in other places as well.
/*recvData*/)
//SF_LOG_DEBUG("network", "WORLD: Recvd CMSG_SETSHEATHED Message guidlow:%u value1:%u", GetPlayer()->GetGUIDLow(), sheathed);
// we guess size
// must be packed guid
// unk, can be 1 also
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ignore accept from duel-sender
//SF_LOG_DEBUG("network", "WORLD: Received CMSG_DUEL_ACCEPTED");
// player surrendered in a duel using /forfeit
// beg
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* differeces from off:
/* todo:
/* = 0 */)
// LFD cooldown related (used with ERR_PARTY_LFG_BOOT_COOLDOWN_S and ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S)
// player who caused error (in some cases).
// inviter name length
// inverse already in group
// auto decline
// cross realm invite (includes hyphen between inviter and server name)
// realm transfer warning("Accepting this invitation may transfer you to another realm")
// counter
/*for (int i = 0; i < counter; i++)
// unused
// Non-zero in cross realm invites
// Unknown
// Always 0
// unused
// attempt add selected player
// cheating
// no player
// restrict invite to GMs
// can't group with
// just ignore us
// player already in another group or invited
// tell the player that they were invited but it failed as they were already in a group
// not have permissions for invite
// not have place
// ok, but group not exist, start a new group
// but don't create and save the group to the DB until
// at least one person joins
// new group: if can't add then delete
// already existed group: if can't add then just leave
// ok, we do it
// Unknown
// Unknown
/*if (unknown)
// Remove player from invitees in any case
// Group is full
// Forming a new group, create it
// This can happen if the leader is zoning. To be removed once delayed actions for zoning are implemented
// If we're about to create a group there really should be a leader present
// Everything is fine, do it, PLAYER'S GROUP IS SET IN ADDMEMBER!!!
// Remember leader if online (group pointer will be invalid if group gets disbanded)
// uninvite, group can be deleted
// report
//can't uninvite yourself
// Everything's fine, accepted.
// unknown
/*recvData*/)
/** error handling **/
/********************/
// everything's fine, do it
// PartyIndex
// Method
// Threshold
/** error handling **/
/********************/
// everything's fine, do it
// 0: pass, 1: need, 2: greed
//SF_LOG_DEBUG("misc", "Received opcode MSG_MINIMAP_PING X: %f, Y: %f", x, y);
/** error handling **/
/********************/
// everything's fine, do it
/** error handling **/
// < 32768 for urand call
/********************/
// everything's fine, do it
//SF_LOG_DEBUG("misc", "ROLL: MIN: %u, MAX: %u, ROLL: %u", minimum, maximum, roll);
/** error handling **/
/********************/
// everything's fine, do it
// target icon request
// target icon update
// error handling
// everything's fine, do it (is it 0 (PARTY_OP_INVITE) correct code)
// New 4.x: it is now possible to convert a raid to a group if member count is 5 or less
// we will get correct pointer for group here, so we don't have to check if group is BG raid
//17, 20, 22, 19, 23, 18, 16, 21
//18, 22, 17, 21, 19, 20, 16, 23
// Remove main assist flag from current if any.
/*recvData*/)
/** error handling **/
// check is also done client side
/********************/
// everything's fine, do it
// unknown
// leader keeps track of ready check timer
// currently unused
/*recvData*/)
//Group* group = GetPlayer()->GetGroup();
//if (!group)
//    return;
//if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
//    return;
// Is any reaction need?
// if update power type, update current/max power also
// same for pets
// average value
// Ukn
// Ukn
/*
/*
// count
// count
/*this procedure handles clients CMSG_REQUEST_PARTY_MEMBER_STATS request*/
// flags
// only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
// only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
// GROUP_UPDATE_FLAG_STATUS
// GROUP_UPDATE_FLAG_CUR_HP
// GROUP_UPDATE_FLAG_MAX_HP
// GROUP_UPDATE_FLAG_CUR_POWER
// GROUP_UPDATE_FLAG_MAX_POWER
// GROUP_UPDATE_FLAG_LEVEL
// GROUP_UPDATE_FLAG_ZONE
// GROUP_UPDATE_FLAG_POSITION
// GROUP_UPDATE_FLAG_POSITION
// GROUP_UPDATE_FLAG_POSITION
// GROUP_UPDATE_FLAG_AURAS
// placeholder
// count
/*if (AuraEffect const* eff = aurApp->GetBase()->GetEffect(i))
// GROUP_UPDATE_FLAG_AURAS
// GROUP_UPDATE_FLAG_PET_NAME
// GROUP_UPDATE_FLAG_PET_MODEL_ID
// GROUP_UPDATE_FLAG_PET_AURAS
// placeholder
// count
/*
// GROUP_UPDATE_FLAG_PET_AURAS
/*recvData*/)
// every time the player checks the character screen
// 1 always pass, 0 do not pass
// ignore if player not loaded
// needed because STATUS_AUTHED
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Raw player level (1-85), do they use MAX_FINDER_LEVEL when on level 85 ?
// Estimated size
// Request pending
// Unk
// Unk
// Guessed
// Unk
/*recvPacket*/)
// Empty opcode
// unk
// Time since application (seconds)
// Time left to application expiry (seconds)
// Applications count left
// Lists all recruits for a guild - Misses times
// Time in seconds since application submitted.
// TIme in seconds until application expires.
// Unk time
/*recvPacket*/)
// Empty opcode
// Player must be in guild
// Guessed
// Unk Int32
// Sent any time a guild master sets an option in the interface and when listing / unlisting his guild
// Level sent is zero if untouched, force to any (from interface). Idk why
// Player must be in guild
// Player must be guild master
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*recvPacket*/)
/*recvPacket*/)
/*recvPacket*/)
/*recvPacket*/)
// note size
// 0 == Officer, 1 == Public
// note
// Remove fake death
// "You are not part of a guild!";
// "That's not an emblem vendor!"
/* recvPacket */)
/* recvPacket */)
/* recvPacket */)
// Null Packet
// Called when clicking on Guild bank gameobject
// Called when opening guild bank tab only (first one)
// Prevent additional spam at rejected packet
// Prevent additional spam at rejected packet
// source item id
// source bank slot
// source bank tab
// Prevent additional spam at rejected packet
// Since Cata you can buy tabs from the guild constrol tab - no need to check for guid
// Unk
// minGuildLevel
/*recvPacket*/)
// Progress - NYI
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//SF_LOG_DEBUG("network", "WORLD: CMSG_SPLIT_ITEM");
//SF_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u, count = %u", srcbag, srcslot, dstbag, dstslot, count);
//check count - if zero it's fake packet
// can be autostore pos
//SF_LOG_DEBUG("network", "WORLD: CMSG_SWAP_INV_ITEM");
//SF_LOG_DEBUG("STORAGE: receive srcslot = %u, dstslot = %u", srcslot, dstslot);
// prevent attempt swap same item to current position generated by client at special cheating sequence
// cheating attempt, client should never send opcode in that case
//SF_LOG_DEBUG("network", "WORLD: CMSG_SWAP_ITEM");
//SF_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u", srcbag, srcslot, dstbag, dstslot);
// prevent attempt swap same item to current position generated by client at special checting sequence
//SF_LOG_DEBUG("network", "WORLD: CMSG_AUTOEQUIP_ITEM");
//SF_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u", srcbag, srcslot);
// only at cheat
// prevent equip in same slot, only at cheat
// empty slot, simple case
// have currently equipped item, not simple case
// check dest->src move possibility
// now do moves, remove...
// add to dest
// add to src
//SF_LOG_DEBUG("network", "WORLD: CMSG_DESTROY_ITEM");
//SF_LOG_DEBUG("STORAGE: receive bag = %u, slot = %u, count = %u", bag, slot, count);
// prevent drop unequipable items (in combat, for example) and non-empty bags
// remove fake death
// prevent sell not owner item
// prevent sell non empty bag by drag-and-drop at vendor's item list
// prevent sell currently looted item
// prevent selling item for sellprice when the item is still refundable
// this probably happens when right clicking a refundable item, the client sends both
// CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
// Therefore, no feedback to client
// special case at auto sell (sell all)
// prevent sell more items that exist in stack (possible only not from client)
// need split items
// remove fake death
// client expects count starting at 1, and we send vendorslot+1 to client already
// cheating
// init for case invalid bagGUID
// find bag slot by bag guid
// bag not found, cheating?
// 1 = item, 2 = currency
// client expects count starting at 1, and we send vendorslot+1 to client already
// cheating
// The client sends the player guid when trying to store an item in the default backpack
// remove fake death
// Stop the npc if moving
//if (rawItemCount > 300),
// rawItemCount = 300; // client cap but uint8 max value is 255
// ignore conditions if GM on
// Respect allowed class
// Only display items in vendor lists for the team the player is on
// Items sold out are not displayed in list
// 1 is items, 2 is currency
// client expects counting to start at 1
// there's no price defined for currencies, only extendedcost is used
// left in stock
// price, only seen currency types that have Extended cost
// 1 is items, 2 is currency
// displayId
// buy count
// client expects counting to start at 1
// else error
// item count
// unknown
// has extended cost
// has unknown
/* It doesn't matter what value is used here (PROBABLY its full vendor size)
//SF_LOG_DEBUG("network", "WORLD: CMSG_AUTOSTORE_BAG_ITEM");
//SF_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u", srcbag, srcslot, dstbag);
// can be autostore pos
// check unequip potability for equipped items and bank bags
// no-op: placed in same slot
// just remove grey item state
// cheating protection
/* not critical if "cheated", and check skip allow by slots in bank windows open by .bank command.
// next slot
// moving from bank to inventory
// moving from inventory to bank
// paper
// item
// cheating: non-wrapper wrapper
// not possable with pacjket from real client
// HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAGS_WRAPPED);
// maybe not correct check  (it is better than nothing)
// save new item, to have alway for `character_gifts` record in `item_instance`
// after save it will be impossible to remove the item from the queue
// item gave inventory record unchanged and can be save standalone
//cheat -> tried to socket same gem multiple times
//missing item to socket
//this slot is excepted when applying / removing meta gem bonus
//get geminfo from dbc storage
//check for hack maybe
// tried to put gem in socket where no socket exists (take care about prismatic sockets)
// no prismatic socket
// not first not-colored (not normaly used) socket
// ok, this is first not colored socket for item with prismatic socket
// tried to put normal gem in meta socket
// tried to put meta gem in normal socket
// tried to put normal gem in cogwheel socket
// tried to put cogwheel gem in normal socket
//get new and old enchantments
// check unique-equipped conditions
// continue check for case when attempt add 2 similar unique equipped gems in one item.
// unique item (for new and already placed bit removed enchantments
// skip self
// unique limit type item
// NOTE: limitEntry->mode is not checked because if item has limit then it is applied in equip case
// new gem
// existing gem
// for equipped item check all equipment for duplicate equipped gems
//save state of socketbonus
//turn off all metagems (except for the target item)
//if a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met
//remove ALL enchants
//current socketbonus state
//if there was a change...
//it is not displayed, client has an inbuilt system to determine if the bonus is activated
//turn on all metagems (except for target item)
// clear tradeable flag
// apply only to equipped item
// item guid
/**
// guess size
// has text
// item guid
// no text
// Read data
// slot of the transmogrified item
// entry of the transmogrifier item, if it's not 0
// guid of the transmogrifier item, if it's not 0
// transmogrified item
// uint16 tempDest;
//// has to be able to equip item transmogrified item
//if (!player->CanEquipItem(slots[i], tempDest, itemTransmogrified, true, true))
//{
//    SF_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the item to be transmogrified (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slots[i], itemTransmogrified->GetEntry());
//    return;
//}
//
//// has to be able to equip item transmogrifier item
//if (!player->CanEquipItem(slots[i], tempDest, itemTransmogrifier, true, true))
//{
//    SF_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the transmogrifier item (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slots[i], itemTransmogrifier->GetEntry());
//    return;
//}
// reset look
// All okay, proceed
// trusting the client, if it got here it has to have enough money
// ... unless client was modified
// 0 cost if reverting look
// Reset the item
// check transmog on item before remove
// Cheating, you cant reforge to a stat that the item already has, nor reforge from a stat that the item does not have
// cheating
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Current itemLevel
// Dungeon entry (id + type)
// Required itemLevel
// Lock status
// Size of lock dungeons
// Is currency
// Is currency
// PartyIndex
// Needs
// Roles
// QueueAsGroup
// remove the type from the dungeon entry
// Always 8
// Join date
// Always 3
// Queue Id
// Check cheating - only leader can leave the queue
// ProposalID
// Id
// Type
// UnixTime
// Player Group Roles
// Agree to kick player
// partyIndex NYI
// Get Random dungeons that can be done at a certain level and expansion
// Get player locked Dungeons
// locksize count
// hasPlayerGuid
// ShortageEligible
// FirstReward
//forloop {} // 64
// if (hasPlayerGuid) {}
// if (hasPlayerGuid) {}
// RewardXP
//forloop {} // ShortageReward
// SpecificQuantity
//forloop {} // BonusCurrency
// PurseLimit
// RewardMoney
//forloop {} // Item
// OverallQuantity
// PurseWeeklyQuantity
// OverallLimit
// Quantity
// CompletionCurrencyID
// Dungeon Entry (id + type)
//forloop {} // Currency
// PurseWeeklyLimit
// Mask
// PurseQuantity
// CompletionLimit
// SpecificLimit
// CompletedMask
// CompletionQuantity
// Dungeon entry (id + type)
// Lock status
// Current itemLevel
// Required itemLevel
// Get the locked dungeons of the other party members
// Raid id to search
//SendLfrUpdateListOpcode(entry);
// Raid id queue to leave
//sLFGMgr->LeaveLfr(GetPlayer(), dungeonId);
/*recvData*/)
// Joined queue outside the dungeon
// Rolecheck Success
// CommentLen
// IsParty
// Joined
// Slots
// NotifyUI
// LfgJoined
// Queued
// SuspendedPlayers
//forloop 75 SuspendedPlayers
// Needs
//forloop 75 SuspendedPlayers
// SubType
// RequestedRoles
// Id
// Comment
// UnixTime
// Reason
// Type
// Accepted
// RoleMask
// RoleCheckStatus
// PartyIndex
// Members
// Leader info MUST be sent 1st :S        
// RoleCheckComplete
// RoleCheckComplete
// JoinSlots
// IsBeginning
// Leader info MUST be sent 1st :S        
// Level
// RolesDesired
// Level
// RolesDesired
// Dungeon
// BlackList
// Slots
// Result
// SubReason2
// SubReason1
// Reason
// Slot
// ResultDetail
// UnixTime
// Id
// Type
// Dungeon
// Player wait time in queue
// Join time
// Wait Tanks
// Tanks needed
// Wait Healers
// Healers needed
// Wait Dps
// Dps needed
// Wait Time
// Average Wait time
// Queue Id
// Random Dungeon Finished
// Dungeon Finished
// MyVoteCompleted
// VotePassed
// MyVote
// VoteInProgress
// VotesNeeded
// TimeLeft
// BootVotes
// TotalVotes
// show random dungeon if player selected random dungeon and it's not lfg group
// ValidCompletedMask
// Players
// MyParty
// Me
// Responded
// Accepted
// SameParty
// ProposalSilent
// Slot
// State
// Id
// ProposalID
// UnixTime
// Role
// CompletedMask
// Type
// In Lfg Queue?
// Error
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// not check distance for GO in case owned GO (fishing bobber case, for example) or Fishing hole GO
// If player is removing the last LootItem, delete the empty container.
/*recvData*/)
// do not check distance for GO if player is the owner of it (ex. fishing bobber)
// remove insignia ONLY in BG
// unlootable type
//item, pickpocket and players can be looted only single player
// Controls the text displayed in chat. 0 is "Your share is..." and 1 is "You loot..."
// "You loot..."
// Delete the money loot record from the DB
// Delete container if empty
// Check possible cheat
// interrupt cast
// cheaters can modify lguid to prevent correct apply loot release code and re-loot
// use internal stored guid
// not check distance for GO in case owned GO (fishing bobber case, for example) or Fishing hole GO
// locked doors are opened with spelleffect openlock, prevent remove its as looted
// The fishing hole used once more
// if the max usage is reached, will be despawned in next tick
// not fully looted object
// if the round robin player release, reset it.
// ONLY remove insignia at BG
// destroy only 5 items from stack in case prospecting and milling
// >=5 checked in spell code, but will work for cheating cases also with removing from another stacks.
// Only delete item if no loot or money (unlooted loot is saved to db)
// item can be looted only single player
// skip pickpocketing loot for speed, skinning timer reduction is no-op in fact
// if the round robin player release, reset it.
// force update of dynamic flags, otherwise other group's players still not able to loot.
//Player is not looking at loot list, he doesn't need to see updates on the loot list
// send duplicate of error massage to master looter
// list of players allowed to receive this item in trade
// not move item from loot to target inventory
// mark as looted
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// both unknown
// money and cod
// attached items count
// client limit
// set to end to avoid warnings spam
// item slot in mail, not used
// packet read complete, now do check
// price hardcoded in client
//do not allow to send to one player more than 100 mails
// do not allow to have more than 100 mails in mailbox.. mails count is in opcode uint8!!! - so max can be 255..
// test the receiver's Faction... or all items are account bound
// prevent sending bag with items (cheat: can be placed in bag after adding equipped empty bag to mail)
// makes the item no longer refundable
// deletes item from character's inventory
// recursive and not have transaction guard into self, item not in inventory and can be save standalone
// if item send to character at another account, then apply item delivery delay
// If theres is an item, there is a one hour delivery delay if sent to another account's character.
// Mail sent between guild members arrives instantly if they have the guild perk "Guild Mail"
// will delete item or place to receiver mail list
//called when mail is read
//called when client deletes mail
// mailTemplateId
// delete shouldn't show up for COD mails
//we can return mail now, so firstly delete the old one
// only return mail if the player exists (and delete if not existing)
// items already included
//we can deallocate old mail
//called when player takes item attached in mail
// prevent cheating with skip client money check
//if there is COD, take COD money from player and send them to sender by mail
// can be calculated early
// check player existence
// save counts before store and possible merge with deleting
// need to set this state, otherwise item cannot be removed later, if neccessary
// save money and mail to prevent cheating
//called when player lists his received mails
//load players mails, and mailed items
// client can't work with packets > max int16 value
// true mail count (includes any skipped mail)
// guess size
// placeholder
// placeholder
// Only first 50 mails are displayed
// skip deleted or not delivered (deliver delay not expired) mails
// skip mail with more than MAX_MAIL_ITEMS items (should not occur)
// skip mail if the packet has become too large (should not occur)
// placeholder
// has guid
// unknown
// unknown
// unknown
// recalculate m_nextMailDelivereTime and unReadMails
//used when player copies mail body to his inventory
// This is not bag and then can be used new Item.
// in mail template case we need create new item text
/// @todo Fix me! ... this void has probably bad condition, but good data are sent
/*recvData*/)
// float
// count
// must be not checked yet
// and already delivered
// only send each mail sender once
// player guid
// non-player entries
// do not display more than 2 mails
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// silently return, client should display the error by itself
// the world update order is sessions, players, creatures
// the netcode runs in parallel with all of these
// creatures can kill players
// so if the server is lagging enough the player can
// release spirit after he's killed but before he is updated
//this is spirit release confirm?
// remove fake death
//CMSG_WHO
// 10 is client limit
// race mask
// minimal player level, default 100 (MAX_LEVEL)
// maximal player level, default 0
// class mask
// zones count, client limit = 10 (2.0.10)
// can't be received from real client or broken packet
// can't be received from real client or broken packet
// user entered string, it used as universal search pattern(guild+player name)?
// zone id, 0 if zone is unknown...
// NYI
// SMSG_WHO
// client send in case not set max level value 100 but Skyfire supports 255 max level,
// update it to show GMs with characters after 100 level
//bool allowTwoSideWhoList = sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_WHO_LIST);
// player can see member of other team only if CONFIG_ALLOW_TWO_SIDE_WHO_LIST
// player can see MODERATOR, GAME MASTER, ADMINISTRATOR only if CONFIG_GM_IN_WHO_LIST
// do not process players which are not in world
// check if target is globally visible for player
// check if target's level is in level range
// check if class matches classmask
// check if race matches racemask
// 49 is maximum player count sent to client - can be overridden
// through config, but is unstable
/*recvData*/)
/// TODO: Possibly add RBAC permission to log out in combat
// is jumping or falling
// is dueling or frozen by GM via freeze command
// FIXME - Need the correct value
// instant logout in taverns/cities or on taxi or for admins, gm's, mod's if its enabled in worldserver.conf
// not set flags if player can't free move to prevent lost state at logout cancel
/*recvData*/)
/*recvData*/)
// Player have already logged out serverside, too late to cancel
// not remove flags if can't free move - its not set in Logout request code.
//!we can move again
//! Stand Up
//! DISABLE_ROTATE
// start toggle-off
//if (OutdoorPvP* pvp = _player->GetOutdoorPvP())
//    pvp->HandlePlayerActivityChanged(_player);
// use server size data
//GetPlayer()->SendInitWorldStates(true, newZone);
/*recvPacket*/)
/*recvPacket*/)
// client max
// SF_LOG_DEBUG("network", "WORLD: Received CMSG_STAND_STATE_CHANGE"); -- too many spam in log at lags/debug stop
// always 1
//not add yourself
// ignore list full
// do not allow corpse reclaim in arena
// body not released yet
// prevent resurrect before 30-sec delay after body release not finished
// resurrect
// spawn bones
// reject
// delta is safe radius
// if we have radius check it
// we have only extent
// rotate the players position instead of rotating the whole cube, that way we can make a simplified
// is-in-cube check and we have to calculate only one point instead of 4
// 2PI = 360°, keep in mind that ingame orientation is counter-clockwise
// box edges are parallel to coordiante axis, so we can treat every dimension independently :D
// set resting flag we are in the inn
// erase
// unneeded warning spam in this case
// unneeded warning spam in this case
// type (0-7)
// decompressed length
// unix time
// Instructs the server we wish to receive few amounts of large packets (SMSG_MULTIPLE_PACKETS?)
// instead of large amount of small packets
/*recvData*/)
/*recvData*/)
//TODO!
/*
// no used
// prevent warnings spam
// no used
// prevent warnings spam
/*
// now can skip not our packet
// prevent warnings spam
// unk
// unk2
// no used
// prevent warnings spam
/*
// now can skip not our packet
// prevent warnings spam
// unk
// ignore until not logged (check needed because STATUS_AUTHED)
// 0 or 1 expected
// 0 - will not show in chat frame
// yesterday kills
// today kills
// rank
// time in m.sec.
// o (3.141593 = 180 degrees)
// 0 - mail, 1 - chat
// unk 0x01 const, may be spam type (mail/chat)
// player guid
// const 0
// probably mail id
// const 0
// probably language
// message type?
// probably channel id
// time
// spam description string (messagetype, channel name, player name, message)
// NOTE: all chat messages from this spammer automatically ignored by spam reporter until logout in case chat spam.
// if it's mail spam - ALL mails from this spammer automatically removed by client
// Complaint Received message
// value 1 resets CGChat::m_complaintsSystemStatus in client. (unused?)
// value 0xC generates a "CalendarError" in client.
// realm split state
// split states:
// 0x0 realm normal
// 0x1 realm split
// 0x2 realm split pending
//SF_LOG_DEBUG("response sent %u", unk);
// -1 at none
// diff should be small
/*recvData*/)
// cannot reset while in an instance
// the difficulty is set even if the instances can't be reset
//_player->SendDungeonDifficulty(true);
// cannot reset while in an instance
// the difficulty is set even if the instances can't be reset
//_player->SendDungeonDifficulty(true);
/*recvData*/)
//If player is not mounted, so go out :)
// not blizz like; no any messages on blizz
// not blizz like; no any messages on blizz
// Calls Dismount()
// fly mode on/off
// guid - unused
// unk
// unk2
/*recvData */)
/*
/*recvData*/)
// empty opcode
/*recvData*/)
// empty opcode
// Phase.dbc ids
// Inactive terrain swaps
//for (uint8 i = 0; i < inactiveSwapsCount; ++i)
//    data << uint16(0);
// WorldMapArea.dbc id (controls map display)
// Active terrain swaps
// flags (not phasemask)
// Battlefield and Battleground
// it's not spirit service
// it's not spirit service
/*recvData*/)
/*Battlefield* bf = */sBattlefieldMgr->GetBattlefieldToZoneId(_player->GetZoneId()))
// bf->PlayerAskToLeave(_player); FIXME
// temp: this should be moved once broadcast text is properly implemented
/*
// always set to MSG_MOVE_STOP in client SetOpcode
// do something?
// If create object failed for current player then client will be stuck on loading screen
//if (_player->GetGUID() == guid)
//{
//    LogoutPlayer(true);
//    return;
//}
// Pretend we've never seen this object
//_player->m_clientGUIDs.erase(guid);
// Language Orcish
// Language Pandaren
// Language Common
// Language Pandaren
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*recvData*/)
// ignore unexpected far teleports
// get the teleport destination
// possible errors in the coordinate validity check
// get the destination map entry, not the current one, this will fix homebind and reset greeting
// reset instance validity, except if going to an instance inside an instance
// relocate the player to the teleport destination
// the CanEnter checks are done in TeleporTo but conditions may change
// while the player is in transit, for example the map may get full
// battleground state prepare (in case join to BG), at relogin/tele player not invited
// only add to bg group and object, if the player was invited (else he entered through command)
// cleanup setting if outdated
// We're not in BG
// reset destination bg team
// join to bg case
// flight fast teleport case
// short preparations to continue flight
// battleground state prepare, stop flight
// resurrect character at enter into instance where his corpse exist after add to map
// mount allow check
// update zone immediately, otherwise leave channel will cause crash in mtmap
// honorless target
// in friendly area
// resummon pet
// resummon battle pet
//lets process all delayed operations on successful teleport
// new zone
// honorless target
// in friendly area
// resummon pet
// resummon battle pet
//lets process all delayed operations on successful teleport
// there must always be a mover
// ignore, waiting processing in WorldSession::HandleMoveWorldportAckOpcode and WorldSession::HandleMoveTeleportAck
// prevent warnings spam
/* extract packet */
// prevent tampered movement data
/* handle special cases */
// transports size limited
// (also received at zeppelin leave by some reason with t_* as absolute in continent coordinates, can be safely skipped)
// prevent warnings spam
// prevent warnings spam
// if we boarded a transport, add us to it
// if we were on a transport, leave
// fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
// now client not include swimming flag in case jumping under water
/*----------------------*/
/* process position-change */
/*----------------------*/
/* process position-change */
// this is almost never true (not sure why it is sometimes, but it is), normally use mover->IsVehicle()
// nothing is charmed, or player charmed
// NOTE: this is actually called many times while falling
// even after the player has been teleported away
/// @todo discard movement packets after the player is rooted
// player can be alive if GM/etc
// change the death state to CORPSE to prevent the death timer from
// starting in the next player update
// SplineID?
/* extract packet */
// now can skip not our packet
// prevent warnings spam
/*----------------*/
// client ACK send one packet for mounted/run case and need skip all except last from its
// in other cases anti-cheat check can be fail in false case
// skip all forced speed changes except last and unexpected
// in run/mounted case used one ACK and it must be skipped. m_forced_speed_changes[MOVE_RUN] store both.
// must be greater - just correct
// must be lesser - cheating
/*recvData*/)
// guid - unused
// unk
// unk2
// guid - unused
// unk
// unk2
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// "you don't have enough money"
// "That slot is locked"
// stable success
// unstable/swap success
// buy slot success
// "you are unable to control exotic creatures"
// "Internal pet error"
// remove fake death
// remove fake death
// placeholder
// reputation discount
// learned spell (or cast-spell in profession case)
// spells required (3 max)
// different value for each trainer, also found in CMSG_TRAINER_BUY_SPELL
// remove fake death
// check present spell in trainer spell list
// not found, cheat?
// can't be learn, cheat? Or double learn with lags...
//if (_player->GetTrainerSpellState(trainer_spell) != TRAINER_SPELL_GREEN)
//   SendTrainerBuyFailed(guid, spellId, 0);
//   return;
//}
// apply reputation discount
// check money requirement
// 53 SpellCastDirected
// 113 EmoteSalute
// learn explicitly or cast explicitly
// 1 == "Not enough money for trainer service." 0 == "Trainer service %d unavailable."
// should be same as in packet from client
// set faction visible if needed
// remove fake death
//if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
//    GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
// If spiritguide, no need for gossip menu, just put player into resurrect queue
//        _player->TalkedToCreature(unit->GetEntry(), unit->GetGUID());
/*void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
// remove fake death
// remove fake death
// get corpse nearest graveyard
// now can spawn bones
// teleport to nearest from corpse graveyard, if different from nearest to player ghost
// or update at original position
// or update at original position
// remove fake death
// prevent set homebind to instances in any case
// send spell for homebinding (3286)
// remove fake death
// remove mounts this fix bug where getting pet from stable while mounted deletes pet.
// guess size
// place holder for slot show number
// counter for place holder
// not let move dead pet in slot
// 4.x unknown, some kind of order?
// petname
// 1 = current, 2/3 = in stable (any from 4, 5, ... create problems with proper show)
// petnumber
// creature entry
// level
// name
// 1 = current, 2/3 = in stable (any from 4, 5, ... create problems with proper show)
// set real data to placeholder
// remove fake death
// can't place in stable dead pet
// slots ordered in query, and if not equal then free
// this slot not free, skip
// remove fake death
// if problem in exotic pet
// delete dead pet
// remove fake death
/*StableSlotPricesEntry const* SlotPrice = sStableSlotPricesStore.LookupEntry(GetPlayer()->m_stableSlots+1);
/* recvData */)
// remove fake death
// Find swapped pet slot in stable
// The player's pet could have been removed during the delay of the DB callback
// move alive pet to slot or delete dead pet
// summon unstabled pet
// new in 2.3.2, bool that means from guild bank money
// remove fake death
// reputation discount
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//  sub_68C8FD [5.4.8 18291]
// Position
//delete = 0x07 CastSpell = C1
// used also for charmed creature
/// @todo allow control charmed player?
//If a pet is dismissed, m_Controlled will change
//0x07
//flat=1792  //STAY
//spellid=1792  //FOLLOW
//spellid=1792  //ATTACK
// Can't attack if owner is pacified
//pet->SendPetCastFail(spellid, SPELL_FAILED_PACIFIED);
/// @todo Send proper error message to client
// only place where pet can be player
// This is true if pet has no target or has target but targets differs.
//10% chance to play special pet attack talk, else growl
// 90% chance for pet and 100% chance for charmed creature
// charmed player
// abandon (hunter pet) or dismiss (summoned pet)
//dismissing a summoned pet is like killing them (this prevents returning a soulshard...)
// 0x6
//assist
//passive
//recovery
//activete
// 0x81    spell (disabled), ignore
// 0x01
// 0xC1    spell
// do not cast unknown spells
// do not cast not learned spells
//  Clear the flags as if owner clicked 'attack'. AI will reset them
//  after AttackStart, even if spell failed
//auto turn to target unless possessed
//10% chance to play special pet attack talk, else growl
//actually this only seems to happen on special spells, fire shield for imp, torment for voidwalker, but it's stupid to check every spell
// This is true if pet has no target or has target but targets differs.
/// @todo: confirm this check
// reset specific flags in case of spell fail. AI will reset other flags
// has data
// unknown
// spell case or GM
// stable master case
//ignore invalid position
//if it's act for spell (en/disable/cast) and there is a spell given (0 = remove spell) which pet doesn't know, don't add
//sign for autocast
//sign for no/turn off autocast
// cast can't be helped
// pet/charmed
// do not add not learned spells/ passive spells
// This opcode is also sent from charmed and possessed units (players and creatures)
// do not cast not learned spells
// probably pending spell cast
// 10% chance to play special pet attack talk, else growl
// actually this only seems to happen on special spells, fire shield for imp, torment for voidwalker, but it's stupid to check every spell
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Charters ID in item_template
// prevent cheating
// remove fake death
// if tabard designer, then trying to buy a guild charter.
// do not let if already in guild.
//player hasn't got enough money
// ITEM_FIELD_ENCHANTMENT is guild/arenateam id
// ITEM_FIELD_ENCHANTMENT+1 is current signatures count (showed on item)
// a petition is invalid, if both the owner and the type matches
// we checked above, if this player is in an arenateam, so this must be
// datacorruption
// delete petitions with the same guid as this one
// solve (possible) some strange compile problems with explicit use GUID_LOPART(petitionguid) at some GCC versions (wrong code optimization in compiler?)
// if guild petition and has guild => error, return;
// result == NULL also correct in case no sign yet
// Choice ??? Blizzard also stores declined players ???
// guildID
// ok
// in Skyfire always same as GUID_LOPART(petitionguid)
// guild/team guid (in Skyfire always same as GUID_LOPART(petition guid)
// hasData;
// Unk strings;
//NameLen
// Type - 4 guild
// Required sign count
// Deadline
// ok
// not let enemies sign guild charter
// client signs maximum
// Client doesn't allow to sign petition two times by one character, but not check sign by another character from same account
// not allow sign another player from already sign player account
// close at signer side
// close at signer side
// update signs count on charter, required testing...
//Item* item = _player->GetItemByGuid(petitionguid));
//if (item)
//    item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT+1, signs);
// update for owner if online
// ok
// petition owner online
// ok
// result == NULL also correct charter without signs
// Choice ??? Blizzard also stores declined players ???
// guildID
// Get petition guid from packet
// Check if player really has the required petition charter
// Get petition data from db
// Only the petition owner can turn in the petition
// Petition type (guild/arena) specific checks
// Check if player is already in a guild
// Check if guild name is already taken
// Get petition signatures from db
// Notify player if signatures are missing
// Proceed with guild/arena team creation
// Delete charter item
// Create guild
// Register guild and add guild master
// Add members from signatures
// created
// Petition Cost
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// realmIdSecond
// AccID
//isDeleted ? Wod ?
// virtual and native realm Addresses
// This is disable by default to prevent lots of console spam
// SF_LOG_INFO("network", "HandleNameQueryOpcode %u", guid);
/*recvData*/)
/// Only _static_ data is sent in this packet !!!
// Has data
// Quest items
// Name2, ..., name8
// New in 3.1, kill credit
// Modelid4
// Modelid2
// Expansion Required
// CreatureType.dbc
// Hp modifier
// Flags
// Flags2
// Creature Rank (elite, boss, etc)
// CreatureMovementInfo.dbc
// Subname
// Modelid1
// Modelid3
// "Directions" for guard, string for Icons 2.3.0
// ItemId[6], quest drop
// New in 3.1, kill credit
// Mana modifier
// CreatureFamily.dbc
/// Only _static_ data is sent in this packet !!!
// name2, name3, name4
// 2.0.3, string. Icon name to use instead of default icon for go's (ex: "Attack" makes sword)
// 2.0.3, string. Text will appear in Cast Bar when using GO (ex: "Collecting")
// 2.0.3, string
// go size
// itemId[6], quest drop
// 4.x, unknown
/*recvData*/)
// Not found + guid stream
// if corpse at different map
// search entrance map for proper show entrance
// if corpse map have entrance
// Corpse Found
// size (8 * 4) * 2
// should be a broadcast id
// has data
/// Only _static_ data is sent in this packet !!!
// guess size
// POI count bits
// POI points count bits
// floor id
// POI point x
// POI point y
// objective index
// POI index
// unknown (new 5.x.x)
// unknown (new 5.x.x)
// mapid
// POI points count
// areaid
// unknown (new 5.x.x)
// unknown
// unknown
// quest ID
// POI count
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// do not show quest status to enemies
//inform client about status of quest
// remove fake death
// Stop the npc if moving
// no or incorrect quest giver
// some kind of WPE protection
// prevent cheating
// QUEST_FLAGS_PARTY_ACCEPT
// not self
//need confirmation that any gossip window will close
// destroy not required for quest finish quest starting item
// Verify that the guid is valid and is a questgiver or involved in the requested quest
// not sure here what should happen to quests with QUEST_FLAGS_AUTOCOMPLETE
// if this breaks them, add && object->GetTypeId() == TYPEID_ITEM to this check
// item-started quests never have that flag
// 5.x - reward value is now an item ID and not slot ID
// QUEST_FLAGS_AUTO_SUBMIT
// some kind of WPE protection
// Send next quest
// Only send the quest to the player if the conditions are met
// Send next quest
// Only send the quest to the player if the conditions are met
// some kind of WPE protection
/*recvData*/)
// can't un-equip some items, reject quest cancel
// remove quest src item from player
// QUEST_FLAGS_PARTY_ACCEPT
// NULL, this prevent DB script from duplicate running
// 0 - standard complete quest mode with npc, 1 - auto-complete mode
// some kind of WPE protection
/*recvPacket*/)
// valid values: 0-8
//its imposible, but check ^)
/*recvPacket*/)
// placeholder
// need also pet quests case support
/*recvData*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// check cheating
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// remove fake death
//spell: "Untalent Visual Effect"
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// some spell cast packet including more data (for projectiles?)
// not sure about these two
// Archaeology
// Keystones
// Item id
// Item count
// Fragments
// Currency id
// Currency count
/// @todo add targets.read() check
// ignore for remote control state
// Movement data
// some item classes can be used only in equipped state
// only allow conjured consumable, bandage, poisons (all should have the 2^21 item flag set in DB)
// don't allow items banned in arena
// check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
// Note: If script stop casting it must send appropriate data to client to prevent stuck item in gray state.
// no script or script not process request by self
// ignore for remote control state
// Verify that the bag is an actual bag or wrapped item that can be used "normally"
// locked item
// was not unlocked yet
// wrapped?
// ignore for remote control state
// ignore for remote control state
// ignore for remote control state (for player case)
// prevent spam at ignore packet
// Movement data
// Fake bit
// Fake Bit
// prevent spam at ignore packet
// prevent spam at ignore packet
// If the vehicle creature does not have the spell but it allows the passenger to cast own spells
// change caster to player and let him cast
// prevent spam at ignore packet
// not have spell in spellbook
// prevent spam at ignore packet
// Client is resending autoshot cast opcode when other spell is casted during shoot rotation
// Skip it to prevent "interrupt" message
// can't use our own spells when we're in possession of another unit,
// prevent spam at ignore packet
// client provided targets
// auto-selection buff level base at target level (in spellInfo)
// if rank not found then function return NULL but in explicit cast case original spell can be casted and later failed with appropriate error message
// set count of casts
// Archaeology
// Keystones
// Item id
// Item count
// Fragments
// Currency id
// Currency count
// Fake Bit
// not allow remove spells with attr SPELL_ATTR0_CANT_CANCEL
// channeled spell case (it currently casted then)
// non channeled case:
// don't allow remove non positive spells
// don't allow cancelling passive auras (some of them are visible)
// maybe should only remove one buff when there are multiple?
/*recvPacket*/) { }
/*recvPacket*/)
// may be better send SMSG_CANCEL_AUTO_REPEAT?
// cancel and prepare for deleting
// spellid, not used
// ignore for remote control state (for player case)
// ignore for remote control state
/*recvData*/)
// empty opcode
// silent return, client should display error by itself and not send this opcode
// this will get something not in world. crash
/// @todo Unit::SetCharmedBy: 28782 is not in world but 0 is trying to charm it! -> crash
// DisplayId
// Get unit for which data is needed by client
// Get creator of the unit (SPELL_AURA_CLONE_CASTER does not stack)
// item slots count
// haircolor
// facial hair
// hair 
// skin
// Display items in visible slots
// face
// Position of missile hit
/*recvPacket*/)
// Spell ID
// Cooldown mod in milliseconds
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// cheating checks
// not found nearest
// cheating checks
// remove fake death
// unknown taxi node case
// known taxi node case
// find current node
// Grimwing in Ebon Hold, special case. NOTE: Not perfect, Zul'Aman should not be included according to WoWhead, and I think taxicheat includes it.
//unk
// remove fake death
// find current node
// `true` send to avoid WorldSession::SendTaxiMenu call with one more curlock seartch with same false result.
// used only for proper packet read
// in taxi flight packet received in 2 case:
// 1) end taxi path in far (multi-node) flight
// 2) switch from one map to other in case multim-map taxi path
// we need process only (1)
// far teleport case
// short preparations to continue flight
// if more destinations to go
// current source node for next destination
// Add to taximask middle hubs in taxicheat mode (to prevent having player with disabled taxicheat and not having back flight path)
// skip start fly node
// clear problematic path and next
// not destinations, clear source node
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Don't accept tickets if the ticket queue is disabled. (Ticket UI is greyed out but not fully dependable)
// Player must not have ticket
// flags!?
/*recvData*/)
/*recvData*/)
/*recvData*/)
// Note: This only disables the ticket UI at client side and is not fully reliable
// are we sure this is a uint32? Should ask Zor
/*recvData*/)
/*
// just put the survey into the database
// GMSurveyCurrentSurvey.dbc, column 1 (all 9) ref to GMSurveySurveys.dbc
// sub_survey1, r1, comment1, sub_survey2, r2, comment2, sub_survey3, r3, comment3, sub_survey4, r4, comment4, sub_survey5, r5, comment5, sub_survey6, r6, comment6, sub_survey7, r7, comment7, sub_survey8, r8, comment8, sub_survey9, r9, comment9, sub_survey10, r10, comment10,
// ref to i'th GMSurveySurveys.dbc field (all fields in that dbc point to fields in GMSurveyQuestions.dbc)
// probably some sort of ref to GMSurveyAnswers.dbc
// comment ("Usage: GMSurveyAnswerSubmit(question, rank, comment)")
// just a guess
// just put the lag report into the database...
// can't think of anything else to do with it
/*recvPacket*/)
// empty packet
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// unk bit, usually 0
// zero guid
// unk
// unk
// unk
// unk
// unk
// Not implemented
// Not implemented
// unk
// unk
/*recvPacket*/)
/*recvPacket*/)
/*= true*/)
// this value must be equal to value from TRADE_STATUS_INITIATED status packet (different value for different players to block multiple trades?)
// unk 2
// spell casted on lowest slot item
// 1 means traders data, 0 means own
// trader gold
// trade slots count/number?, = next field in most cases
// unk 5
// trade slots count/number?, = prev field in most cases
// ok
/*3*/; ++enchant_slot)
//==============================================================
// transfer the items to the players
// Ok, if trade item exists and can be stored
// If we trade in both directions we had to check, if the trade will work before we actually do it
// A roll back is not possible after we stored it
// logging
// adjust time (depends on /played)
// store
// logging
// adjust time (depends on /played)
// store
// in case of fatal error log error message
// return the already removed items to the original owner
// return the already removed items to the original owner
//==============================================================
// store items in local list and set 'in-trade' flag
//Can return NULL
// clear 'in-trade' flag
/*recvPacket*/)
// set before checks for propertly undo at problems (it already set in to client)
// not accept case incorrect money amount
// not accept case incorrect money amount
// not accept if some items now can't be trade (cheating)
/*TRADE_STATUS_CANCELLED*/);
//if (item->IsBindedNotWith(_player))   // dont mark as invalid when his item isnt good (not exploitable because if item is invalid trade will fail anyway later on the same check)
//{
//    SendTradeStatus(TRADE_STATUS_NOT_ON_TAPLIST);
//    his_trade->SetAccepted(false, true);
//    return;
//}
// not accept if spell can't be casted now (cheating)
// not accept if spell can't be casted now (cheating)
// inform partner client
// test if item will fit in each inventory
// in case of missing space report error
// execute trade: 1. remove
// execute trade: 2. store
// logging money
// update money
// cleanup
// desynchronized with the other saves here (SaveInventoryAndGoldToDB() not have own transaction guards)
/*recvPacket*/)
/*recvPacket*/)
/*recvPacket*/)
// sent also after LOGOUT COMPLETE
// needed because STATUS_LOGGEDIN_OR_RECENTLY_LOGGOUT
// OK start trade
// unk bit, usually 0
// WTB StartBitStream...
// gold can be incorrect, but this is checked at trade finished.
// send update
// invalid slot number
// check cheating, can't fail with correct client operations
// prevent place single item into many trade slots using cheating and client bugs
// cheating attempt
// invalid slot number
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// something wrong here...
// prevent warnings spam
// prevent warnings spam
// prevent warnings spam
// prev/next
// current vehicle guid
// prevent warnings spam
// creatures can be ejected too from player mounts
/*recvData*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// uint8 isVoiceEnabled, uint8 isMicrophoneEnabled
// Enable Voice button in channel context menu
//channel->EnableVoice(recvData.GetOpcode() == CMSG_CHANNEL_VOICE_ON);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//= 32
//= 16 - UpgradeID
//= 24
//= 28
//= 20
//40
// make this a Player function
// slot
// Item Upgrade Level
// should be always true
//VoidItemSlotA
//if (VoidItemSlotA)
//    data << uint32(VoidItemSlotA);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// it is undefined whether this or objectmgr will be unloaded first
// so we must be prepared for both cases
/*
// initialize reset time
// for normal instances if no creatures are killed the instance will reset in two hours
// normally this will be removed soon after in InstanceMap::Add, prevent error
// Respawn times should be deleted only when the map gets unloaded
// save the resettime for normal instances only when they get unloaded
// the players and groups must be unbound before deleting the save
/*
// save instance data too
// only save the reset time for normal instances
// to cache or not to cache, that is the question
/* true if the instance save is still valid */
// Delete expired instances (Instance related spawns are removed in the following cleanup queries)
// Delete invalid character_instance and party_instance references
// Delete invalid instance references
// Delete invalid references to instance
// Clean invalid references to instance
// Initialize instance id storage (Needs to be done after the trash has been clean out)
// Load reset times and clean expired instances
// NOTE: Use DirectPExecute for tables that will be queried later
// get the current reset times for normal instances (these may need to be updated)
// these are only kept in memory for InstanceSaves that are loaded later
// resettime = 0 in the DB for raid/heroic instances so those are skipped
/*PAIR32(map, difficulty)*/, time_t> ResetTimeMapDiffType;
// index instance ids by map/difficulty pairs for fast reset warning send
/*PAIR32(map, difficulty)*/, uint32 /*instanceid*/ > ResetTimeMapDiffInstances;
// Instances are pulled in ascending order from db and nextInstanceId is initialized with 1,
// so if the instance id is used, increment until we find the first unused one for a potential new instance
// Mark instance id as being used
// update reset time for normal instances with the max creature respawn time + X hours
// schedule the reset times
// load the global respawn times for raid/heroic instances
// update the reset time if the hour in the configs changes
// calculate new global reset times for expired instances and those that have never been reset yet
// add the global reset times to the priority queue
// the reset_delay must be at least one day
// initialize the reset time
// assume that expired instances have already been cleaned
// calculate the next reset time
// schedule the global reset/warning
// find the event in the queue and remove it
// in case the reset time changed (should happen very rarely), we search the whole queue
// for individual normal instances, max creature respawn + X hours
// global reset/warning for a certain map
// schedule the next warning/reset
// unbind all players bound to the instance
// do not allow UnbindInstance to automatically unload the InstanceSaves
// even if save not loaded
// Free up the instance id and allow it to be reused
// global reset for all instances of the given map
// remove all binds to instances of the given map
// delete them from the DB, even if not loaded
// calculate the next reset time
// Update it in the DB
// note: this isn't fast but it's meant to be executed very rarely
// _not_ include difficulty
/// @todo delete creature/gameobject respawn times even if the maps are not loaded
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// loading
//SF_LOG_ERROR("misc", "Inialize boss %u state as %u.", id, (uint32)state);
//not expect any of these should ever be handled
// Send Notify to all players in instance
// Update Achievement Criteria for all players in instance
/*= 0*/, uint32 miscValue2 /*= 0*/, Unit* unit /*= NULL*/)
// Start timed achievement for all players in instance
// Stop timed achievement for all players in instance
// Remove Auras due to Spell on all players in instance
// Cast spell on all players in instance
/*source*/, Unit const* /*target*/ /*= NULL*/, uint32 /*miscvalue1*/ /*= 0*/)
/*= NULL*/, uint8 param1 /*= 0*/, uint8 param2 /*= 0*/)
// size of this packet is at most 15 (usually less)
/*source*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// ITEM_QUALITY_POOR
// ITEM_QUALITY_NORMAL
// ITEM_QUALITY_UNCOMMON
// ITEM_QUALITY_RARE
// ITEM_QUALITY_EPIC
// ITEM_QUALITY_LEGENDARY
// ITEM_QUALITY_ARTIFACT
// Selects invalid loot items to be removed from group possible entries (before rolling)
// A set of loot definitions for items (refs are not allowed)
// Adds an entry to the group (at loading stage)
// True if group includes at least 1 quest drop entry
// The same for active quests of the player
// Rolls an item from the group (if any) and adds the item to the loot
// Overall chance for the group (without equal chanced items)
// Overall chance for the group
// Entries with chances defined in DB
// Zero chances - every entry takes the same chance
// Rolls an item from the group, returns NULL if all miss their chances
// This class must never be copied - storing pointers
//Remove all data and free all memory
// Checks validity of the loot store
// Actual checks are done within LootTemplate::Verify() which is called for every template
// Loads a *_loot_template DB table into loot store
// All checks of the loaded template are called from here, no error reports at loot generation required
// Clearing store (for reloading case)
//                                                  0     1            2               3         4         5             6
// error already printed to log/console.
// it stored in 7 bit field
// Validity checks
// Looking for the template of the entry
// often entries are put together
// Searching the template (in case template Id changed)
// else is empty - template Id and iter are the same
// finally iter refers to already existed or just created <entry, LootTemplate>
// Adds current row to the template
// Checks validity of the loot store
// scan loot for quest items
// all still listed ids isn't referenced
//
// --------- LootStoreItem ---------
//
// Checks if the entry (quest, non-quest, reference) takes it's chance (at loot generation)
// RATE_DROP_ITEMS is no longer used for all types of entries
// reference case
// Checks correctness of values
// item (quest or non-quest) entry, maybe grouped
// Zero chance is allowed for grouped entries only
// loot with low chance
// wrong max count
// mincountOrRef < 0
// no chance for the reference
// Referenced template existence is checked at whole store level
//
// --------- LootItem ---------
//
// Constructor, copies most fields from LootStoreItem and generates random count
// Basic checks for player/item compatibility - if false no chance to see the item in the loot
// DB conditions check
// not show loot for players without profession or those who already know the recipe
// not show loot for not own team
// check quest requirements
//
// --------- Loot ---------
//
// Inserts the item into the loot (called by LootTemplate processors)
// non-conditional one-player only items are counted here,
// free for all items are counted in FillFFALoot(),
// non-ffa conditionals are counted in FillNonQuestNonFFAConditionalLoot()
// Calls processor of corresponding LootTemplate (which handles everything including references)
/*= LOOT_MODE_DEFAULT*/)
// Must be provided
// Processing is done there, callback via Loot::AddItem()
// Setting access rights for group loot case
// should actually be looted object instead of lootOwner but looter has to be really close so doesnt really matter
// ... for personal loot
// if not auto-processed player will have to come and pick it up manually
// Process currency items
// quest items get blocked when they first appear in a
// player's quest vector
//
// increase once if one looter only, looter-times if free for all
//===================================================
// notify all players that are looting this that the item was removed
// convert the index to the slot the player sees
// notify all players that are looting this that the money was removed
// when a free for all questitem is looted
// all players will get notified of it being removed
// (other questitems can be looted by each group member)
// bit inefficient but isn't called often
// find where/if the player has the given item in it's vector
// Deletes a single item associated with an openable item from the DB
// Mark the item looted to prevent resaving
// Deletes money loot associated with an openable item from the DB
// return true if there is any FFA, quest or conditional item for the player.
// return true if there is any item over the group threshold (i.e. not underthreshold).
// canTradeToTapList
// Contains Slot - Always sent
// Unk 2 bits
// Send situ size
// Blizz always send 0 uint32 as situ (read in packet handler)
// Missing unk8
// lootType present
// isPersonalLooting
// Missing unk8
// isAoELooting
// Missing unk8
// Missing unk8
// lootType present
// isPersonalLooting
// Missing unk8
// isAoELooting
// if you are not the round-robin group looter, you can only see
// blocked rolled items and quest items, and !ffa items
// no round robin owner or he has released the loot
// or it IS the round robin group owner
// => item is lootable
// item shall not be displayed.
// item shall not be displayed.
// currency permission loop
// Missing unk8
//update number of items and currencies shown
//
// --------- LootTemplate::LootGroup ---------
//
// Adds an entry to the group (at loading stage)
// Rolls an item from the group, returns NULL if all miss their chances
// First explicitly chanced entries are checked
// check each explicitly chanced entry in the template and modify its chance based on quality.
// If nothing selected yet - an item is taken from equal-chanced part
// Empty drop from the group
// True if group includes at least 1 quest drop entry
// True if group includes at least 1 quest drop entry for active quests of the player
/*conditions*/)
// Rolls an item from the group (if any takes its chance) and adds the item to the loot
// Overall chance for the group without equal chanced items
// Overall chance for the group
/// @todo replace with 100% when DBs will be ready
/*store*/, LootIdSet* ref_set) const
//
// --------- LootTemplate ---------
//
// Adds an entry to the group (at loading stage)
// Group
// Adds new group the the loot template if needed
// Adds new entry to the group
// Non-grouped entries and references are stored together
// Copies the conditions list from a template item to a LootItem
// Rolls for every item in the template and adds the rolled items the the loot
// Group reference uses own processing of the group
// Error message already printed at loading stage
// Rolling non-grouped items
// Do not add if mode mismatch
// Bad luck for the entry
// References processing
// Error message already printed at loading stage
// Ref multiplicator
// Plain entries (not a reference, not grouped)
// Chance is already checked, just add
// Now processing groups
// True if template includes at least 1 quest drop entry
// Group reference
// Error message [should be] already printed at loading stage
// References
// Error message [should be] already printed at loading stage
// quest drop found
// Now processing groups
// True if template includes at least 1 quest drop for an active quest of the player
// Group reference
// Error message already printed at loading stage
// Checking non-grouped entries
// References processing
// Error message already printed at loading stage
// active quest drop found
// Now checking groups
// Checks integrity of the template
// Checking group chances
/// @todo References validity checks
//should never happen, checked at loading
//not found or not reference
// Remove real entries and check loot existence
// output error for any still listed (not referenced from appropriate table) ids
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// Remove real entries and check loot existence
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// output error for any still listed (not referenced from appropriate table) ids
// remove real entries and check existence loot
// possible cases
// not report about not trainable spells (optionally supported by DB)
// ignore 61756 (Northrend Inscription Research (FAST QA VERSION) for example
// output error for any still listed (not referenced from appropriate table) ids
// check references and remove used
// output error for any still listed ids (not referenced from any loot table)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*case TYPEID_ITEM:
// will show mail from not existed player
// what stationery we should use here?
// can be empty
// save for prevent lost at next mail load, if send fail then item will deleted
/*= false*/ )
// sender not exist
// prepare mail and send in other case
// if item send to character at another account, then apply item delivery delay
// set owner to new receiver (to prevent delete item with sender char deleting)
// item not in inventory and can be save standalone
// owner in data will set at mail receive and item extracting
// If theres is an item, there is a one hour delivery delay.
// will delete item or place to receiver mail list
// can be NULL
// generate mail template items
//expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
// auction mail without any items and money
// mail from battlemaster (rewardmarks) should last only one day
// default case: expire time if COD 3 days, if no COD 30 days (or 90 days if sender is a game master)
// Add to DB
// For online receiver update in game mail status and data
// to insert new mail to beginning of maillist
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//ASSERT(obj->GetTypeId() == TYPEID_CORPSE);
// Destroy local transports
/*if (header.mapMagic.asUInt != MapMagic.asUInt || header.versionMagic.asUInt != MapVersionMagic.asUInt)
// x and y are swapped !!
// load grid map for base map
//map already load, delete it before reloading (Is it necessary? Do we really need the ability the reload maps during runtime?)
// map file name
// loading data
// Only load the data for the base map
//z code
//lets initialize visibility distance for map
//init visibility for continents
// Template specialization of utility methods
/*obj*/, bool /*on*/) { }
//This step is not really necessary but we want to do ASSERT in remove/add
//This step is not really necessary but we want to do ASSERT in remove/add
// Note: In case resurrectable corpse and pet its removed from global lists in own destructor
/// @todo I do not know why we need this, it should be removed in ~Object anyway
//Create NGrid so the object can be added to it
//But object data is not loaded here
// build a linkage between this map and NGridType
//z coord
//Load NGrid and make it active
// refresh grid state & timer
//Create NGrid and load the object data in it
// Add resurrectable corpses to world object list in grid
// Check if we are adding to correct map
/*obj*/) { }
/// @todo Needs clean up. An object should not be added to map twice.
//It will create many problems (including crashes) if an object is not added to grid after creation
//The correct way to fix it is to make AddToMap return false and delete the object if it is not added to grid
//But now AddToMap is used in too many places, I will just see how many ASSERT failures it will cause
//Should delete object
//Must already be set before AddToMap. Usually during obj->Create.
//obj->SetMap(this);
//something, such as vehicle, needs to be update immediately
//also, trigger needs to cast spell, if not update, cannot see visual
//TODO: Needs clean up. An object should not be added to map twice.
//Should delete object
// Check for valid position
// Update mobs/objects in ALL visible cells around object!
// marked cells are those that have been visited
// don't visit the same cell twice
/// update worldsessions for existing players
//player->Update(t_diff);
/// update active cells around players and active objects
// for creature
// for pets
// the player iterator is stored in the map object
// to make sure calls to Map::Remove don't invalidate it
// update players at tick
// non-player active objects, increasing iterator in the loop in case of object removal
///- Process necessary scripts
//maybe deleted in logoutplayer when player is not in a map
// if option set then object already saved at this moment
// if option set then object already saved at this moment
//! If hovering, always increase our server-side Z position
//! Client automatically projects correct position based on Z coord sent in monster move
//! and UNIT_FIELD_HOVER_HEIGHT sent in object updates
//! If hovering, always increase our server-side Z position
//! Client automatically projects correct position based on Z coord sent in monster move
//! and UNIT_FIELD_HOVER_HEIGHT sent in object updates
// delay creature move for grid/cell to grid/cell moves
// in diffcell/diffgrid case notifiers called at finishing move creature in Map::MoveAllCreaturesInMoveList
// delay creature move for grid/cell to grid/cell moves
// in diffcell/diffgrid case notifiers called at finishing move go in Map::MoveAllGameObjectsInMoveList
//can this happen?
//can this happen?
//can this happen?
//can this happen?
//pet is teleported to another map
// do move or do move to respawn or remove creature if previous all fail
// update pos
//CreatureRelocationNotify(c, new_cell, new_cell.cellCoord());
// if creature can't be move in new cell/grid (not loaded) move it to repawn cell/grid
// creature coordinates will be updated and notifiers send
// ... or unload (if respawn grid also not loaded)
//AddObjectToRemoveList(Pet*) should only be called in Pet::Remove
//This may happen when a player just logs in and a pet moves to a nearby unloaded cell
//To avoid this, we can load nearby cells when player log in
//But this check is always needed to ensure safety
/// @todo pets will disappear if this is outside CreatureRespawnRelocation
//need to check why pet is frequently relocated to an unloaded cell
//transport is teleported to another map
// do move or do move to respawn or remove creature if previous all fail
// update pos
// if GameObject can't be move in new cell/grid (not loaded) move it to repawn cell/grid
// GameObject coordinates will be updated and notifiers send
// ... or unload (if respawn grid also not loaded)
// in same grid
// if in same cell then none do
// in diff. grids but active creature
// in diff. loaded grid normal creature
// fail to move: normal creature attempt move to unloaded grid
// in same grid
// if in same cell then none do
// in diff. grids but active GameObject
// in diff. loaded grid normal GameObject
// fail to move: normal GameObject attempt move to unloaded grid
//creature will be unloaded with grid
// teleport it to respawn point (like normal respawn if player see)
// prevent possible problems with default move generators
//CreatureRelocationNotify(c, resp_cell, resp_cell.GetCellCoord());
//GameObject will be unloaded with grid
// teleport it to respawn point (like normal respawn if player see)
//pets, possessed creatures (must be active), transport passengers
// Finish creature moves, remove and delete all creatures with delayed remove before moving to respawn grids
// Must know real mob position before move
// move creatures to respawn grids if this is diff.grid or to remove list
// Finish creature moves, remove and delete all creatures with delayed remove before unload
// delete grid map, but don't delete if it is from parent map (and thus only reference)
//+++if (GridMaps[gx][gy]) don't check for GridMaps[gx][gy], we might have to unload vmaps
// this is happening for bg
// clear all delayed moves, useless anyway do this moves before map unload.
// deletes the grid and removes it from the GridRefManager
// *****************************
// Grid function
// *****************************
// Area data
// Height level data
// Liquid data
// Unload old data if exist
// Not return error if file not found
// load up area data
// load up height data
// load up liquid data
/*size*/)
/*size*/)
/*size*/)
/*x*/, float /*y*/) const
// Height stored as: h5 - its v8 grid, h1-h4 - its v9 grid
// +--------------> X
// | h1-------h2     Coordinates is:
// | | \  1  / |     h1 0, 0
// | |  \   /  |     h2 0, 1
// | | 2  h5 3 |     h3 1, 0
// | |  /   \  |     h4 1, 1
// | | /  4  \ |     h5 1/2, 1/2
// | h3-------h4
// V Y
// For find height need
// 1 - detect triangle
// 2 - solve linear equation from triangle points
// Calculate coefficients for solve h = a*x + b*y + c
// Select triangle:
// 1 triangle (h1, h2, h5 points)
// 2 triangle (h1, h3, h5 points)
// 3 triangle (h2, h4, h5 points)
// 4 triangle (h3, h4, h5 points)
// Calculate height
// 1 triangle (h1, h2, h5 points)
// 2 triangle (h1, h3, h5 points)
// 3 triangle (h2, h4, h5 points)
// 4 triangle (h3, h4, h5 points)
// Calculate height
// 1 triangle (h1, h2, h5 points)
// 2 triangle (h1, h3, h5 points)
// 3 triangle (h2, h4, h5 points)
// 4 triangle (h3, h4, h5 points)
// Calculate height
// Why does this return LIQUID data?
// Get water state on map
// Check water type (if no water return)
// Get cell
// Check water type in cell
// Check req liquid type mask
// Check water level:
// Check water height map
// Get water level
// Get ground level (sub 0.2 for fix some errors)
// Check water level and ground level
// All ok in water -> store data
// For speed check as int values
// Under water
// In water
// Walk on water
// Above water
// half opt method
//grid x
//grid y
// ensure GridMap is loaded
/*= NULL*/, bool /*swim = false*/) const
// we need ground level (including grid height version) for proper return water level in point
/*= true*/, float maxSearchDist /*= DEFAULT_HEIGHT_SEARCH*/) const
// find raw .map surface under Z coordinates
// look from a bit higher pos to find the floor, ignore under surface case
// look from a bit higher pos to find the floor
// mapHeight set for any above raw ground Z or <= INVALID_HEIGHT
// vmapheight set for any under Z value or <= INVALID_HEIGHT
// we have mapheight and vmapheight and must select more appropriate
// we are already under the surface or vmap height above map heigt
// or if the distance of the vmap height is less the land height distance
// better use .map surface height
// we have only vmapHeight (if have)
// explicitly use map data
/*adtId*/, int32 /*rootId*/, int32 /*groupId*/, WMOAreaTableEntry const* wmoEntry, AreaTableEntry const* atEntry)
// no wmo found? -> outside by default
// check if there's terrain between player height and object height
// z + 2.0f condition taken from GetHeight(), not sure if it's such a great choice...
// this used while not all *.map files generated (instances)
// Check water level and ground level
// All ok in water -> store data
// hardcoded in client like this
// Get position delta
// Under water
// In water
// Walk on water
// Not override LIQUID_MAP_ABOVE_WATER with LIQUID_MAP_NO_WATER:
// hardcoded in client like this
/*=true*/, float maxSearchDist/*=DEFAULT_HEIGHT_SEARCH*/) const
// not crash at error, just output error in debug mode
// send data
// attach to player data current transport data
// build data for self presence in world at own client (one time for map)
// build other passengers at transport also (they always visible and marked as visible and will not send at visibility update at add to map
// Hack to send out transports
// Hack to send out transports
// Don't unload grids if it's battleground, since we may have manually added GOs, creatures, those doesn't load from DB at grid re-load !
// This isn't really bother us, since as soon as we have instanced BG-s, the whole map unloads as the BG gets ended
// The update might delete the map and we need the next map before the iterator gets invalid
// remove or simplify at least cross referenced links
//SF_LOG_DEBUG("maps", "Object (GUID: %u TypeId: %u) added to removing list.", obj->GetGUIDLow(), obj->GetTypeId());
// i_objectsToSwitch is iterated only in Map::RemoveAllObjectsInRemoveList() and it uses
// the contained objects only if GetTypeId() == TYPEID_UNIT , so we can return in all other cases
//SF_LOG_DEBUG("maps", "Object remover 1 check.");
// in case triggered sequence some spell can continue casting after prev CleanupsBeforeDelete call
// make sure that like sources auras/etc removed before destructor start
//SF_LOG_DEBUG("maps", "Object remover 2 check.");
//we must find visible range in cells so we unload only non-visible cells...
// also not allow unloading spawn grid to prevent creating creature clone at load
/*obj*/) { }
// also allow unloading spawn grid
/* ******* Dungeon Instance Maps ******* */
//lets initialize visibility distance for dungeons
// the timer is started by default, and stopped when the first player joins
// this make sure it gets unloaded if for some reason no player joins
//init visibility distance for instances
/*
// allow GM's to enter
// cannot enter if the instance is full (player cap), GMs don't count
// cannot enter while an encounter is in progress on raids
/*Group* group = player->GetGroup();
// cannot enter if instance is in use by another party/soloer that have a
// permanent save in the same instance id
// bypass GMs
// player has not group and there is someone inside, deny entry
// player inside instance has no group or his groups is different to entering player's one, deny entry
/*
/// @todo Not sure about checking player level: already done in HandleAreaTriggerOpcode
// GMs still can teleport player in instance.
// Is it needed?
// Check moved to void WorldSession::HandleMoveWorldportAckOpcode()
//if (!CanEnter(player))
//return false;
// Dungeon only code
// increase current instances (hourly limit)
// get or create an instance save for the map
// check for existing instance binds
// cannot enter other instances if bound permanently
// solo saves should be reset when entering a group
//ASSERT(false);
// bind to the group or keep using the group save
// cannot jump to a different instance without resetting it
// if the group/leader is permanently bound to the instance
// players also become permanently bound when they enter
// events it throws:  1 : INSTANCE_LOCK_WARNING   0 : INSTANCE_LOCK_STOP / INSTANCE_LOCK_START
// set up a solo bind or continue using it
// cannot jump to a different instance without resetting it
// for normal instances cancel the reset schedule when the
// first player enters (no players yet)
// initialize unload state
// this will acquire the same mutex so it cannot be in the previous block
//if last player set unload timer
// for normal instances schedule the reset after all players have left
/// @todo make a global storage for this
/*
// note: since the map may not be loaded when the instance needs to be reset
// the instance must be deleted from the DB by InstanceSaveManager
// notify the players to leave the instance so it can be reset
// set the homebind timer for players inside (1 minute)
// the unload timer is not started
// instead the map will unload immediately after the players have left
// unloaded at next update
// group members outside the instance group don't get bound
// players inside an instance cannot be bound to other instances
// some players may already be permanently bound, in this case nothing happens
// isGM?
// if the leader is not in the instance the group will not get a perm bind
// only for normal instances
// the reset time is only scheduled when there are no payers inside
// it is assumed that the reset time will rarely (if ever) change while the reset is scheduled
// Normal case (expect that regular difficulty always have correct maxplayers)
// DBC have 0 maxplayers for heroic instances with expansion < 2
// The heroic entry exists, so we don't have to check anything, simply return normal max players
// I'd rather ASSERT(false);
/* ******* Battleground Instance Maps ******* */
//lets initialize visibility distance for BG/Arenas
//unlink to prevent crash, always unlink all pointer reference before destruction
//init visibility distance for BG/Arenas
// player number limit is checked in bgmgr, no need to do it here
//Check moved to void WorldSession::HandleMoveWorldportAckOpcode()
//if (!CanEnter(player))
//return false;
// reset instance validity, battleground maps do not homebind
// Delete only
// Delete only
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// fill with zero
//initialize visibility distances for all instance copies
// take care of loaded GridMaps (when unused, unload it!)
// update the instanced maps
// iterator incremented
//m_unloadTimer
// update only here, because it may schedule some bad things before delete
// this may be removed
/*
// Unload instanced maps
// Delete the maps only after everything is unloaded to prevent crashes
// Unload own grids (just dummy(placeholder) grids, neccesary to unload GridMaps!)
/*
// instanceId of the resulting map
// instantiate or find existing bg map for player
// the instance id is set in battlegroundid
// the player's permanent player bind is taken into consideration first
// then the player's group bind and finally the solo bind.
// use the player's difficulty setting (it may not be the same as the group's)
// solo/perm/group
// it is possible that the save exists but the map doesn't
// if no instanceId via group members or instance saves is found
// the instance will be created for the first time
//Seems it is now possible, but I do not know if it should be allowed
//ASSERT(!FindInstanceMap(NewInstanceId));
// load/create a map
// make sure we have a valid map id
// some instances only have one difficulty
// load/create a map
// increments the iterator after erase
// should only unload VMaps if this is the last instance and grid unloading is enabled
// in that case, unload grids of the base map, too
// so in the next map creation, (EnsureGridCreated actually) VMaps will be reloaded
// Free up the instance id and allow it to be reused for bgs and arenas (other instances are handled in the InstanceSaveMgr)
// erase map
/*player*/)
//ASSERT(false);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// debugging code, should be deleted some day
// debugging code, should be deleted some day
// Start mtmaps if needed.
// debugging code, should be deleted some day
// inner class checking only when compiled with debug
//The player has a heroic mode and tries to enter into instance which has no a heroic mode
// Send aborted message for dungeons
// attempt to downscale
// FIXME: mapDiff is never used
//Bypass checks for GMs
// can only enter in a raid group
// probably there must be special opcode, because client has this string constant in GlobalStrings.lua
/// @todo this is not a good place to send the message
// let enter in ghost mode in instance that connected to inner instance with corpse
//Get instance where player's group is bound & its map
/*
// Player permanently bounded to different instance than groups one
/// @todo send some kind of error message to the player
// players are only allowed to enter 5 instances per hour
// instanceId can never be 0 - will not be found
//Other requirements
/// @todo add check for battleground template
// Resize to multiples of 32 (vector<bool> allocates memory the same way)
// Allocation and sizing was done in InitInstanceIds()
// Find the lowest available id starting from the current NextInstanceId (which should be the lowest according to the logic in FreeInstanceId()
// Allocate space if necessary
// Due to the odd memory allocation behavior of vector<bool> we match size to capacity before triggering a new allocation
// If freed instance id is lower than the next id available for new instances, use the freed one instead
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Collect shared pointers into a set to avoid deleting the same memory more than once
// paths are generated per template, saves us from generating it again in case of instanced transports
// transports in instance are only on one map
// Not sure if data8 means the transport can be stopped or that its path in dbc does not contain extra spline points
// Remove special catmull-rom spline points
// Cyclic spline has one more extra point
// last to first is always "teleport", even for closed paths
// first cell is arrived at by teleportation :S
// find the rest of the distances between key points
// Every path segment has its own spline
// remember first stop frame
// remember first stop frame
// at stopping keyframes, we define distSinceStop == 0,
// and distUntilStop is to the next stopping keyframe.
// this is required to properly handle cases of two stopping frames in a row (yes they do exist)
// won't reach full speed
// is still accelerating
// calculate accel+brake time for this short segment
// substract acceleration time
// slowing down
// still accelerating (but will reach full speed)
// calculate accel + cruise + brake time for this long segment
// substract acceleration time
// already slowing down (but reached full speed)
// at full speed
// calculate tFrom times from tTo times
// calculate path times
/*= 0*/, Map* map /*= NULL*/)
// instance case, execute GetGameObjectEntry hook
// SetZoneScript() is called after adding to map, so fetch the script using map
// create transport...
// ...at first waypoint
// initialize the gameobject base
// use preset map for instances (need to know which instance)
// Passengers will be loaded once a player is near
// no transports here
// create transports
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// clear ALL movement generators (including default)
// set new default movement generator
// clear ALL movement generators (including default)
// what about UNIT_STATE_DISTRACTED? Why is this not included?
// probably not the best place to pu this but im not really sure where else to put it.
//! Should be preceded by MovementExpired or Clear if there's an overlying movementgenerator active
// ignore movement request if target not exist
//_owner->ClearUnitState(UNIT_STATE_FOLLOW);
// ignore movement request if target not exist
//_owner->AddUnitState(UNIT_STATE_FOLLOW);
//this function may make players fall below map
//this function may make players fall below map
/*=0*/)
// use larger distance for vmap height search than in most other cases
// Abort too if the ground is very near
// Charge movement is not started when using EVENT_CHARGE_PREPATH
// in case a new one is generated in this slot during directdelete
//We set waypoint movement as new default movement generator
// clear ALL movement generators (including default)
/*while (!empty())
//_owner->GetTypeId() == TYPEID_PLAYER ?
//Mutate(new WaypointMovementGenerator<Player>(path_id, repeatable)):
/*Impl::container_type::iterator it = Impl::c.begin();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 5.4.8 18414
// 112
// 18
// 148
// 149
// 16
// 48
// 140
// 42
// 19
// 136
// 104
// 20
// 61
// 60
// 63
// 58
// 62
// 92
// 59
// 57
// 100
// 56
// 144
// 6
// 172
// 6
// 7
// 23
// 17
// 8
// 7
// 21
// 38
// 22
// 40
// 63
// 88 (22)
// 64
// 61
// 80
// 58
// 56
// 59
// 84 (21)
// 60
// 72
// 57
// 68
// 76
// 62
// 24
// 21
// 17
// 44
// 8
// 48
// 19
// 128
// 132
// 124
// 120
// 29
// 16
// 112
// 18
// 22
// 144
// 42
// 36
// 20
// 23
// 5.4.8 18414
// 40
// 44
// 36
// 140
// 172
// 148
// 32
// 23
// 149
// 144
// 21
// 112
// 28
// 18
// 19
// 16
// 48
// 152
// 24
// 168
// 17
// 104
// 22
// 20
// 56
// 92
// 59
// 61
// 57
// 63
// 60
// 58
// 62
// 100
// 28
// 136
// 24
// 20
// 19
// 23
// 16
// 18
// 21
// 17
// 22
// 156
// 128
// 132
// 124
// 116
// 120
// 60
// 68
// 76
// 72
// 80
// 59
// 62
// 88
// 58
// 57
// 61
// 96
// 84
// 64
// 63
// 56
// 168
// 32
// 144
// 112
// 48
// 5.4.8 18414
// 44
// 36
// 40
// 152
// 24
// 148
// 168
// 19
// 22
// 112
// 149
// 172
// 23
// 18
// 20
// 28
// 48
// 32
// 104
// 140
// 21
// 144
// 17
// 16
// 61
// 59
// 62
// 56
// 63
// 100
// 57
// 58
// 60
// 92
// 24
// 136
// 28
// 18
// 19
// 22
// 17
// 20
// 23
// 156
// 21
// 16
// 128
// 124
// 132
// 120
// 116
// 57
// 59
// 58
// 56
// 96
// 80
// 63
// 64
// 60
// 88
// 68
// 62
// 61
// 72
// 84
// 76
// 168
// 48
// 112
// 32
// 144
// 5.4.8 18414
// 40
// 36
// 44
// 17
// 23
// 28
// 21
// 144
// 48
// 22
// 20
// 149
// 104
// 148
// 152
// 112
// 24
// 32
// 168
// 19
// 172
// 140
// 18
// 16
// 58
// 59
// 57
// 60
// 92
// 61
// 62
// 56
// 63
// 100
// 24
// 28
// 136
// 23
// 17
// 16
// 156
// 18
// 22
// 19
// 20
// 21
// 120
// 128
// 124
// 132
// 116
// 61
// 63
// 80
// 60
// 56
// 72
// 62
// 58
// 68
// 84
// 64
// 88
// 57
// 59
// 96
// 76
// 144
// 48
// 112
// 168
// 32
// 5.4.8 18414
// 40
// 36
// 44
// 21
// 28
// 19
// 18
// 152
// 172
// 112
// 16
// 48
// 32
// 148
// 168
// 20
// 149
// 17
// 22
// 140
// 24
// 144
// 104
// 23
// 63
// 56
// 92
// 59
// 62
// 100
// 58
// 61
// 57
// 60
// 136
// 28
// 24
// 156
// 16
// 22
// 19
// 17
// 18
// 23
// 20
// 21
// 56
// 58
// 76
// 63
// 96
// 61
// 84
// 64
// 88
// 72
// 80
// 68
// 60
// 59
// 62
// 57
// 116
// 120
// 132
// 128
// 124
// 168
// 32
// 144
// 48
// 112
// 5.4.8 18414
// 44
// 36
// 40
// 24
// 149
// 20
// 104
// 23
// 32
// 16
// 28
// 21
// 168
// 172
// 18
// 152
// 48
// 112
// 144
// 22
// 17
// 148
// 140
// 19
// 57
// 59
// 61
// 63
// 62
// 92
// 58
// 100
// 60
// 56
// 136
// 24
// 28
// 18
// 20
// 21
// 22
// 16
// 156
// 19
// 23
// 17
// 144
// 72
// 59
// 58
// 96
// 61
// 88
// 62
// 84
// 60
// 80
// 76
// 68
// 57
// 63
// 64
// 56
// 132
// 128
// 124
// 116
// 120
// 168
// 32
// 48
// 112
// 5.4.8 18414
// 40
// 44
// 36
// 32
// 48
// 23
// 18
// 152
// 140
// 172
// 21
// 19
// 22
// 144
// 20
// 104
// 16
// 24
// 112
// 168
// 28
// 148
// 17
// 149
// 57
// 92
// 56
// 63
// 100
// 59
// 61
// 62
// 58
// 60
// 28
// 24
// 136
// 156
// 17
// 19
// 21
// 18
// 16
// 20
// 23
// 22
// 168
// 84
// 60
// 57
// 61
// 59
// 62
// 80
// 76
// 64
// 56
// 68
// 96
// 63
// 88
// 72
// 58
// 48
// 116
// 128
// 124
// 132
// 120
// 112
// 32
// 144
// 5.4.8 18414
// 44
// 36
// 40
// 28
// 149
// 168
// 148
// 16
// 48
// 140
// 152
// 20
// 17
// 32
// 23
// 112
// 104
// 21
// 24
// 19
// 144
// 18
// 22
// 172
// 57
// 100
// 59
// 60
// 58
// 61
// 56
// 63
// 62
// 92
// 136
// 28
// 24
// 17
// 22
// 23
// 156
// 21
// 16
// 19
// 18
// 20
// 59
// 57
// 62
// 72
// 60
// 96
// 80
// 63
// 76
// 88
// 61
// 58
// 64
// 56
// 68
// 84
// 124
// 128
// 132
// 116
// 120
// 32
// 112
// 144
// 48
// 168
// 5.4.8 18414
// 40
// 44
// 36
// 16
// 32
// 19
// 28
// 112
// 148
// 18
// 149
// 104
// 140
// 21
// 152
// 172
// 20
// 48
// 144
// 23
// 168
// 17
// 22
// 24
// 56
// 58
// 57
// 62
// 63
// 59
// 61
// 100
// 92
// 60
// 24
// 136
// 28
// 16
// 18
// 156
// 19
// 21
// 17
// 23
// 20
// 22
// 58
// 72
// 96
// 62
// 59
// 76
// 61
// 88
// 57
// 68
// 60
// 84
// 80
// 64
// 56
// 63
// 112
// 32
// 116
// 124
// 132
// 128
// 120
// 168
// 144
// 48
// 5.4.8 18414
// 40
// 36
// 44
// 16
// 140
// 152
// 23
// 22
// 20
// 24
// 21
// 144
// 19
// 149
// 104
// 168
// 17
// 172
// 18
// 112
// 28
// 48
// 148
// 32
// 136
// 57
// 62
// 59
// 61
// 58
// 56
// 60
// 100
// 63
// 92
// 24
// 28
// 22
// 23
// 16
// 20
// 17
// 156
// 18
// 19
// 21
// 112
// 57
// 80
// 59
// 88
// 63
// 96
// 61
// 62
// 58
// 56
// 84
// 76
// 68
// 72
// 60
// 64
// 32
// 120
// 124
// 132
// 128
// 116
// 48
// 168
// 144
// 5.4.8 18414
// 44
// 36
// 40
// 48
// 20
// 21
// 148
// 32
// 172
// 149
// 168
// 19
// 17
// 28
// 24
// 16
// 18
// 152
// 104
// 23
// 112
// 144
// 140
// 22
// 100
// 61
// 62
// 58
// 59
// 60
// 63
// 92
// 56
// 57
// 24
// 28
// 136
// 23
// 19
// 22
// 20
// 17
// 156
// 21
// 16
// 18
// 116
// 132
// 124
// 128
// 120
// 112
// 68
// 59
// 64
// 76
// 61
// 88
// 72
// 58
// 57
// 63
// 60
// 56
// 96
// 80
// 62
// 84
// 48
// 144
// 168
// 32
// 5.4.8 18414
// 36
// 44
// 40
// 148
// 172
// 17
// 16
// 24
// 140
// 112
// 168
// 152
// 144
// 28
// 48
// 18
// 32
// 20
// 22
// 21
// 19
// 149
// 104
// 23
// 58
// 92
// 62
// 61
// 59
// 63
// 60
// 100
// 56
// 57
// 24
// 28
// 136
// 21
// 17
// 19
// 16
// 20
// 18
// 22
// 156
// 23
// 128
// 132
// 124
// 120
// 116
// 112
// 96
// 59
// 88
// 63
// 57
// 64
// 80
// 61
// 60
// 58
// 56
// 72
// 84
// 68
// 62
// 76
// 48
// 32
// 144
// 168
// 5.4.8 18414
// 36
// 40
// 44
// 21
// 18
// 140
// 16
// 172
// 148
// 168
// 17
// 152
// 112
// 19
// 20
// 104
// 149
// 22
// 24
// 32
// 28
// 48
// 144
// 23
// 92
// 63
// 60
// 57
// 56
// 61
// 58
// 59
// 100
// 62
// 136
// 28
// 24
// 16
// 19
// 156
// 22
// 17
// 20
// 18
// 21
// 23
// 48
// 120
// 132
// 128
// 124
// 116
// 144
// 64
// 84
// 59
// 76
// 68
// 58
// 62
// 63
// 57
// 60
// 96
// 56
// 80
// 72
// 61
// 88
// 168
// 112
// 32
// 5.4.8 18414
// 44
// 36
// 40
// 140
// 48
// 144
// 32
// 24
// 168
// 22
// 104
// 172
// 28
// 20
// 112
// 21
// 19
// 18
// 152
// 149
// 23
// 16
// 148
// 17
// 63
// 100
// 59
// 57
// 62
// 92
// 58
// 61
// 60
// 56
// 28
// 136
// 24
// 21
// 19
// 156
// 18
// 16
// 17
// 22
// 20
// 23
// 56
// 96
// 57
// 62
// 84
// 68
// 72
// 60
// 88
// 59
// 80
// 64
// 58
// 63
// 61
// 76
// 48
// 144
// 32
// 124
// 128
// 132
// 116
// 120
// 112
// 168
// 5.4.8 18414
// 36
// 44
// 40
// 104
// 152
// 149
// 20
// 21
// 168
// 19
// 172
// 140
// 16
// 17
// 112
// 22
// 24
// 18
// 148
// 28
// 144
// 48
// 23
// 32
// 28
// 57
// 100
// 92
// 59
// 62
// 58
// 56
// 61
// 63
// 60
// 24
// 136
// 18
// 19
// 22
// 156
// 16
// 21
// 20
// 23
// 17
// 84
// 96
// 80
// 68
// 64
// 88
// 60
// 59
// 76
// 56
// 72
// 62
// 63
// 61
// 57
// 58
// 48
// 32
// 128
// 124
// 132
// 120
// 116
// 168
// 144
// 112
// 5.4.8 18414
// 40
// 36
// 44
// 48
// 19
// 104
// 24
// 172
// 16
// 20
// 32
// 23
// 149
// 112
// 21
// 28
// 148
// 22
// 18
// 168
// 152
// 17
// 144
// 140
// 60
// 56
// 59
// 61
// 92
// 57
// 100
// 62
// 58
// 63
// 136
// 28
// 24
// 18
// 21
// 156
// 17
// 16
// 20
// 23
// 22
// 19
// 48
// 32
// 59
// 84
// 68
// 76
// 62
// 96
// 64
// 58
// 88
// 57
// 63
// 72
// 80
// 56
// 60
// 61
// 144
// 120
// 128
// 124
// 132
// 116
// 112
// 168
// 5.4.8 18414
// 36
// 40
// 44
// 140
// 24
// 23
// 16
// 20
// 28
// 112
// 22
// 18
// 148
// 168
// 152
// 104
// 48
// 17
// 149
// 172
// 19
// 21
// 144
// 32
// 56
// 100
// 63
// 92
// 57
// 60
// 61
// 59
// 62
// 58
// 28
// 24
// 136
// 20
// 23
// 17
// 19
// 156
// 18
// 22
// 16
// 21
// 64
// 56
// 59
// 63
// 80
// 61
// 57
// 68
// 96
// 84
// 60
// 88
// 76
// 72
// 58
// 62
// 116
// 124
// 132
// 128
// 120
// 112
// 168
// 144
// 48
// 32
// 5.4.8 18414
// 36
// 40
// 44
// 144
// 104
// 18
// 172
// 28
// 152
// 112
// 32
// 19
// 149
// 22
// 17
// 140
// 168
// 148
// 23
// 16
// 48
// 21
// 24
// 20
// 92
// 58
// 63
// 62
// 61
// 57
// 60
// 100
// 56
// 59
// 24
// 136
// 28
// 21
// 16
// 156
// 23
// 19
// 20
// 17
// 22
// 18
// 59
// 64
// 63
// 56
// 68
// 80
// 88
// 62
// 60
// 57
// 58
// 72
// 84
// 76
// 96
// 61
// 124
// 128
// 132
// 116
// 120
// 32
// 144
// 48
// 168
// 112
// 5.4.8 18414
// 36
// 44
// 40
// 112
// 22
// 48
// 172
// 149
// 148
// 168
// 20
// 28
// 104
// 140
// 17
// 152
// 24
// 23
// 16
// 32
// 19
// 21
// 144
// 18
// 57
// 92
// 61
// 58
// 60
// 62
// 63
// 59
// 100
// 56
// 136
// 24
// 28
// 23
// 22
// 17
// 21
// 20
// 19
// 156
// 16
// 18
// 84
// 57
// 58
// 72
// 64
// 68
// 56
// 62
// 59
// 80
// 76
// 63
// 60
// 61
// 88
// 96
// 124
// 132
// 128
// 120
// 116
// 144
// 112
// 32
// 168
// 48
// 5.4.8 18414
// 44
// 36
// 40
// 48
// 16
// 19
// 23
// 18
// 22
// 28
// 32
// 168
// 104
// 112
// 148
// 172
// 20
// 149
// 21
// 152
// 140
// 24
// 17
// 144
// 92
// 56
// 61
// 60
// 62
// 58
// 57
// 100
// 59
// 63
// 28
// 24
// 136
// 16
// 156
// 20
// 21
// 17
// 23
// 22
// 19
// 18
// 61
// 68
// 60
// 63
// 57
// 59
// 88
// 64
// 76
// 56
// 58
// 72
// 96
// 84
// 80
// 62
// 124
// 132
// 128
// 116
// 120
// 32
// 144
// 112
// 168
// 48
// 5.4.8 18414
// 40
// 36
// 44
// 140
// 144
// 16
// 32
// 148
// 18
// 152
// 48
// 24
// 112
// 19
// 23
// 21
// 28
// 172
// 168
// 104
// 22
// 20
// 149
// 17
// 60
// 61
// 100
// 62
// 59
// 56
// 63
// 57
// 92
// 58
// 28
// 24
// 136
// 16
// 22
// 23
// 17
// 156
// 21
// 19
// 20
// 18
// 128
// 132
// 124
// 116
// 120
// 57
// 64
// 72
// 68
// 61
// 56
// 88
// 62
// 58
// 59
// 80
// 96
// 84
// 60
// 63
// 76
// 112
// 32
// 144
// 48
// 168
// 5.4.8 18414
// 44
// 40
// 36
// 18
// 23
// 19
// 48
// 21
// 172
// 168
// 148
// 24
// 20
// 17
// 144
// 140
// 149
// 104
// 32
// 28
// 152
// 22
// 16
// 112
// 92
// 58
// 62
// 59
// 63
// 61
// 60
// 100
// 57
// 56
// 24
// 28
// 136
// 22
// 19
// 21
// 16
// 20
// 156
// 23
// 18
// 17
// 132
// 124
// 128
// 116
// 120
// 76
// 60
// 63
// 72
// 56
// 84
// 62
// 57
// 80
// 58
// 61
// 64
// 96
// 68
// 59
// 88
// 48
// 32
// 144
// 168
// 112
// 5.4.8 18414
// 40
// 44
// 36
// 16
// 112
// 19
// 148
// 48
// 21
// 149
// 18
// 23
// 17
// 140
// 28
// 104
// 168
// 24
// 22
// 152
// 32
// 20
// 172
// 144
// 61
// 57
// 92
// 60
// 58
// 62
// 56
// 100
// 63
// 59
// 28
// 24
// 136
// 22
// 156
// 16
// 21
// 23
// 17
// 19
// 20
// 18
// 80
// 59
// 96
// 58
// 63
// 56
// 68
// 60
// 61
// 88
// 57
// 64
// 76
// 62
// 84
// 72
// 112
// 48
// 144
// 120
// 132
// 128
// 124
// 116
// 168
// 32
// 5.4.8 18414
// 5.4.8 18414
// 40
// 36
// 44
// 17
// 28
// 18
// 149
// 104
// 148
// 21
// 22
// 24
// 23
// 16
// 32
// 152
// 112
// 168
// 172
// 48
// 140
// 19
// 144
// 20
// 63
// 57
// 60
// 61
// 62
// 100
// 58
// 59
// 56
// 92
// 24
// 28
// 136
// 17
// 18
// 19
// 21
// 23
// 22
// 156
// 20
// 16
// 112
// 32
// 59
// 63
// 61
// 76
// 58
// 68
// 64
// 57
// 84
// 96
// 72
// 88
// 80
// 56
// 60
// 62
// 128
// 132
// 124
// 120
// 116
// 168
// 48
// 144
// 44
// 40
// 36
// 32
// 21
// 24
// 148
// 16
// 172
// 112
// 104
// 152
// 20
// 23
// 19
// 48
// 17
// 168
// 22
// 144
// 149
// 28
// 18
// 140
// 60
// 56
// 63
// 61
// 57
// 59
// 62
// 92
// 58
// 100
// 136
// 24
// 28
// 16
// 21
// 19
// 18
// 17
// 20
// 156
// 22
// 23
// 120
// 132
// 124
// 128
// 116
// 112
// 56
// 61
// 63
// 72
// 58
// 60
// 64
// 57
// 96
// 80
// 68
// 62
// 84
// 59
// 88
// 76
// 144
// 32
// 48
// 168
// 40
// 36
// 44
// 140
// 16
// 28
// 22
// 24
// 172
// 18
// 48
// 168
// 144
// 104
// 17
// 21
// 112
// 148
// 20
// 32
// 152
// 149
// 23
// 19
// 58
// 100
// 63
// 61
// 59
// 57
// 60
// 56
// 62
// 92
// 136
// 24
// 28
// 156
// 20
// 18
// 22
// 19
// 16
// 23
// 17
// 21
// 168
// 63
// 60
// 84
// 59
// 62
// 76
// 56
// 72
// 64
// 80
// 68
// 88
// 57
// 61
// 58
// 96
// 124
// 132
// 128
// 116
// 120
// 144
// 48
// 32
// 112
// 5.4.8 18414
// 40
// 44
// 36
// 184 MSEExtraFloat
// 28
// 168
// 22
// 32
// 140
// 21
// 48
// 149
// 19
// 18
// 17
// 172
// 20
// 104
// 23
// 16
// 152
// 24
// 112
// 144
// 148
// 100
// 57
// 63
// 92
// 56
// 62
// 60
// 59
// 58  
// 61
// 136
// 24
// 28
// 16
// 20
// 18
// 22
// 17
// 19
// 23
// 21
// 156
// 168
// 144
// 58
// 80
// 96
// 57
// 62
// 59
// 72
// 64
// 63
// 76
// 56
// 68
// 88
// 61
// 84
// 60
// 128
// 124
// 132
// 120
// 116
// 48
// 32
// 112
// 5.4.8 18414
// 5.4.8 18414
// 40
// 44
// 36
// 17
// 22
// 149
// 48
// 24
// 112
// 28
// 152
// 32
// 148
// 172
// 168
// 16
// 23
// 18
// 20
// 144
// 140
// 21
// 104
// 19
// 100
// 62
// 58
// 57
// 56
// 92
// 63
// 60
// 61
// 59
// 136
// 28
// 24
// 20
// 22
// 17
// 156
// 23
// 21
// 19
// 16
// 18
// 116
// 128
// 124
// 132
// 120
// 96
// 56
// 76
// 63
// 59
// 64
// 88
// 58
// 72
// 62
// 80
// 68
// 61
// 60
// 84
// 57
// 32
// 168
// 112
// 144
// 48
// 5.4.8 18414
// 44
// 9
// 11
// 10
// 21
// 42
// 8
// 7
// 172
// 104
// 36
// 19
// 28
// 38
// 17
// 6
// 23
// 22
// 20
// 16
// 12
// 18
// 149
// 140
// 148
// 6
// 58
// 100
// 59
// 57
// 60
// 62
// 56
// 92
// 61
// 63
// 136
// 7
// 20
// 17
// 16
// 18
// 21
// 19
// 39
// 23
// 22
// 104 100 (24)
// 104 92 (22)
// 104 (21)
// 104 (16)
// 104 (17)
// 104 (63)
// 104 (80)
// 104 (57)
// 104 (18)
// 104 (19)
// 104 (62)
// 104 (58)
// 104 (59)
// 104 (56)
// 104 (60)
// 104 (61)
// 140 136 (33)
// 140 136 (32)
// 140 136 (31)
// 140 (30)
// 140 (29)  
// 36
// 28
// 21
// 36
// 8
// 38
// 7
// 18
// 20
// 22
// 17
// 16
// 149
// 12
// 148
// 104
// 104 (61)
// 104 (58)
// 104 (56)
// 104 (63)
// 104 (57)
// 104 (62)
// 104 (60)
// 104 (92)
// 104 (59)
// 104 (100)
// 19
// 140
// 42
// 140 (136)
// 23
// 172
// 28
// 7
// 6
// 17
// 104 (61)
// 104 100 (24)
// 104 (59)
// 104 (57)
// 104 (60)
// 104 (18)
// 104 (63)
// 104 (62)
// 104 (58)
// 104 (17)
// 104 (56)
// 104 (80)
// 104 (19)
// 104 (16)
// 104 92 (22)
// 104 (21)
// 18
// 36
// 140 136 (32)
// 140 136 (33)
// 140 136 (31)
// 140 (30)
// 140 (29) 
// 10
// 12
// 39
// 23
// 22
// 20
// 11
// 42
// 19
// 16
// 9
// 28
// 21
// 8
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
//5.4.8 18414
// 5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
//5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
/*= SMSG_PLAYER_MOVE*/, ExtraMovementStatusElement* extras /*= NULL*/)
///! Need to reset current extra element index before writing another packet
//case CMSG_MOVE_NOT_ACTIVE_MOVER:
//    return MoveNotActiveMover;
//case CMSG_DISMISS_CONTROLLED_VEHICLE:
//    return DismissControlledVehicle;
//case SMSG_MOVE_UPDATE_TELEPORT:
//    return MoveUpdateTeleport;
//case CMSG_MOVE_FALL_RESET:
//    return MovementFallReset;
//case CMSG_MOVE_FEATHER_FALL_ACK:
//    return MovementFeatherFallAck;
//case CMSG_MOVE_FORCE_FLIGHT_SPEED_CHANGE_ACK:
//    return MovementForceFlightSpeedChangeAck;
//case CMSG_MOVE_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
//    return MovementForceRunBackSpeedChangeAck;
//case CMSG_MOVE_FORCE_SWIM_SPEED_CHANGE_ACK:
//    return MovementForceSwimSpeedChangeAck;
//case CMSG_MOVE_FORCE_WALK_SPEED_CHANGE_ACK:
//    return MovementForceWalkSpeedChangeAck;
//case CMSG_MOVE_GRAVITY_DISABLE_ACK:
//    return MovementGravityDisableAck;
//case CMSG_MOVE_GRAVITY_ENABLE_ACK:
//    return MovementGravityEnableAck;
//case CMSG_MOVE_HOVER_ACK:
//    return MovementHoverAck;
//case CMSG_MOVE_SET_CAN_FLY:
//    return MovementSetCanFly;
//case CMSG_MOVE_SET_CAN_FLY_ACK:
//    return MovementSetCanFlyAck;
//case CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK:
//    return MovementSetCanTransitionBetweenSwimAndFlyAck;
//case CMSG_MOVE_WATER_WALK_ACK:
//    return MovementWaterWalkAck;
//case MSG_MOVE_SET_RUN_MODE:
//    return MovementSetRunMode;
//case MSG_MOVE_SET_WALK_MODE:
//    return MovementSetWalkMode;
//case SMSG_MOVE_UPDATE_RUN_BACK_SPEED:
//    return MovementUpdateRunBackSpeed;
//case SMSG_MOVE_UPDATE_SWIM_SPEED:
//    return MovementUpdateSwimSpeed;
//case SMSG_MOVE_UPDATE_WALK_SPEED:
//    return MovementUpdateWalkSpeed;
//case CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE:
//    return ChangeSeatsOnControlledVehicle;
//case CMSG_CAST_SPELL:
//case CMSG_PET_CAST_SPELL:
//case CMSG_USE_ITEM:
//    return CastSpellEmbeddedMovement;*/
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
////////////////// PathGenerator //////////////////
// make sure navMesh works - we can run on map w/o mmap
// check if the start and end point have a .mmtile loaded (can we pass via not loaded tile on the way?)
// shortcut out - close enough for us
// first we check the current path
// if the current path doesn't contain the current poly,
// we need to use the expensive navMesh.findNearestPoly
// we don't have it in our old path
// try to get it by findNearestPoly()
// first try with low search box
// bounds of poly search area
// still nothing ..
// try with bigger search box
// Note that the extent should not overlap more than 128 polygons in the navmesh (see dtNavMeshQuery::findNearestPoly)
// *** getting start/end poly logic ***
// we have a hole in our mesh
// make shortcut path and mark it as NOPATH ( with flying and swimming exception )
// its up to caller how he will use this info
// Check both start and end points, if they're both in water, then we can *safely* let the creature move
// One of the points is not in the water, cancel movement.
// we may need a better number here
// we may want to use closestPointOnPolyBoundary instead
// *** poly path generating logic ***
// start and end are on same polygon
// just need to move in straight line
// look for startPoly/endPoly in current path
/// @todo we can merge it with getPathPolyByPosition() loop
// here to carch few bugs
// we moved along the path and the target did not move out of our old poly-path
// our path is a simple subpath case, we have all the data we need
// just "cut" it out
// we are moving on the old path but target moved out
// so we have atleast part of poly-path ready
// try to adjust the suffix of the path instead of recalculating entire length
// at given interval the target cannot get too far from its last location
// thus we have less poly to cover
// sub-path of optimal path is optimal
// take ~80% of the original length
/// @todo play with the values here
// we need any point on our suffix start poly to generate poly-path, so we need last poly in prefix data
// we can hit offmesh connection as last poly - closestPointOnPoly() don't like that
// try to recover by using prev polyref
// suffixStartPoly is still invalid, error state
// generate suffix
// start polygon
// end polygon
// start position
// end position
// polygon search filter
// [out] path
// max number of polygons in output path
// this is probably an error state, but we'll leave it
// and hopefully recover on the next Update
// we still need to copy our preffix
// new path = prefix + suffix - overlap
// either we have no path at all -> first run
// or something went really wrong -> we aren't moving along the path to the target
// just generate new path
// free and invalidate old path data
// start polygon
// end polygon
// start position
// end position
// polygon search filter
// [out] path
// max number of polygons in output path
// only happens if we passed bad data to findPath(), or navmesh is messed up
// by now we know what type of path we can get
// generate the point-path out of our up-to-date poly-path
// start position
// end position
// current path
// lenth of current path
// [out] path corner points
// [out] flags
// [out] shortened path
// maximum number of points/polygons to use
// start position
// end position
// current path
// length of current path
// [out] path corner points
// maximum number of points
// only happens if pass bad data to findStraightPath or navmesh is broken
// single point paths can be generated here
/// @todo check the exact cases
// first point is always our current location - we need the next one
// force the given destination, if needed
// we may want to keep partial subpath
// make two point path, our curr pos is the start, and dest is the end
// set start and a default next position
// walk
// creatures don't take environmental damage
// swim
// assume Player
// perfect support not possible, just stay 'safe'
// allow creatures to cheat and use different movement types if they are moved
// forcefully into terrain they can't normally move in
/// Workaround
/// For some reason, often the tx and ty variables wont get a valid value
/// Use this check to prevent getting negative tile coords and crashing on getTileAt
// Find furthest common polygon.
// If no intersection found just return current path.
// Concatenate paths.
// Adjust beginning of the buffer to include the visited.
// Store visited
// Find steer target.
// Find vertex far enough to steer to.
// Stop at Off-Mesh link or when point is further than slop away.
// Failed to find good point to steer to.
// keep Z value
// Move towards target a small advancement at a time until target reached or
// when ran out of memory to store the path.
// Find location to steer towards.
// Find movement delta.
// If the steer target is end of path or off-mesh link, do not move past the location.
// Move
// Handle end of path and off-mesh links when close enough.
// Reached end of path.
// Advance the path up to and over the off-mesh connection.
// Handle the connection.
// Move position at the other side of the off-mesh link.
// Store results.
// this is most likely a loop
// elevation
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// currently moving, update location
// waiting for next move
// start moving
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// we are inside quiet range
// This calls grant-parent Update method hiden by FleeingMovementGenerator::Update(Creature &, uint32) version
// This is done instead of casting Unit& to Creature& and call parent method, then we can use Unit directly
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// at apply we can select more nice return points base at current movegen
/*time_diff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// StopMoving is needed to make unit stop if its last movement generator expires
// But it should not be sent otherwise there are many redundent packets
// UpdateSplinePosition does not set orientation with UNIT_STATE_ROTATING
// Send spline movement to clients
/*owner*/, uint32 time_diff)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//----- Point Movement Generator
// Call for creature group update
/*diff*/)
// Default value for point motion type is 0.0, if 0.0 spline will use GetSpeed on unit
// Call for creature group update
/*unit*/) { }
// Need restore previous movement since we have no proper states system
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//will be "1 / RUNNING_CHANCE_RANDOMMV"
// For 2D/3D system selection
//bool is_land_ok  = creature.CanWalk();                // not used?
//bool is_water_ok = creature.CanSwim();                // not used?
// prevent invalid coordinates generation
// 3D system above ground and above water (flying mode)
// Limit height change
// Problem here, we must fly above the ground and water, not under. Let's try on next tick
//else if (is_water_ok)                                 // 3D system under water and above ground (swimming mode)
// 2D only
// 10.0 is the max that vmap high can check (MAX_CAN_FALL_DISTANCE)
// The fastest way to get an accurate result 90% of the time.
// Better result can be obtained like 99% accuracy with a ray light, but the cost is too high and the code is too long.
// Map check
// Vmap Horizontal or above
// Vmap Higher
// let's forget this bad coords where a z cannot be find and retry at next tick
//Call for creature group update
// Expire the timer
// use current if in range
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// to nearest contact position
// Pets need special handling.
// We need to subtract GetObjectSize() because it gets added back further down the chain
//  and that makes pets too far away. Subtracting it allows pets to properly
//  be (GetCombatReach() + i_offset) away.
// Only applies when i_target is pet's owner otherwise pets and mobs end up
//   doing a "dance" while fighting
// to at i_offset distance from target and i_angle from target facing
// the destination has not changed, we just need to refresh the path (usually speed change)
// allow pets to use shortcut if no path found when following their master
// Cant reach target
// Using the same condition for facing target as the one that is used for SetInFront on movement end
// - applies to ChaseMovementGenerator mostly
// prevent movement while casting spells with cast time or channel time
// prevent crash after creature killed pet
//More distance let have better performance, less distance let have more sensitive reaction at target move.
//-----------------------------------------------//
/*unit*/) { }
// Pass back the GUIDLow of the target. If it is pet's owner then PetAI will handle
//-----------------------------------------------//
/*owner*/)
// nothing to do for Player
// pet only sync speed with owner
/// Make sure we are not in the process of a map change (IsInWorld)
/*unit*/) { }
// Pass back the GUIDLow of the target. If it is pet's owner then PetAI will handle
//-----------------------------------------------//
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//Basic headers
//Extended headers
//Flightmaster grid preloading
//Creature-specific headers
//Player-specific
// No path id found for entry
// Inform script
// If that's our last waypoint
// else if (vehicle) - this should never happen, vehicle offsets are const
//! If creature is on transport, we assume waypoints set in DB are already transport offsets
//! Do not use formationDest here, MoveTo requires transport offsets due to DisableTransportPathTransformations() call
//! but formationDest contains global coordinates
//! Accepts angles such as 0.00001 and -0.00001, 0 must be ignored, default value in waypoint table
//Call for creature group update
// Waypoint movement can be switched on/off
// This is quite handy for escort quests and other stuff
// prevent a crash at empty waypoint path.
// prevent a crash at empty waypoint path.
//----------------------------------------------------//
// remove flag to prevent send object build movement packets for flight state and crash (movement generator already not at top of stack)
// update z position to ground and orientation for landing point
// this prevent cheating with landing  point at lags
// when client side flight end early in comparison server side
/*diff*/)
/*! Storage to preload flightmaster grid at end of flight. For multi-stop flights, this will
//! Number of nodes in path.
//! MapId of last node
// used to preload the final grid where the flightmaster is
// Load the grid
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Most likely transport Y
// Most likely transport Z
// Most likely transport X
// Parabolic speed // esi+4Ch
// WP count
// Fake bit
// Send no block
// first and last points already appended
// Fake point, client will erase it from the spline after first cycle done
// Most likely transport Y
// Most likely transport Z
// Most likely transport X
// Parabolic speed // esi+4Ch
// WP count
// Fake bit
// Send no block
// NYI Block
// splineInfo.duration_mod_next; added in 3.1
// splineInfo.duration_mod; added in 3.1
// added in 3.1
// added in 3.1
//    NYI block here
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// Velocity bounds that makes fall speed limited
// the time that needed to reach terminalVelocity
// the time that needed to reach terminalVelocity with safefall
/*= 0.0f*/)
// the time that needed to reach terminalVelocity
// 0x00000001,
// 0x00000002,
// 0x00000004,
// 0x00000008,
// 0x00000010,
// 0x00000020,
// 0x00000040,
// 0x00000080,
// 0x00000100,               // Walking
// 0x00000200,
// 0x00000400,
// 0x00000800,
// 0x00001000,
// 0x00002000,
// 0x00004000,
// 0x00008000,
// 0x00010000,
// 0x00020000,
// 0x00040000,
// 0x00080000,
// 0x00100000,               // Appears With Fly Flag Also
// 0x00200000,               // Swim Up Also
// 0x00400000,               // Swim Down Also
// 0x00800000,               // Can Fly In 3.3?
// 0x01000000,               // Actual Flying Mode
// 0x02000000,               // Used For Flight Paths
// 0x04000000,               // Prevent Unit From Falling Through Water
// 0x08000000,               // Active Rogue Safe Fall Spell (Passive)
// 0x10000000
// 0x20000000
// 0x40000000
// 0x80000000
// 0x00000001,
// 0x00000002,
// 0x00000004,
// 0x00000008,
// 0x00000010,
// 0x00000020,
// 0x00000040,           // Not Compartible With Trajectory Movement
// 0x00000080,
// 0x00000100,
// 0x00000200,           // Smooth Movement(Catmullrom Interpolation Mode), Flying Animation
// 0x00000400,           // Model Orientation Fixed
// 0x00000800,           // Used Catmullrom Interpolation Mode
// 0x00001000,           // Movement By Cycled Spline
// 0x00002000,           // Everytime Appears With Cyclic Flag In Monster Move Packet
// 0x00004000,
// 0x00008000
// 0x00010000
// 0x00020000,
// 0x00040000,
// 0x00080000,           // Appears With Runmode Flag, Nodes ), // 1, Handles Orientation
// 0x00100000,
// 0x00200000,
// 0x00400000,
// 0x00800000,
// 0x01000000,           // Animationid (0...3), Uint32 Time, Not Compartible With Trajectory And Fall Movement
// 0x02000000,           // Not Compartible With Fall Movement
// 0x04000000,
// 0x08000000,
// 0x10000000,
// 0x20000000,
// 0x40000000,
// 0x80000000,
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// MoveSplineFlag::Animation disables falling or parabolic movement
//nothing to do for MoveSplineFlag::Final_Target flag
//client use not modified duration here
// -a*x*x + bx + c:
//(dur * v3->z_acceleration * dt)/2 - (v3->z_acceleration * dt * dt)/2 + Z;
// MoveSplineFlag::Enter_Cycle support dropped
//if (splineflags & SPLINEFLAG_ENTER_CYCLE)
//cyclic_point = 1;   // shouldn't be modified, came from client
// init spline timestamps
/// @todo what to do in such cases? problem is in input data (all points are at same coords)
// Check if its a stop spline
// init parabolic / animation
// spline initialized, duration known and i able to compute parabolic acceleration
/// ============================================================================================
//CHECK(_checkPathBounds());
// MONSTER_MOVE packet format limitation for not CatmullRom movement:
// each vertex offset packed into 11 bytes
/// ============================================================================================
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*&& speed_obj.flight >= speed_obj.flight_back*/)
/*&& speed_obj.swim >= speed_obj.swim_back*/)
//if (speed_obj.run > speed_obj.walk)
/*&& speed_obj.run >= speed_obj.run_back*/)
// Flying creatures use MOVEMENTFLAG_CAN_FLY or MOVEMENTFLAG_DISABLE_GRAVITY
// Run speed is their default flight speed.
// Elevators also use MOVEMENTFLAG_ONTRANSPORT but we do not keep track of their position changes
// there is a big chance that current position is unknown if current state is not finalized, need compute it
// this also allows calculate spline position and update map position in much greater intervals
// Don't compute for transport movement if the unit is in a motion between two transports
// should i do the things that user should do? - no.
// correct first vertex
// If spline is initialized with SetWalk method it only means we need to select
// walk move speed for it but not add walk flag to unit
// No need to stop if we are not moving
// Elevators also use MOVEMENTFLAG_ONTRANSPORT but we do not keep track of their position changes
// mix existing state into new
// enabled by default, CatmullRom mode or client config "pathSmoothing" will disable this
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//&SplineBase::InitLinear,
// we should use catmullrom initializer even for linear mode! (client's internal structure limitation)
///////////
/*  classic view:
// first and last two indexes are space for special 'virtual points'
// these points are required for proper C_Evaluate and C_Evaluate_Derivative methtod work
// first and last two indexes are space for special 'virtual points'
// these points are required for proper C_Evaluate and C_Evaluate_Derivative methtod work
/*cyclic*/, index_type /*cyclic_point*/)
//mov_assert(points.size() % 3 == 0);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//                                                0    1         2           3          4            5           6        7      8           9
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// send this too, sometimes the slider disappears, dunno why :(
// send these updates to only the ones in this objective
// send this too, sometimes it resets :S
// check info existence
// get the needed values from goinfo
// can happen when closing the core
// Don't save respawn time
// explicit removal from map
// beats me why this is needed, but with the recent removal "cleanup" some creatures stay in the map if "properly" deleted
// so this is a big fat workaround, if AddObjectToRemoveList and DoDelayedMovesAndRemoves worked correctly, this wouldn't be needed
//if (Map* map = sMapMgr->FindMap(cr->GetMapId()))
//    map->Remove(cr, false);
// delete respawn time for this creature
// instance id, always 0 for world maps
// not save respawn time
// not save respawn time
/*zone*/)
/*zone*/)
// inform the objectives of the leaving
// remove the world state information from the player (we can't keep everyone up to date, so leave out those who are not in the concerning zones)
/*player*/, uint32 /*zone*/) { }
// get the difference of numbers
// horde is in majority, but it's already horde-controlled -> no change
// ally is in majority, but it's already ally-controlled -> no change
// red
// blue
// grey, go through mid point
// if challenger is ally, then n->a challenge
// if challenger is horde, then n->h challenge
// grey, did not go through mid point
// old phase and current are on the same side, so one team challenges the other
//SF_LOG_ERROR("outdoorpvp", "%u->%u", m_OldState, m_State);
// send to all players present in the area
// send to all players present in the area
// skip if too far away
// creature kills must be notified, even if not inside objective / not outdoor pvp active
// player kills only count if active and inside objective
// creature kills must be notified, even if not inside objective / not outdoor pvp active
/*spellId*/, GameObject* /*go*/)
/*player*/, uint64 /*guid*/, uint32 /*id*/)
/*player*/, Creature* /*c*/, GossipMenuItems const& /*gso*/)
/*player*/, uint32 /*id*/)
/*player*/, uint64 guid)
/*player*/, uint32 /*trigger*/)
// This is faster than sWorld->SendZoneMessage
// by stack?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//SF_LOG_DEBUG("outdoorpvp", "Instantiating OutdoorPvPMgr");
//SF_LOG_DEBUG("outdoorpvp", "Deleting OutdoorPvPMgr");
//                                                 0       1
// teleport: remove once in removefromworld, once in updatezone
// no handle for this zone, return
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
////////////////////////////////////////////////////////////
// template class ActivePoolData
// Method that tell amount spawned objects/subpools
// Method that tell if a creature is spawned currently
// Method that tell if a gameobject is spawned currently
// Method that tell if a pool is spawned currently
// Method that tell if a quest can be started
////////////////////////////////////////////////////////////
// Methods of template class PoolGroup
// Method to add a gameobject/creature guid to the proper list depending on pool type and chance value
// Method to check the chances are proper in this object pool
// Triggering object is marked as spawned at this time and can be also rolled (respawn case)
// so this need explicit check for this case
// Triggering object is marked as spawned at this time and can be also rolled (respawn case)
// so this need explicit check for this case
// Main method to despawn a creature or gameobject in a pool
// If no guid is passed, the pool is just removed (event end case)
// If guid is filled, cache will be used and no removal will occur, it just fill the cache
// if spawned
// spawned
// Method that is actualy doing the removal job on one creature
// Same on one gameobject
// Same on one pool
// Same on one quest
// Creatures
// iterator is now no more valid
// but we can exit loop since the element is found
// Gameobjects
// iterator is now no more valid
// but we can exit loop since the element is found
// Method for a pool only to remove any found record causing a circular dependency loop
// If triggered from some object respawn this object is still marked as spawned
// and also counted into m_SpawnedPoolAmount so we need increase count to be
// spawned by 1
// This will try to spawn the rest of pool, not guaranteed
// One spawn one despawn no count increase
// Method that is actualy doing the spawn job on 1 creature
// Spawn if necessary (loaded grids only)
// We use spawn coords to spawn
//SF_LOG_DEBUG("pool", "Spawning creature %u", guid);
// Same for 1 gameobject
// Spawn if necessary (loaded grids only)
// this base map checked as non-instanced and then only existed
// We use current coords to unspawn, not spawn coords since creature can have changed grid
//SF_LOG_DEBUG("pool", "Spawning gameobject %u", guid);
// Same for 1 pool
// Same for 1 quest
// Creatures
// Gameobjects
// load state from db
// always try to select different quests
// clear the pool
// recycle minimal amount of quests if possible count is lower than limit
// failsafe
// activate <limit> random quests
// if we are here it means the pool is initialized at startup and did not have previous saved state
// Method that does the respawn job on the specified creature
// Method that does the respawn job on the specified gameobject
// Nothing to do for a child Pool
/*obj*/) { }
// Nothing to do for a quest
/*obj*/) { }
////////////////////////////////////////////////////////////
// Methods of class PoolMgr
// Pool templates
// Creatures
//                                                 1       2         3
// Gameobjects
//                                                 1        2         3
// Pool of pools
//                                                  1        2            3
// Now check for circular reference
// The initialize method will spawn all pools not in an event and not in another pool, this is why there is 2 left joins with 2 null checks
// The pool is a child pool in pool_pool table. Ideally we should remove it from the pool handler to ensure it never gets spawned,
// however that could recursively invalidate entire chain of mother pools. It can be done in the future but for now we'll do nothing.
// Don't spawn child pools, they are spawned recursively by their parent pools
// anything non-zero means don't load from db
// Call to spawn a pool, if cache if true the method will spawn only if cached entry is different
// If it's same, the creature is respawned only (added back to map)
// Call to spawn a pool, if cache if true the method will spawn only if cached entry is different
// If it's same, the gameobject is respawned only (added back to map)
// Call to spawn a pool, if cache if true the method will spawn only if cached entry is different
// If it's same, the pool is respawned only
// Call to spawn a pool
// Call to despawn a pool, all gameobjects/creatures in this pool are removed
// Method that check chance integrity of the creatures and gameobjects in this pool
// Call to update the pool when a gameobject/creature part of pool [pool_id] is ready to respawn
// Here we cache only the creature/gameobject whose guid is passed as parameter
// Then the spawn pool call will use this cache to decide
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*if (GetRewHonorAddition() > 0 || GetRewHonorMultiplier() > 0.0f)
// values stored from 0.. for 1...
// Note: These next two functions will need to be changed/extended once QuestPackageItem.db2 is implemented
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// in faction.dbc exist factions with (RepListId >=0, listed in character reputation list) with all BaseRepRaceMask[i] == 0
// Faction without recorded reputation. Just ignore.
// faction_id (Faction.dbc)
// reputation rank
// Reset
// RaF data
// fill in absent fields
// fill in encountered data
// Bonus reputation (Your account has unlocked bonus reputation gain with this faction.)
// fill in absent fields
// make faction visible in reputation list at client
// if spillover definition exists in DB, override DBC
// bonuses are already given, so just modify standing by rate
// check for sub-factions that receive spillover
// if has no sub-factions, check for factions with same parent
// some team factions have own reputation standing, in this case do not spill to other sub-factions
// spill to "sister" factions
// Spillover to affiliated factions
// spillover done, update faction itself
// only this faction gets reported to client, even if it has no own visible standing
// int32 *= float cause one point loss?
// Never show factions of the opposing team
// always invisible or hidden faction can't be make visible
// except if faction has FACTION_FLAG_SPECIAL
// already set
// always invisible or hidden faction can't change war state
// always invisible or hidden faction can't change war state
// not allow declare war to own faction
// already set
// always invisible or hidden faction can't be inactive
// already set
// Set initial reputations (so everything is nifty before DB data load)
//QueryResult* result = CharacterDatabase.PQuery("SELECT faction, standing, flags FROM character_reputation WHERE guid = '%u'", GetGUIDLow());
// update standing to current
// update counters
// have internal checks for forced invisibility
// have internal checks for visibility requirement
// DB at war
// have internal checks for FACTION_FLAG_PEACE_FORCED
// DB not at war
// allow remove if visible (and then not FACTION_FLAG_INVISIBLE_FORCED or FACTION_FLAG_HIDDEN)
// have internal checks for FACTION_FLAG_PEACE_FORCED
// set atWar for hostile
// reset changed flag if values similar to saved in DB
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// Put scripts in the execution queue
///- Find the script map
// prepare static data
//some script commands doesn't have source
///- Schedule script execution for all scripts in the script map
///- If one of the effects should be immediate, launch the script execution
/*start &&*/ immedScript && !i_scriptLock)
// NOTE: script record _must_ exist until command executed
// prepare static data
///- If effects should be immediate, launch the script execution
// Helpers for ScriptProcess method.
// Check target first, then source.
// Check target first, then source.
// Check source first, then target.
/// Process queued scripts
///- Process overdue queued scripts
// ok as multimap is a *sorted* associative container
// as well as HIGHGUID_CONTAINER
// empty GUID case also
// must be already checked at load
// Source or target must be Creature.
// must be already checked at load
// Source or target must be Creature.
// Source or target must be Creature.
// Validate field number.
// Source or target must be Creature.
// Source or target must be Creature.
// Validate field number.
// Source or target must be Creature.
// Validate field number.
// Source or target must be Creature.
// Source or target must be Player.
// when script called for item spell casting then target == (unit or GO) and source is player
// quest id and flags checked at script loading
// Source or target must be Player.
// Source or target must be WorldObject.
// Check that GO is not spawned
// Source must be WorldObject.
// Source must be Unit.
// Target must be GameObject.
// Source (datalong2 != 0) or target (datalong2 == 0) must be Unit.
/// @todo Allow gameobjects to be targets and casters
// source/target cast spell at target/source (script->datalong2: 0: s->t 1: s->s 2: t->t 3: t->s
// source -> target
// source -> source
// target -> target
// target -> source
// source -> creature with entry
// Source must be WorldObject.
// PlaySound.Flags bitmask: 0/1=anyone/target
// Target must be Player.
// PlaySound.Flags bitmask: 0/2=without/with distance dependent
// Target or source must be Player.
// Target or source must be Creature.
// Source must be Unit.
//using grid searcher
//check hashmap holders
//Lets choose our ScriptMap map
//if no scriptmap present...
// Insert script into schedule but do not start it
// Source or target must be Creature.
// Source must be Unit.
// Target must be Unit.
// Source must be Creature.
// Source must be Creature.
// Source must be Player.
// Source must be Player.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// spells
//void AddSC_monk_spell_scripts();
//Commands
//world
//eastern kingdoms
//Alterac Valley
//Baradin Hold
//Blackrock Depths
//Blackrock Spire
//Blackwing lair
//void AddSC_deadmines();                      //Deadmines
//void AddSC_instance_deadmines();
//void AddSC_boss_mr_smite();
//Gnomeregan
//Karazhan
// Magister's Terrace
//Molten core
//void AddSC_instance_ragefire_chasm();        //Ragefire Chasm
//Scarlet Enclave
//void AddSC_boss_arcanist_doan();             //Scarlet Monastery
//void AddSC_boss_azshir_the_sleepless();
//void AddSC_boss_bloodmage_thalnos();
//void AddSC_boss_headless_horseman();
//void AddSC_boss_herod();
//void AddSC_boss_high_inquisitor_fairbanks();
//void AddSC_boss_houndmaster_loksey();
//void AddSC_boss_interrogator_vishas();
//void AddSC_boss_scorn();
//void AddSC_instance_scarlet_monastery();
//void AddSC_boss_mograine_and_whitemane();
//void AddSC_boss_darkmaster_gandling();       //Scholomance
//void AddSC_boss_death_knight_darkreaver();
//void AddSC_boss_theolenkrastinov();
//void AddSC_boss_illuciabarov();
//void AddSC_boss_instructormalicia();
//void AddSC_boss_jandicebarov();
//void AddSC_boss_kormok();
//void AddSC_boss_lordalexeibarov();
//void AddSC_boss_lorekeeperpolkelt();
//void AddSC_boss_rasfrost();
//void AddSC_boss_theravenian();
//void AddSC_boss_vectus();
//void AddSC_boss_kirtonos_the_herald();
//void AddSC_instance_scholomance();
//void AddSC_shadowfang_keep();                //Shadowfang keep
//void AddSC_instance_shadowfang_keep();
//Stratholme
//void AddSC_sunken_temple();                  // Sunken Temple
//void AddSC_instance_sunken_temple();
//Sunwell Plateau
//void AddSC_boss_archaedas();                 //Uldaman
//void AddSC_boss_ironaya();
//void AddSC_uldaman();
//void AddSC_instance_uldaman();
//void AddSC_instance_the_stockade();          //The Stockade
//void AddSC_boss_akilzon();                   //Zul'Aman
//void AddSC_boss_halazzi();
//void AddSC_boss_hex_lord_malacrass();
//void AddSC_boss_janalai();
//void AddSC_boss_nalorakk();
//void AddSC_boss_daakara();
//void AddSC_instance_zulaman();
//void AddSC_zulaman();
// Zul'Gurub
//kalimdor
//Blackfathom Depths
//CoT Battle for Mt. Hyjal
//CoT Old Hillsbrad
//CoT The Black Morass
//CoT Culling Of Stratholme
//Dire Maul
//void AddSC_boss_celebras_the_cursed();       //Maraudon
//void AddSC_boss_landslide();
//void AddSC_boss_noxxion();
//void AddSC_boss_ptheradras();
//void AddSC_instance_maraudon();
//Onyxia's Lair
//Razorfen Downs
//Razorfen Kraul
//Ruins of ahn'qiraj
//Temple of ahn'qiraj
//void AddSC_wailing_caverns();                //Wailing caverns
//void AddSC_instance_wailing_caverns();
//void AddSC_boss_zum_rah();                   //Zul'Farrak
//void AddSC_zulfarrak();
//void AddSC_instance_zulfarrak();
//Halls of Origination
//Firelands
// Northrend
// Azjol-Nerub - Azjol-Nerub
// Azjol-Nerub - Ahn'kahet
// Drak'Tharon Keep
//Trial of the Champion
//Trial of the Crusader
//Naxxramas
//The Nexus Nexus
//The Nexus The Oculus
// The Nexus: Eye of Eternity
//Obsidian Sanctum
//Ulduar Halls of Lightning
//Ulduar Halls of Stone
//Ulduar Ulduar
// Utgarde Keep - Utgarde Keep
// Utgarde Keep - Utgarde Pinnacle
// Vault of Archavon
//Violet Hold
//Forge of Souls
//Pit of Saron
// Halls of Reflection
// Icecrown Citadel
// Ruby Sanctum
// Outland
// Auchindoun - Auchenai Crypts
// Auchindoun - Mana Tombs
// Auchindoun - Sekketh Halls
// Auchindoun - Shadow Labyrinth
//Black Temple
//CR Serpent Shrine Cavern
//CR Steam Vault
//The Slave Pens
//CR Underbog
//Gruul's Lair
//HC Blood Furnace
//HC Magtheridon's Lair
//HC Shattered Halls
//HC Ramparts
//TK Arcatraz
//TK Botanica
//TK The Eye
//TK The Mechanar
// Maelstrom
// Events
// Pandaria
// Pets
// battlegrounds
// outdoor pvp
// player
//AddPandariaScripts();
//AddSC_monk_spell_scripts();
//Alterac Valley
//Baradin Hold
//Blackrock Depths
//Blackrock Spire
//Blackwing lair
//AddSC_deadmines();                      //Deadmines
//AddSC_boss_mr_smite();
//AddSC_instance_deadmines();
//Gnomeregan
//Karazhan
// Magister's Terrace
//Molten core
//AddSC_instance_ragefire_chasm();        //Ragefire Chasm
//Scarlet Enclave
//AddSC_boss_arcanist_doan();             //Scarlet Monastery
//AddSC_boss_azshir_the_sleepless();
//AddSC_boss_bloodmage_thalnos();
//AddSC_boss_headless_horseman();
//AddSC_boss_herod();
//AddSC_boss_high_inquisitor_fairbanks();
//AddSC_boss_houndmaster_loksey();
//AddSC_boss_interrogator_vishas();
//AddSC_boss_scorn();
//AddSC_instance_scarlet_monastery();
//AddSC_boss_mograine_and_whitemane();
//AddSC_boss_darkmaster_gandling();       //Scholomance
//AddSC_boss_death_knight_darkreaver();
//AddSC_boss_theolenkrastinov();
//AddSC_boss_illuciabarov();
//AddSC_boss_instructormalicia();
//AddSC_boss_jandicebarov();
//AddSC_boss_kormok();
//AddSC_boss_lordalexeibarov();
//AddSC_boss_lorekeeperpolkelt();
//AddSC_boss_rasfrost();
//AddSC_boss_theravenian();
//AddSC_boss_vectus();
//AddSC_boss_kirtonos_the_herald();
//AddSC_instance_scholomance();
//AddSC_shadowfang_keep();                //Shadowfang keep
//AddSC_instance_shadowfang_keep();
//Stratholme
//AddSC_sunken_temple();                  // Sunken Temple
//AddSC_instance_sunken_temple();
//Sunwell Plateau
//AddSC_instance_the_stockade();          //The Stockade
//AddSC_boss_archaedas();                 //Uldaman
//AddSC_boss_ironaya();
//AddSC_uldaman();
//AddSC_instance_uldaman();
//AddSC_boss_akilzon();                   //Zul'Aman
//AddSC_boss_halazzi();
//AddSC_boss_hex_lord_malacrass();
//AddSC_boss_janalai();
//AddSC_boss_nalorakk();
//AddSC_boss_daakara();
//AddSC_instance_zulaman();
//AddSC_zulaman();
// Zul'Gurub
//Blackfathom Depths
//CoT Battle for Mt. Hyjal
//CoT Old Hillsbrad
//CoT The Black Morass
//CoT Culling Of Stratholme
//Dire Maul
//AddSC_boss_celebras_the_cursed();       //Maraudon
//AddSC_boss_landslide();
//AddSC_boss_noxxion();
//AddSC_boss_ptheradras();
//AddSC_instance_maraudon();
//Onyxia's Lair
//Razorfen Downs
//Razorfen Kraul
//Ruins of ahn'qiraj
//Temple of ahn'qiraj
//AddSC_wailing_caverns();                //Wailing caverns
//AddSC_instance_wailing_caverns();
//AddSC_boss_zum_rah();                   //Zul'Farrak
//AddSC_zulfarrak();
//AddSC_instance_zulfarrak();
//Halls of Origination
//Firelands
// Auchindoun - Auchenai Crypts
// Auchindoun - Mana Tombs
// Auchindoun - Sekketh Halls
// Auchindoun - Shadow Labyrinth
//Black Temple
//CR Serpent Shrine Cavern
//CR Steam Vault
//The Slave Pens
//CR Underbog
//Gruul's Lair
//HC Blood Furnace
//HC Magtheridon's Lair
//HC Shattered Halls
//HC Ramparts
//TK Arcatraz
//TK Botanica
//TK The Eye
//TK The Mechanar
//Gundrak
// Azjol-Nerub - Ahn'kahet
// Azjol-Nerub - Azjol-Nerub
// Drak'Tharon Keep
//Trial of the Champion
//Trial of the Crusader
//Naxxramas
//The Nexus Nexus
//The Nexus The Oculus
// The Nexus: Eye of Eternity
//Obsidian Sanctum
//Ulduar Halls of Lightning
//Ulduar Halls of Stone
//Ulduar Ulduar
// Utgarde Keep - Utgarde Keep
// Utgarde Keep - Utgarde Pinnacle
// Vault of Archavon
//Violet Hold
//Forge of Souls
//Pit of Saron
// Halls of Reflection
// Icecrown Citadel
// Ruby Sanctum
//void AddPandariaScripts()
//{
//#ifdef SCRIPTS
//#endif
//}
/* This is where custom scripts' loading functions should be declared. */
/* This is where custom scripts should be added. */
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// This is the global static registry of scripts.
// The actual list of scripts. This will be accessed concurrently, so it must not be modified
// after server startup.
// See if the script is using the same memory as another script. If this happens, it means that
// someone forgot to allocate new memory for a script.
// Get an ID for the script. An ID only exists if it's a script that is assigned in the database
// through a script name (or similar).
// Try to find an existing script.
// If the script names match...
// ... It exists.
// If the script isn't assigned -> assign it!
// If the script is already assigned -> delete it!
// Error that should be fixed ASAP.
// The script uses a script name from database, but isn't assigned to anything.
// These scripts don't get stored anywhere so throw them into this to avoid leaking memory
// We're dealing with a code-only script; just add it.
// Gets a script by its ID (assigned by ObjectMgr).
// Counter used for code-only scripts.
// Utility macros to refer to the script registry.
// Utility macros for looping over scripts.
// Utility macros for finding specific scripts.
// Clear scripts for every script type.
// This spell doesn't exist.
// Spell targets self.
// Spell targets a single enemy.
// Spell targets AoE at enemy.
// Spell targets an enemy.
// Spell targets a single friend (or self).
// Spell targets AoE friends.
// Spell targets any friend (or self).
// Make sure that this spell includes a damage effect.
// Make sure that this spell includes a healing effect (or an apply aura with a periodic heal).
// Make sure that this spell applies an aura.
/// @todo 100 is a funny magic number to have hanging around here...
/// @todo 100 is a funny magic number to have hanging around here...
/*typeId*/)
/// @todo Implement script-side battlegrounds.
// target can be NULL.
// Player
// Guild
// Group
// Unit
// Instantiate static members of ScriptRegistry.
// Specialize for each script type class like so:
// Undefine utility macros.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Drop Existing Waypoint list
// Load Waypoints
//                                     0       1         2           3           4           5
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//! Compresses packet in place
//! Compresses another packet and stores it in self (source left intact)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
// must be first to make ACE happy with ACE includes in it
// namespace
//let's check if our opcode can be really processed in Map::Update()
//we do not process thread-unsafe packets
//in Map::Update() we do not process packets where player is not in world!
//we should process ALL packets when player is not in world/logged in
//OR packet handler is not thread-safe!
//check if packet handler is supposed to be safe
//thread-unsafe packets should be processed in World::UpdateSessions()
//no player attached? -> our client! ^^
//lets process all packets for non-in-the-world player
/// WorldSession constructor
// One-time query
/// WorldSession destructor
///- unload player if not unloaded
/// - If have unclosed socket, close it
///- empty incoming packet queue
// One-time query
// Z_DATA_ERROR signals that internal state was BUSY
/// Get player guid if available. Use for logging purposes only
/// Send a packet to the client
/*= false*/)
// Code for network use statistic
// next 60 secs start time
// wpos is real written size
// !SKYFIRE_DEBUG
/// Add an incoming packet to the queue
/// Logging helper for unexpected opcodes
/// Logging helper for unexpected opcodes
/// Update the WorldSession (triggered by World update)
/// Update Timeout timer.
///- Before we process anything:
/// If necessary, kick the player from the character select screen
///- Retrieve packets from the receive queue and call the appropriate handlers
/// not process packets if socket already closed
//! Delete packet after processing by default
//! To prevent infinite loop
//! If _recvQueue.peek() == firstDelayedPacket it means that in this Update call, we've processed all
//! *properly timed* packets, and we're now at the part of the queue where we find
//! delayed packets that were re-enqueued due to improper timing. To prevent an infinite
//! loop caused by re-enqueueing the same packets over and over again, we stop updating this session
//! and continue updating others. The re-enqueued packets will be handled in the next Update call for this session.
// skip STATUS_LOGGEDIN opcode unexpected errors if player logout sometime ago - this can be network lag delayed packets
//! If player didn't log out a while ago, it means packets are being sent while the server does not recognize
//! the client to be in world yet. We will re-add the packets to the bottom of the queue and process them later.
//! Prevent infinite loop
//! Because checking a bool is faster than reallocating memory
//! Log
// lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
// There's a short delay between _player = null and m_playerRecentlyLogout = true during logout
// not expected _player or must checked in packet hanlder
// prevent cheating with skip queue wait
// some auth opcodes can be recieved before STATUS_LOGGEDIN_OR_RECENTLY_LOGGOUT opcodes
// however when we recieve CMSG_ENUM_CHARACTERS we are surely no longer during the logout process.
//process only a max amout of packets in 1 Update() call.
//Any leftover will be processed in next update
//check if we are safe to proceed with logout
//logout procedure should happen only in World::UpdateSessions() method!!!
///- If necessary, log the player out
///- Cleanup socket pointer if need
//Will remove this session from the world session map
/// %Log the player out
// finish pending transfers before starting the logout
///- If the player just died before logging out, make him appear as a ghost
//FIXME: logout must be delayed in case lost connection with client in time of combat
// this will kill character by SPELL_AURA_SPIRIT_OF_REDEMPTION
//drop a flag if player is carrying it
///- Teleport to home if the player is in an invalid instance
// Repop at GraveYard or other player far teleport will prevent saving player because of not present map
// Teleport player immediately for correct player save
///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
///- Remove pet
///- Clear whisper whitelist
///- empty buyback items and save the player in the database
// some save parts only correctly work in case player present in map/player_lists (pets, etc)
///- Leave all channels before player delete...
// if player is leader of a group and is holding a ready check, complete it early
///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
// remove player from the group if he is:
// a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
//! Send update to group and reset stored max enchanting level
//! Broadcast a logout message to the player's friends
//! Call script hook before deletion
//! Remove the player from the world
// the player may not be in the world when logging out
// e.g if he got disconnected during a transfer to another map
// calls to GetMap in this case may cause crashes
//! Pointer already deleted during RemovePlayerFromMap
//! Send the 'logout complete' packet to the client
//! Client will respond by sending 3x CMSG_CANCEL_TRADE, which we currently dont handle
// Autolog guid - 0 for logout
// Dafuck ? 1st bit twice read ??????
//! Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
/// Kick a player out of the World
//CMSG_AUTH_CONTINUED_SESSION(void *this, int a2)
/*
// has account info
// has queue info
// has account info
// has queue info
// unk queue bool
// _player can be NULL and packet received after logout but m_GUID still store correct guid
// also unix time
// Server time
// Modify data in DB
// addons count
// check next addon data format correctness
/// @todo Find out when to not use CRC/pubkey, and other possible states.
// Has URL
// If client doesnt have it, send it
// IsBanned
// Those 3 might be in wrong order
// TIME_ZONE_INFORMATION timeZoneInfo;
// GetTimeZoneInformation(&timeZoneInfo);
// wcstombs(timezoneString, timeZoneInfo.StandardName, sizeof(timezoneString));
// The method above cannot be used, because of non-english OS translations, so we send const data (possible strings are hardcoded in the client because of the same reason)
// if we have hit the softcap (64) nothing should be filtered
// empty packet
/*recvPacket*/) // empty packet
// This is always sent after CMSG_UNREGISTER_ALL_ADDON_PREFIXES
// if we have hit the softcap (64) nothing should be filtered
// shouldn't happen
// set m_GUID that can be used while player loggined and later until m_playerRecentlyLogout not reset
// Callback parameters that have pointers in them should be properly
// initialized to NULL here.
//! HandleCharEnumOpcode
// Don't call FreeResult() here, the callback handler will do that depending on the events in the callback chain
//! HandlePlayerLoginOpcode
//! HandleAddFriendOpcode
//- HandleCharRenameOpcode
//- HandleCharAddIgnoreOpcode
//- SendStabledPet
//- HandleStablePet
//- HandleUnstablePet
//- HandleStableSwapPet
// Disabled as it is causing the client to crash
// _warden = new WardenMac();
// _warden->Init(this, k);
// Opcode not allowed, let the punishment begin
// in seconds
// not supported, ban account
// invalid policy
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Dynamic header size is not needed anymore, we are using not encrypted part for only the first few packets
// Dump outgoing packet
// Empty buffer used in case packet should be compressed
// Disable compression for now :)
/* WorldPacket buff;
// Put the packet on the buffer.
// Enqueue the packet.
// Prevent double call to this func.
// This will also prevent the socket from being Updated
// while we are initializing it.
// Hook for the manager.
// Allocate the buffer.
// Store peer address.
// not an opcode. this packet sends raw string WORLD OF WARCRAFT CONNECTION - SERVER TO CLIENT"
// because of our implementation, bytes "WO" become the opcode
// Register with ACE Reactor
// reactor takes care of the socket from now on
// interesting line, isn't it ?
// another interesting line ;)
// MSG_NOSIGNAL
//now n > 0
// move the data to the base of the buffer
//now n == send_len
// MSG_NOSIGNAL
//now n > 0
//now n == send_len
// Critical section
// Critical section
// set errno properly here on error !!!
// now have a header and payload
//need to receive the header
// Couldn't receive the whole header this time.
// We just received nice new header
//need to receive the header
// Couldn't receive the whole header this time.
// We just received nice new header
// Its possible on some error situations that this happens
// for example on closing when epoll receives more chunked data and stuff
// hope this is not hack, as proper m_RecvWPct is asserted around
// We have full read header, now check the data payload
//need more data in the payload
// Couldn't receive the whole data this time.
//just received fresh new payload
// would be good to store errno from reactor with errno guard
// manage memory ;)
// Dump received packet.
//case CMSG_KEEP_ALIVE:
//    sScriptMgr->OnPacketReceive(this, WorldPacket(*new_pct));
//    return 0;
// contains uint32 disconnectReason;
// not an opcode, client sends string "WORLD OF WARCRAFT CONNECTION - CLIENT TO SERVER" without opcode
// first 4 bytes become the opcode (2 dropped)
/*case CMSG_ENABLE_NAGLE:
// prevent invalid memory access/crash with custom opcodes
// Our Idle timer will reset on any non PING opcodes.
// Catches people idling on the login screen and any lingering ingame connections.
// OK, give the packet to WorldSession
// WARNING here we call it with locks held.
// Its possible to cause deadlock if QueuePacket calls back
// Get the account information from the realmd database
//         0           1        2       3          4         5       6          7   8
// SELECT id, sessionkey, last_ip, locked, expansion, mutetime, locale, recruiter, os FROM account WHERE username = ?
// Stop if the account is not found
///- Re-check ip locking (same check as in realmd).
// if ip is locked
//! Negative mutetime indicates amount of seconds to be muted effective on next login - which is now.
// Must be done before WorldSession is created
// Checks gmlevel per Realm
// Re-check account ban (same check as in realmd)
// if account banned
// Check locked state for server
// Check that Key and account name are the same on client and server
// Check if this user is by any chance a recruiter
// Update the last_ip in the database
// NOTE ATM the socket is single-threaded, have this in mind ...
// Initialize Warden system only if it is enabled by config
// Sleep this Network thread for
// Get the ping packet content
// for 1st ping
// critical section
// has account info
// has queue info
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file WorldSocketMgr.cpp
/**
// dont be too smart to move this outside the loop
// the run_reactor_event_loop will modify interval
// -1 means use default
// set some options here
// Set TCP_NODELAY.
// we skip the Acceptor Thread
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*opcode*/, uint16 /*opcodeNumber*/, char const* /*name*/, SessionStatus /*status*/, PacketProcessing /*processing*/, pOpcodeHandler /*handler*/)
// if for some reason we are here, that means NUM_OPCODE_HANDLERS == 0 (or your compiler is broken)
/*opcode*/, uint16 opcodeNumber, char const* /*name*/, SessionStatus /*status*/, PacketProcessing /*processing*/, pOpcodeHandler /*handler*/)
/*opcode*/, uint16 /*opcodeNumber*/, char const* name, SessionStatus /*status*/, PacketProcessing /*processing*/, pOpcodeHandler /*handler*/)
/// Correspondence between opcodes and their names
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414 // LEGACY CMSG sub_600632
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
//UNHANDLED
//5.4.8 18414 - not implemented
//5.4.8 18414 - not implemented
//5.4.8 18414 - not implemented
//5.4.8 18414 - not implemented
//DEFINE_OPCODE_HANDLER(CMSG_GM_TICKET_ACKNOWLEDGE_SURVEY, 0x1093, STATUS_UNHANDLED, PROCESS_THREADUNSAFE, &WorldSession::Handle_NULL);
// Not an opcode
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414 // LEGACY!
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
// 5.4.8 18414
//UNHANDLED
// obsolete
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
//NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
//NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// NYI 5.4.8 18414
// Not an opcode
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// discavered spell
// skill level limitation
// chance
// need for reload
//                                                0        1         2              3
// chance
// spell case
// mechanic discovery
// explicit discovery ability
// skill case
// report about empty data for explicit discovery spells
// skip not explicit discovery spells
// explicit discovery spell chances (always success if case exist)
// in this case we have both skill and spell
// roll now in range 0..full_chance
// check spell case
// check skill line case
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// some type definitions
// no use putting them in the header file, they're only used in this .cpp
// struct to store information about extra item creation
// one entry for every spell that is able to create an extra item
// the spell id of the specialization required to create extra items
// the chance to create one additional item
// maximum number of extra items created per crafting
// map to store the extra item creation info, the key is the spellId of the creation spell, the mapped value is the assigned SkillExtraItemEntry
// loads the extra item creation info from DB
// need for reload
//                                                  0               1                       2                    3
// get the info for the specified spell
// if no entry, then no extra items can be created
// the player doesn't have the required specialization, return false
// set the arguments to the appropriate values
// enable extra item creation
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// relative position guid here - transport for example
// relative position guid here - transport for example
// here it is not guid but slot. Also prevents hacking slots
// update positions by transport move
// Get data for type of attack
// Wands
// Can be override for some spell (wand shoot for example)
// wand case
//Auto Shot & Shoot (wand)
// setup to correct value in Spell::prepare, must not be used before.
// setup to correct value in Spell::prepare, must not be used before.
// will set to castime in prepare
// Determine if spell can be reflected back to the caster
// Patch 1.2 notes: Spell Reflection no longer reflects abilities
// unload scripts
// Clean the reference to avoid later crash.
// If this error is repeating, we may have to add an ASSERT to better track down how we get into this case.
// this function tries to correct spell explicit targets for spell
// client doesn't send explicit targets correctly sometimes - we need to fix such spells serverside
// this also makes sure that we correctly send explicit targets to client (removes redundant data)
// check if object target is valid with needed target flags
// for unit case allow corpse target mask because player with not released corpse is a unit target
// try to select correct unit target if not provided by client or by serverside cast
// try to use player selection as a target
// selection has to be found and to be valid target for the spell
// try to use attacked unit as a target
// didn't find anything - let's use self as target
// check if spell needs dst target
// and target isn't set
// try to use unit target if provided
// or use self if not available
// here go all explicit target changes made to explicit targets after spell prepare phase is finished
// check for explicit target redirection, for Grounding Totem for example
// select targets for cast phase
// not call for empty effect.
// Also some spells use not used effect targets for store targets for dummy effect in triggered spells
// set expected type of implicit targets to be sent to client
// Select targets of effect based on effect type
// those are used when no valid target could be added for spell effect based on spell target type
// some spell effects use explicit target as a default target added to target map (like SPELL_EFFECT_LEARN_SPELL)
// some spell effects add target to target map only when target type specified (like SPELL_EFFECT_WEAPON)
// some spell effects don't add anything to target map (confirmed with sniffs) (like SPELL_EFFECT_DESTROY_ALL_TOTEMS)
// remove targets which did not pass min level check
// Do not check for selfcast
// set the same target list for all effects
// some spells appear to need this, however this requires more research
// targets for effect already selected
// choose which targets we can select at once
// unit target may be no longer avalible - teleported out of map for example
// handle emergency case - try to use other provided targets if no conditions provided
// Other special target selection goes here
// for compability with older code - add only unit and go targets
/// @todo remove this
// find last added target for this effect
// Custom entries
/// @todo remove those
// Raise Dead
// no break;
// wont work until corpses are allowed in target lists, but at least will send dest in packet
// nothing more to do here
// don't add targets to target map
// Corpse Explosion
// check if our target is not valid (spell can target ghoul or dead unit)
// remove existing targets
// for compability with older code - add only unit and go targets
/// @todo remove this
// Special target selection for smart heals and energizes
// Ancestral Awakening
// Echoes of Light (Althor's Abacus normal version)
// Echoes of Light (Althor's Abacus heroic version)
// Glyph of Holy Light
// Replenishment
// In arenas Replenishment may only affect the caster
// Circle of Healing
// Glyph of Circle of Healing
// Divine Hymn
// Hymn of Hope
// Remove targets outside caster's raid
// Wild Growth
// Glyph of Wild Growth
// Remove targets outside caster's raid
// Other special target selection goes here
/// @todo fix this check
// When there is no liquid Map::GetWaterOrGroundLevel returns ground level
// set destination to caster if no dest provided
// can only happen if previous destination target could not be set for some reason
// (not found nearby target, or channel target for example
// maybe we should abort the spell in such case?
// Script hook can remove object target and we would wrongly land here
// mark damage multipliers as used
// Chain primary target is added earlier
// for backward compability
//if (x < std::numeric_limits<float>::max() && x > -std::numeric_limits<float>::max()) return x;
//if (x >= std::numeric_limits<float>::max()) return std::numeric_limits<float>::max();
//if (x <= -std::numeric_limits<float>::max()) return -std::numeric_limits<float>::max();
//a
//(*itr)->IsOnVehicle(m_caster))
// 1/sqrt(3)
/// @todo all calculation should be based on src instead of m_caster
// special case for SPELL_EFFECT_SUMMON_RAF_FRIEND and SPELL_EFFECT_SUMMON_PLAYER
/// @todo this is a workaround - target shouldn't be stored in target map for those spells
// select spell implicit targets based on effect type
// add explicit object target or self to the target map
// player which not released his spirit is Unit, but target flag for it is TARGET_FLAG_CORPSE_MASK
/// @todo this is a workaround - corpses should be added to spell target map too, but we can't do that so we add owner instead
//if (targetMask & TARGET_FLAG_UNIT_MASK)
// add self to the target map
// this function selects which containers need to be searched for spell target
// filter searchers based on searched object type
// search world and grid for possible targets
// max dist for jump target selection
// 7.5y for multi shot
// 5y for swipe, cleave and similar
// 12.5y for chain heal spell since 3.2 patch
// 10y as default for magic chain spells
// chain lightning/heal spells and similar - allow to jump at larger distance and go out of los
// max dist which spell can reach
// remove targets which are always invalid for chain spells
// for some spells allow only chain targets in front of caster (swipe for example)
// try to get unit for next chain jump
// get unit with highest hp deficit in dist
// get closest object
// not found any valid target - chain ends
/*triggeredByAura*/)
//==========================================================================================
// Now fill data for trigger system, need know:
// can spell trigger another or not (m_canTrigger)
// Create base triggers flags for Attacker and Victim (m_procAttacker, m_procVictim and m_procEx)
//==========================================================================================
// Get data for type of attack and fill base info for trigger
// Auto attack
// Ranged spell attack
// Wands auto attack
// For other spells trigger procflags are set in Spell::DoAllEffectOnTarget
// Because spell positivity is dependant on target
// Hunter trap spells - activation proc for Lock and Load, Entrapment and Misdirection
// Freezing and Frost Trap, Freezing Arrow
// Snake Trap - done this way to avoid double proc
// Explosive and Immolation Trap
/* Effects which are result of aura proc from triggered spell cannot proc
// Hellfire Effect - trigger as DOT
// Ranged autorepeat attack is set as triggered spell - ignore it
// Totem casts require spellfamilymask defined in spell_proc_event to proc
/*= true*/, bool implicit /*= true*/)
// no effects left
// Check for effect immune skip if immuned
// Lookup target in already in list
// Found in list
// Immune effects removed from mask
// This is new target calculate data for him
// Get spell hit result on target
// Store target GUID
// Store all effects not immune
// Effects not apply on target
// Calculate hit result
//SPELL_MISS_NONE;
// Spell have speed - need calculate incoming time
// Incoming time is zero for self casts. At least I think so.
// calculate spell incoming interval
/// @todo this is a hack
// Calculate minimum incoming time
// If target reflect spell back to caster
// Calculate reflected spell result on caster
// Impossible reflect again, so simply deflect spell
// Increase time interval for reflected spells by 1.5
// Add target to list
// Lookup target in already in list
// Found in list
// Add only effect mask
// This is new target calculate data for him
// Effects not apply on target
// Spell have speed - need calculate incoming time
// calculate spell incoming interval
// Add target to list
// no effects left
// Lookup target in already in list
// Found in list
// Add only effect mask
// This is new target add data
// Target checked in apply effects procedure
// Get mask of effects for target
// create far target mask
// find unit in world
// do far effects on the unit
// can't use default call because of threading, do stuff as fast as possible
// No missinfo in that case
// Get original caster (if exist) and calculate damage/healing from him data
// Skip if m_originalCaster not avaiable
// Need init unitTarget by default unit (can changed in code on reflect)
// Or on missInfo != SPELL_MISS_NONE unitTarget undefined (but need in trigger subsystem)
// Reset damage/healing counter
// Fill base trigger info
// Set aura to null for every target-make sure that pointer is not used for unit without aura applied
//Spells with this flag cannot trigger if effect is casted on self
// In case spell hit target, do all effect on that target
// In case spell reflect from target, do all effect on caster (if hit)
// If reflected spell hit caster -> do all effect on him
// Do not take combo points on dodge and miss
// Restore spell mods for a miss/dodge/parry Cold Blood
/// @todo check how broad this rule should be
// Trigger info was not filled in spell::preparedatafortriggersystem - we do it now
// If at least one effect negative spell is negative hit
// All calculated do it!
// Do healing and triggers
// Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
// Do damage and triggers
// Fill base damage struct (unitTarget - is real spell target)
// Add bonuses and fill damageInfo struct
// Send log damage message to client
// Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
// Passive spell hits/misses or active spells only misses (only triggers)
// Fill base damage struct (unitTarget - is real spell target)
// Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
// Failed Pickpocket, reveal rogue
//AI functions
// Needs to be called after dealing damage/healing to not remove breaking on damage auras
// if target is fallged for pvp also flag caster if a player
// For delayed spells immunity may be applied between missile launch and hit - check immunity for that case
// disable effects to which unit is immune
// Recheck  UNIT_FLAG_NON_ATTACKABLE for delayed spells
/// @todo This is a hack. But we do not know what types of stealth should be interrupted by CC
// for delayed spells ignore negative spells (after duel end) for friendly targets
/// @todo this cause soul transfer bugged
// 63881 - Malady of the Mind jump spell (Yogg-Saron)
// assisting case, healing and resurrection
// Get Data Needed for Diminishing Returns, some effects may have multiple auras, so this must be done on spell hit, not aura add
// Increase Diminishing on unit, current informations for actually casts will use values above
// Select rank for aura with level requirements only in specific cases
// Unit has to be target only of aura effect, both caster and target have to be players, target has to be other than unit target
// Set aura stack amount to desired value
// Now Reduce spell duration using data received at spell hit
// unit is immune to aura if it was diminished to 0 duration
// Haste modifies duration of channeled spells
// amplitude is hastened by UNIT_FIELD_MOD_CASTING_SPEED
// if there is no periodic effect
// Apply additional spell effects to target
/// @todo move this code to scripts
// Paladin immunity shields
// Cast Forbearance
// Cast Avenging Wrath Marker
// Avenging Wrath
// Cast the serverside immunity shield marker
// Blizz seems to just apply aura without bothering to cast
// handle SPELL_AURA_ADD_TARGET_TRIGGER auras
// this is executed after spell proc spells on target hit
// spells are triggered for each hit spell target
// info confirmed with retail sniffs of permafrost and shadow weaving
// SPELL_AURA_ADD_TARGET_TRIGGER auras shouldn't trigger auras without duration
// set duration of current aura to the triggered spell
// get duration from aura-only once
// trigger linked auras remove/apply
/// @todo remove/cleanup this, as this table is not documented and people are doing stupid things with it
// Check target
// Target checked in apply effects procedure
// Not need check return true
// aura is dispelled
// remove from need alive mask effect that have alive target
// is all effects from m_needAliveTargetMask have alive targets
// Fill aura scaling information
// Change aura with ranks only if basepoints are taken from spellInfo and aura is positive
// create and add update event for this spell
//Prevent casting at cast another spell (ServerSide check)
// Fill cost data (not use power for item casts
// Set combo point requirement
// target is checked in too many locations and with different results to handle each of them
// handle just the general SPELL_FAILED_BAD_TARGETS result which is the default result for most DBC target checks
//always cast autorepeat dummy for triggering
// Periodic auras should be interrupted when aura triggers a spell which can't be cast
// for example bladestorm aura should be removed on disarm as of patch 3.3.5
// channeled periodic spells should be affected by this (arcane missiles, penance, etc)
// a possible alternative sollution for those would be validating aura target on unit state change
// Prepare data for triggers
// calculate cast time (calculated after first CheckCast check to prevent charge counting for first CheckCast fail)
// Set cast time to 0 if .cheat casttime is enabled.
// don't allow channeled spells / spells with cast time to be casted while moving
// (even if they are interrupted on moving, spells with almost immediate effect get to have their effect processed before movement interrupter kicks in)
// don't cancel spells which are affected by a SPELL_AURA_CAST_WHILE_WALKING effect
// set timer base at cast time
//Containers for channeled spells have to be set
/// @todoApply this to all casted spells if needed
// Why check duration? 29350: channelled triggers channelled
// stealth must be removed at cast starting (at show channel bar)
// skip triggered spell (item equip spell casting and other not explicit character casts/item uses)
// set target for proper facing
//item: first cast may destroy item and second cast causes crash
// no break
// spell is canceled-take mods and clear list
// if not channeled then the object for the current cast wasn't summoned yet
//set state back so finish will be processed
// update pointers base at GUIDs to prevent access to non-existed already object
// cancel at lost explicit target during cast
// now that we've done the basic check, now run the scripts
// should be done before the spell is actually executed
// As of 3.0.2 pets begin attacking their owner's target immediately
// Let any pets know we've attacked something. Check DmgClass for harmful spells only
// This prevents spells such as Hunter's Mark from triggering pet attack
// Should this be done for original caster?
// Set spell which will drop charges for triggered cast spells
// if not successfully casted, will be remove in finish(false)
// skip check if done already (for instant cast spells for example)
//restore spell mods
// cleanup after mod system
// triggered spell pointer can be not removed in some cases
// additional check after cast bar completes (must not be in CheckCast)
// if trade not complete then remember it in trade data
// Spell will be casted at completing the trade. Silently ignore at this place
// cleanup after mod system
// triggered spell pointer can be not removed in some cases
// Spell may be finished after target map check
//restore spell mods
// cleanup after mod system
// triggered spell pointer can be not removed in some cases
// traded items have trade slot instead of guid in m_itemTargetGUID
// set to real guid to be sent later to the client
// Powers have to be taken before SendSpellGo
// we must remove reagents before HandleEffects to allow place crafted item in same slot
/// Not own traded item (in trader trade slot) req. reagents including triggered spell case
// CAST SPELL
// we must send smsg_spell_go packet before m_castItem delete in TakeCastItem()...
// Okay, everything is prepared. Now we need to distinguish between immediate and evented delayed spells
// Remove used for cast item if need (it can be already NULL after TakeReagents call
// in case delayed spell remove item at cast delay start
// Okay, maps created, now prepare flags
// Immediate spell, no big deal
//Clear spell cooldowns after every spell is cast if .cheat cooldown is enabled.
// start channeling if applicable
// First mod_duration then haste - see Missile Barrage
// Apply duration mod
// Apply haste mods
// process immediate effects (items, ground, etc.) also initialize some variables
// spell is finished, perform some last features of the spell here
// Remove used for cast item if need (it can be already NULL after TakeReagents call
// handle ammo consumption for thrown weapons
//if (m_spellInfo->IsRangedWeaponSpell() && m_spellInfo->IsChanneled())
//   TakeAmmo();
// successfully finish spell cast (not last in case autorepeat or channel spell)
// now recheck units targeting correctness (need before any effects apply to prevent adding immunity at first effect not allow apply second spell effect and similar cases)
// now recheck gameobject targeting correctness
// All targets passed - need finish phase
// spell is finished, perform some last features of the spell here
// successfully finish spell cast
// return zero, spell is finished now
// spell is unfinished, return next execution time
// initialize Diminishing Returns Data
// handle some immediate features of the spell here
// handle effects with SPELL_EFFECT_HANDLE_HIT mode
// don't do anything for empty effect
// call effect handlers to handle destination hit
// process items
// Handle procs on cast
/// @todo finish new proc system:P
// Proc the spells that have DEST target
// Take for real after all targets are processed
// Real add combo points from effects
/// @todo trigger proc phase finish here
// mana/health/etc potions, disabled by client (until combat out as declarate)
// need in some way provided data for Spell::finish SendCooldownEvent
// have infinity cooldown but set at aura apply                  // do not set cooldown for triggered spells (needed by reincarnation)
// update pointers based at it's GUIDs
// check if the player caster has moved before the spell finished
// with the exception of spells affected with SPELL_AURA_CAST_WHILE_WALKING effect
// don't cancel for melee, autorepeat, triggered and instant spells
// don't CheckCast for instant spells - done in spell::prepare, skip duplicate checks, needed for range checks for example
// check if there are alive targets left
// Unsummon summon as possessed creatures on spell cancel
// Unsummon statue
// potions disabled by client, send event "not in combat" if need
// triggered spell pointer can be not set in some cases
// this is needed for proper apply of triggered spell mods
// Take mods after trigger spell (needed for 14177 to affect 48664)
// mods are taken only on succesfull cast and independantly from targets of the spell
// Stop Attack for some spells
// don't send cast results at loading time
/*= SPELL_CUSTOM_ERROR_NONE*/, Opcodes opcode /*= SMSG_CAST_FAILED*/)
// problem
// unknown (value 1 update cooldowns on client flag)
// SpellFocusObject.dbc id
// AreaTable.dbc id
// hardcode areas limitation case
// Cenarion Mana Salve
// Cenarion Healing Salve
// Bottled Nethergon Energy
// Bottled Nethergon Vapor
// Bloodberry Elixir
// default case (don't must be)
// SpellMechanic.dbc id
// seems correct...
// Item id
// Item count?
// SkillLine.dbc id
// required skill value
// required fishing skill
// Unknown
// first missing item
// TODO: SPELL_FAILED_NOT_STANDING
// 1 and 1
// Miss Count (not used currently in SMSG_SPELL_START)
//for (uint32 i = 0; i < missCount; ++i)
//{
//}
// Unk read int8
// Fake Bit
// Rune Cooldown Passed Count
// MissType Count (not used currently in SMSG_SPELL_START)
// Unknown Bits
// Hit Count (not used currently in SMSG_SPELL_START)
//for (uint32 i = 0; i < hitCount; ++i)
//{
//}
// Unk Read32
// Fake Bit
// Unk read int8
// Fake Bit
// Extra Target Count (not used currently in SMSG_SPELL_START)
//for (uint32 i = 0; i < extraTargetCount; ++i)
//{
//}
// Unk uint8
//for (uint32 i = 0; i < missTypeCount; ++i)
//{
//}
//for (uint32 i = 0; i < hitCount; ++i)
//{
//}
//for (uint32 i = 0; i < extraTargetCount; ++i)
//{
//}
//for (uint32 i = 0; i < missCount; ++i)
//{
//}
/*for (uint32 i = 0; i < powerUnitPowerCount; ++i)
// float casts ensure the division is performed on floats as we need float result
// rune cooldown passed
// not send invisible spell casting
//SF_LOG_DEBUG("spells", "Sending SMSG_SPELL_GO id=%u", m_spellInfo->Id);
// triggered spells with spell visual != 0
// should only be sent to self, but the current messaging doesn't make that possible
// same as in SMSG_SPELL_START
// rune cooldowns list
// rune cooldowns list
// same as in SMSG_SPELL_START
// This function also fill data for channeled spells:
// m_needAliveTargetMask req for stop channelig if one target die
// No effect apply - all immuned add state
// possibly SPELL_MISS_IMMUNE2 for this??
// hasAmmoDisplayType
// Extra Target Count
// Miss Type Count
// Miss Count
// Unknown bits
//for (uint32 i = 0; i < extraTargetCount; ++i)
//{
//}
// Fake bit
// Fake bit
// predictedPowerCount
// Missing Predict heal
// hasPowerData
// has castImmunitiy
// Fake bit
// has School Immunities
// runeCooldownPassedCount
// hasAmmodisplayID
// Hit Count
// Always hits
//for (uint32 i = 0; i < extraTargetCount; ++i)
//{
//}
// Always hits
//for (uint32 i = 0; i < powerUnitPowerCount; ++i)
//{
//    data << int32(powerValue);
//    data << uint8(powerType);
//}
// float casts ensure the division is performed on floats as we need float result
// rune cooldown passed
// Reset m_needAliveTargetMask for non channeled spell
// effCount
// HasSpellCastLogData
// SpellID
/*effIndex*/, Unit* victim, uint32 spellId)
// problem
// this is for TARGET_SELECT_CATEGORY_NEARBY
/*+8+4+1+8*/));
// healPrediction
/*
// target packguid
// spellid
// unk3
// unk packed guid (unused ?)
// SchoolImmunityMask
// MechanicImmunityMask
// get ressurector name for creature resurrections, otherwise packet will be not accepted
// for player resurrections the name is looked up by guid
// not remove cast item at triggered spell (equipping, weapon damage, etc)
// This code is to avoid a crash
// I'm not sure, if this is really an error, but I guess every item needs a prototype
// item has limited charges
// item has charges left
// abs(charges) less at 1 after use
// all charges used
// prevent crash at access to deleted m_targets.GetItemTarget
//Don't take power if the spell is cast while .cheat power is enabled.
//lower spell cost on fail (by talent aura)
// health as power used
/*void Spell::TakeAmmo()
// wands don't have ammo
// decrease durability for non-stackable throw weapon
// decrease items amount for stackable throw weapon
// blood, frost, unholy, death
// calculated later
// not sure if result code is correct
// store previous state
// blood, frost, unholy, death
// calculated later
// keep Death Rune type if missed
// you can gain some runic power when use runes
// do not take reagents for these item casts
// if CastItem is also spell reagent
// CastItem will be used up and does not count as reagent
// if GetItemTarget is also spell reagent
// past this point only multiplicative effects occur
// since 2.0.1 threat from positive effects also is distributed among all targets, so the overall caused threat is at most the defined bonus
// positive spells distribute threat among all units that are in combat with target, like healing
// for negative spells threat gets distributed among affected targets
// Always use all the holy power we have
// The spell did hit the target, apply aura cost mods if there are any.
// check death state
// check cooldowns to prevent cheating
//can cast triggered (by aura only?) spells while have this flag
// Check global cooldown
// only triggered spells can be processed an ended battleground
// only check at first call, Stealth auras are already removed at second call
// for now, ignore triggered spells
// Ignore form req aura
// Cannot be used in this stance/form
// caster state requirements
// not for triggered spells (needed by execute)
// Note: spell 62473 requres casterAuraSpell = triggering spell
// cancel autorepeat spells if cast start when moving
// (not wand currently autorepeat cast delayed to moving stop anyway in spell update code)
// Do not cancel spells which are affected by a SPELL_AURA_CAST_WHILE_WALKING effect
// skip stuck spell to allow use it in falling case and apply spell limitations at movement
// Check vehicle flags
// check spell cast conditions from database
// mLastFailedCondition can be NULL if there was an error processing the condition in Condition::Meets (i.e. wrong data for ConditionTarget or others)
// Don't check explicit target for passive spells (workaround) (check should be skipped only for learn case)
// those spells may have incorrect target entries or not filled at all (for example 15332)
// such spells when learned are not targeting anyone using targeting system, they should apply directly to caster instead
// also, such casts shouldn't be sent to client
// Check explicit target for m_originalCaster - todo: get rid of such workarounds
// Must be behind the target
// Target must be facing you
// Ignore LOS for gameobjects casts (wrongly casted by a trigger)
// Check for line of sight for spells with dest
// check pet presence
// not report pet not existence for triggered spells
// Spell casted only on battleground
// do not allow spells to be cast in arenas or rated battlegrounds
/* || player->InRatedBattleGround() NYI*/)
// zone check
// not let players cast spells at mount (and let do it to creatures)
// check spell focus object
// always (except passive spells) check items (only player related checks)
// Triggered spells also have range check
/// @todo determine if there is some flag to enable/disable the check
// script hook
// for effects of spells that have only one target
// Awaken Peon
// Righteous Defense
// check target only for unit target case
// Can be area effect, Check only for players and not check if target - caster (spell can have multiply drain/burn effects)
// Warbringer - can't be handled in proc system - should be done before checkcast root check and charge effect process
// chance for fail at orange skinning attempt
// only players can open locks, gather etc.
// we need a go target in case of TARGET_GAMEOBJECT_TARGET
// we need a go target, or an openable item target in case of TARGET_GAMEOBJECT_ITEM_TARGET
// In Battleground players can use only flags and banners
// get the lock entry
// check lock compatibility
// chance for fail at orange mining/herb/LockPicking gathering attempt
// second check prevent fail at rechecks
// chance for failure in orange gather / lockpick (gathering skill can't fail at maxskill)
// This is generic summon effect
//let warlock do a replacement summon
//starting cast, trigger pet stun (cast by pet so it doesn't attack player)
// refer-a-friend spell
// check if our map is dungeon or raid
// RETURN HERE
//
//Do not allow to cast it before BG starts.
// can't change during already started arena/battleground
// Ignore map check if spell have AreaId. AreaId already checked and this prevent special mount spells
// can be casted at non-friendly unit or own pet/charm
// not allow cast fly spells if not have req. skills  (all spells is self target)
// allow always ghost flight spells
// check trade slot case (last, for allow catch any another cast problems)
// check if caster has at least 1 combo point for spells that require combo points
// all ok
//prevent spellcast interruption by another spellcast
// dead owner (pets still alive when owners ressed?)
// cooldown
// Check if spell is affected by GCD
// spells totally immuned to caster auras (wsg flag drop, give marks etc)
// Check if the spell grants school or mechanic immunity.
// We use bitmasks so the loop is done only once and not on every aura check below.
// immune movement impairment and loss of control
// Glyph of Pain Suppression
// Allow Pain Suppression and Guardian Spirit to be cast while stunned
// there is no other way to handle it
// Check whether the cast should be prevented by any state you might have.
// Have to check if there is a stun aura. Otherwise will have problems with ghost aura apply while logging out
// Get unit state
// spell is usable while stunned, check if caster has only mechanic stun auras, another stun types must prevent cast spell
// Attr must make flag drop spell totally immune from all effects
//Checking auras is needed now, because you are prevented by some state but the spell grants immunity.
//Make a second check for spell failed so the right SPELL_FAILED message is returned.
//That is needed when your casting is prevented by multiple states and you are only immune to some of them.
// You are prevented from casting and the spell casted does not grant immunity. Return a failed error.
// NYI
// check USABLE attributes
// USABLE takes precedence over NOT_USABLE
// check NOT_USABLE attributes
// check cooldowns
// not sure if still needed
//check if among target units, our WANTED target is as well (->only self cast spells return false)
//target invalid
// Don't check for instant cast spells
// check needed by 68766 51693 - both spells are cast on enemies and have 0 max range
// these are triggered by other spells - possibly we should omit range check in that case?
// Because of lag, we can not check too strictly here.
//0x5A;
// skip this check if min_range = 0
// item cast not used power
// health as power used - need check health amount
// Check valid power type
//check rune cost only if a spell has PowerType == POWER_RUNES
// Check power amount
// consumable cast item checks
// such items should only fail if there is no suitable effect at all - see Rejuvenation Potions for example
// skip check, pet not required like checks, and for TARGET_UNIT_PET m_targets.GetUnitTarget() is not the real target but the caster
// Mana Potion, Rage Potion, Thistle Tea(Rogue), ...
// check target item
// if not item target then required item must be equipped
// do not take reagents for these item casts
// Not own traded item (in trader trade slot) requires reagents even if triggered spell
// check reagents (ignore triggered spells with reagents processed by original spell) and special reagent ignore case.
// if CastItem is also spell reagent
// CastItem will be used up and does not count as reagent
// check totem-item requirements (items presence in inventory)
// special checks for spell effects
/// @todo Needs review
// move this to anywhere
// cannot enchant vellum for other player
// do not allow to enchant vellum from scroll made by vellum-prevent exploit
// no break
// do not allow adding usable enchantments to items that have use effect already
// Not allow enchant in trade slot for some enchant type
// Not allow enchant in trade slot for some enchant type
// check item existence in effect code (not output errors at offhand hold item effect to main hand for example
// prevent disenchanting in trade slot
// 2.0.x addon: Check player enchanting level against the item disenchanting requirements
//ensure item is a prospectable ore
//prevent prospecting in trade slot
//Check for enough skill in jewelcrafting
//make sure the player has the required ores in inventory
//ensure item is a millable herb
//prevent milling in trade slot
//Check for enough skill in inscription
//make sure the player has the required herbs in inventory
// check weapon presence in slots for main/offhand weapons
// main hand weapon required
// skip spell if no weapon in slot or broken
// skip spell if weapon not fit to triggered spell
// offhand hand weapon required
// skip spell if no weapon in slot or broken
// skip spell if weapon not fit to triggered spell
// only called in DealDamage()
// || m_caster->GetTypeId() != TYPEID_PLAYER)
//if (m_spellState == SPELL_STATE_DELAYED)
//    return;                                             // spell is active and can't be time-backed
// Spells may only be delayed twice
// spells not loosing casting time (slam, dynamites, bombs..)
//if (!(m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_DAMAGE))
//    return;
//check pushback reduce
// spellcasting delay is normally 500ms
// must be initialized to 100 for percent modifiers
// Spells may only be delayed twice
//check pushback reduce
// channeling delay is normally 25% of its time per hit
// must be initialized to 100 for percent modifiers
// partially interrupt persistent area auras
// further actions done only for dest targets
// cache last transport
// update effect destinations (in case of moved transport dest target)
/// @todo shit below shouldn't be here, but it's temporary
//Check targets for LOS visibility (except spells without range limitations)
// player far away, maybe his corpse near?
// all ok by some way or another, skip normal check
// normal case
// Get GO cast coordinates if original caster -> GO
/// @todo changed SPELL_INTERRUPT_FLAG_AUTOATTACK -> SPELL_INTERRUPT_FLAG_INTERRUPT to fix compile - is this check correct at all?
// update spell if it is not finished
// check spell state to process
// spell was finished, check deletable state
// check, if we do have unfinished triggered spells
// spell is deletable, finish event
// event will be re-added automatically at the end of routine)
// first, check, if we have just started
// no, we aren't, do the typical update
// check, if we have channeled spell on our hands
/*
// evented channeled spell is processed separately, casted once after delay, and not destroyed till finish
// check, if we have casting anything else except this channeled spell and autorepeat
// another non-melee non-delayed spell is casted now, abort
// Set last not triggered spell for apply spellmods
// do the action (pass spell to channeling state)
// And remove after effect handling
// event will be re-added automatically at the end of routine)
// run the spell handler and think about what we can do next
// re-add us to the queue
// event not complete
// event complete
// finish update event will be re-added automatically at the end of routine)
// delaying had just started, record the moment
// re-plan the event for the delay moment
// event not complete
// all other states
// event will be re-added automatically at the end of routine)
// spell processing not complete, plan event on the next update interval
// event not complete
/*e_time*/)
// oops, the spell we try to do is aborted
// handle effects with SPELL_EFFECT_HANDLE_LAUNCH mode
// don't do anything for empty effect
// do not consume ammo anymore for Hunter's volley spell
//TakeAmmo();
// In case spell hit target, do all effect on that target
// In case spell reflect from target, do all effect on caster (if hit)
// possible case for GO and maybe for items.
// Get LockInfo
// some locks not have reqs
// check key item (many fit cases can be)
// check key skill (only single first fit case can be)
// wrong locktype, skip
// castitem check: rogue using skeleton keys. the skill values should not be added in this case.
// skill bonus provided by casting spell (mostly item spells)
// add the effect base points modifier from the spell casted (cheat lock / skeleton key etc.)
// first dword - target counter
// increase target counter by one
// execute script effect handler hooks and check if effects was prevented
// effect execution can be prevented
// Skip if there are not any script
// If triggeredByAura has SPELL_ATTR4_PROC_ONLY_ON_CASTER then it can only proc on a casted spell with TARGET_UNIT_CASTER
/// @todo move this to scripts
/// @todo move this to scripts
// Permafrost
// handle SPELL_AURA_ADD_TARGET_TRIGGER auras:
// save auras which were present on spell caster on cast, to prevent triggered auras from affecting caster
// and to correctly calculate proc chance when combopoints are present
// calculate the chance using spell base amount, because aura amount is not updated on combo-points change
// this possibly needs fixing
// proc chance is stored in effect amount
// build trigger and add to the list
// Global cooldowns management
// Only player or controlled units have global cooldown
// Global cooldown can't leave range 1..1.5 secs
// There are some spells (mostly not casted directly by player) that have < 1 sec and > 1.5 sec global cooldowns
// but as tests show are not affected by any spell mods.
// gcd modifier auras are applied only to own spells and only players have such mods
// Apply haste rating
// Only players or controlled units have global cooldown
// Cancel global cooldown when interrupting current cast
// Only players or controlled units have global cooldown
// use ofter for party/assistance checks
// nobreak;
// return all targets on missile trajectory (0 - size of a missile)
//namespace Skyfire
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//  0
//  1 SPELL_EFFECT_INSTAKILL
//  2 SPELL_EFFECT_SCHOOL_DAMAGE
//  3 SPELL_EFFECT_DUMMY
//  4 SPELL_EFFECT_PORTAL_TELEPORT          unused
//  5 SPELL_EFFECT_TELEPORT_UNITS
//  6 SPELL_EFFECT_APPLY_AURA
//  7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
//  8 SPELL_EFFECT_POWER_DRAIN
//  9 SPELL_EFFECT_HEALTH_LEECH
// 10 SPELL_EFFECT_HEAL
// 11 SPELL_EFFECT_BIND
// 12 SPELL_EFFECT_PORTAL
// 13 SPELL_EFFECT_RITUAL_BASE              unused
// 14 SPELL_EFFECT_RITUAL_SPECIALIZE        unused
// 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL   unused
// 16 SPELL_EFFECT_QUEST_COMPLETE
// 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
// 18 SPELL_EFFECT_RESURRECT
// 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
// 20 SPELL_EFFECT_DODGE
// 21 SPELL_EFFECT_EVADE                    one spell: Evade (DND)
// 22 SPELL_EFFECT_PARRY
// 23 SPELL_EFFECT_BLOCK                    one spell: Block
// 24 SPELL_EFFECT_CREATE_ITEM
// 25 SPELL_EFFECT_WEAPON
// 26 SPELL_EFFECT_DEFENSE                  one spell: Defense
// 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
// 28 SPELL_EFFECT_SUMMON
// 29 SPELL_EFFECT_LEAP
// 30 SPELL_EFFECT_ENERGIZE
// 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
// 32 SPELL_EFFECT_TRIGGER_MISSILE
// 33 SPELL_EFFECT_OPEN_LOCK
// 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
// 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
// 36 SPELL_EFFECT_LEARN_SPELL
// 37 SPELL_EFFECT_SPELL_DEFENSE            one spell: SPELLDEFENSE (DND)
// 38 SPELL_EFFECT_DISPEL
// 39 SPELL_EFFECT_LANGUAGE
// 40 SPELL_EFFECT_DUAL_WIELD
// 41 SPELL_EFFECT_JUMP
// 42 SPELL_EFFECT_JUMP_DEST
// 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
// 44 SPELL_EFFECT_SKILL_STEP
// 45 SPELL_EFFECT_PLAY_MOVIE
// 46 SPELL_EFFECT_SPAWN clientside, unit appears as if it was just spawned
// 47 SPELL_EFFECT_TRADE_SKILL
// 48 SPELL_EFFECT_STEALTH                  one spell: Base Stealth
// 49 SPELL_EFFECT_DETECT                   one spell: Detect
// 50 SPELL_EFFECT_TRANS_DOOR
// 51 SPELL_EFFECT_FORCE_CRITICAL_HIT       unused
// 52 SPELL_EFFECT_GUARANTEE_HIT            unused
// 53 SPELL_EFFECT_ENCHANT_ITEM
// 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
// 55 SPELL_EFFECT_TAMECREATURE
// 56 SPELL_EFFECT_SUMMON_PET
// 57 SPELL_EFFECT_LEARN_PET_SPELL
// 58 SPELL_EFFECT_WEAPON_DAMAGE
// 59 SPELL_EFFECT_CREATE_RANDOM_ITEM       create item base at spell specific loot
// 60 SPELL_EFFECT_PROFICIENCY
// 61 SPELL_EFFECT_SEND_EVENT
// 62 SPELL_EFFECT_POWER_BURN
// 63 SPELL_EFFECT_THREAT
// 64 SPELL_EFFECT_TRIGGER_SPELL
// 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
// 66 SPELL_EFFECT_CREATE_MANA_GEM          (possibly recharge it, misc - is item ID)
// 67 SPELL_EFFECT_HEAL_MAX_HEALTH
// 68 SPELL_EFFECT_INTERRUPT_CAST
// 69 SPELL_EFFECT_DISTRACT
// 70 SPELL_EFFECT_PULL                     one spell: Distract Move
// 71 SPELL_EFFECT_PICKPOCKET
// 72 SPELL_EFFECT_ADD_FARSIGHT
// 73 SPELL_EFFECT_UNTRAIN_TALENTS
// 74 SPELL_EFFECT_APPLY_GLYPH
// 75 SPELL_EFFECT_HEAL_MECHANICAL          one spell: Mechanical Patch Kit
// 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
// 77 SPELL_EFFECT_SCRIPT_EFFECT
// 78 SPELL_EFFECT_ATTACK
// 79 SPELL_EFFECT_SANCTUARY
// 80 SPELL_EFFECT_ADD_COMBO_POINTS
// 81 SPELL_EFFECT_CREATE_HOUSE             one spell: Create House (TEST)
// 82 SPELL_EFFECT_BIND_SIGHT
// 83 SPELL_EFFECT_DUEL
// 84 SPELL_EFFECT_STUCK
// 85 SPELL_EFFECT_SUMMON_PLAYER
// 86 SPELL_EFFECT_ACTIVATE_OBJECT
// 87 SPELL_EFFECT_GAMEOBJECT_DAMAGE
// 88 SPELL_EFFECT_GAMEOBJECT_REPAIR
// 89 SPELL_EFFECT_GAMEOBJECT_SET_DESTRUCTION_STATE
// 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
// 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
// 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
// 93 SPELL_EFFECT_FORCE_DESELECT
// 94 SPELL_EFFECT_SELF_RESURRECT
// 95 SPELL_EFFECT_SKINNING
// 96 SPELL_EFFECT_CHARGE
// 97 SPELL_EFFECT_CAST_BUTTON (totem bar since 3.2.2a)
// 98 SPELL_EFFECT_KNOCK_BACK
// 99 SPELL_EFFECT_DISENCHANT
//100 SPELL_EFFECT_INEBRIATE
//101 SPELL_EFFECT_FEED_PET
//102 SPELL_EFFECT_DISMISS_PET
//103 SPELL_EFFECT_REPUTATION
//104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
//105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
//106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
//107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
//108 SPELL_EFFECT_DISPEL_MECHANIC
//109 SPELL_EFFECT_SUMMON_DEAD_PET
//110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
//111 SPELL_EFFECT_DURABILITY_DAMAGE
//112 SPELL_EFFECT_112
//113 SPELL_EFFECT_RESURRECT_NEW
//114 SPELL_EFFECT_ATTACK_ME
//115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
//116 SPELL_EFFECT_SKIN_PLAYER_CORPSE       one spell: Remove Insignia, bg usage, required special corpse flags...
//117 SPELL_EFFECT_SPIRIT_HEAL              one spell: Spirit Heal
//118 SPELL_EFFECT_SKILL                    professions and more
//119 SPELL_EFFECT_APPLY_AREA_AURA_PET
//120 SPELL_EFFECT_TELEPORT_GRAVEYARD       one spell: Graveyard Teleport Test
//121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
//122 SPELL_EFFECT_122                      unused
//123 SPELL_EFFECT_SEND_TAXI                taxi/flight related (misc value is taxi path id)
//124 SPELL_EFFECT_PULL_TOWARDS
//125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
//126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF    spell steal effect?
//127 SPELL_EFFECT_PROSPECTING              Prospecting spell
//128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
//129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
//130 SPELL_EFFECT_REDIRECT_THREAT
//131 SPELL_EFFECT_PLAY_SOUND               sound id in misc value (SoundEntries.dbc)
//132 SPELL_EFFECT_PLAY_MUSIC               sound id in misc value (SoundEntries.dbc)
//133 SPELL_EFFECT_UNLEARN_SPECIALIZATION   unlearn profession specialization
//134 SPELL_EFFECT_KILL_CREDIT              misc value is creature entry
//135 SPELL_EFFECT_CALL_PET
//136 SPELL_EFFECT_HEAL_PCT
//137 SPELL_EFFECT_ENERGIZE_PCT
//138 SPELL_EFFECT_LEAP_BACK                Leap back
//139 SPELL_EFFECT_CLEAR_QUEST              Reset quest status (miscValue - quest ID)
//140 SPELL_EFFECT_FORCE_CAST
//141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
//142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
//143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
//144 SPELL_EFFECT_KNOCK_BACK_DEST
//145 SPELL_EFFECT_PULL_TOWARDS_DEST                      Black Hole Effect
//146 SPELL_EFFECT_ACTIVATE_RUNE
//147 SPELL_EFFECT_QUEST_FAIL               quest fail
//148 SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE
//149 SPELL_EFFECT_CHARGE_DEST
//150 SPELL_EFFECT_QUEST_START
//151 SPELL_EFFECT_TRIGGER_SPELL_2
//152 SPELL_EFFECT_SUMMON_RAF_FRIEND        summon Refer-a-Friend
//153 SPELL_EFFECT_CREATE_TAMED_PET         misc value is creature entry
//154 SPELL_EFFECT_DISCOVER_TAXI
//155 SPELL_EFFECT_TITAN_GRIP Allows you to equip two-handed axes, maces and swords in one hand, but you attack $49152s1% slower than normal.
//156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
//157 SPELL_EFFECT_CREATE_ITEM_2            create item or create item template and replace by some randon spell loot item
//158 SPELL_EFFECT_MILLING                  milling
//159 SPELL_EFFECT_ALLOW_RENAME_PET         allow rename pet once again
//160 SPELL_EFFECT_TRIGGER_SPELL_3
//161 SPELL_EFFECT_TALENT_SPEC_COUNT        second talent spec (learn/revert)
//162 SPELL_EFFECT_TALENT_SPEC_SELECT       activate primary/secondary spec
//163 SPELL_EFFECT_163  unused
//164 SPELL_EFFECT_REMOVE_AURA
//165 SPELL_EFFECT_DAMAGE_FROM_MAX_HEALTH_PCT
//166 SPELL_EFFECT_GIVE_CURRENCY
//167 SPELL_EFFECT_167
//168 SPELL_EFFECT_168
//169 SPELL_EFFECT_DESTROY_ITEM
//170 SPELL_EFFECT_170
//171 SPELL_EFFECT_SUMMON_OBJECT_SLOT_2
//172 SPELL_EFFECT_RESURRECT_WITH_AURA
//173 SPELL_EFFECT_UNLOCK_GUILD_VAULT_TAB
//174 SPELL_EFFECT_174
//175 SPELL_EFFECT_175          one spell: Wild Fixation (125570)
//176 SPELL_EFFECT_176
//177 SPELL_EFFECT_177
//178 SPELL_EFFECT_178          unused
//179 SPELL_EFFECT_CREATE_AREATRIGGER
//180 SPELL_EFFECT_180
//181 SPELL_EFFECT_REMOVE_TALENT
//182 SPELL_EFFECT_182
//183 SPELL_EFFECT_183          unused
//184 SPELL_EFFECT_184
//185 SPELL_EFFECT_185
//186 SPELL_EFFECT_186
//187 SPELL_EFFECT_187
//188 SPELL_EFFECT_188
//189 SPELL_EFFECT_189
//190 SPELL_EFFECT_190
//191 SPELL_EFFECT_191
//192 SPELL_EFFECT_192
//193 SPELL_EFFECT_193          unused
//194 SPELL_EFFECT_194          unused
//195 SPELL_EFFECT_195
//196 SPELL_EFFECT_196
//197 SPELL_EFFECT_197
//198 SPELL_EFFECT_198
//199 SPELL_EFFECT_199          unused
//200 SPELL_EFFECT_200
//201 SPELL_EFFECT_BATTLE_PET_UNLOCK
//202 SPELL_EFFECT_202
//203 SPELL_EFFECT_203
//204 SPELL_EFFECT_204
//205 SPELL_EFFECT_205
//206 SPELL_EFFECT_206
//207 SPELL_EFFECT_207          unused
//208 SPELL_EFFECT_REPUTATION_2 one spell: Test Reputation Set (142250)
//209 SPELL_EFFECT_209          one spell: QA Test Spell (150808)
//210 SPELL_EFFECT_210          unused
//211 SPELL_EFFECT_211          unused
//212 SPELL_EFFECT_212          unused
//213 SPELL_EFFECT_JUMP_DEST_2  one spell: Death Grip (49575)
/*effIndex*/)
/*effIndex*/)
// NOT USED BY ANY SPELL OR USELESS OR IMPLEMENTED IN DIFFERENT WAY IN SKYFIRE
// already have one active request
/*effIndex*/)
// prevent interrupt message
/*effIndex*/)
// Meteor like spells (divided damage to targets)
// divide to all targets
// better way to check unknown
// Consumption
// percent from health with min
// Thundercrash
// arcane charge. must only affect demons (also undead?)
// Gargoyle Strike
// about +4 base spell dmg per level
// Victory Rush
// Shockwave
// Incinerate Rank 1 & 2
// Incinerate does more dmg (dmg/6) if the target have Immolate debuff.
// Check aura state for speed but aura state set not only for Immolate spell
// Improved Mind Blast (Mind Blast in shadow form bonus)
// Mind Trauma
// Ferocious Bite
// converts each extra point of energy ( up to 25 energy ) into additional damage
// 25 energy = 100% more damage
// Envenom
// consume from stack dozes not more that have combo-points
// Lookup for Deadly poison (only attacker applied)
// count consumed deadly poison doses at target
// Master Poisoner
// Eviscerate and Envenom Bonus Damage (item set effect)
// Eviscerate
// Eviscerate and Envenom Bonus Damage (item set effect)
// Blood Boil - bonus for diseased targets
// Deep Freeze should deal damage to permanently stun-immune targets.
// selection by spell family
// Righteous Defense (step 1)
// Clear targets for eff 1
// not empty (checked), copy
// remove invalid attackers
// selected from list 3
// now let next effect cast spell at each target.
// Raise Dead
// Do we have talent Master of Ghouls?
// summon as pet
// or guardian
// Corpse not found - take reagents (only not triggered cast can take them)
// Remove cooldown - summon spellls have category
// Raise dead - take reagents and trigger summon spells
//spells triggered by dummy effect should not miss
// pet auras
// normal DB scripted effect
// Script based implementation. Must be used only for not good for implementation in core spell effects
// So called only for not proccessed cases
/// @todo move those to spell scripts
// special cases
// Vanish (not exist)
// If this spell is given to an NPC, it must handle the rest using its own AI
// See if we already are stealthed. If so, we're done.
// Reset cooldown on stealth if needed
// Demonic Empowerment -- succubus
// Cast Lesser Invisibility
// Brittle Armor - (need add max stack of 24575 Brittle Armor)
// Brittle Armor
// Mercurial Shield - (need add max stack of 26464 Mercurial Shield)
// Mercurial Shield
// Cloak of Shadows
// remove all harmful spells on you...
// only affect magic spells
// ignore positive and passive auras
// normal case
//if (effectHandleMode == SPELL_EFFECT_HANDLE_LAUNCH)
// set basepoints for trigger with value effect
// Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
// original caster guid only for GO cast
// normal case
//if (effectHandleMode == SPELL_EFFECT_HANDLE_HIT)
// set basepoints for trigger with value effect
// maybe need to set value only when basepoints == 0?
// Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
// original caster guid only for GO cast
// normal case
// Skeletal Gryphon Escape
// Ride Flamebringer Cue
// Hide In Mine Car
// Overtake
// Malleable Goo Summon Trigger
// set basepoints for trigger with value effect
// maybe need to set value only when basepoints == 0?
// Init dest coordinates
/*effIndex*/)
// If not exist data for dest location - return
// Init dest coordinates
// post effects for TARGET_DEST_DB
// Dimensional Ripper - Everlook
// 7/12 success
// 4/12 evil twin
// 1/12 fire
// Ultrasafe Transporter: Toshley's Station
// 50% success
// soul split - evil
// soul split - good
// Increase the size
// Decrease the size
// Transform
// chicken
// evil twin
// Dimensional Ripper - Area 52
// 50% success
// soul split - evil
// soul split - good
// Increase the size
// Transform
// add spell damage bonus
// Don't restore from self drain
// we do not handle a flag dropping or clicking on flag in battleground by sendevent system
// call events for object target if present
// if (effectHandleMode == SPELL_EFFECT_HANDLE_HIT)
// let's prevent executing effect handler twice in case when spell effect is capable of targeting an object
// this check was requested by scripters, but it has some downsides:
// now it's impossible to script (using sEventScripts) a cast which misses all targets
// or to have an ability to script the moment spell hits dest (in a case when there are object targets present)
// some spells have no target entries in dbc and they use focus target
/// @todo there should be a possibility to pass dest target to event script
// needed in case Player is the caster
// burn x% of target's mana, up to maximum of 2x% of caster's mana (Mana Burn)
// NO - Not a typo - EffectPowerBurn uses effect value multiplier - not effect damage multiplier
// add log data before multiplication (need power amount, not damage)
/*effIndex*/)
// Try to get original caster
// Skip if m_originalCaster not available
// Vessel of the Naaru (Vial of the Sunwell trinket)
// Amount of heal - depends from stacked Holy Energy
// Runic Healing Injector (heal increased by 25% for engineers - 3.2.0 patch change)
// Swiftmend - consumes Regrowth or Rejuvenation
// find most short by duration
//int32 tickheal = targetAura->GetSpellInfo()->EffectBasePoints[idx] + 1;
//It is said that talent bonus should not be included
// Rejuvenation
// Regrowth
// if (targetAura->GetSpellInfo()->SpellFamilyFlags[0] & 0x40)
// Glyph of Swiftmend
//addhealth += tickheal * tickcount;
//addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth, HEAL, unitTarget);
// Death Pact - return pct of max health to caster
// Remove Grievious bite if fully healed
/*effIndex*/)
// Skip if m_originalCaster not available
/*effIndex*/)
// Skip if m_originalCaster not available
// get max possible damage, don't count overkill for heal
/*i*/, uint32 itemtype)
// bg reward have some special in code work
// init items_count to 1, since 1 item will be created regardless of specialization
// the chance to create additional items
// the maximum number of created additional items
// get the chance and maximum number for creating extra items
// roll with this chance till we roll not to create or we create the max num
// really will be created more items
// can the player store the new item?
// convert to possible store amount
// if not created by another reason from full inventory or unique items amount limitation
// create the new item and store it
// was it successful? return error if not
// set the "Crafted by ..." property of the item
// send info to the client
// we succeeded in creating at least one item, so a levelup is possible
/*
// special case: fake item replaced by generate using spell_loot_template
// remove reagent
// create some random items
// create some random items
/// @todo ExecuteLogEffectCreateItem(i, m_spellInfo->Effects[i].ItemType);
/*effIndex*/)
// create some random items
/// @todo ExecuteLogEffectCreateItem(i, m_spellInfo->Effects[i].ItemType);
// Caster not in world, might be spell triggered from aura removal
// Some level depends spells
// Restore Energy
// Blood Fury
// Burst of Energy
// Judgements of the Wise
// Primal Wisdom
// Glyph of Seal of Command
// Runic Mana Injector (mana gain increased by 25% for engineers - 3.2.0 patch change)
// Mad Alchemist's Potion
// find elixirs on target
// get all available elixirs by mask and spell level
// cast random elixir on target
// Players shouldn't be able to loot gameobjects that are currently despawned
// special case, already has GossipHello inside so return and avoid calling twice
// triggering linked GO
/// @todo possible must be moved to loot release (in different from linked triggering)
// triggering linked GO
// Don't return, let loots been taken
// Send loot
// Get lockId
// Arathi Basin banner opening. /// @todo Verify correctness of this check
//CanUseBattlegroundObject() already called in CheckCast()
// in battleground check
//CanUseBattlegroundObject() already called in CheckCast()
// in battleground check
/// @todo Add script for spell 41920 - Filling, becouse server it freze when use this spell
// handle outdoor pvp object opening, return true if go was registered for handling
// these objects must have been spawned by outdoorpvp!
// not allow use skill grow at item base open
// update skill if really known
// Allow one skill-up until respawned
// Do one skill-up
// applied only to using item
// ... only to item in own inventory/bank/equip_slot
// prevent crash at access and unexpected charges counting with item update queue corrupt
// prevent crash at access and unexpected charges counting with item update queue corrupt
// prevent crash at access and unexpected charges counting with item update queue corrupt
// fail
/*effIndex*/)
// determine how many units should be summoned
// some spells need to summon many units, for those spells number of summons is stored in effect value
// however so far noone found a generic check to find all of those (there's no related data in summonproperties.dbc
// and in spell attributes, possibly we need to add a table for those)
// so here's a list of MiscValueB values, which is currently most generic check
// Summons a vehicle, but doesn't force anyone to enter it (see SUMMON_CATEGORY_VEHICLE)
// Mana Tide Totem
// if not spell info, DB values used
// randomize position for multiple summons
//switch
// Summoning spells (usually triggered by npc_spellclick) that spawn a vehicle and that cause the clicker
// to cast a ride vehicle spell on the summoned unit.
// The spell that this effect will trigger. It has SPELL_AURA_CONTROL_VEHICLE
// Hard coded enter vehicle spell
// Create dispel mask by dispel type
// Ok if exist some buffs for dispel try dispel it
// dispel N = damage buffs (or while exist buffs for dispel)
// Random select buff for dispel
// 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
// Failed to dispell
// Caster GUID
// Victim GUID
// dispel spell id
// Spell Id
// Send packet header
// steal
// break
// count
// Send dispelled spell info
// Needed
// Rolled
// Harmful
// Send dispelled spell info
//if (Needed) dataSuccess << Needed;
// Spell Id
//if (Rolled) dataSuccess << Rolled;
// dispel spell id
// On success dispel
// Devour Magic
// Glyph of Felhunter
/*effIndex*/)
/// @todo create a proper pull towards distract spell center for distract
/*effIndex*/)
// Check for possible target
// target must be OK to do this
/*effIndex*/)
// victim must be creature and attackable
// victim have to be alive and humanoid or undead
// Caster not in world, might be spell triggered from aura removal
/*effIndex*/)
// the trainer is the caster
/*effIndex*/)
// uint32 skillid =  m_spellInfo->Effects[i].MiscValue;
// uint16 skillmax = unitTarget->ToPlayer()->(skillid);
// m_caster->ToPlayer()->SetSkill(skillid, skillval?skillval:1, skillmax+75);
// Handle vellums
// destroy one vellum from stack
// and add a scroll
// do not increase skill if vellum used
// item can be in trade slot and have owner diff. from caster
// remove old enchanting before applying new if equipped
// add new enchanting if equipped
// support only enchantings with add socket in this slot
// item can be in trade slot and have owner diff. from caster
// remove old enchanting before applying new if equipped
// add new enchanting if equipped
// select enchantment duration
// rogue family enchantments exception by duration
// 30 mins
// other rogue family enchantments always 1 hour (some have spell damage=0, but some have wrong data in EffBasePoints)
// 1 hour
// shaman family enchantments
// 30 mins
// other cases with this SpellVisual already selected
// 30 mins
// some fishing pole bonuses except Glow Worm which lasts full hour
// 10 mins
// shaman rockbiter enchantments
// 30 mins
// 5 mins
// 5 mins
// default case
// 1 hour
// item can be in trade slot and have owner diff. from caster
// remove old enchanting before applying new if equipped
// add new enchanting if equipped
/*effIndex*/)
// cast finish successfully
//SendChannelUpdate(0);
// in very specific state like near world end/etc.
// "kill" original creature
// prepare visual effect for levelup
// add to world
// visual effect for levelup
// caster have pet now
// if pet requested type already exist
// pet in corpse state can't be summoned
//OldSummon->GetMap()->Remove(OldSummon->ToCreature(), false);
//OldSummon->Relocate(px, py, pz, OldSummon->GetOrientation());
//OldSummon->SetMap(owner->GetMap());
//owner->GetMap()->Add(OldSummon->ToCreature());
// generate new name for summon pet
/*effIndex*/)
// this effect use before aura Taunt apply for prevent taunt already attacking target
// for spell as marked "non effective at already attacking target"
// Also use this effect to set the taunter's threat to the taunted creature's highest value
//Set aggro victim to caster
// multiple weapon dmg effect workaround
// execute only the last weapon damage
// and handle all effects at once
// we must calculate only at last weapon effect
// some spell specific modifiers
// applied to final bonus+weapon damage
// bonus specific for spell
// Devastate (player ones)
// Player can apply only 58567 Sunder Armor effect.
// Hemorrhage
// 50% more damage with daggers
// Skyshatter Harness item set bonus
// Stormstrike
// Mangle (Cat): CP
// Shred, Maul - Rend and Tear
// Kill Shot - bonus damage from Ranged Attack Power
// Blood Strike
// Death Knight T8 Melee 4P Bonus
// Death Strike
// Glyph of Death Strike
// 2% more damage per 5 runic power, up to a maximum of 40%
// Obliterate (12.5% more damage per disease)
// Death Knight T8 Melee 4P Bonus
// Blood-Caked Strike - Blood-Caked Blade
// Heart Strike
// Death Knight T8 Melee 4P Bonus
// not weapon damage effect, just skip
// apply to non-weapon bonus weapon total pct effect, weapon total flat effect included in weapon damage
// Sequence is important
// We assume that a spell have at most one fixed_bonus
// and at most one weaponDamagePercentMod
// not weapon damage effect, just skip
// prevent negative damage
// Add melee damage bonuses (also check for negative)
/*effIndex*/)
/*effIndex*/)
// damage == 0 - heal for caster max health
/// @todo not all spells that used this effect apply cooldown at school spells
// also exist case: apply cooldown to interrupted cast only and to all spells
// there is no CURRENT_AUTOREPEAT_SPELL spells that can be interrupted
// check if we can interrupt spell
// Wild object not have owner and check clickable by players
// Wild object not have owner and check clickable by players
/// @todo we must implement hunter pet summon at login there (spell 6962)
// Glyph of Backstab
// search our Rupture aura on target
// this can be wrong, duration should be based on combo-points
// Glyph of Scourge Strike
// search our Blood Plague and Frost Fever on target
// this Glyph
// talent Epidemic
// Clone Me!
// Remove Collapsing Cave Aura
// Bending Shinbone
// Brittle Armor - need remove one 24575 Brittle Armor aura
// Mercurial Shield - need remove one 26464 Mercurial Shield aura
// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
// Onyxia Scale Cloak
// Shadow Flame
// Decimate
// Mirren's Drinking Hat
// Loch Modan Lager
// Stouthammer Lite
// Aerie Peak Pale Ale
// Escape artist
// Improved Sprint
// Removes snares and roots.
// Plant Warmaul Ogre Banner
// Mug Transformation
// 256 = 0 due to var type
// Spell 42518 (Braufest - Gratisprobe des Braufest herstellen)
// Brutallus - Burn
//Workaround for Range ... should be global for every ScriptEffect
// Goblin Weather Machine
// 5, 000 Gold
// Roll Dice - Decahedral Dwarven Dice
// Roll 'dem Bones - Worn Troll Dice
// Death Knight Initiate Visual
// bloodelf female
// bloodelf male
// draenei female
// draenei male
// dwarf female
// dwarf male
// forsaken female
// forsaken male
// gnome female
// gnome male
// human female
// human male
// nightelf female
// nightelf male
// orc female
// orc male
// tauren female
// tauren male
// troll female
// troll male
// Deathbolt from Thalgran Blightbringer
// reflected by Freya's Ward
// Retribution by Sevenfold Retribution
// Summon Ghouls On Scarlet Crusade
// Coyote Spirit Despawn
// Blood Parrot Despawn
// Gift of the Harvester
// Devour Humanoid
// Retrieving (Wintergrasp RP-GG pickup spell)
// Drop RP-GG (Wintergrasp RP-GG at death drop spell)
// Delete item from inventory at death
// Portal to Orgrimmar
// Portal to Stormwind
// Big Blizzard Bear
// Prevent stacking of mounts and client crashes upon dismounting
// Triggered spell id dependent on riding skill
// Teleporting
// return from top
// teleport atop
// Grab Crate
/// @todo a hack, range = 11, should after some time cast, otherwise too far
// Lightwell
// proc a spellcast
// Stoneclaw Totem
// Rank 1
// Rank 2
// Rank 3
// Rank 4
// Rank 5
// Rank 6
// Rank 7
// Rank 8
// Rank 9
// Rank 10
// Cast Absorb on totems
// Glyph of Stoneclaw Totem
// Ultra-Advanced Proto-Typical Shortening Blaster
// chance unknown, using 50
// Bigger!
// Shrunk
// Yellow
// Ghost
// Polymorph
// Bigger!
// Shrunk
// Yellow
// Ghost
// Polymorph
// Judgement (seal trigger)
// Judgement self add switch
// Judgement of Justice
// Judgement of Light
// Judgement of Light
// Judgement of Wisdom
// all seals have aura dummy in 2 effect
// Seal of light, Seal of wisdom, Seal of justice
// Pestilence
// Get diseases on target of spell
// Glyph of Disease - cast on unit target too to refresh aura
// And spread them on target
// Blood Plague
// Frost Fever
// normal DB scripted effect
/*effIndex*/)
// Vanish allows to remove all threat and cast regular stealth so other spells can be used
// Overkill
/*effIndex*/)
// caster or target already have requested duel
// Players can only fight a duel in zones with this flag
// Dueling isn't allowed here
// Dueling isn't allowed here
//CREATE DUEL FLAG OBJECT
//END
// Send request
// create duel-info
// Mounted Duel
// Mounted Duel
/*effIndex*/)
// homebind location is loaded always
// target->TeleportTo(target->m_homebindMapId, target->m_homebindX, target->m_homebindY, target->m_homebindZ, target->GetOrientation(), (m_caster == m_caster ? TELE_TO_SPELL : 0));
// Stuck spell trigger Hearthstone cooldown
/*effIndex*/)
// workaround - this effect should not use target map
// Evil Twin (ignore player summon, but hide this for summoner)
// summoner zone
// auto decline after msecs
/*effIndex*/)
// int32 unk = m_spellInfo->Effects[effIndex].MiscValue; // This is set for EffectActivateObject spells; needs research
// glyph sockets level requirement
// apply new one
// glyph slot mismatch
// remove old glyph
// Removing the glyph, get the old one
// this is only item spell effect applied to main-hand weapon of target player (players in area)
// must be equipped
//Try duration index first ..
//+1;            //Base points after ..
//10 seconds for enchants which don't have listed duration
// Always go to temp enchantment slot
// Enchantment will not be applied if a different one already exists
// Apply the temporary enchantment
/*effIndex*/)
// item will be removed at disenchanting end
/*effIndex*/)
// Drunken Vomit
/// @todo fix crash when a spell has two effects, both pointed at the same item target
// Recast case - null spell id to make auras not be removed on object remove from world
// If dest location if present
// Summon in random point all other units if location present
//pGameObj->SetUInt32Value(GAMEOBJECT_FIELD_LEVEL, m_caster->getLevel());
// already have one active request
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
// never rewarded before
// quest not in log - for internal use
/*effIndex*/)
// flat case
// percent case
/*effIndex*/)
// Double chances for elites
/*effIndex*/)
// Spell is not using explicit target - no generated path
// not all charge effects used in negative spells
/*effIndex*/)
// Spells with SPELL_EFFECT_KNOCK_BACK (like Thunderstorm) can't knockback target if target has ROOT/STUN
// Instantly interrupt non melee spells being casted
//if (m_spellInfo->Effects[i].Effect == SPELL_EFFECT_KNOCK_BACK)
//1891: Disengage
// Player has never done this quest
// remove all quest entries for 'entry' from quest log
// we ignore unequippable quest items in this case, it's still be equipped
//if (m_spellInfo->Effects[i].Effect == SPELL_EFFECT_PULL_TOWARDS)
/*effIndex*/)
//pet->AIM_Initialize();
//player->PetSpellInitialize();
/*effIndex*/)
// -1 means all player equipped items and -2 all items
// invalid slot value
// FIXME: some spells effects have value -1/-2
// Possibly its mean -1 all player equipped items and -2 all items
// invalid slot value
/*effIndex*/)
//FIXME: this can be better check for most objects but still hack
//GO is always friendly to it's creator, get range for friends
// if gameobject is summoning object, it should be spawned right on caster's position
// will removed at spell cancel
// end time of range when possible catch fish (FISHING_BOBBER_READY_TIME..GetDuration(m_spellInfo))
// start time == fish-FISHING_BOBBER_READY_TIME (0..GetDuration(m_spellInfo)-FISHING_BOBBER_READY_TIME)
// will be removed at spell cancel
// 52991
//pGameObj->SetUInt32Value(GAMEOBJECT_FIELD_LEVEL, m_caster->getLevel());
//m_caster->AddGameObject(pGameObj);
//m_ObjToDel.push_back(pGameObj);
//linkedGO->SetUInt32Value(GAMEOBJECT_FIELD_LEVEL, m_caster->getLevel());
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
/* There is currently no need for this effect. We handle it in Battleground.cpp
/*effIndex*/)
/*
//m_spellInfo->Effects[i].BasePoints; == 99 (percent?)
//unitTarget->ToPlayer()->setResurrect(m_caster->GetGUID(), unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), unitTarget->GetMaxHealth(), unitTarget->GetMaxPower(POWER_MANA));
// remove insignia spell effect
/*effIndex*/)
// can't steal from self
// Create dispel mask by dispel type
// Need check for passive? this
// The charges / stack amounts don't count towards the total number of auras that can be dispelled.
// Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
// Polymorph instead of 1 / (5 + 1) -> 16%.
// Ok if exist some buffs for dispel try dispel it
// dispel N = damage buffs (or while exist buffs for dispel)
// Random select buff for dispel
// 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
// Failed to dispell
// Caster GUID
// Victim GUID
// dispel spell id
// Spell Id
// Victim GUID
// Caster GUID
// dispel spell id
// not used
// count
// Spell Id
// 0 - steals !=0 transfers
// Burn Body
// Fallen Combatant
// needed later
// Blood Tap
// Check if both runes are on cd as that is the only time when this needs to come into effect
// Should always update the rune with the lowest cd
// is needed to push through to the client that the rune is active
// Empower rune weapon
// Need to do this just once
// relocate
// add to world
// unitTarget has pet now
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
// Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls/Ulduar Storm Beacons)
/*effIndex*/)
// in another case summon new
// level of pet summoned using engineering item based at engineering skill level
//TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
// randomize position for multiple summons
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
// damage is 1 or 2, spec is 0 or 1
// Restricted Flight Area
// there may be need of specifying casterguid of removed auras
/*effIndex*/)
//! Action button data is unverified when it's set so it can be "hacked"
//! to contain invalid spells, so filter here.
/*effIndex*/)
// binding
// zone update
// Safety checks done in Spell::CheckCast
// Bank tabs start at zero internally
// already have one active request
// trigger entry/miscvalue relation is currently unknown, for now use MiscValue as trigger entry
// Blizz sends talentId as glyphIndex
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// nobreak;
//
// 1 TARGET_UNIT_CASTER
// 2 TARGET_UNIT_NEARBY_ENEMY
// 3 TARGET_UNIT_NEARBY_PARTY
// 4 TARGET_UNIT_NEARBY_ALLY
// 5 TARGET_UNIT_PET
// 6 TARGET_UNIT_TARGET_ENEMY
// 7 TARGET_UNIT_SRC_AREA_ENTRY
// 8 TARGET_UNIT_DEST_AREA_ENTRY
// 9 TARGET_DEST_HOME
// 10
// 11 TARGET_UNIT_SRC_AREA_UNK_11
// 12
// 13
// 14
// 15 TARGET_UNIT_SRC_AREA_ENEMY
// 16 TARGET_UNIT_DEST_AREA_ENEMY
// 17 TARGET_DEST_DB
// 18 TARGET_DEST_CASTER
// 19
// 20 TARGET_UNIT_CASTER_AREA_PARTY
// 21 TARGET_UNIT_TARGET_ALLY
// 22 TARGET_SRC_CASTER
// 23 TARGET_GAMEOBJECT_TARGET
// 24 TARGET_UNIT_CONE_ENEMY_24
// 25 TARGET_UNIT_TARGET_ANY
// 26 TARGET_GAMEOBJECT_ITEM_TARGET
// 27 TARGET_UNIT_MASTER
// 28 TARGET_DEST_DYNOBJ_ENEMY
// 29 TARGET_DEST_DYNOBJ_ALLY
// 30 TARGET_UNIT_SRC_AREA_ALLY
// 31 TARGET_UNIT_DEST_AREA_ALLY
// 32 TARGET_DEST_CASTER_SUMMON
// 33 TARGET_UNIT_SRC_AREA_PARTY
// 34 TARGET_UNIT_DEST_AREA_PARTY
// 35 TARGET_UNIT_TARGET_PARTY
// 36 TARGET_DEST_CASTER_UNK_36
// 37 TARGET_UNIT_LASTTARGET_AREA_PARTY
// 38 TARGET_UNIT_NEARBY_ENTRY
// 39 TARGET_DEST_CASTER_FISHING
// 40 TARGET_GAMEOBJECT_NEARBY_ENTRY
// 41 TARGET_DEST_CASTER_FRONT_RIGHT
// 42 TARGET_DEST_CASTER_BACK_RIGHT
// 43 TARGET_DEST_CASTER_BACK_LEFT
// 44 TARGET_DEST_CASTER_FRONT_LEFT
// 45 TARGET_UNIT_TARGET_CHAINHEAL_ALLY
// 46 TARGET_DEST_NEARBY_ENTRY
// 47 TARGET_DEST_CASTER_FRONT
// 48 TARGET_DEST_CASTER_BACK
// 49 TARGET_DEST_CASTER_RIGHT
// 50 TARGET_DEST_CASTER_LEFT
// 51 TARGET_GAMEOBJECT_SRC_AREA
// 52 TARGET_GAMEOBJECT_DEST_AREA
// 53 TARGET_DEST_TARGET_ENEMY
// 54 TARGET_UNIT_CONE_ENEMY_54
// 55 TARGET_DEST_CASTER_FRONT_LEAP
// 56 TARGET_UNIT_CASTER_AREA_RAID
// 57 TARGET_UNIT_TARGET_RAID
// 58 TARGET_UNIT_NEARBY_RAID
// 59 TARGET_UNIT_CONE_ALLY
// 60 TARGET_UNIT_CONE_ENTRY
// 61 TARGET_UNIT_TARGET_AREA_RAID_CLASS
// 62 TARGET_UNK_62
// 63 TARGET_DEST_TARGET_ANY
// 64 TARGET_DEST_TARGET_FRONT
// 65 TARGET_DEST_TARGET_BACK
// 66 TARGET_DEST_TARGET_RIGHT
// 67 TARGET_DEST_TARGET_LEFT
// 68 TARGET_DEST_TARGET_FRONT_RIGHT
// 69 TARGET_DEST_TARGET_BACK_RIGHT
// 70 TARGET_DEST_TARGET_BACK_LEFT
// 71 TARGET_DEST_TARGET_FRONT_LEFT
// 72 TARGET_DEST_CASTER_RANDOM
// 73 TARGET_DEST_CASTER_RADIUS
// 74 TARGET_DEST_TARGET_RANDOM
// 75 TARGET_DEST_TARGET_RADIUS
// 76 TARGET_DEST_CHANNEL_TARGET
// 77 TARGET_UNIT_CHANNEL_TARGET
// 78 TARGET_DEST_DEST_FRONT
// 79 TARGET_DEST_DEST_BACK
// 80 TARGET_DEST_DEST_RIGHT
// 81 TARGET_DEST_DEST_LEFT
// 82 TARGET_DEST_DEST_FRONT_RIGHT
// 83 TARGET_DEST_DEST_BACK_RIGHT
// 84 TARGET_DEST_DEST_BACK_LEFT
// 85 TARGET_DEST_DEST_FRONT_LEFT
// 86 TARGET_DEST_DEST_RANDOM
// 87 TARGET_DEST_DEST
// 88 TARGET_DEST_DYNOBJ_NONE
// 89 TARGET_DEST_TRAJ
// 90 TARGET_UNIT_TARGET_MINIPET
// 91 TARGET_DEST_DEST_RADIUS
// 92 TARGET_UNIT_SUMMONER
// 93 TARGET_CORPSE_SRC_AREA_ENEMY
// 94 TARGET_UNIT_VEHICLE
// 95 TARGET_UNIT_TARGET_PASSENGER
// 96 TARGET_UNIT_PASSENGER_0
// 97 TARGET_UNIT_PASSENGER_1
// 98 TARGET_UNIT_PASSENGER_2
// 99 TARGET_UNIT_PASSENGER_3
// 100 TARGET_UNIT_PASSENGER_4
// 101 TARGET_UNIT_PASSENGER_5
// 102 TARGET_UNIT_PASSENGER_6
// 103 TARGET_UNIT_PASSENGER_7
// 104 TARGET_UNIT_CONE_ENEMY_104
// 105 TARGET_UNIT_UNK_105
// 106 TARGET_DEST_CHANNEL_CASTER
// 107 TARGET_UNK_DEST_AREA_UNK_107
// 108 TARGET_GAMEOBJECT_CONE
// 109
// 110 TARGET_DEST_UNK_110
// 111
// 112
// 113
// 114
// 115
// 116
// 117
// 118
// 119
// 120
// 121
// 122
// 123
// 124
// 125
// 126
// 127
// 128
// 129
// 130
// 131
// 132
// 133
// 134
// 135
// 136
// 137
// 138
// 139
// 140
// 141
// 142
// 143
/*spellEntry*/, SpellInfo const* spellInfo, uint8 effIndex, SpellEffectEntry const* _effect)
// base amount modification based on spell lvl vs caster lvl
// roll in a range <1;EffectDieSides> as of patch 3.3.3
// range 1..1
// range can have positive (1..rand) and negative (rand..1) values, so order its for irand
// random damage
// bonus amount from combo points
// amount multiplication based on caster's level
/* REVIEW - MERGE <<<<<<< HEAD
//there are many more: slow speed, -healing pct
//value = int32(value * (int32)getLevel() / (int32)(_spellInfo->spellLevel ? _spellInfo->spellLevel : 1));
// REVIEW - MERGE >>>>>>> master
//! Still not sure which to pick. Anyway at the current time (Patch 4.3.4) most of the spell effects
//! have no radius mod per level, and RadiusMin is equal to RadiusMax.
/*= false*/, bool dstSet /*= false*/, uint32 mask /*=0*/) const
// remove all flags covered by effect target mask
// implicit target type           used target object type
// 0
// 1 SPELL_EFFECT_INSTAKILL
// 2 SPELL_EFFECT_SCHOOL_DAMAGE
// 3 SPELL_EFFECT_DUMMY
// 4 SPELL_EFFECT_PORTAL_TELEPORT
// 5 SPELL_EFFECT_TELEPORT_UNITS
// 6 SPELL_EFFECT_APPLY_AURA
// 7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
// 8 SPELL_EFFECT_POWER_DRAIN
// 9 SPELL_EFFECT_HEALTH_LEECH
// 10 SPELL_EFFECT_HEAL
// 11 SPELL_EFFECT_BIND
// 12 SPELL_EFFECT_PORTAL
// 13 SPELL_EFFECT_RITUAL_BASE
// 14 SPELL_EFFECT_RITUAL_SPECIALIZE
// 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL
// 16 SPELL_EFFECT_QUEST_COMPLETE
// 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
// 18 SPELL_EFFECT_RESURRECT
// 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
// 20 SPELL_EFFECT_DODGE
// 21 SPELL_EFFECT_EVADE
// 22 SPELL_EFFECT_PARRY
// 23 SPELL_EFFECT_BLOCK
// 24 SPELL_EFFECT_CREATE_ITEM
// 25 SPELL_EFFECT_WEAPON
// 26 SPELL_EFFECT_DEFENSE
// 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
// 28 SPELL_EFFECT_SUMMON
// 29 SPELL_EFFECT_LEAP
// 30 SPELL_EFFECT_ENERGIZE
// 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
// 32 SPELL_EFFECT_TRIGGER_MISSILE
// 33 SPELL_EFFECT_OPEN_LOCK
// 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
// 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
// 36 SPELL_EFFECT_LEARN_SPELL
// 37 SPELL_EFFECT_SPELL_DEFENSE
// 38 SPELL_EFFECT_DISPEL
// 39 SPELL_EFFECT_LANGUAGE
// 40 SPELL_EFFECT_DUAL_WIELD
// 41 SPELL_EFFECT_JUMP
// 42 SPELL_EFFECT_JUMP_DEST
// 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
// 44 SPELL_EFFECT_SKILL_STEP
// 45 SPELL_EFFECT_ADD_HONOR
// 46 SPELL_EFFECT_SPAWN
// 47 SPELL_EFFECT_TRADE_SKILL
// 48 SPELL_EFFECT_STEALTH
// 49 SPELL_EFFECT_DETECT
// 50 SPELL_EFFECT_TRANS_DOOR
// 51 SPELL_EFFECT_FORCE_CRITICAL_HIT
// 52 SPELL_EFFECT_GUARANTEE_HIT
// 53 SPELL_EFFECT_ENCHANT_ITEM
// 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
// 55 SPELL_EFFECT_TAMECREATURE
// 56 SPELL_EFFECT_SUMMON_PET
// 57 SPELL_EFFECT_LEARN_PET_SPELL
// 58 SPELL_EFFECT_WEAPON_DAMAGE
// 59 SPELL_EFFECT_CREATE_RANDOM_ITEM
// 60 SPELL_EFFECT_PROFICIENCY
// 61 SPELL_EFFECT_SEND_EVENT
// 62 SPELL_EFFECT_POWER_BURN
// 63 SPELL_EFFECT_THREAT
// 64 SPELL_EFFECT_TRIGGER_SPELL
// 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
// 66 SPELL_EFFECT_CREATE_MANA_GEM
// 67 SPELL_EFFECT_HEAL_MAX_HEALTH
// 68 SPELL_EFFECT_INTERRUPT_CAST
// 69 SPELL_EFFECT_DISTRACT
// 70 SPELL_EFFECT_PULL
// 71 SPELL_EFFECT_PICKPOCKET
// 72 SPELL_EFFECT_ADD_FARSIGHT
// 73 SPELL_EFFECT_UNTRAIN_TALENTS
// 74 SPELL_EFFECT_APPLY_GLYPH
// 75 SPELL_EFFECT_HEAL_MECHANICAL
// 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
// 77 SPELL_EFFECT_SCRIPT_EFFECT
// 78 SPELL_EFFECT_ATTACK
// 79 SPELL_EFFECT_SANCTUARY
// 80 SPELL_EFFECT_ADD_COMBO_POINTS
// 81 SPELL_EFFECT_CREATE_HOUSE
// 82 SPELL_EFFECT_BIND_SIGHT
// 83 SPELL_EFFECT_DUEL
// 84 SPELL_EFFECT_STUCK
// 85 SPELL_EFFECT_SUMMON_PLAYER
// 86 SPELL_EFFECT_ACTIVATE_OBJECT
// 87 SPELL_EFFECT_GAMEOBJECT_DAMAGE
// 88 SPELL_EFFECT_GAMEOBJECT_REPAIR
// 89 SPELL_EFFECT_GAMEOBJECT_SET_DESTRUCTION_STATE
// 90 SPELL_EFFECT_KILL_CREDIT
// 91 SPELL_EFFECT_THREAT_ALL
// 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
// 93 SPELL_EFFECT_FORCE_DESELECT
// 94 SPELL_EFFECT_SELF_RESURRECT
// 95 SPELL_EFFECT_SKINNING
// 96 SPELL_EFFECT_CHARGE
// 97 SPELL_EFFECT_CAST_BUTTON
// 98 SPELL_EFFECT_KNOCK_BACK
// 99 SPELL_EFFECT_DISENCHANT
// 100 SPELL_EFFECT_INEBRIATE
// 101 SPELL_EFFECT_FEED_PET
// 102 SPELL_EFFECT_DISMISS_PET
// 103 SPELL_EFFECT_REPUTATION
// 104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
// 105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
// 106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
// 107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
// 108 SPELL_EFFECT_DISPEL_MECHANIC
// 109 SPELL_EFFECT_SUMMON_DEAD_PET
// 110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
// 111 SPELL_EFFECT_DURABILITY_DAMAGE
// 112 SPELL_EFFECT_112
// 113 SPELL_EFFECT_RESURRECT_NEW
// 114 SPELL_EFFECT_ATTACK_ME
// 115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
// 116 SPELL_EFFECT_SKIN_PLAYER_CORPSE
// 117 SPELL_EFFECT_SPIRIT_HEAL
// 118 SPELL_EFFECT_SKILL
// 119 SPELL_EFFECT_APPLY_AREA_AURA_PET
// 120 SPELL_EFFECT_TELEPORT_GRAVEYARD
// 121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
// 122 SPELL_EFFECT_122
// 123 SPELL_EFFECT_SEND_TAXI
// 124 SPELL_EFFECT_PULL_TOWARDS
// 125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
// 126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF
// 127 SPELL_EFFECT_PROSPECTING
// 128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
// 129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
// 130 SPELL_EFFECT_REDIRECT_THREAT
// 131 SPELL_EFFECT_PLAY_SOUND
// 132 SPELL_EFFECT_PLAY_MUSIC
// 133 SPELL_EFFECT_UNLEARN_SPECIALIZATION
// 134 SPELL_EFFECT_KILL_CREDIT2
// 135 SPELL_EFFECT_CALL_PET
// 136 SPELL_EFFECT_HEAL_PCT
// 137 SPELL_EFFECT_ENERGIZE_PCT
// 138 SPELL_EFFECT_LEAP_BACK
// 139 SPELL_EFFECT_CLEAR_QUEST
// 140 SPELL_EFFECT_FORCE_CAST
// 141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
// 142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
// 143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
// 144 SPELL_EFFECT_KNOCK_BACK_DEST
// 145 SPELL_EFFECT_PULL_TOWARDS_DEST
// 146 SPELL_EFFECT_ACTIVATE_RUNE
// 147 SPELL_EFFECT_QUEST_FAIL
// 148 SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE
// 149 SPELL_EFFECT_CHARGE_DEST
// 150 SPELL_EFFECT_QUEST_START
// 151 SPELL_EFFECT_TRIGGER_SPELL_2
// 152 SPELL_EFFECT_SUMMON_RAF_FRIEND
// 153 SPELL_EFFECT_CREATE_TAMED_PET
// 154 SPELL_EFFECT_DISCOVER_TAXI
// 155 SPELL_EFFECT_TITAN_GRIP
// 156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
// 157 SPELL_EFFECT_CREATE_ITEM_2
// 158 SPELL_EFFECT_MILLING
// 159 SPELL_EFFECT_ALLOW_RENAME_PET
// 160 SPELL_EFFECT_160
// 161 SPELL_EFFECT_TALENT_SPEC_COUNT
// 162 SPELL_EFFECT_TALENT_SPEC_SELECT
// 163 SPELL_EFFECT_163
// 164 SPELL_EFFECT_REMOVE_AURA
// 165 SPELL_EFFECT_165
// 166 SPELL_EFFECT_GIVE_CURRENCY
// 167 SPELL_EFFECT_167
// 168 SPELL_EFFECT_168
// 169 SPELL_EFFECT_DESTROY_ITEM
// 170 SPELL_EFFECT_170
// 171 SPELL_EFFECT_171
// 172 SPELL_EFFECT_172
// 173 SPELL_EFFECT_UNLOCK_GUILD_VAULT_TAB
// 174 SPELL_EFFECT_174
// 175 SPELL_EFFECT_175
// 176 SPELL_EFFECT_176
// 177 SPELL_EFFECT_177
// 178 SPELL_EFFECT_178
// 179 SPELL_EFFECT_CREATE_AREATRIGGER
// 180 SPELL_EFFECT_180
// 181 SPELL_EFFECT_181
// 182 SPELL_EFFECT_182
// SpellDifficultyEntry
// SpellScalingEntry
// SpellAuraOptionsEntry
// SpellAuraRestrictionsEntry
// SpellCastingRequirementsEntry
// SpellCategoriesEntry
// SpellClassOptionsEntry
// SpellCooldownsEntry
// SpellEquippedItemsEntry
// SpellInterruptsEntry
// SpellLevelsEntry
// SpellPowerEntry
// SpellReagentsEntry
// SpellShapeshiftEntry
// SpellTargetRestrictionsEntry
// SpellTotemsEntry
// SpecializationSpellsEntry
// different random cards from Inscription (121==Virtuoso Inking Set category) r without explicit item
// checks if spell targets are selected from area, doesn't include spell effects in check (like area wide auras for example)
/*
// All stance spells. if any better way, change it.
// Paladin aura Spell
// Druid form Spell
// Power Spark, Fel Flak Fire, Incanter's Absorption
/// TODO: Re-verify meaning of SPELL_ATTR3_STACK_FOR_DIFF_CASTERS and update conditions here
// for 53352, cannot find better way
// False if affect_spell == NULL or spellFamily not equal
// true
// these spells pierce all avalible spells (Resurrection Sickness for example)
// these spells (Cyclone for example) can pierce all...
// ...but not these (Divine shield for example)
// These spells (like Mass Dispel) can dispell all auras
// These auras (like Divine Shield) can't be dispelled
// These auras (Cyclone for example) are not dispelable
// all other single target spells have if it has AttributesEx5
// talents that learn spells can have stance requirements that need ignore
// (this requirement only for client-side stance show in talent description)
// can explicitly not be casted in this stance
// can explicitly be casted in this stance
// shapeshift acts as normal form for spells
// not while shapeshifted
// needs other shapeshift
// needs shapeshift
// Check if stance disables cast of not-stance spells
// Example: cannot cast any other spells in zombie or ghoul form
/// @todo Find a way to disable use of these spells clientside
// normal case
// Try search in next group
// continent limitation (virtual continent)
// raid instance limitation
// DB base check (if non empty then must fit at least single for allow)
// bg spell checks
// Warsong Flag
// Silverwing Flag
// Netherstorm Flag
// Waiting to Resurrect
// Spirit Heal Channel
// Spirit Heal
// Resurrection Impact Visual
// Recently Dropped Flag
// Inactive
// Spirit Heal (mana)
// Preparation
// Gold Team (Alliance)
// Green Team (Alliance)
// Gold Team (Horde)
// Green Team (Horde)
// Arena Preparation
// aura limitations
// check visibility - ignore stealth for implicit (area) targets
// creature/player specific target checks
// only spells with SPELL_ATTR3_ONLY_TARGET_GHOSTS can target ghosts
// Do not allow these spells to target creatures not tapped by us (Banish, Polymorph, many quest spells)
// Not allow disarm unarmed player
// corpse specific target checks
// cannot target bare bones
// we have to use owner for some checks (aura preventing resurrection for example)
// we're not interested in corpses without owner
// other types of objects - always valid
// corpseOwner and unit specific target checks
// check this flag only for implicit targets (chain and area), allow to explicitly target units for spells like Shield of Righteousness
// checked in Unit::IsValidAttack/AssistTarget, shouldn't be checked for ENTRY targets
//if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
//    return SPELL_FAILED_BAD_TARGETS;
//if (!(AttributesEx6 & SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS)
// check GM mode and GM invisibility - only for player casts (npc casts are controlled by AI) and negative spells
// not allow casting on flying player
/* TARGET_UNIT_MASTER gets blocked here for passengers, because the whole idea of this check is to
// All creatures should be able to cast as passengers freely, restriction and attribute are only for players
// unk flag
// Can only summon uncontrolled minions/guardians when on controlled vehicle
// Curse of Doom & Exorcism: not find another way to fix spell target check :/
// not allow cast at player
// If dispel all
// Seals
// Conflagrate aura state on Immolate and Shadowflame
// Immolate
// Shadowflame
// Faerie Fire (druid versions)
// Sting (hunter's pet ability)
// Victorious
// Swiftmend state on Regrowth & Rejuvenation
// Deadly poison aura state
// Enrage aura state
// Bleeding aura state
// Divine Surge
// Evasive Charges
// Food / Drinks (mostly)
// Food
// Drink
// scrolls effects
// Strength
// Stamina
// Spirit
// Intellect
// Agility
// Armor
// Enrage (Enrage)
// Enrage (Wrecking Crew)
// family flags 18(Molten), 25(Frost/Ice), 28(Mage)
// Arcane brillance and Arcane intelect (normal check fails because of flags difference)
// Death Wish
// Warlock (Bane of Doom | Bane of Agony | Bane of Havoc)
// only warlock curses have this
// Warlock (Demon Armor | Demon Skin | Fel Armor)
//seed of corruption and corruption
// only hunter stings have this
// only hunter aspects have this (but not all aspects in hunter family)
// Collection of all the seal family flags. No other paladin spell has any of those.
// Judgement of Wisdom, Judgement of Light, Judgement of Justice
// only paladin auras have this (for palaldin class family)
// family flags 10 (Lightning), 42 (Earth), 37 (Water), proc shield from T2 8 pieces bonus
/// @workaround For non-stacking tracking spells (We need generic solution)
// Gas Cloud Tracking
/*= NULL*/) const
// not all spells have cast time index and this is all is pasiive abilities
// 200% limit
// Spell drain all exist power on cast (Only paladin lay of Hands)
// If power type - health drain all
// Else drain all power
// Base powerCost
// PCT cost from total amount
// health as power used
// Flat mod from caster auras by spell school and power type
/*// Flat mod from caster auras by spell school and power type
// Shiv - costs 20 + weaponSpeed*10 energy (apply only to non-triggered spell with energy cost)
/* REVIEW - MERGE
// Apply cost mod by spell
/*
// ignore passive spells
// not required
// if found appropriate level
// one rank less then
// not found
// prepare target mask using effect target entries
// add explicit target flags based on spell effects which have EFFECT_IMPLICIT_TARGET_EXPLICIT and no valid target provided
// extend explicit target mask only if valid targets for effect could not be provided by target types
// don't add explicit object/dest flags when spell has no max range
// not found a single positive spell with this attribute
// Wrath of the Plaguebringer
// Allergic Reaction
// Wrath of the Plaguebringer
// Tag Murloc
// Rabbit Costume
// Noblegarden Bunny
// Fists of Stone
// Ignite
// Divine Hymn
// Hymn of Hope
// Dispersion
// Envenom must be considered as a positive effect even though it deals damage
// Envenom
// Special case: effects which determine positivity of whole spell
// some explicitly required dummy effect sets
// AB Effect 000
// always positive effects (check before target checks that provided non-positive result in some case for positive effects)
// non-positive aura use
// dependent from bas point sign (negative -> negative)
// dependent from bas point sign (positive -> negative)
// some expected positive spells have SPELL_ATTR1_NEGATIVE
// negative targets of main spell return early
// if non-positive trigger cast targeted to positive target this main cast is non-positive
// this will place this spell auras as debuffs
// many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
//have positive and negative spells, we can't sort its correctly at this moment.
// but all single stun aura spells is negative
// Wisp Costume
// used in positive spells also.
// part of negative spell if casted at self (prevent cancel)
// used in positive spells also
// part of positive spell if casted at self
// but not this if this first effect (didn't find better check)
// non-positive immunities
// mods
// non-positive mods
// dependent from bas point sign (negative -> positive)
// non-positive targets
// negative spell if triggered spell is negative
// ok, positive
// spells with at least one negative effect are considered negative
// some self-applied spells have negative effects but in self casting case negative check ignored.
// non-positive targets
// find the same instances of ConditionList and delete them.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Explicit Diminishing Groups
// Pet charge effects (Infernal Awakening, Demon Charge)
// Frost Tomb
// Gnaw
// ToC Icehowl Arctic Breath
// Black Plague
// Event spells
// Frostbite
// Shattered Barrier
// Deep Freeze
// Frost Nova / Freeze (Water Elemental)
// Dragon's Breath
// Hamstring - limit duration to 10s in PvP
// Charge Stun (own diminishing)
// Curses/etc
// Seduction
// Sin and Punishment (Priest spell, don't ask)
// Pounce
// Cyclone
// Entangling Roots
// Nature's Grasp
// Faerie Fire
// Gouge
// Blind
// Cheap Shot
// Crippling poison - Limit to 10 seconds in PvP (No SpellFamilyFlags)
// Hunter's Mark
// Scatter Shot (own diminishing)
// Entrapment (own diminishing)
// Wyvern Sting mechanic is MECHANIC_SLEEP but the diminishing is DIMINISHING_DISORIENT
// Freezing Arrow
// Judgement of Justice - limit duration to 10s in PvP
// Turn Evil
// Storm, Earth and Fire - Earthgrab
// Hungering Cold (no flags)
// Mark of Blood
// Lastly - Set diminishing depending on mechanic
// Mechanic Knockout, except Blast Wave
// Explicit diminishing duration
// Faerie Fire - limit to 40 seconds in PvP (3.1)
// Wyvern Sting
// Hunter's Mark
// Repentance - limit to 6 seconds in PvP
// Banish - limit to 6 seconds in PvP
// Curse of Tongues - limit to 12 seconds in PvP
// Curse of Elements - limit to 120 seconds in PvP
/// Some checks for spells, to prevent adding deprecated/broken spells for trainers, spell book, etc
// not exist
// check effects
// craft spell for crafting non-existed item (break client recipes list show)
// skip auto-loot crafting spells, its not need explicit item info (but have special fake items sometime)
// also possible IsLootCrafting case but fake item must exist anyway
//return source spell
//return source spell, it has only REGULAR_DIFFICULTY
//return source spell
// Find group with SPELL_GROUP_STACK_RULE_EXCLUSIVE_SAME_EFFECT if it belongs to one
// Put the highest amount in the map
// Take absolute value because this also counts for the highest negative aura
// return because a spell should be in only one SPELL_GROUP_STACK_RULE_EXCLUSIVE_SAME_EFFECT group
// Not in a SPELL_GROUP_STACK_RULE_EXCLUSIVE_SAME_EFFECT group, so return false
// find SpellGroups which are common for both spells
// No extra req need
// check prockFlags for condition
/* Check Periodic Auras
// Trap casts are active by default
// Always trigger for this
// Exist event data
// Store extra req
// For melee triggers
// Check (if set) for school (melee attack have Normal school)
// For spells need check school/spell family/family mask
// Check (if set) for school
// Check (if set) for spellFamilyName
// spellFamilyName is Ok need check for spellFamilyMask if present
// Some spells are not considered as active even with have spellfamilyflags
// Check for extra req (if none) and hit/crit
// No extra req, so can trigger only for hit/crit - spell has to be active
// Passive spells hits here only if resist/reflect/immune/evade
// if spell marked as procing only from not active spells
// if spell marked as procing only from active spells
// Exist req for PROC_EX_EX_TRIGGER_ALWAYS
// PROC_EX_NOT_ACTIVE_SPELL and PROC_EX_ONLY_ACTIVE_SPELL flags handle: if passed checks before
// Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
// proc type doesn't match
// check XP or honor target requirement
// always trigger for these types
// check school mask (if set) for other trigger types
// check spell family name/flags (if set) for spells
// check spell type mask (if set)
// check spell phase mask
// check hit mask (on taken hit or on done hit, but not on spell cast phase)
// get default values if hit mask not set
// for taken procs allow normal + critical hits by default
// for done procs allow normal + critical + absorbs by default
// Lookup data
// Not found, try lookup for 1 spell rank if exist
// not in expected gender
// not in expected race
// not in expected zone
// not in expected required quest state
// not in expected forbidden quest state
// not have expected aura
// Extra conditions
// No fly Zone - Wintergrasp
// Horde Controls Factory Phase Shift
// Alliance Controls Factory Phase Shift
// team that controls the workshop in the specified area
// Essence of Wintergrasp - Northrend
// Essence of Wintergrasp - Wintergrasp
// Battleground - Dampening
// Remove Me
// cleanup data and load spell ranks for talents from dbc
//                                                     0             1      2
// spellid, rank
// fill one chain
// don't drop the row if we're moving to the next rank
// check if chain is made with valid first spell
// check if chain is long enough
// check spells in chain
// insert the chain
// need for reload case
// need for reload case
//                                                   0        1
// check if chain is made with valid first spell
// need for reload case
// search auto-learned skills and add its to map also for use in unlearn spells/talents
// need for reload case
//                                                  0      1        2
// copy state loaded from db
// search auto-learned spells and add its to map also for use in unlearn spells/talents
// all dbc based learned spells is active (show in spell book or hide by client itself)
// ignore learning not existed spells (broken/outdated/or generic learnig spell 483
// talent or passive spells or skill-step spells auto-casted and not need dependent learning,
// pet teaching spells must not be dependent learning (casted)
// other required explicit dependent learning
// add new spell-spell pair if not found
/*
// Check if it is already found in Spell.dbc, ignore silently if yes
// need for reload case
//                                                0      1          2             3                  4                  5                   6
/*
// need for reload case
//                                                0     1
// need for reload case
//                                                       0         1
// need for reload case
//                                                0      1           2                3                 4                 5                6                 7          8        9       10            11
// need for reload case
//                                                 0        1           2                3                 4                 5                 6         7              8               9        10              11             12      13        14
// take defaults from dbcs
// validate data
// need for reload case
//                                                0      1             2          3         4
// need for reload case
//                                                0      1        2       3
// need for reload case
//                                                  0       1       2    3
// Fill custom data about enchancments
/// @todo find a better check
// need for reload case
//                                                  0         1           2         3
// need for reload case
//                                                0              1             2
//we will find a better way when more types are needed
// need for reload case
// not exist
//if (skillLine->skillId != creatureFamily->skillLine[0] &&
//    (!creatureFamily->skillLine[1] || skillLine->skillId != creatureFamily->skillLine[1]))
//    continue;
// not exist or triggered or talent
// skip empty list;
// remove duplicates with levelupSpells if any
// skip empty list;
// for creature with PetSpellDataId get default pet spells from dbc
// different summon spells
// already loaded
// for creature without PetSpellDataId get default pet spells from creature_template
// need for reload case
//                                                  0     1         2              3               4                 5          6          7       8         9
// duplicate by requirements
// not allow autocast chains by auraSpell field (but allow use as alternative if not present)
// for search by current zone/subzone at zone/subzone change
// for search at quest start/reward
// for search at quest start/reward
// for search at aura apply
// Temporary structure to hold spell effect entries for faster loading
// only enchanting profession enchantments procs can stack
// if proced directly from enchantment, not via proc aura
// NOTE: Enchant Weapon - Blade Ward also has proc aura spell and is proced directly
// however its not expected to stack so this check is good
// Gouge
// Head Smack
// Backstab
// Garrote
// Shred
// Ambush
// Ravage
// Lash of Pain
// Test Stab R50
// Test Backstab
// Assassinate Restless Lookout
// Dark Glare
// Spout
// Flame Breath
// Flame Breath
// Coldflame Trap
// Pain and Suffering
// Pain and Suffering
// Pain and Suffering
// Pain and Suffering
// Meteor
// Meteor
// Meteor
// Meteor
// Meteor
// Meteor
// Meteor
// Shard of the Fallen Star
// Malevolent Cleave
// Dive Bomb
// Saber Lash
// Saber Lash
// Saber Lash
// Brutal Swipe
// Meteor Slash
// Sonic Screech
// Shared Suffering
// Chaos Bane
// Ooze Eruption
// Ooze Eruption
// Ooze Eruption
// Ooze Eruption
// ONLY SPELLS WITH SPELLFAMILY_GENERIC and EFFECT_SCHOOL_DAMAGE
// Wing Buffet
// Wild Bite
// Piercing Blow
// Penetrating Strike
// Impale
// Impale
// Shatter
// Machine Gun
// Machine Gun
// Impale
// Impale
// Impale
// Impale
// Wing Buffet
// Machine Gun
// Mark of the Faceless (General Vezax)
// Thrust (Argent Tournament)
// Thrust (Argent Tournament)
// Thrust (Argent Tournament)
// Thrust (Argent Tournament)
// Counterattack! (Argent Tournament)
// Break-Shield (Argent Tournament, Player)
// Break-Shield (Argent Tournament, Player)
// Break-Shield (Argent Tournament, NPC)
// Break-Shield (Argent Tournament, NPC)
// Break-Shield (Argent Tournament, NPC)
// Break-Shield (Argent Tournament, NPC)
// Charge (Argent Tournament, Player)
// Charge (Argent Tournament, Player)
// Charge (Argent Tournament, Player)
// Charge (Argent Tournament, NPC)
// Charge (Argent Tournament, NPC)
// Charge (Argent Tournament, NPC)
// Mark of the Fallen Champion (Deathbringer Saurfang)
// Mark of the Fallen Champion (Deathbringer Saurfang)
// Mark of the Fallen Champion (Deathbringer Saurfang)
// Mark of the Fallen Champion (Deathbringer Saurfang)
// Sonic Screech (Auriaya)
// Mark of the Fallen Champion (Deathbringer Saurfang)
// Shout
// Roar
// flight
// Woe Strike
// Woe Strike
// Summon Skeletons
// Summon Skeletons
// Simon Game Visual
// Simon Game Visual
// Simon Game Visual
// Simon Game Visual
// Spout, remove damage effect, only anim is needed
// Quake
// Blaze (needs conditions entry)
// Charge (Argent Tournament emote on riders)
// Sleep (needs target selection script)
// Summon Ghouls On Scarlet Crusade (this should use conditions table, script for this spell needs to be fixed)
// Wrath of Air Totem rank 2 (Aura)
// Purify Helboar Meat
// Howl of Azgalor
// 100yards instead of 50000?!
// Headless Horseman - Wisp Flight Port
// Headless Horseman - Wisp Flight Missile
// 100 yards
// They Must Burn Bomb Aura (self)
// They Must Burn Bomb Drop (DND)
// Stop Time
// Energize Cores
// Energize Cores
// Energize Cores
// Energize Cores
// Energize Cores
// Energize Cores
// Glyph of Life Tap
// Rapid Killing (Rank 1)
// Rapid Killing (Rank 2)
// Entries were not updated after spell effect change, we have to do that manually :/
// Execute
// Improved Spell Reflection - aoe aura
// Target entry seems to be wrong for this spell :/
// Doom
// Thundering Storm
// Raise Dead (HACK)
// Vengeance Landing Cannonfire
// Shoot
// Wild Magic
// Wild Magic
// Wild Magic
// Wild Magic
// Wild Magic
// Wild Magic
// Shoot Gun
// Cosmetic - Incinerate to Random Target
// Ball of Flame
// Prayer of Mending
// Spectral Blast
// Revitalize
// Muru Portal Channel
// Sky Darkener Assault
// Quetz'lun's Judgment
// Gift of the Harvester
// Blazing Harpoon
// Skartax Purple Beam
// Life Drain - Sapphiron
// Curse of the Plaguebringer - Noth
// Multi-Shot
// Spread Shot
// Needle Spine
// Saber Lash
// Soul Drain
// Spite
// Shadow Blades
// Flame Sear
// Divine Storm
// Divine Storm (heal)
// Flaming Spear
// Multi-Shot
// Divine Storm (Damage)
// Bloodboil
// Spitfire Totem
// Insidious Whisper
// Negative Energy
// Fire Bloom
// Life Drain - Sapphiron (H)
// Poison Bolt Volly - Faerlina
// Sinful Beam
// Sinister Beam
// Vile Beam
// Wicked Beam
// Curse of the Plaguebringer - Noth (H)
// Poison Bolt Volly - Faerlina (H)
// Unholy Frenzy
// Murmur's Touch
// Murmur's Touch
// Shadow Trance
// Netherwind Focus
// Misdirection
// Backlash
// Hot Streak
// Killing Machine
// Firestarter
// Fireball!
// Item - Druid T8 Balance 4P Bonus
// Daybreak
// Fingers of Frost
// Fingers of Frost visual buff
// Ascendance (Talisman of Ascendance trinket)
// Everlasting Affliction (1)
// Everlasting Affliction (2)
// Everlasting Affliction (3)
// Everlasting Affliction (4)
// Everlasting Affliction (5)
// add corruption to affected spells
// The Eye of Acherus (no spawn in phase 2 in db)
// Crafty's Ultra-Advanced Proto-Typical Shortening Blaster
// Master Shapeshifter: missing stance data for forms other than bear - bear version has correct data
// To prevent aura staying on target after talent unlearned
// Master Shapeshifter
// Heart of the Wild - Cat Effect
// Heart of the Wild - Bear Effect
// Master Shapeshifter
// Elemental Oath (Rank 1)
// Elemental Oath (Rank 2)
// Improved Shadowform (Rank 1)
// with this spell atrribute aura can be stacked several times
// Hymn of Hope
// Nether Portal - Perseverence
// Parasitic Shadowfiend Passive
// proc debuff, and summon infinite fiends
// To Anchor 1
// To Anchor 1
// To Anchor 1
// Anchor to Skulls
// Anchor to Skulls
// Anchor to Skulls
// target allys instead of enemies, target A is src_caster, spells with effect like that have ally target
// this is the only known exception, probably just wrong data
// Wrath of the Plaguebringer
// Wrath of the Plaguebringer
// Improved Devouring Plague
// Tremor Totem (instant pulse)
// Earthbind Totem (instant pulse)
// Marked for Death (Rank 1)
// Marked for Death (Rank 2)
// Wrath
// Starfire
// Starsurge
// Exploit Weakness (needs target selection script)
// Devious Minds (needs target selection script)
// Culling The Herd (needs target selection script)
// Sigil of the Frozen Conscience - change class mask to custom extended flags of Icy Touch
// this is done because another spell also uses the same SpellFamilyFlags as Icy Touch
// SpellFamilyFlags[0] & 0x00000040 in SPELLFAMILY_DEATHKNIGHT is currently unused (3.3.5a)
// this needs research on modifier applying rules, does not seem to be in Attributes fields
// Idol of the Flourishing Life
// Libram of the Lightbringer
// Libram of Tolerance
// Libram of the Resolute
// Libram of Light
// Libram of Divinity
// Blessed Book of Nagrand
// Ride Carpet
// force seat 0, vehicle doesn't have the required seat flags for "no seat specified (-1)"
// Easter Lay Noblegarden Egg Aura - Interrupt flags copied from aura which this aura is linked with
// Drain Life - Bryntroll Normal
// Drain Life - Bryntroll Heroic
// The Beast Within
// ULDUAR SPELLS
//
// Pursued (Flame Leviathan)
// 50000yd
// Focused Eyebeam Summon Trigger (Kologarn)
// Growth of Nature (Freya)
// Growth of Nature (Freya)
// Strength of the Pack (Auriaya)
// Searing Light (XT-002)
// Searing Light (25m) (XT-002)
// Gravity Bomb (XT-002)
// Gravity Bomb (25m) (XT-002)
// Boom (XT-002)
// This hack is here because we suspect our implementation of spell effect execution on targets
// is done in the wrong order. We suspect that EFFECT_0 needs to be applied on all targets,
// then EFFECT_1, etc - instead of applying each effect on target1, then target2, etc.
// The above situation causes the visual for this spell to be bugged, so we remove the instakill
// effect and implement a script hack for that.
// Terrifying Screech (Auriaya)
// Sentinel Blast (Auriaya)
// Sentinel Blast (Auriaya)
// 5 seconds, wrong DBC data?
// Potent Pheromones (Freya)
// spell should dispel area aura, but doesn't have the attribute
// may be db data bug, or blizz may keep reapplying area auras every update with checking immunity
// that will be clear if we get more spells with problem like this
// Ride Vehicle (Yogg-Saron)
// TODO: remove this when basepoints of all Ride Vehicle auras are calculated correctly
// Empowering Shadows (Yogg-Saron)
// Empowering Shadows (Yogg-Saron)
// same for both modes?
// Cosmic Smash (Algalon the Observer)
// Cosmic Smash (Algalon the Observer)
// Cosmic Smash (Algalon the Observer)
// Cosmic Smash (Algalon the Observer)
// Cosmic Smash (Algalon the Observer)
// 100yd
// Expedition Base Camp Teleport
// Conservatory Teleport
// Halls of Invention Teleport
// Colossal Forge Teleport
// Shattered Walkway Teleport
// Antechamber Teleport
// Scrapyard Teleport
// Formation Grounds Teleport
// Prison of Yogg-Saron Teleport
// ENDOF ULDUAR SPELLS
//
// TRIAL OF THE CRUSADER SPELLS
//
// Infernal Eruption (10N)
// Infernal Eruption (25N)
// increase duration from 15 to 18 seconds because caster is already
// unsummoned when spell missile hits the ground so nothing happen in result
// ENDOF TRIAL OF THE CRUSADER SPELLS
//
// ICECROWN CITADEL SPELLS
//
// THESE SPELLS ARE WORKING CORRECTLY EVEN WITHOUT THIS HACK
// THE ONLY REASON ITS HERE IS THAT CURRENT GRID SYSTEM
// DOES NOT ALLOW FAR OBJECT SELECTION (dist > 333)
// Light's Hammer Teleport
// Oratory of the Damned Teleport
// Rampart of Skulls Teleport
// Deathbringer's Rise Teleport
// Upper Spire Teleport
// Frozen Throne Teleport
// Sindragosa's Lair Teleport
// Bone Storm (Lord Marrowgar)
// Bone Storm (Lord Marrowgar)
// Bone Storm (Lord Marrowgar)
// Bone Storm (Lord Marrowgar)
// Death Plague (Rotting Frost Giant)
// Plague Stench (Stinky)
// Plague Stench (Stinky)
// Decimate (Stinky & Precious)
// 100yd
// Shadow's Fate
// Blood Nova (Deathbringer Saurfang)
// Blood Nova (Deathbringer Saurfang)
// Scent of Blood (Deathbringer Saurfang)
// no break
// Scent of Blood (Deathbringer Saurfang)
// Resistant Skin (Deathbringer Saurfang adds)
// this spell initially granted Shadow damage immunity, however it was removed but the data was left in client
// Coldflame Jets (Traps after Saurfang)
// 10 seconds
// Green Ooze Summon (Professor Putricide)
// Orange Ooze Summon (Professor Putricide)
// Awaken Plagued Zombies
// Volatile Ooze Beam Protection (Professor Putricide)
// for an unknown reason this was SPELL_EFFECT_APPLY_AREA_AURA_RAID
// THIS IS HERE BECAUSE COOLDOWN ON CREATURE PROCS IS NOT IMPLEMENTED
// Mutated Strength (Professor Putricide)
// Mutated Strength (Professor Putricide)
// Mutated Strength (Professor Putricide)
// Mutated Strength (Professor Putricide)
// Mutated Plague (Professor Putricide)
// Mutated Plague (Professor Putricide)
// Mutated Plague (Professor Putricide)
// Mutated Plague (Professor Putricide)
// 50000yd
// Unbound Plague (Professor Putricide) (needs target selection script)
// Unbound Plague (Professor Putricide) (needs target selection script)
// Unbound Plague (Professor Putricide) (needs target selection script)
// Unbound Plague (Professor Putricide) (needs target selection script)
// Unholy Infusion Quest Credit (Professor Putricide)
// Blood Infusion Quest Credit (Blood-Queen Lana'thel)
// Frost Infusion Quest Credit (Sindragosa)
// another missing radius
// Empowered Flare (Blood Prince Council)
// Empowered Flare (Blood Prince Council)
// Empowered Flare (Blood Prince Council)
// Empowered Flare (Blood Prince Council)
// Swarming Shadows
// Swarming Shadows
// originally, these require area 4522, which is... outside of Icecrown Citadel
// Corruption
// Paralyze
// Column of Frost (visual marker)
// 6 seconds (missing)
// Mana Void (periodic aura)
// 30 seconds (missing)
// Frostbolt Volley (only heroic)
// Frostbolt Volley (only heroic)
// Summon Suppressor (needs target selection script)
// Achievement Check (Valithria Dreamwalker)
// Order Whelp
// 200yd
// Sindragosa's Fury
// Frost Bomb
// This spell's summon happens instantly
// Ice Lock
// Defile
// 53 seconds
// Defile
// 45 seconds
// Defile
// Defile
// Defile
// Defile
// 200yd
// 200yd
// Val'kyr Target Search
// 200yd
// 200yd
// Raging Spirit Visual
// 50000yd
// Harvest Souls
// Harvest Souls
// Harvest Souls
// Harvest Souls
// 50000yd
// 50000yd
// 50000yd
// Harvest Soul
// Summon Shadow Trap
// 90 seconds
// Shadow Trap (visual)
// 5 seconds
// Shadow Trap
// 10yd
// Shadow Trap (searcher)
// 3yd
// Restore Soul
// Restore Soul
// 200yd
// Destroy Soul
// 200yd
// Summon Spirit Bomb
// Summon Spirit Bomb
// 200yd
// Summon Spirit Bomb
// Summon Spirit Bomb
// 200yd
// Summon Spirit Bomb
// 25yd
// Fury of Frostmourne
// 50000yd
// 50000yd
// Kill Frostmourne Players
// Fury of Frostmourne
// Jump (removes Fury of Frostmourne debuff)
// Mass Resurrection
// Play Movie
// Trigger Vile Spirit (Inside, Heroic)
// 50000yd
// Raise Dead
// 50000yd
// Jump
// 20yd
// 25yd
// Broken Frostmourne
// 200yd
// ENDOF ICECROWN CITADEL SPELLS
//
// RUBY SANCTUM SPELLS
//
// Twilight Cutter
// Twilight Cutter
// Twilight Cutter
// Twilight Cutter
// 100yd
// Twilight Mending
// Awaken Flames
// Awaken Flames
// ENDOF RUBY SANCTUM SPELLS
//
// EYE OF ETERNITY SPELLS
// All spells below work even without these changes. The LOS attribute is due to problem
// from collision between maps & gos with active destroyed state.
// Arcane Storm bonus explicit visual spell
// Summon Static Field
// Flame Spike (Wyrmrest Skytalon)
// Engulf in Flames (Wyrmrest Skytalon)
// Revivify (Wyrmrest Skytalon)
// Life Burst (Wyrmrest Skytalon)
// This would never crit on retail and it has attribute for SPELL_ATTR3_NO_DONE_BONUS because is handled from player,
// until someone figures how to make scions not critting without hack and without making them main casters this should stay here.
// Arcane Barrage (casted by players and NONMELEEDAMAGELOG with caster Scion of Eternity (original caster)).
// ENDOF EYE OF ETERNITY SPELLS
//
// Introspection
// Introspection
// Introspection
// Introspection
// Minor Fortitude
// Halls Of Origination spells
// Temple Guardian Anhuur
// Disable Beacon Beams L
// Disable Beacon Beams R
// Little hack, Increase the radius so it can hit the Cave In Stalkers in the platform.
// Reverberating Hymn
// Aura is refreshed at 3 seconds, and the tick should happen at the fourth.
// Threatening Gaze
// Tree of Life (Passive)
// Feral Charge (Cat Form)
// Using Steam Tonk Controller
// Steam Tonk Controller
// Collect Sample
// Crashes client on pressing ESC
// Gaze of Occu'thar
// Gaze of Occu'thar
// ISLE OF CONQUEST SPELLS
//
// Teleport
// 50000yd
// ENDOF ISLE OF CONQUEST SPELLS
//
// Seals of the Pure should affect Seal of Righteousness
// Icy Touch - extend FamilyFlags (unused value) for Sigil of the Frozen Conscience to use
// 52893
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// effect index must be in range <0;2>, allow use of special effindexes
// SINGLE
// BOTH
// AREA
// AREA
// EMPTY
// EMPTY
// SINGLE
// BOTH
/*= AURA_REMOVE_BY_DEFAULT*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//
// EFFECT HANDLER NOTES
//
// in aura handler there should be check for modes:
// AURA_EFFECT_HANDLE_REAL set
// AURA_EFFECT_HANDLE_SEND_FOR_CLIENT_MASK set
// AURA_EFFECT_HANDLE_CHANGE_AMOUNT_MASK set - aura is recalculated or is just applied/removed - need to redo all things related to m_amount
// AURA_EFFECT_HANDLE_CHANGE_AMOUNT_SEND_FOR_CLIENT_MASK - logical or of above conditions
// AURA_EFFECT_HANDLE_STAT - set when stats are reapplied
// such checks will speedup trinity change amount/send for client operations
// because for change amount operation packets will not be send
// aura effect handlers shouldn't contain any AuraEffect or Aura object modifications
//  0 SPELL_AURA_NONE
//  1 SPELL_AURA_BIND_SIGHT
//  2 SPELL_AURA_MOD_POSSESS
//  3 SPELL_AURA_PERIODIC_DAMAGE implemented in AuraEffect::PeriodicTick
//  4 SPELL_AURA_DUMMY
//  5 SPELL_AURA_MOD_CONFUSE
//  6 SPELL_AURA_MOD_CHARM
//  7 SPELL_AURA_MOD_FEAR
//  8 SPELL_AURA_PERIODIC_HEAL implemented in AuraEffect::PeriodicTick
//  9 SPELL_AURA_MOD_ATTACKSPEED
// 10 SPELL_AURA_MOD_THREAT
// 11 SPELL_AURA_MOD_TAUNT
// 12 SPELL_AURA_MOD_STUN
// 13 SPELL_AURA_MOD_DAMAGE_DONE
// 14 SPELL_AURA_MOD_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonus and Unit::SpellDamageBonus
// 15 SPELL_AURA_DAMAGE_SHIELD    implemented in Unit::DoAttackDamage
// 16 SPELL_AURA_MOD_STEALTH
// 17 SPELL_AURA_MOD_DETECT
// 18 SPELL_AURA_MOD_INVISIBILITY
// 19 SPELL_AURA_MOD_INVISIBILITY_DETECTION
// 20 SPELL_AURA_OBS_MOD_HEALTH implemented in AuraEffect::PeriodicTick
// 21 SPELL_AURA_OBS_MOD_POWER implemented in AuraEffect::PeriodicTick
// 22 SPELL_AURA_MOD_RESISTANCE
// 23 SPELL_AURA_PERIODIC_TRIGGER_SPELL implemented in AuraEffect::PeriodicTick
// 24 SPELL_AURA_PERIODIC_ENERGIZE implemented in AuraEffect::PeriodicTick
// 25 SPELL_AURA_MOD_PACIFY
// 26 SPELL_AURA_MOD_ROOT
// 27 SPELL_AURA_MOD_SILENCE
// 28 SPELL_AURA_REFLECT_SPELLS        implement in Unit::SpellHitResult
// 29 SPELL_AURA_MOD_STAT
// 30 SPELL_AURA_MOD_SKILL
// 31 SPELL_AURA_MOD_INCREASE_SPEED
// 32 SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED
// 33 SPELL_AURA_MOD_DECREASE_SPEED
// 34 SPELL_AURA_MOD_INCREASE_HEALTH
// 35 SPELL_AURA_MOD_INCREASE_MAX_POWER_FLAT
// 36 SPELL_AURA_MOD_SHAPESHIFT
// 37 SPELL_AURA_EFFECT_IMMUNITY
// 38 SPELL_AURA_STATE_IMMUNITY
// 39 SPELL_AURA_SCHOOL_IMMUNITY
// 40 SPELL_AURA_DAMAGE_IMMUNITY
// 41 SPELL_AURA_DISPEL_IMMUNITY
// 42 SPELL_AURA_PROC_TRIGGER_SPELL  implemented in Unit::ProcDamageAndSpellFor and Unit::HandleProcTriggerSpell
// 43 SPELL_AURA_PROC_TRIGGER_DAMAGE implemented in Unit::ProcDamageAndSpellFor
// 44 SPELL_AURA_TRACK_CREATURES
// 45 SPELL_AURA_TRACK_RESOURCES
// 46 SPELL_AURA_46 (used in test spells 54054 and 54058, and spell 48050) (3.0.8a)
// 47 SPELL_AURA_MOD_PARRY_PERCENT
// 48 SPELL_AURA_48 spell Napalm (area damage spell with additional delayed damage effect)
// 49 SPELL_AURA_MOD_DODGE_PERCENT
// 50 SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT implemented in Unit::SpellCriticalHealingBonus
// 51 SPELL_AURA_MOD_BLOCK_PERCENT
// 52 SPELL_AURA_MOD_WEAPON_CRIT_PERCENT
// 53 SPELL_AURA_PERIODIC_LEECH implemented in AuraEffect::PeriodicTick
// 54 SPELL_AURA_MOD_HIT_CHANCE
// 55 SPELL_AURA_MOD_SPELL_HIT_CHANCE
// 56 SPELL_AURA_TRANSFORM
// 57 SPELL_AURA_MOD_SPELL_CRIT_CHANCE
// 58 SPELL_AURA_MOD_INCREASE_SWIM_SPEED
// 59 SPELL_AURA_MOD_DAMAGE_DONE_CREATURE implemented in Unit::MeleeDamageBonus and Unit::SpellDamageBonus
// 60 SPELL_AURA_MOD_PACIFY_SILENCE
// 61 SPELL_AURA_MOD_SCALE
// 62 SPELL_AURA_PERIODIC_HEALTH_FUNNEL implemented in AuraEffect::PeriodicTick
// 63 unused (4.3.4) old SPELL_AURA_PERIODIC_MANA_FUNNEL
// 64 SPELL_AURA_PERIODIC_MANA_LEECH implemented in AuraEffect::PeriodicTick
// 65 SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK
// 66 SPELL_AURA_FEIGN_DEATH
// 67 SPELL_AURA_MOD_DISARM
// 68 SPELL_AURA_MOD_STALKED
// 69 SPELL_AURA_SCHOOL_ABSORB implemented in Unit::CalcAbsorbResist
// 70 SPELL_AURA_EXTRA_ATTACKS clientside
// 71 SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL
// 72 SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT
// 73 SPELL_AURA_MOD_POWER_COST_SCHOOL
// 74 SPELL_AURA_REFLECT_SPELLS_SCHOOL  implemented in Unit::SpellHitResult
// 75 SPELL_AURA_MOD_LANGUAGE
// 76 SPELL_AURA_FAR_SIGHT
// 77 SPELL_AURA_MECHANIC_IMMUNITY
// 78 SPELL_AURA_MOUNTED
// 79 SPELL_AURA_MOD_DAMAGE_PERCENT_DONE
// 80 SPELL_AURA_MOD_PERCENT_STAT
// 81 SPELL_AURA_SPLIT_DAMAGE_PCT implemented in Unit::CalcAbsorbResist
// 82 SPELL_AURA_WATER_BREATHING
// 83 SPELL_AURA_MOD_BASE_RESISTANCE
// 84 SPELL_AURA_MOD_REGEN implemented in Player::RegenerateHealth
// 85 SPELL_AURA_MOD_POWER_REGEN implemented in Player::Regenerate
// 86 SPELL_AURA_CHANNEL_DEATH_ITEM
// 87 SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN implemented in Unit::MeleeDamageBonus and Unit::SpellDamageBonus
// 88 SPELL_AURA_MOD_HEALTH_REGEN_PERCENT implemented in Player::RegenerateHealth
// 89 SPELL_AURA_PERIODIC_DAMAGE_PERCENT
// 90 unused (4.3.4) old SPELL_AURA_MOD_RESIST_CHANCE
// 91 SPELL_AURA_MOD_DETECT_RANGE implemented in Creature::GetAttackDistance
// 92 SPELL_AURA_PREVENTS_FLEEING
// 93 SPELL_AURA_MOD_UNATTACKABLE
// 94 SPELL_AURA_INTERRUPT_REGEN implemented in Player::Regenerate
// 95 SPELL_AURA_GHOST
// 96 SPELL_AURA_SPELL_MAGNET implemented in Unit::SelectMagnetTarget
// 97 SPELL_AURA_MANA_SHIELD implemented in Unit::CalcAbsorbResist
// 98 SPELL_AURA_MOD_SKILL_TALENT
// 99 SPELL_AURA_MOD_ATTACK_POWER
//100 SPELL_AURA_AURAS_VISIBLE obsolete? all player can see all auras now, but still have spells including GM-spell
//101 SPELL_AURA_MOD_RESISTANCE_PCT
//102 SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonus
//103 SPELL_AURA_MOD_TOTAL_THREAT
//104 SPELL_AURA_WATER_WALK
//105 SPELL_AURA_FEATHER_FALL
//106 SPELL_AURA_HOVER
//107 SPELL_AURA_ADD_FLAT_MODIFIER implemented in AuraEffect::CalculateSpellMod()
//108 SPELL_AURA_ADD_PCT_MODIFIER implemented in AuraEffect::CalculateSpellMod()
//109 SPELL_AURA_ADD_TARGET_TRIGGER
//110 SPELL_AURA_MOD_POWER_REGEN_PERCENT implemented in Player::Regenerate, Creature::Regenerate
//111 SPELL_AURA_ADD_CASTER_HIT_TRIGGER implemented in Unit::SelectMagnetTarget
//112 SPELL_AURA_OVERRIDE_CLASS_SCRIPTS
//113 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonus
//114 SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonus
//115 SPELL_AURA_MOD_HEALING                 implemented in Unit::SpellBaseHealingBonusForVictim
//116 SPELL_AURA_MOD_REGEN_DURING_COMBAT
//117 SPELL_AURA_MOD_MECHANIC_RESISTANCE     implemented in Unit::MagicSpellHitResult
//118 SPELL_AURA_MOD_HEALING_PCT             implemented in Unit::SpellHealingBonus
//119 unused (4.3.4) old SPELL_AURA_SHARE_PET_TRACKING
//120 SPELL_AURA_UNTRACKABLE
//121 SPELL_AURA_EMPATHY
//122 SPELL_AURA_MOD_OFFHAND_DAMAGE_PCT
//123 SPELL_AURA_MOD_TARGET_RESISTANCE
//124 SPELL_AURA_MOD_RANGED_ATTACK_POWER
//125 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN implemented in Unit::MeleeDamageBonus
//126 SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT implemented in Unit::MeleeDamageBonus
//127 SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonus
//128 SPELL_AURA_MOD_POSSESS_PET
//129 SPELL_AURA_MOD_SPEED_ALWAYS
//130 SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS
//131 SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS implemented in Unit::MeleeDamageBonus
//132 SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT
//133 SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT
//134 SPELL_AURA_MOD_MANA_REGEN_INTERRUPT
//135 SPELL_AURA_MOD_HEALING_DONE
//136 SPELL_AURA_MOD_HEALING_DONE_PERCENT   implemented in Unit::SpellHealingBonus
//137 SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE
//138 SPELL_AURA_MOD_MELEE_HASTE
//139 SPELL_AURA_FORCE_REACTION
//140 SPELL_AURA_MOD_RANGED_HASTE
//141 SPELL_AURA_141
//142 SPELL_AURA_MOD_BASE_RESISTANCE_PCT
//143 SPELL_AURA_MOD_RESISTANCE_EXCLUSIVE
//144 SPELL_AURA_SAFE_FALL                         implemented in WorldSession::HandleMovementOpcodes
//145 SPELL_AURA_MOD_PET_TALENT_POINTS
//146 SPELL_AURA_ALLOW_TAME_PET_TYPE
//147 SPELL_AURA_MECHANIC_IMMUNITY_MASK
//148 SPELL_AURA_RETAIN_COMBO_POINTS
//149 SPELL_AURA_REDUCE_PUSHBACK
//150 SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT
//151 SPELL_AURA_TRACK_STEALTHED
//152 SPELL_AURA_MOD_DETECTED_RANGE implemented in Creature::GetAttackDistance
//153 Unused (4.3.4) old SPELL_AURA_SPLIT_DAMAGE_FLAT
//154 SPELL_AURA_MOD_STEALTH_LEVEL
//155 SPELL_AURA_MOD_WATER_BREATHING
//156 SPELL_AURA_MOD_REPUTATION_GAIN
//157 SPELL_AURA_PET_DAMAGE_MULTI
//158 SPELL_AURA_MOD_SHIELD_BLOCKVALUE
//159 SPELL_AURA_NO_PVP_CREDIT      only for Honorless Target spell
//160 Unused (4.3.4) old SPELL_AURA_MOD_AOE_AVOIDANCE
//161 SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT
//162 SPELL_AURA_POWER_BURN implemented in AuraEffect::PeriodicTick
//163 SPELL_AURA_MOD_CRIT_DAMAGE_BONUS
//164 unused (3.2.0), only one test spell
//165 SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS implemented in Unit::MeleeDamageBonus
//166 SPELL_AURA_MOD_ATTACK_POWER_PCT
//167 SPELL_AURA_MOD_RANGED_ATTACK_POWER_PCT
//168 SPELL_AURA_MOD_DAMAGE_DONE_VERSUS            implemented in Unit::SpellDamageBonus, Unit::MeleeDamageBonus
//169 Unused (4.3.4) old SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
//170 SPELL_AURA_DETECT_AMORE       various spells that change visual of units for aura target (clientside?)
//171 SPELL_AURA_MOD_SPEED_NOT_STACK
//172 SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK
//173 unused (4.3.4) no spells, old SPELL_AURA_ALLOW_CHAMPION_SPELLS  only for Proclaim Champion spell
//174 SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT  implemented in Unit::SpellBaseDamageBonus
//175 SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT implemented in Unit::SpellBaseHealingBonus
//176 SPELL_AURA_SPIRIT_OF_REDEMPTION   only for Spirit of Redemption spell, die at aura end
//177 SPELL_AURA_AOE_CHARM
//178 old SPELL_AURA_MOD_DEBUFF_RESISTANCE unused 4.3.4
//179 SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE implemented in Unit::SpellCriticalBonus
//180 SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS   implemented in Unit::SpellDamageBonus
//181 unused (4.3.4) old SPELL_AURA_MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS
//182 SPELL_AURA_MOD_RESISTANCE_OF_STAT_PERCENT
//183 SPELL_AURA_MOD_CRITICAL_THREAT only used in 28746 - miscvalue - spell school
//184 SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE  implemented in Unit::RollMeleeOutcomeAgainst
//185 SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE implemented in Unit::RollMeleeOutcomeAgainst
//186 SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE  implemented in Unit::MagicSpellHitResult
//187 SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE  implemented in Unit::GetUnitCriticalChance
//188 SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE implemented in Unit::GetUnitCriticalChance
//189 SPELL_AURA_MOD_RATING
//190 SPELL_AURA_MOD_FACTION_REPUTATION_GAIN     implemented in Player::CalculateReputationGain
//191 SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED
//192 SPELL_AURA_MOD_MELEE_RANGED_HASTE
//193 SPELL_AURA_MELEE_SLOW (in fact combat (any type attack) speed pct)
//194 SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL implemented in Unit::CalcAbsorbResist
//195 SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL implemented in Unit::CalcAbsorbResist
//196 SPELL_AURA_MOD_COOLDOWN - flat mod of spell cooldowns
//197 SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE implemented in Unit::SpellCriticalBonus Unit::GetUnitCriticalChance
//198 unused (4.3.4) old SPELL_AURA_MOD_ALL_WEAPON_SKILLS
//199 unused (4.3.4) old SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT
//200 SPELL_AURA_MOD_XP_PCT implemented in Player::RewardPlayerAndGroupAtKill
//201 SPELL_AURA_FLY                             this aura enable flight mode...
//202 SPELL_AURA_CANNOT_BE_DODGED                implemented in Unit::RollPhysicalOutcomeAgainst
//203 SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE  implemented in Unit::CalculateMeleeDamage and Unit::CalculateSpellDamage
//204 SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE implemented in Unit::CalculateMeleeDamage and Unit::CalculateSpellDamage
//205 SPELL_AURA_MOD_SCHOOL_CRIT_DMG_TAKEN
//206 SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED
//207 SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED
//208 SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED
//209 SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS
//210 SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS
//211 SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK
//212 Unused (4.3.4) old SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT
//213 SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT implemented in Player::RewardRage
//214 Tamed Pet Passive
//215 SPELL_AURA_ARENA_PREPARATION
//216 SPELL_AURA_HASTE_SPELLS
//217 SPELL_AURA_MOD_MELEE_HASTE_2
//218 SPELL_AURA_HASTE_RANGED
//219 SPELL_AURA_MOD_MANA_REGEN_FROM_STAT
//220 SPELL_AURA_MOD_RATING_FROM_STAT
//221 SPELL_AURA_MOD_DETAUNT
//222 unused (3.2.0) only for spell 44586 that not used in real spell cast
//223 SPELL_AURA_RAID_PROC_FROM_CHARGE
//224 unused (4.3.4)
//225 SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE
//226 SPELL_AURA_PERIODIC_DUMMY implemented in AuraEffect::PeriodicTick
//227 SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE implemented in AuraEffect::PeriodicTick
//228 SPELL_AURA_DETECT_STEALTH stealth detection
//229 SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE
//230 SPELL_AURA_MOD_INCREASE_HEALTH_2
//231 SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE
//232 SPELL_AURA_MECHANIC_DURATION_MOD           implement in Unit::CalculateSpellDuration
//233 set model id to the one of the creature with id GetMiscValue() - clientside
//234 SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK implement in Unit::CalculateSpellDuration
//235 SPELL_AURA_MOD_DISPEL_RESIST               implement in Unit::MagicSpellHitResult
//236 SPELL_AURA_CONTROL_VEHICLE
//237 SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER  implemented in Unit::SpellBaseDamageBonus
//238 SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER implemented in Unit::SpellBaseHealingBonus
//239 SPELL_AURA_MOD_SCALE_2 only in Noggenfogger Elixir (16595) before 2.3.0 aura 61
//240 SPELL_AURA_MOD_EXPERTISE
//241 SPELL_AURA_FORCE_MOVE_FORWARD Forces the caster to move forward
//242 SPELL_AURA_MOD_SPELL_DAMAGE_FROM_HEALING - 2 test spells: 44183 and 44182
//243 SPELL_AURA_MOD_FACTION
//244 SPELL_AURA_COMPREHEND_LANGUAGE
//245 SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL
//246 SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK implemented in Spell::EffectApplyAura
//247 SPELL_AURA_CLONE_CASTER
//248 SPELL_AURA_MOD_COMBAT_RESULT_CHANCE         implemented in Unit::RollMeleeOutcomeAgainst
//249 SPELL_AURA_CONVERT_RUNE
//250 SPELL_AURA_MOD_INCREASE_HEALTH_2
//251 SPELL_AURA_MOD_ENEMY_DODGE
//252 SPELL_AURA_252 Is there any difference between this and SPELL_AURA_MELEE_SLOW ? maybe not stacking mod?
//253 SPELL_AURA_MOD_BLOCK_CRIT_CHANCE  implemented in Unit::isBlockCritical
//254 SPELL_AURA_MOD_DISARM_OFFHAND
//255 SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT    implemented in Unit::SpellDamageBonus
//256 SPELL_AURA_NO_REAGENT_USE Use SpellClassMask for spell select
//257 SPELL_AURA_MOD_TARGET_RESIST_BY_SPELL_CLASS Use SpellClassMask for spell select
//258 SPELL_AURA_MOD_SPELL_VISUAL
//259 unused (4.3.4) old SPELL_AURA_MOD_HOT_PCT
//260 SPELL_AURA_SCREEN_EFFECT (miscvalue = id in ScreenEffect.dbc) not required any code
//261 SPELL_AURA_PHASE
//262 SPELL_AURA_ABILITY_IGNORE_AURASTATE implemented in spell::cancast
//263 SPELL_AURA_ALLOW_ONLY_ABILITY player can use only abilities set in SpellClassMask
//264 unused (3.2.0)
//265 unused (4.3.4)
//266 unused (4.3.4)
//267 SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL         implemented in Unit::IsImmunedToSpellEffect
//268 unused (4.3.4) old SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT.
//269 SPELL_AURA_MOD_IGNORE_TARGET_RESIST implemented in Unit::CalcAbsorbResist and CalcArmorReducedDamage
//270 unused (4.3.4) old SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST
//271 SPELL_AURA_MOD_DAMAGE_FROM_CASTER    implemented in Unit::SpellDamageBonus
//272 SPELL_AURA_IGNORE_MELEE_RESET
//273 clientside
//274 unused (4.3.4)
//275 SPELL_AURA_MOD_IGNORE_SHAPESHIFT Use SpellClassMask for spell select
//276 mod damage % mechanic?
//277 unused (4.3.4) old SPELL_AURA_MOD_MAX_AFFECTED_TARGETS
//278 SPELL_AURA_MOD_DISARM_RANGED disarm ranged weapon
//279 SPELL_AURA_INITIALIZE_IMAGES
//280 SPELL_AURA_MOD_ARMOR_PENETRATION_PCT (used in 5.4.8)
//281 SPELL_AURA_MOD_HONOR_GAIN_PCT implemented in Player::RewardHonor
//282 SPELL_AURA_INCREASE_BASE_HEALTH_PERCENT
//283 SPELL_AURA_MOD_HEALING_RECEIVED       implemented in Unit::SpellHealingBonus
//284 SPELL_AURA_LINKED
//285 SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR  implemented in Player::UpdateAttackPowerAndDamage
//286 SPELL_AURA_ABILITY_PERIODIC_CRIT implemented in AuraEffect::PeriodicTick
//287 SPELL_AURA_DEFLECT_SPELLS             implemented in Unit::MagicSpellHitResult and Unit::MeleeSpellHitResult
//288 SPELL_AURA_IGNORE_HIT_DIRECTION  implemented in Unit::MagicSpellHitResult and Unit::MeleeSpellHitResult Unit::RollMeleeOutcomeAgainst
//289 unused (3.2.0)
//290 SPELL_AURA_MOD_CRIT_PCT
//291 SPELL_AURA_MOD_XP_QUEST_PCT  implemented in Player::RewardQuest
//292 SPELL_AURA_OPEN_STABLE
//293 SPELL_AURA_OVERRIDE_SPELLS auras which probably add set of abilities to their target based on it's miscvalue
//294 SPELL_AURA_PREVENT_REGENERATE_POWER implemented in Player::Regenerate(Powers power)
//295 unused (4.3.4)
//296 SPELL_AURA_SET_VEHICLE_ID sets vehicle on target
//297 Spirit Burst spells
//298 70569 - Strangulating, maybe prevents talk or cast
//299 unused (4.3.4)
//300 SPELL_AURA_SHARE_DAMAGE_PCT implemented in Unit::DealDamage
//301 SPELL_AURA_SCHOOL_HEAL_ABSORB implemented in Unit::CalcHealAbsorb
//302 unused (4.3.4)
//303 SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE implemented in Unit::SpellDamageBonus, Unit::MeleeDamageBonus
//304 SPELL_AURA_MOD_DRUNK
//305 SPELL_AURA_MOD_MINIMUM_SPEED
//306 unused (4.3.4)
//307 unused (4.3.4)
//308 new aura for hunter traps
//309 unused (4.3.4)
//310 SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE implemented in Spell::CalculateDamageDone
//311 0 spells in 3.3.5
//312 0 spells in 3.3.5
//313 unused (4.3.4)
//314 SPELL_AURA_PREVENT_RESURRECTION todo
//315 SPELL_AURA_UNDERWATER_WALKING todo
//316 unused (4.3.4) old SPELL_AURA_PERIODIC_HASTE
//317 SPELL_AURA_MOD_SPELL_POWER_PCT
//318 SPELL_AURA_MASTERY
//319 SPELL_AURA_MOD_MELEE_HASTE_3
//320 SPELL_AURA_MOD_RANGED_HASTE_2
//321 SPELL_AURA_321
//322 SPELL_AURA_INTERFERE_TARGETTING
//323 unused (4.3.4)
//324 SPELL_AURA_324
//325 unused (4.3.4)
//326 SPELL_AURA_PHASE_GROUP
//327 unused (4.3.4)
//328 SPELL_AURA_PROC_ON_POWER_AMOUNT implemented in Unit::HandleAuraProcOnPowerAmount
//329 SPELL_AURA_MOD_RUNE_REGEN_SPEED
//330 SPELL_AURA_CAST_WHILE_WALKING
//331 SPELL_AURA_FORCE_WEATHER
//332 SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS implemented in WorldSession::HandleCastSpellOpcode
//333 SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2 implemented in WorldSession::HandleCastSpellOpcode
//334 SPELL_AURA_MOD_BLIND
//335 SPELL_AURA_335
//336 SPELL_AURA_MOD_FLYING_RESTRICTIONS
//337 SPELL_AURA_MOD_VENDOR_ITEMS_PRICES
//338 SPELL_AURA_MOD_DURABILITY_LOSS
//339 SPELL_AURA_INCREASE_SKILL_GAIN_CHANCE
//340 SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER
//341 SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN
//342 SPELL_AURA_MOD_MELEE_RANGED_HASTE_2
//343 SPELL_AURA_343
//344 SPELL_AURA_MOD_AUTOATTACK_DAMAGE
//345 SPELL_AURA_BYPASS_ARMOR_FOR_CASTER
//346 SPELL_AURA_ENABLE_ALT_POWER
//347 SPELL_AURA_MOD_SPELL_COOLDOWN_BY_HASTE
//348 SPELL_AURA_DEPOSIT_BONUS_MONEY_IN_GUILD_BANK_ON_LOOT implemented in WorldSession::HandleLootMoneyOpcode
//349 SPELL_AURA_MOD_CURRENCY_GAIN implemented in Player::ModifyCurrency
//350 SPELL_AURA_MOD_GATHERING_ITEMS_GAINED_PERCENT
//351 SPELL_AURA_351
//352 SPELL_AURA_352
//353 SPELL_AURA_MOD_CAMOUFLAGE
//354 SPELL_AURA_354
//355 unused (4.3.4)
//356 SPELL_AURA_356
//357 SPELL_AURA_ENABLE_BOSS1_UNIT_FRAME
//358 SPELL_AURA_358
//359 SPELL_AURA_359
//360 SPELL_AURA_PROC_TRIGGER_SPELL_COPY
//361 SPELL_AURA_PROC_TRIGGER_SPELL_2 implemented in Unit::ProcDamageAndSpellFor
//362 unused (4.3.4)
//363 SPELL_AURA_MOD_NEXT_SPELL
//364 unused (4.3.4)
//365 SPELL_AURA_MAX_FAR_CLIP_PLANE
//366 SPELL_AURA_OVERRIDE_SPELL_POWER_BY_AP_PCT
//367 SPELL_AURA_OVERRIDE_AUTOATTACK_WITH_SPELL
//368 unused (4.3.4)
//369 SPELL_AURA_ENABLE_POWER_BAR_TIMER
//370 SPELL_AURA_SET_FAIR_FAR_CLIP
// Auras < 371 Need Recheck.
//371 SPELL_AURA_371
//372 SPELL_AURA_372 (used in spell 130041) (5.4.2)
//373 SPELL_AURA_373
//374 SPELL_AURA_374
//375 unused (5.4.2)
//376 SPELL_AURA_376
//377 SPELL_AURA_377
//378 unused (5.4.2)
//379 SPELL_AURA_379
//380 unused (5.4.2)
//381 SPELL_AURA_381 (used in spell 21741) (5.4.2)
//382 SPELL_AURA_382
//383 SPELL_AURA_383
//384 unused (5.4.2)
//385 SPELL_AURA_385
//386 SPELL_AURA_386 (used in spell 117915) (5.4.2)
//387 SPELL_AURA_387 (used in spell 117923) (5.4.2)
//388 SPELL_AURA_388 (used in spell 117983) (5.4.2)
//389 unused (5.4.2)
//390 unused (5.4.2)
//391 unused (5.4.2)
//392 unused (5.4.2)
//393 SPELL_AURA_393
//394 SPELL_AURA_394
//395 SPELL_AURA_395
//396 SPELL_AURA_396
//397 SPELL_AURA_397
//398 SPELL_AURA_398
//399 unused (5.4.2)
//400 SPELL_AURA_400 (used in spells 124353 & 124351) (5.4.2)
//401 SPELL_AURA_401 (used in spell 125695) (5.4.2)
//402 SPELL_AURA_402
//403 SPELL_AURA_403
//404 SPELL_AURA_OVERRIDE_AP_BY_SPELL_POWER_PCT (used in spell 115070) (5.4.2)
//405 SPELL_AURA_405
//406 SPELL_AURA_406
//407 SPELL_AURA_407
//408 SPELL_AURA_408
//409 SPELL_AURA_409
//410 SPELL_AURA_410 (used in spell 57902) (5.4.2)
//411 SPELL_AURA_411
//412 SPELL_AURA_412 (used in spell 111546 & 117957) (5.4.2)
//413 SPELL_AURA_413
//414 SPELL_AURA_414
//415 SPELL_AURA_415 (used in spell 123316) (5.4.2)
//416 SPELL_AURA_416
//417 SPELL_AURA_417 (used in spell 25956) (5.4.2)
//418 SPELL_AURA_418
//419 SPELL_AURA_419
//420 SPELL_AURA_MOD_PET_XP_PCT / NYI
//421 SPELL_AURA_421
//422 SPELL_AURA_422 (used in spell 136577) (5.4.2)
//423 SPELL_AURA_423 (used in spell 108294) (5.4.2)
//424 SPELL_AURA_424
//425 unused (5.4.2)
//426 SPELL_AURA_426 (used in spell 132633) (5.4.2)
//427 SPELL_AURA_427 (used in spell 91318) (5.4.2)
//428 SPELL_AURA_428
//429 SPELL_AURA_429
//430 SPELL_AURA_430
//431 SPELL_AURA_431 (used in spell 142869) (5.4.2)
//432 SPELL_AURA_432 (used in spell 91318) (5.4.2)
//433 unused (5.4.2)
//434 SPELL_AURA_434
//435 unused (5.4.2)
//436 SPELL_AURA_436 (used in spell 49977) (5.4.2)
//437 SPELL_AURA_437
// remove all targets which were not added to new list - they no longer deserve area aura
// default amount calculation
// check item enchant aura cast
// custom amount calculations go here
// crowd control auras
// Glyphs increasing damage cap
// Glyph of Frost nova and similar auras
// if Level <= 70 resist = player level
// Aspect of the Wild
// Elemental Resistance
// Resistance Aura
// Shadow Protection
// Shadow Protection
// Mark of the Wild
// Mark of the Wild
// Blessing of Kings
// Blessing of Kings
// Embrace of the Shale Spider
/*= true*/, bool load /*= false*/)
// prepare periodics
// 3 spells have no amplitude set
// Apply casting time mods
// Apply periodic time mod
// Haste modifies periodic time of channeled spells
// aura loaded from db
// aura just created or reapplied
// reset periodic timer on aura create or on reapply when aura isn't dot
// possibly we should not reset periodic timers only when aura is triggered by proc
// or maybe there's a spell attribute somewhere
// Start periodic on next tick or at aura apply
// SpellModType value == spell aura types
// Reapply if amount change
// check if call is correct, we really don't want using bitmasks here (with 1 exception)
// register/unregister effect in lists in case of real AuraEffect apply/remove
// registration/unregistration is done always before real effect handling (some effect handlers code is depending on this)
// real aura apply/remove, handle modifier
// call scripts helping/replacing effect handlers
// check if script events have removed the aura or if default effect prevention was requested
// check if script events have removed the aura or if default effect prevention was requested
// call scripts triggering additional events after apply/remove
// Auras with charges do not mod amount of passive auras
// reapply some passive spells after add/remove related spellmods
// Warning: it is a dead loop if 2 auras each other amount-shouldn't happen
// only passive and permament auras-active auras should have amount set on spellcast and not be affected
// if aura is casted by others, it will not be affected
// tick also at m_periodicTimer == 0 to prevent lost last tick in case max m_duration == (max m_periodicTimer)*N
// update before tick (aura can be removed in TriggerSpell or PeriodicTick calls)
// tick on targets of effects
// Drink
// Drink Coffee
// Drink Pandaren Brew
// Drink Bitter Brew
// Drink Stormstout Brew
// Drink Unga Brew
// Drink Funky Monkey Brew
// Drink Boomer Brew
// Drink Greenstone Brew
// Drink Blazing Brew
// Get SPELL_AURA_MOD_POWER_REGEN aura from spell
// default case - not in arena
// **********************************************
// This feature uses only in arenas
// **********************************************
// Here need increase mana regen per tick (6 second rule)
// on 0 tick -   0  (handled in 2 second)
// on 1 tick - 166% (handled in 4 second)
// on 2 tick - 133% (handled in 6 second)
// Apply bonus for 1 - 4 tick
// 0%
// 166%
// 133%
// 100% - normal regen
// No need to update after 4th tick
// Tenacity
// Tenacity (vehicle)
// Paralytic Toxin
// Get 0 effect aura
// Mirror Image
// Chains of Ice
// Get 0 effect aura
// Check family name
// Check EffectClassMask
// needed for spell 43680, maybe others
/// @todo is there a spell flag, which can solve this in a more sophisticated way?
// must be second, this important at aura remove to prevent to early iterator invalidation.
// Remove cooldown of spells triggered on stance change - they may share cooldown with stance spell
// Also do it for Glyphs
// Leader of the Pack
// Heart of the Wild
// Savage Roar
// Nurturing Instinct
// Master Shapeshifter - Cat
// Master Shapeshifter - Bear
// Survival of the Fittest
// Master Shapeshifter - Moonkin
// Iterate through all the shapeshift auras that the target has, if there is another aura with SPELL_AURA_MOD_SHAPESHIFT, then this aura is being removed due to that one being applied
// Use the new aura to see on what stance the target will be
// If the stances are not compatible with the spell, remove it
/*********************************************************/
/***               AURA EFFECT HANDLERS                ***/
/*********************************************************/
/**************************************/
/***       VISIBILITY & PHASES      ***/
/**************************************/
// call functions which may have additional effects after chainging state of unit
// apply glow vision
//if (target->GetTypeId() == TYPEID_PLAYER)
//    target->SetByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK2, 3, PLAYER_FIELD_BYTE2_INVISIBILITY_GLOW);
// if not have different invisibility auras.
// remove glow vision
// if (target->GetTypeId() == TYPEID_PLAYER)
//     target->RemoveByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK2, 3, PLAYER_FIELD_BYTE2_INVISIBILITY_GLOW);
// call functions which may have additional effects after chainging state of unit
// drop flag at invisibiliy in bg
// call functions which may have additional effects after chainging state of unit
//if (target->GetTypeId() == TYPEID_PLAYER)
//    target->SetByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK2, 3, PLAYER_FIELD_BYTE2_STEALTH);
// if last SPELL_AURA_MOD_STEALTH
//if (target->GetTypeId() == TYPEID_PLAYER)
//   target->RemoveByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK2, 3, PLAYER_FIELD_BYTE2_STEALTH);
// call functions which may have additional effects after chainging state of unit
// drop flag at stealth in bg
// call functions which may have additional effects after chainging state of unit
// prepare spirit state
// disable breath/etc timers
// set stand state (expected in this form)
// die at aura end
// call functions which may have additional effects after chainging state of unit
// call functions which may have additional effects after chainging state of unit
// phase auras normally not expected at BG but anyway better check
// drop flag at invisibiliy in bg
// need triggering visibility update base at phase update of not GM invisible (other GMs anyway see in any phases)
// call functions which may have additional effects after chainging state of unit
// phase auras normally not expected at BG but anyway better check
// drop flag at invisibiliy in bg
// need triggering visibility update base at phase update of not GM invisible (other GMs anyway see in any phases)
/**********************/
/***   UNIT MODEL   ***/
/**********************/
// 0x01
// 0x07
// 0x17
// 0x18
// 0x05
// 0x11
// 0x12
// 0x13
// 0x02
// 0x03
// 0x04
// 0x06
// 0x09
// 0x0A
// 0x0B
// 0x0C
// 0x0D
// 0x0E
// 0x0F
// 0x10
// 0x14
// 0x15
// 0x16
// 0x19
// 0x1A
// 0x1B
// 0x1C
// 0x1D
// 0x1E
// 0x1F
// 0x20
// remove polymorph before changing display id to keep new display id
// remove movement affects
// and polymorphic affects
// remove other shapeshift before applying a new one
// stop handling the effect if it was removed by linked event
// reset power to default values only at power change
// get furor proc chance
// stop handling the effect if it was removed by linked event
// reset model id if no other auras present
// may happen when aura is applied on linked event on aura removal
// Remove movement impairing effects also when shifting out
// Nordrassil Harness - bonus
// Nordrassil Regalia - bonus
// Defensive Tactics
// Stance mastery + Tactical mastery (both passive, and last have aura only in defense stance, but need apply at any stance switch)
// adding/removing linked auras
// add/remove the shapeshift aura's boosts
// Dash
// Disarm handling
// If druid shifts while being disarmed we need to deal with that since forms aren't affected by disarm
// and also HandleAuraModDisarm is not triggered
// stop handling the effect if it was removed by linked event
// Learn spells for shapeshift form - no need to send action bars or add spells to spellbook
// update active transform spell only when transform or shapeshift not set or not overwriting negative by positive case
// special case (spell specific functionality)
// Orb of Deception
// Blood Elf
// Orc
// Troll
// Tauren
// Undead
// Draenei
// Dwarf
// Gnome
// Human
// Night Elf
// Murloc costume
// Dread Corsair
// Corsair Costume
// Blood Elf
// Orc
// Troll
// Tauren
// Undead
// Draenei
// Dwarf
// Gnome
// Human
// Night Elf
// Pygmy Oil
// Honor the Dead
// Darkspear Pride
// Gnomeregan Pride
// pig pink ^_^
// Will use the default model here
// Polymorph (sheep)
// Glyph of the Penguin
// Dragonmaw Illusion (set mount model also)
// update active transform spell only when transform or shapeshift not set or not overwriting negative by positive case
// polymorph case
// for players, start regeneration after 1s (in polymorph fast regeneration case)
// only if caster is Player (after patch 2.4.2)
//dismount polymorphed target (after patch 2.4.2)
// HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true) will reapply it if need
// Dragonmaw Illusion (restore mount model)
// What must be cloned? at least display and scale
//target->SetObjectScale(caster->GetObjectScale()); // we need retail info about how scaling is handled (aura maybe?)
/************************/
/***      FIGHT       ***/
/************************/
/*
// prevent interrupt message
// stop handling the effect if it was removed by linked event
// blizz like 2.0.x
// blizz like 2.0.x
// blizz like 2.0.x
/*
// blizz like 2.0.x
// blizz like 2.0.x
// blizz like 2.0.x
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// call functions which may have additional effects after chainging state of unit
// Prevent handling aura twice
// if disarm aura is to be removed, remove the flag first to reapply damage/aura mods
// Handle damage modification, shapeshifted druids are not affected
// if disarm effects should be applied, wait to set flag until damage mods are unapplied
// call functions which may have additional effects after chainging state of unit
// Stop cast only spells vs PreventionType == SPELL_PREVENTION_TYPE_SILENCE
// Stop spells on prepare or casting state
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// Vengeance of the Blue Flight (@todo REMOVE THIS!)
/// @workaround
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
/****************************/
/***      TRACKING        ***/
/****************************/
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// used by spells: Hunter's Mark, Mind Vision, Syndicate Tracker (MURP) DND
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// call functions which may have additional effects after chainging state of unit
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
/****************************/
/***  SKILLS & TALENTS    ***/
/****************************/
/*apply*/) const
// Recalculate pet talent points
/****************************/
/***       MOVEMENT       ***/
/****************************/
// Festive Holiday Mount
//some spell has one aura of mount and one of vehicle
// cast speed aura
//some mounts like Headless Horseman's Mount or broom stick are skill based spell
// need to remove ALL arura related to mounts, this will stop client crash with broom stick
// and never endless flying after using Headless Horseman's Mount
// remove speed aura
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// start fall from current height
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
//! Sets movementflags
/*apply*/) const
// update timers in client
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
/****************************/
/***        THREAT        ***/
/****************************/
// When taunt aura fades out, mob will switch to previous target if current has less than 1.1 * secondthreat
/*****************************/
/***        CONTROL        ***/
/*****************************/
/***************************/
/***        CHARM        ***/
/***************************/
// no support for posession AI yet
// Used by spell "Eyes of the Beast"
//seems it may happen that when removing it is no longer owner's pet
//if (caster->ToPlayer()->GetPet() != target)
//    return;
// Must clear current motion or pet leashes back to owner after a few yards
//  when under spell 'Eyes of the Beast'
// Reinitialize the pet bar or it will appear greyed out
// Follow owner only if not fighting or owner didn't click "stay" at new location
// This may be confusing because pet bar shows "stay" when under the spell but it retains
//  the "follow" flag. Player MUST click "stay" while under the spell.
/**
// Currently spells that have base points  0 and DieSides 0 = "0/0" exception are pushed to -1,
// however the idea of 0/0 is to ingore flag VEHICLE_SEAT_FLAG_CAN_ENTER_OR_EXIT and -1 checks for it,
// so this break such spells or most of them.
// Current formula about m_amount: effect base points + dieside - 1
// TO DO: Reasearch more about 0/0 and fix it.
// Remove pending passengers before exiting vehicle - might cause an Uninstall
// Devour Humanoid
// Only remove passenger from vehicle without launching exit movement or despawning the vehicle
// some SPELL_AURA_CONTROL_VEHICLE auras have a dummy effect on the player - remove them
/*********************************************************/
/***                  MODIFY SPEED                     ***/
/*********************************************************/
/*apply*/) const
//! Update ability to fly
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
//! Someone should clean up these hacks and remove it from this function. It doesn't even belong here.
//Players on flying mounts must be immune to polymorph
// Dragonmaw Illusion (overwrite mount model, mounted aura already applied)
/*apply*/) const
/*apply*/) const
/*apply*/) const
/*********************************************************/
/***                     IMMUNITY                      ***/
/*********************************************************/
// These flag can be recognized wrong:
// apply immunities
// The Beast Within
// Bestial Wrath
// PvP trinket
// Every Man for Himself
// Actually we should apply immunities here, too, but the aura has only 100 ms duration, so there is practically no point
// Demonic Empowerment
// when removing flag aura, handle flag drop
// remove all flag auras (they are positive, but they must be removed when you are immune)
/// @todo optimalize this cycle - use RemoveAurasWithInterruptFlags call or something else
//Only positive immunity removes auras
//Check for school mask
//Don't remove positive spells
//Don't remove self
/*********************************************************/
/***                  MODIFY STATS                     ***/
/*********************************************************/
/********************************/
/***        RESISTANCE        ***/
/********************************/
// only players have base stats
//pets only have base armor
// only players have base stats
//only pets have base stats
// applied to damage as HandleNoImmediateEffect in Unit::CalcAbsorbResist and Unit::CalcArmorReducedDamage
// show armor penetration
// show as spell penetration only full spell penetration bonuses (all resistances except armor and holy
/********************************/
/***           STAT           ***/
/********************************/
// -1 or -2 is all stats (misc < -2 checked in function beginning)
//target->ApplyStatMod(Stats(i), m_amount, apply);
// only players have base stats
/*apply*/) const
// Magic damage modifiers implemented in Unit::SpellDamageBonus
// This information for client side use only
// Recalculate bonus
/*apply*/) const
// Recalculate bonus
/*apply*/) const
// Magic damage modifiers implemented in Unit::SpellDamageBonus
// This information for client side use only
// Recalculate bonus
/*apply*/) const
// Recalculate bonus
/*apply*/) const
// implemented in Unit::SpellHealingBonus
// this information is for client side only
// save current health state
// 0 is also used for all stats
// recalculate current HP/MP after applying aura modifications (only for spells with SPELL_ATTR0_UNK4 0x00000010 flag)
// this check is total bullshit i think
/*apply*/) const
// support required adding replace UpdateArmor by loop by UpdateResistence at intellect update
// and include in UpdateResistence same code as in UpdateArmor for aura mod apply.
// Recalculate Armor
/*apply*/) const
/********************************/
/***      HEAL & ENERGIZE     ***/
/********************************/
/*apply*/) const
// Update manaregen value
// other powers are not immediate effects - implemented in Player::Regenerate, Creature::Regenerate
/*apply*/) const
//Note: an increase in regen does NOT cause threat.
// refresh percentage
// do not check power type, we can always modify the maximum
// as the client will not see any difference
// also, placing conditions that may change during the aura duration
// inside effect handlers is not a good idea
//if (int32(powerType) != GetMiscValue())
//    return;
// do not check power type, we can always modify the maximum
// as the client will not see any difference
// also, placing conditions that may change during the aura duration
// inside effect handlers is not a good idea
//if (int32(powerType) != GetMiscValue())
//    return;
// Unit will keep hp% after MaxHealth being modified if unit is alive.
/********************************/
/***          FIGHT           ***/
/********************************/
/*apply*/) const
/*apply*/) const
/*apply*/) const
// mods must be applied base at equipped weapon class and subclass comparison
// with spell->EquippedItemClass and  EquippedItemSubClassMask and EquippedItemInventoryTypeMask
// GetMiscValue() comparison with item generated damage types
// done in Player::_ApplyWeaponDependentAuraMods
/*apply*/) const
// included in Player::UpdateSpellCritChance calculation
/********************************/
/***         ATTACK SPEED     ***/
/********************************/
//! ToDo: Haste auras with the same handler _CAN'T_ stack together
//! ToDo: Haste auras with the same handler _CAN'T_ stack together
//! ToDo: Haste auras with the same handler _CAN'T_ stack together
/********************************/
/***       COMBAT RATING      ***/
/********************************/
// Just recalculate ratings
/********************************/
/***        ATTACK POWER      ***/
/********************************/
//UNIT_FIELD_ATTACK_POWER_MULTIPLIER = multiplier - 1
//UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER = multiplier - 1
/*apply*/) const
// Recalculate bonus
/********************************/
/***        DAMAGE BONUS      ***/
/********************************/
// apply item specific bonuses for already equipped weapon
// GetMiscValue() is bitmask of spell schools
// 1 (0-bit) - normal school damage (SPELL_SCHOOL_MASK_NORMAL)
// 126 - full bitmask all magic damages (SPELL_SCHOOL_MASK_MAGIC) including wands
// 127 - full bitmask any damages
//
// mods must be applied base at equipped weapon class and subclass comparison
// with spell->EquippedItemClass and  EquippedItemSubClassMask and EquippedItemInventoryTypeMask
// GetMiscValue() comparison with item generated damage types
// apply generic physical damage bonuses including wand case
// done in Player::_ApplyWeaponDependentAuraMods
// Skip non magic case for speedup
// wand magic case (skip generic to all item spell bonuses)
// done in Player::_ApplyWeaponDependentAuraMods
// Skip item specific requirements for not wand magic damage
// Magic damage modifiers implemented in Unit::SpellDamageBonus
// This information for client side use only
// done in Player::_ApplyWeaponDependentAuraMods for SPELL_SCHOOL_MASK_NORMAL && EquippedItemClass != -1 and also for wand case
/********************************/
/***        POWER COST        ***/
/********************************/
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
/*apply*/) const
// combo points was added in SPELL_EFFECT_ADD_COMBO_POINTS handler
// remove only if aura expire by time (in case combo points amount change aura removed without combo points lost)
/*********************************************************/
/***                    OTHERS                         ***/
/*********************************************************/
// pet auras
// AT APPLY
// Tame beast
// FIX_ME: this is 2.0.12 threat effect replaced in 2.1.x by dummy aura, must be checked for correctness
// net-o-matic
// root to self part of (root_target->charge->root_self sequence
// kill command
// set 3 stacks and 3 charges (to make all auras not disappear at once)
// Blood Elf Illusion
// Blood Elf Disguise
// Rocket Blast
// backfire stun
// Headless Horseman Laugh
// Blood Elf Illusion
// Reinforced Net
// Honor Among Thieves
// AT REMOVE
// Waiting to Resurrect
// Waiting to resurrect spell cancel, we must remove player from resurrect queue
// Flame Strike
// Flame Strike
// Inactive
// Wrath of the Astromancer
// Burning Winds casted only at creatures at spawn
// Coyote Spirit Despawn Aura
// Blood Parrot Despawn Aura
// Restricted Flight Area
// Summon Gargoyle (Dismiss Gargoyle at remove)
// AT APPLY & REMOVE
// Recently Bandaged
// Unstable Power
// Restless Strength
// Tag Murloc
// Tag/untag Blacksilt Scout
// Argent Champion
// Ebon Champion
// Champion of the Kirin Tor
// Wyrmrest Champion
// Argent Crusade
// Knights of the Ebon Blade
// Kirin Tor
// The Wyrmrest Accord
// LK Intro VO (1)
// Play part 1
// continue in 58205
// LK Intro VO (2)
// Play part 2
// Play part 3
// Festive Holiday Mount
//if (!(mode & AURA_EFFECT_HANDLE_REAL))
//break;
//if (!(mode & AURA_EFFECT_HANDLE_REAL))
//break;
//if (!(mode & AURA_EFFECT_HANDLE_REAL))
//break;
//if (!(mode & AURA_EFFECT_HANDLE_REAL))
//break;
// if (!(mode & AURA_EFFECT_HANDLE_REAL))
//    break;
//if (!(mode & AURA_EFFECT_HANDLE_REAL))
//    break;
// Item amount
// Soul Shard
// Soul Shard only from units that grant XP or honor
//Adding items
// stop fighting if at apply forced rank friendly or at remove real rank friendly
// do not remove unit flag if there are more than this auraEffect of that kind on unit on unit
// convert number of runes specified in aura amount of rune type in miscvalue to runetype in miscvalueb
// If amount avalible cast with basepoints (Crypt Fever for example)
// change the stack amount to be equal to stack amount of our aura
// client auto close stable dialog at !apply aura
// call functions which may have additional effects after chainging state of unit
//target->SetUInt16Value(PLAYER_FIELD_LIFETIME_MAX_RANK2, 0, overrideId);
//target->SetUInt16Value(PLAYER_FIELD_LIFETIME_MAX_RANK2, 0, 0);
/*apply*/) const
// Bullet Controller Periodic - 10 Man
// Bullet Controller Periodic - 25 Man
// Blaze (Pool of Tar)
// should we use custom damage?
// Overload Circuit
// System Shutdown
// Fuse Armor (Razorscale)
// Mirror Image
// Set name of summons to name of caster
// Frenzied Regeneration
// Converts up to 10 rage per second into health for $d.  Each point of rage is converted into ${$m2/10}.1% of max health.
// Should be manauser
// Nothing todo
// Killing Spree
/// @todo this should use effect[1] of 51690
// eff_radius == 0
// Explosive Shot
// Feeding Frenzy Rank 1
// Feeding Frenzy Rank 2
// Astral Shift
// Periodic need for remove visual on stun/fear/silence lost
// Hysteria
// Death and Decay
// Blood of the North
// Reaping
// Death Rune Mastery
// timer expired - remove death runes
// generic casting code with custom spells and target/caster customs
// specific code for cases with no trigger spell provided in field
// Brood Affliction: Bronze
// Restoration
// Nitrous Boost
// Frost Blast
// Inoculate Nestlewood Owlkin
// prevent error reports in case ignored player target
// Feed Captured Animal
// Extract Gas
// move loot to player inventory and despawn target
// missing lootid has been reported on startup - just return
// Quake
// Doom
/// @todo effect trigger spell may be independant on spell targets, and executed in spell finish phase
// so instakill will be naturally done before trigger spell
// Spellcloth
// Summon Elemental after create item
// Flame Quills
// cast 24 spells 34269-34289, 34314-34316
// Remote Toy
// Eye of Grillok
// Absorb Eye of Grillok (Zezzak's Shard)
// Tear of Azzinoth Summon Channel - it's not really supposed to do anything, and this only prevents the console spam
// Personalized Weather
// Lightning Shield (The Earthshatterer set trigger after cast Lighting Shield)
// Need remove self if Lightning Shield not active
// Totemic Mastery (Skyshatter Regalia (Shaman Tier 6) - bonus)
// Spell exist but require custom code
// Pursuing Spikes (Anub'arak)
// Mana Tide
// Negative Energy Periodic
// Poison (Grobbulus)
// Slime Pool (Dreadscale & Acidmaw)
// Slime Spray - temporary here until preventing default effect works again
// added on 9.10.2010
// Summon Templar, Trigger
// Summon Templar Fire, Trigger
// Summon Templar Air, Trigger
// Summon Templar Earth, Trigger
// Summon Templar Water, Trigger
// Summon Duke, Trigger
// Summon Duke Fire, Trigger
// Summon Duke Air, Trigger
// Summon Duke Earth, Trigger
// Summon Duke Water, Trigger
// Summon Royal, Trigger
// Summon Royal Fire, Trigger
// Summon Royal Air, Trigger
// Summon Royal Earth, Trigger
// Summon Royal Water, Trigger
// All this spells trigger a spell that requires reagents; if the
// triggered spell is cast as "triggered", reagents are not consumed
// Reget trigger spell proto
// Consecrate ticks can miss and will not show up in the combat log
// some auras remove at specific health level or more
// Grievous Wound
// Gushing Wound
// Grievous Wound
// ignore non positive values (can be result apply spellmods to aura damage
// Script Hook For HandlePeriodicDamageAurasTick -- Allow scripts to change the Damage pre class mitigation calculations
// Calculate armor mitigation
// Curse of Agony damage-per-tick calculation
// 1..4 ticks, 1/2 from normal tick damage
// 9..12 ticks, 3/2 from normal tick damage
// +1 prevent 0.5 damage possible lost at 1..4 ticks
// 5..8 ticks have normal tick damage
// There is a Chance to make a Soul Shard when Drain soul does damage
// Unbound Plague
// Unbound Plague
// Unbound Plague
// Unbound Plague
// Set trigger flag
// Calculate armor mitigation
// Set trigger flag
// do not kill health donator
// heal for caster damage (must be alive)
// don't regen when permanent aura target has full power
// ignore negative values (can be result apply spellmods to aura damage
// Taken mods
// Tenacity increase healing % taken
// Healing taken percent
// Wild Growth = amount + (6 - 2*doneTicks) * ticks* amount / 100
// Item - Druid T10 Restoration 2P Bonus
// divided by 50 instead of 100 because calculated as for every 2 tick
// Health Funnel
// damage caster for heal amount
// damage is not affected by spell power
// ignore item heals
// ignore negative values (can be result apply spellmods to aura damage
// Special case: draining x% of mana (up to a maximum of 2*x% of the caster's maximum mana)
// It's mana percent cost spells, m_amount is percent drain from target
// max value
// Drain Mana
// Mana Feed - Drain Mana
// don't regen when permanent aura target has full power
// ignore negative values (can be result apply spellmods to aura damage
// don't regen when permanent aura target has full power
// ignore negative values (can be result apply spellmods to aura damage
// ignore negative values (can be result apply spellmods to aura damage
// maybe has to be sent different to client, but not by SMSG_SPELL_PERIODIC_AURA_LOG
// no SpellDamageBonus for burn mana
// Set trigger flag
/*eventInfo*/)
// Shiver
//animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
// Shiver
// Cold Stare
// current aura expire on proc finish
// next target selection
/*eventInfo*/)
// Currently only Prayer of Mending
// current aura expire on proc finish
// next target selection
// send weather for current zone
// send fine weather packet to remove old weather
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Try find slot for aura
// Lookup for auras already applied from spell
// allow use single slot only by auras from same caster
// lookup for free slots in units visibleAuras
// Register Visible Aura
// Reuse visible aura slot by aura which is still applied - prevent storing dead pointers
// set not valid slot for aura - prevent removing other visible aura
// update for out of range group members
// mark as selfcasted if needed
// aura is casted by self or an enemy
// one negative effect and we know aura is negative
// aura is casted by friend
// one positive effect and we know aura is positive
// Remove all triggered by aura spells vs unlimited duration
// Is AURA_UPDATE_ALL
// Aura Count
// Not remove
// Effect Count
// Effect Count
// HasCasterGuid
// Unk effect count
// HasDuration
// HasMaxDuration
// send stack amount for aura which could be stacked (never 0 - causes incorrect display) or charges
// stack amount has priority over charges (checked on retail with spell 50262)
/*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/, bool* refresh /*= NULL*/)
// we've here aura, which script triggered removal after modding stack amount
// check the state here, so we won't create new Aura object
/*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/)
// try to get caster of aura
// check if aura can be owned by owner
// owner not in world so don't allow to own not self casted single target auras
// aura can be removed in Unit::_AddAura call
// m_casterLevel = cast item level/caster level, caster level should be saved to db, confirmed with sniffs
// shouldn't be in constructor - functions in AuraEffect::AuraEffect use polymorphism
// unload scripts
// free effects memory
// aura mustn't be already applied on target
// set infinity cooldown state for spells
/// @todo Figure out why this happens
// aura has to be already applied
// reset cooldown state for spells
// note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
// removes aura from all targets
// and marks aura as removed
// fill up to date target list
//       target, effMask
// mark all auras as ready to remove
// not found in current area - remove the aura
// needs readding - remove now, will be applied in next update cycle
// (dbcs do not have auras which apply on same type of targets but have different radius, so this is not really needed)
// nothing todo - aura already applied
// remove from auras to register list
// register auras for units
// aura mustn't be already applied on target
// the core created 2 different units with same guid
// this is a major failue, which i can't fix right now
// let's remove one unit from aura list
// this may cause area aura "bouncing" between 2 units after each update
// but because we know the reason of a crash we can remove the assertion for now
// remove from auras to register list
// ok, we have one unit twice in target map (impossible, but...)
// check target immunities
// persistent area aura does not hit flying targets
// unit auras can not stack with each other
// (GetType() == UNIT_AURA_TYPE)
// Allow to remove by stack when aura is going to be applied on owner
// check if not stacking aura already on target
// this one prevents unwanted usefull buff loss because of stacking and prevents overriding auras periodicaly by 2 near area aura owners
// owner has to be in world, or effect has to be applied to self
/// @todo There is a crash caused by shadowfiend load addon
// remove auras from units no longer needing them
// apply aura effects for units
// owner has to be in world, or effect has to be applied to self
// targets have to be registered and not have effect applied yet to use this function
// prepare list of aura targets
// apply effect to targets
// owner has to be in world, or effect has to be applied to self
// Apply spellmods for channeled auras
// used for example when triggered spell of spell:10 is modded
// update aura effects
// remove spellmods after effects update
// handle manaPerSecond/manaPerSecondPerLevel
// IsPermanent() checks max duration (which we are supposed to calculate here)
// If only one tick remaining, roll it over into new duration
// limit charges (only on charges increase, charges may be changed manually)
// we're out of charges, remove
// limit the stack amount (only on stack increase, stack amount may be changed manually)
// not stackable aura - set stack amount to 1
// we're out of stacks, remove
// Update stack amount
// reset charges
// FIXME: not a best way to synchronize charges, but works
// Can't be saved - aura handler relies on calculated amount and changes it
// No point in saving this, since the stable dialog can't be open on aura load anyway.
// Can't save vehicle auras, it requires both caster & target to be in world
// Incanter's Absorbtion - considering the minimal duration and problems with aura stacking
// we skip saving this aura
// Also for some reason other auras put as MultiSlot crash core on keeping them after restart,
// so put here only these for which you are sure they get removed
// Incanter's Absorption
// Fel Flak Fire
// Power Spark
// When a druid logins, he doesnt have either eclipse power, nor the marker auras, nor the eclipse buffs. Dont save them.
// don't save auras removed by proc system
// Same spell?
// spell with single target specific types
/// @todo find a better way to do this.
// we assume that aura dispel chance is 100% on start
// need formula for level difference based chance
// Apply dispel mod from aura caster
// Dispel resistance from target SPELL_AURA_MOD_DISPEL_RESIST
// Only affects offensive dispels
// trigger effects on real aura apply/remove
// handle spell_area table
// some auras remove at aura remove
// some auras applied at aura apply
// handle spell_linked_spell table
// apply linked auras
// remove linked auras
// modify stack amount of linked auras
// mods at aura apply
// Buffeting Winds of Susurrus
// Gronn Lord's Grasp, becomes stoned
//Petrifying Grip, becomes stoned
// Heroic Fury (remove Intercept cooldown)
// Rejuvenation
// Druid T8 Restoration 4P Bonus
/// @todo This should be moved to similar function in spell::hit
// Polymorph Sound - Sheep && Penguin
// Glyph of the Penguin
// Clearcasting
// Presence of Mind
// Arcane Potency
// Devouring Plague
// Improved Devouring Plague
// Power Word: Shield
// Glyph of Power Word: Shield
// instantly heal m_amount% of the absorb-value
// Sprint (skip non player casted spells by category)
// in official maybe there is only one icon?
// Glyph of Blurred Speed
// Sprint (waterwalk)
// mods at aura remove
// Avenging Wrath
// Remove the immunity shield marker on Avenging Wrath removal if Forbearance is not present
// Shared Suffering
// Invisibility
// Improved Fear
// Power word: shield
// Rapture
// check cooldown
// This additional check is needed to add a minimal delay before cooldown in in effect
// to allow all bubbles broken by a single damage source proc mana return
// and add if needed
// effect on caster
// Remove Vanish on stealth remove
// Remove the immunity shield marker on Forbearance removal if AW marker is not present
// Blood of the North
// Reaping
// Death Rune Mastery
// aura removed - remove death runes
// Glyph of Freezing Trap
// mods at aura apply or remove
// Enrage
// Item - Druid T10 Feral 4P Bonus
// Bestial Wrath
// The Beast Within cast on owner if talent present
// Search talent
// Divine Favor
// Item - Paladin T10 Holy 2P Bonus
// Drain Soul - If the target is at or below 25% health, Drain Soul causes four times the normal damage
// unit not in world or during remove from world
// area auras mustn't be applied
// not selfcasted single target auras mustn't be applied
// Can stack with self
// Dynobj auras always stack
// passive auras don't stack with another rank of the spell cast by same caster
// prevent remove triggering aura by triggered aura
// prevent remove triggered aura by triggering aura refresh
// check spell specific stack rules
// check spell group stack rules
// Channeled auras can stack if not forbidden by db or aura type
// check same periodic auras
// DOT or HOT from different casters will stack
// periodic auras which target areas are not allowed to stack this way (replenishment for example)
// We should probably just let it stack. Vehicle system will prevent undefined behaviour later
// No empty seat available
// Empty seat available (skip rest)
// spell of same spell rank chain
// don't allow passive area auras to stack
// same spell with same caster should not stack
/*if (m_procCooldown)
/*msec*/)
//m_procCooldown = time(NULL) + msec;
// take one charge, aura expiration will be handled in Aura::TriggerProcOnEvent (if needed)
// cooldowns should be added to the whole aura (see 51698 area aura)
// only auras with spell proc entry can trigger proc
// check if we have charges to proc with
// check proc cooldown
/// @todo
// something about triggered spells triggering, and add extra attack effect
// do checks against db data
// do checks using conditions table
// AuraScript Hook
/// @todo
// do allow additional requirements for procs
// this is needed because this is the last moment in which you can prevent aura charge drop on proc
// and possibly a way to prevent default checks (if there're going to be any)
// Check if current equipment meets aura requirements
// do that only for passive spells
/// @todo this needs to be unified for all kinds of auras
// Check if player is wearing shield
// calculate chances depending on unit with caster's data
// so talents modifying chances and judgements will have properly calculated proc chance
// calculate ppm chance if present and we're using weapon
// apply chance modifer aura, applies also to ppm chance (see improved judgement of light spell)
// OnEffectProc / AfterEffectProc hooks handled in AuraEffect::HandleProc()
// Remove aura if we've used last charge to proc
/*defaultPrevented*/)
// register aura diminishing on apply
// unregister aura diminishing (and store last time)
// non-area aura
// No GetCharmer in searcher
// no break
/*caster*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// for reload case
//reset all currently used temp texts
//entry not yet added, add empty TextHolder (list of groups)
//add the text into our entry's group
// for reload case
/*= NULL*/, ChatMsg msgType /*= CHAT_MSG_ADDON*/, Language language /*= LANG_ADDON*/, CreatureTextRange range /*= TEXT_RANGE_NORMAL*/, uint32 sound /*= 0*/, Team team /*= TEAM_OTHER*/, bool gmOnly /*= false*/, Player* srcPlr /*= NULL*/)
//has all texts in the group
//has all textIDs from the group that were already said
//will use this to talk after sorting repeatGroup
//ignores team and gmOnly
//should never happen
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
///////////////////////////////////////////////////////////////////////////////////////////////////
// @ TicketInfo
// Stores all common data needed for a Ticket : id, mapid, createtime, closedby, assignedTo, Position
///////////////////////////////////////////////////////////////////////////////////////////////////
// GM ticket
///////////////////////////////////////////////////////////////////////////////////////////////////
// BugTicket System
///////////////////////////////////////////////////////////////////////////////////////////////////
// SuggestTicket System
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// @ response Packets
// Initilize
// waitTimeOverrideMessage size
// Unk
// Unk
// Has message ???
// Has response ???
// Response ID
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// config to disable
// check flags which clean ups are necessary
// clean up
// NOTE: In order to have persistentFlags be set in worldstates for the next cleanup,
// you need to define them at least once in worldstates.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Low level functions
// not an error
// not an error
// not an error
// not an error
// near to max query
// Writing - High-level functions
// for guid set stop if set is empty
// nothing to do
// setup for guids case start position
// set case, get next guids string
// not set case, get single guid string
// collect guids
// item guid collection (character_inventory.item)
// pet petnumber collection (character_pet.id)
// mail id collection (mail.id)
// item guid collection (mail_items.item_guid)
// avoid crashes on next check
// characters.deleteInfos_Account - if filled error
// not set case iterate single time, set case iterate for all guids
/// @todo Add instance/group..
/// @todo Add a dump level option to skip some non-important tables
// Reading - High-level functions
// make sure the same guid doesn't already exist and is safe to use
// use first free if exists
// normalize the name if specified and check if it exists
// use the one from the dump
// name encoded or empty
// old->new petid relation
// skip empty strings
// skip logfile-side dump start notice, the important notes and dump end notices
// add required_ check
/*
// determine table name and load type
// change the data to server values
// characters.guid update
// characters.account update
// check if the original name already exists
// characters.at_login set to "rename on login"
// characters.name
// characters.deleteInfos_Account
// characters.deleteInfos_Name
// characters.deleteDate
// character_*.guid update
// character_equipmentsets.guid
// character_equipmentsets.setguid
// character_inventory.guid update
// character_inventory.bag update
// character_inventory.item update
// mail
// mail.id update
// mail.receiver update
// mail_items
// mail_items.id
// mail_items.item_guid
// mail_items.receiver
// item, owner, data field:item, owner guid
// item_instance.guid update
// item_instance.owner_guid update
// character_gifts.guid update
// character_gifts.item_guid update
//store a map of old pet id to new inserted pet id for use by type 5 tables
// character_pet.id update
// character_pet.owner update
// pet_aura, pet_spell, pet_spell_cooldown
// lookup currpetid and match to new inserted pet id
// couldn't find new inserted id
// in case of name conflict player has to rename at login anyway
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*10 sec*/), _clientResponseTimer(0), _dataSent(false), _initialized(false) { }
// Create packet structure
// Create packet structure
// Encrypt with warden RC4 key.
// Kick player if client response delays more than set in config
/*= NULL*/)
// Check can be NULL, for example if the client sent a wrong signature in the warden packet (CHECKSUM FAIL)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Check if Warden is enabled by config before loading anything
//                                    0    1     2     3        4       5      6      7
// Initialize action with default action from config
// PROC_CHECK support missing
// Check if Warden is enabled by config before loading anything
//                                                      0        1
// Check if action value is in range (0-2, see WardenActions enum)
// Check if check actually exists before accessing the CheckStore vector
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Generate Warden Key
/*
// data assign
// md5 hash
// Create packet structure
// Encrypt with warden RC4 key.
// test
// end test
//const uint8 validHash[20] = { 0x56, 0x8C, 0x05, 0x4C, 0x78, 0x1A, 0x97, 0x2A, 0x60, 0x37, 0xA2, 0x29, 0x0C, 0x22, 0xB5, 0x25, 0x71, 0xA0, 0x6F, 0x4E };
// Verify key
// client 7F96EEFDA5B63D20A4DF8E00CBF48304
//const uint8 client_key[16] = { 0x7F, 0x96, 0xEE, 0xFD, 0xA5, 0xB6, 0x3D, 0x20, 0xA4, 0xDF, 0x8E, 0x00, 0xCB, 0xF4, 0x83, 0x04 };
// server C2B7ADEDFCCCA9C2BFB3F85602BA809B
//const uint8 server_key[16] = { 0xC2, 0xB7, 0xAD, 0xED, 0xFC, 0xCC, 0xA9, 0xC2, 0xBF, 0xB3, 0xF8, 0x56, 0x02, 0xBA, 0x80, 0x9B };
// change keys here
// Encrypt with warden RC4 key.
//uint16 Length;
//buff >> Length;
//uint32 Checksum;
//buff >> Checksum;
//if (!IsValidCheckSum(Checksum, buff.contents() + buff.rpos(), Length))
//{
//    buff.rpos(buff.wpos());
//    if (sWorld->getBoolConfig(CONFIG_BOOL_WARDEN_KICK))
//        Client->KickPlayer();
//    return;
//}
//bool found = false;
// unsure
//found = true;
//found = true;
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Generate Warden Key
// data assign
// md5 hash
// Create packet structure
// 0x00400000 + 0x00024F80 SFileOpenFile
// 0x00400000 + 0x000218C0 SFileGetFileSize
// 0x00400000 + 0x00022530 SFileReadFile
// 0x00400000 + 0x00022910 SFileCloseFile
// 0x00400000 + 0x00419D40 FrameScript::GetText
// 0x00400000 + 0x0046AE20 PerformanceCounter
// Encrypt with warden RC4 key.
// Create packet structure
// Encrypt with warden RC4 key.
// Verify key
// Change keys here
// If all checks were done, fill the todo list again
// Build check request
// If todo list is done break loop (will be filled on next Update() run)
// Get check id from the end and remove it from todo
// Add the id to the list sent in this cycle
// If todo list is done break loop (will be filled on next Update() run)
// Get check id from the end and remove it from todo
// Add the id to the list sent in this cycle
// Add TIMING_CHECK
/*case PROC_CHECK:
// Should never happen
// Encrypt with warden RC4 key
// TIMING_CHECK
/// @todo test it.
// Now
// At request
// At response
// null terminator
// Skip string
// SHA1
// 20 bytes SHA1
// 20 bytes SHA1
// Should never happen
// Set hold off timer, minimum timer should at least be 1 second
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/// Create the Weather object
/// Launch a weather update
///- If the timer has passed, ReGenerate the weather
// update only if Regenerate has changed the weather
///- Weather will be removed if not updated (no players in zone anymore)
/// Calculate the new weather
/// Weather statistics:
///- 30% - no change
///- 30% - weather gets better (if not fine) or change weather type
///- 30% - weather worsens (if not fine)
///- 10% - radical change (if not fine)
// remember old values
//78 days between January 1st and March 20nd; 365/4=91 days by season
// season source http://aa.usno.navy.mil/data/docs/EarthSeasons.html
// Get fair
// Get better
// Get worse
/// Radical change:
///- if light -> heavy
///- if medium -> change weather type
///- if heavy -> 50% light, 50% change weather type
// go nuts
// Severe change, but how severe?
// clear up
// At this point, only weather that isn't doing anything remains but that have weather data
/// New weather statistics (if not fine):
///- 85% light
///- 7% medium
///- 7% heavy
/// If fine 100% sun (no fog)
// Severe change, but how severe?
// return true only in case weather changes
/// Send the new weather to all players in the zone
///- Send the weather packet to all players in this zone
///- Log the event
/// Set the weather
/// Get the sound number associated with the current weather
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/// Find a Weather object by the given zoneid
/// Remove a Weather object for the given zoneid
// not called at the moment. Kept for completeness
/// Add a Weather object to the list
// zone does not have weather, ignore
///- Send an update signal to Weather objects
///- and remove Weather objects for zones with no player
// As interval > WorldTick
// namespace
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/// World constructor
/// World destructor
///- Empty the kicked session set
// not remove from queue, prevent loading new sessions
/// @todo free addSessQueue
/// Find a player in a specified zone
///- circle through active sessions and return the first player found in the zone
// Used by the weather system. We return the player to broadcast the change weather message to him and all players in the zone.
// Invert the value, for simplicity for scripters.
/// Find a session by its id
// also can return NULL for kicked session
/// Remove a given session
///- Find the session, kick the user, but we can't delete session at this moment to prevent iterator invalidation
//NOTE - Still there is race condition in WorldSession* being used in the Sockets
///- kick already loaded player with same account (if any) and remove session
///- if player is in loading and want to load again, return
// session not added yet in session list, so not listed in queue
// decrease session counts only at not reconnection case
// if session already exist, prepare to it deleting at next world update
// NOTE - KickPlayer() should be called on "old" in RemoveSession()
// prevent decrease sessions count if session queued
// not remove replaced session form queue if listed
//number of players in the queue
//so we don't count the user trying to
//login as a session and queue the socket that we are using
// Updates the population
// updated number of users on the server
// The 1st SMSG_AUTH_RESPONSE needs to contain other info too.
// sessions count including queued to remove (if removed_session set)
// search to remove and count skipped positions
// removing queued session
// iter point to next socked after removed or end()
// position store position of removed socket and then new position next socket after removed
// if session not queued then we need decrease sessions count
// accept first in queue
// update iter to point first queued socket or end() if queue is empty now
// update position from iter to end()
// iter point to first not updated socket, position store new position
/// Initialize config values
///- Read the player limit and the Message of the day from the config file
///- Read ticket system setting from the config file
///- Get string for new logins (newly created characters)
///- Send server info on login?
///- Read all rates from the config file
///- Read other configuration items from the config file
/// @todo Add MonsterSight and GuarderSight (with meaning) in worldserver.conf or put them as define
// must be after CONFIG_CHARACTERS_PER_REALM
// TODO: (See MAX_MONEY_AMOUNT)
//precision mod
//precision mod
//precision mod
//precision mod
// log db cleanup interval
// 14 days default
// note: disable value (-1) will assigned as 0xFFFFFFF, to prevent overflow at calculations limit it to max possible player level MAX_LEVEL(100)
// always use declined names in the russian client
// overwrite DB/old value
// battle pet
// blackmarket
// character boost
//visibility on continents
//visibility in instances
//visibility in BG/Arenas
///- Load the CharDelete related config options
///- Read the "Data" directory from the config file
// chat logging
// Warden
// Dungeon finder
// DBC_ItemAttributes
// Accountpassword Secruity
// Rbac Free Permission mode
// Random Battleground Rewards
// Max instances per hour
// Anounce reset of instance to whole party
// AutoBroadcast
// MySQL ping time interval
// Guild save interval
// misc
// Wintergrasp battlefield
// Stats limits
//packet spoof punishment
// call ScriptMgr if we're reloading the configuration
/// Initialize the World
///- Server startup begin
///- Initialize the random number generator
///- Initialize detour memory management
///- Initialize config settings
///- Initialize Allowed Security Level
///- Init highest guids before any table loading to prevent using not initialized guids in some code.
///- Check the existence of the map files for all races' startup areas.
/*.vmtile files in '%svmaps'. Please place *.map/*.vmtree/*.vmtile files in appropriate directories or correct the DataDir value in the worldserver.conf file.", m_dataPath.c_str(), m_dataPath.c_str());
///- Initialize pool manager
///- Initialize game event manager
///- Loading strings. Getting no records means core load has to be canceled because no error message can be output.
// Error message displayed in function already
///- Update the realm entry in the database with the realm type from the config file
//No SQL injection as values are treated as integers
// not send custom type REALM_FFA_PVP to realm list
// One-time query
///- Remove the bones (they should not exist in DB though) and old corpses after a restart
///- Load the DBC files
// Must be called before `creature_respawn`/`gameobject_respawn` tables
// Get once for all the locale index of DBC language (console/broadcasts)
// must be after LoadPageTexts
// must be after LoadSpellRanks
// must be before loading quests and items
// must be after LoadRandomEnchantmentsTable and LoadPageTexts
// must be after LoadItemPrototypes
// must be after LoadItemPrototypes
// must be after LoadCreatureTemplates
// must be after LoadCreatureTemplates() and LoadGameObjectTemplates()
// must be after LoadCreatureTemplates() and LoadCreatures()
// must be after LoadCreatures(), LoadGameObjects()
// must be loaded after DBCs, creature_template, item_template, gameobject tables
// must be after loading quests
// must be after quest load
// must be after loading pools fully
// must be after LoadQuests
// must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
// must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
// must be after quest load
// must be after item template load
// must be after LoadQuests
// Must be after areatriggers
// Loot tables
// Delete expired auctions before loading
///- Load dynamic data tables from the database
// must be after load CreatureTemplate and ItemTemplate
// must be after load CreatureTemplate
// must be loaded before battleground, outdoor PvP and conditions
///- Handle outdated emails (delete/return)
///- Load and initialize scripts
// must be after load Creature/Gameobject(Template/Data)
// must be after load Creature/Gameobject(Template/Data)
// must be after Load*Scripts calls
// must be done after the ScriptMgr has been properly initialized
//SF_LOG_INFO("server.loading", "Loading Research Digsite info...");
//sObjectMgr->LoadResearchDigsiteInfo();
//SF_LOG_INFO("server.loading", "Loading Archaeology Find info...");
//sObjectMgr->LoadArchaeologyFindInfo();
//SF_LOG_INFO("server.loading", "Loading Research Project requirements...");
//sObjectMgr->LoadResearchProjectRequirements();
///- Initialize game time and timers
// One-time query
//Update "uptime" table based on configuration entry in minutes.
//erase corpses every 20 minutes
// clean logs table every 14 days by default
// check for chars to delete every day
// Mysql ping time in minutes
//to set mailtimer to return mails every day between 4 and 5 am
//mailtimer is increased when updating auctions
//one second is 1000 -(tested on win system)
/// @todo Get rid of magic numbers
//1440
///- Initilize static helper structures
///- Initialize MapManager
//depend on next event
// Delete all characters which have been deleted X days before
// Delete all custom channels which haven't been used for PreserveCustomChannelDuration days.
///- Initialize Battlegrounds
///- Initialize outdoor pvp
///- Initialize Battlefield
///- Initialize Warden
// One-time query
// 0 reserved for auth
/// Update the World !
///- Update the different timers
///- Update the game time and check for shutdown time
/// Handle daily quests reset time
/// Handle weekly quests reset time
/// Handle monthly quests reset time
/// <ul><li> Handle auctions when the timer has passed
///- Update mails (return old mails with item, or delete them)
//(tested... works on win)
///- Handle expired Blackmarket auctions
/// <ul><li> Handle auctions when the timer has passed
///- Update mails (return old mails with item, or delete them)
//(tested... works on win)
///- Handle expired auctions
/// <li> Handle session updates when the timer has passed
/// <li> Handle weather updates when the timer has passed
/// <li> Update uptime table
/// <li> Clean logs table
// if not enabled, ignore the timer
/// <li> Handle all other objects
///- Update objects when the timer has passed (maps, transport, creatures, ...)
///- Delete all characters which have been deleted X days before
// execute callbacks from sql queries that were queued recently
///- Erase corpses once every 20 minutes
///- Process Game events when necessary
// to give time for Update() to be processed
///- Ping to keep MySQL connections alive
// update the instance reset times
// And last, but not least handle the issued cli commands
// to give time for Update() to be processed
/// Send a packet to all players (except self if mentioned)
/// Send a packet to all GMs (except self if mentioned)
// check if session and can receive global GM Messages and its not self
// Player should be in world
// Send only to same team, if team is given
// we need copy va_list before use or original va_list will corrupted
// namespace Skyfire
/// Send a System Message to all players (except self if mentioned)
/// Send a System Message to all GMs (except self if mentioned)
// Session should have permissions to receive global gm messages
// Player should be in world
/// DEPRECATED, only for debug purpose. Send a System Message to all players (except self if mentioned)
// need copy to prevent corruption by strtok call in LineFromMessage original string
/// Send a packet to all players (or players selected team) in the zone (except self if mentioned)
/// Send a System Message to all players in the zone (except self if mentioned)
/// Kick (and save) all players
// prevent send queue update packet and login queued sessions
// session not removed at kick and will removed in next update tick
/// Kick (and save) all players with security level less `sec`
// session not removed at kick and will removed in next update tick
/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
/// Ban an account or ban an IP address, duration is in seconds if positive, otherwise permban
//used for kicking
///- Update the database with ban information
// No SQL injection with prepared statements
// No SQL injection with prepared statements
// No SQL injection with prepared statements
// ip correctly banned but nobody affected (yet)
// Nobody to ban
///- Disconnect all affected players (for IP it can be several)
// make sure there is only one active ban
// No SQL injection with prepared statements
/// Remove a ban from an account or IP address
//NO SQL injection as account is uint32
/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
/// Pick a player to ban if not online
// Nobody to ban
// make sure there is only one active ban
/// Remove a ban from a character
/// Pick a player to ban if not online
/// Update the game time
///- update the time
///- if there is a shutdown timer
///- ... and it is overdue, stop the world (set m_stopEvent)
// exist code already set
// minimum timer value to wait idle state
///- ... else decrease it and if necessary display a shutdown countdown to the users
/// Shutdown the server
// ignore if server shutdown at next tick
///- If the shutdown time is 0, set m_stopEvent (except if shutdown is 'idle' with remaining sessions)
// exist code already set
//So that the session count is re-evaluated at next world tick
///- Else set the shutdown timer and warn users
/// Display a shutdown message to the user(s)
// not show messages for idle shutdown mode
///- Display a message every 12 hours, hours, 5 minutes, minute, 5 seconds and finally seconds
// < 5 min; every 15 sec
// < 15 min ; every 1 min
// < 30 min ; every 5 min
// < 12 h ; every 1 h
// > 12 h ; every 12 h
/// Cancel a planned server shutdown
// nothing cancel or too later
// to default value
/// Send a server message to the user(s)
// guess size
///- Add new sessions
///- Then send an update signal to remaining ones
///- and remove not active sessions from the list
// As interval = 0
// This handles the issued and queued CLI commands
// client built-in time for reset is 6:00 AM
// FIX ME: client not show day start time
// current day reset time
// last reset time before current moment
// need reset (if we have quest time before last reset time (not processed by some reason)
// plan next reset time
// game time not yet init
// generate time by config
// current day reset time
// next reset time before current moment
// normalize reset time
// game time not yet init
// generate time by config
// current day reset time
// next reset time before current moment
// normalize reset time
// game time not yet init
// generate time by config
// current week reset time
// next reset time before current moment
// normalize reset time
// change available dailies
// change available weeklies
// generate time
// month 11 is december, next is january (0)
// reset time for next month
// don't know if we really need config option for day / hour
// plan next reset time
// will be overwrite by config values if different and non-0
// Setting a worldstate will save it to DB
/**
/*gender*/, fields[2].GetUInt8() /*race*/, fields[4].GetUInt8() /*class*/, fields[5].GetUInt8() /*level*/);
/*= GENDER_NONE*/, uint8 race /*= RACE_NONE*/)
// Passive reload, we mark the data as invalidated and next time a permission is checked it will be reloaded
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//get int anyway (0 if error)
/// Create an account
///- %Parse the command line arguments
/// Delete a user account and all associated characters in this realm
/// @todo This function has to be enhanced to respect the login/realm split (delete char, delete account chars in realm then delete account)
///- Get the account name from the command line
/// Commands not recommended call from chat, but support anyway
/// can delete only for account with less security
/// This is also reject self apply in fact
/// Display info on users currently in the realm
/*args*/)
///- Get the list of accounts ID logged to the realm
///- Display the list of account/characters online
///- Cycle through accounts
///- Get the username, last IP and GM level of each account
// No SQL injection. account is uint32.
// locked
// unlocked
// If no args are given at all, we can return false right away.
// First, we check config. What security type (sec type) is it ? Depending on it, the command branches out
// 0 - PW_NONE, 1 - PW_EMAIL, 2 - PW_RBAC
// Command is supposed to be: .account password [$oldpassword] [$newpassword] [$newpasswordconfirmation] [$emailconfirmation]
// This extracts [$oldpassword]
// This extracts [$newpassword]
// This extracts [$newpasswordconfirmation]
// This defines the emailConfirmation variable, which is optional depending on sec type.
// This extracts [$emailconfirmation]. If it doesn't exist, however...
// ... it's simply "" for emailConfirmation.
//Is any of those variables missing for any reason ? We return false.
// We compare the old, saved password to the entered old password - no chance for the unauthorized.
// This compares the old, current email to the entered email - however, only...
// ...if either PW_EMAIL or PW_RBAC with the Permission is active...
// ... and returns false if the comparison fails.
// Making sure that newly entered password is correctly entered.
// Changes password and prints result.
/*args*/)
// GM Level
// Security level required
// 0 - PW_NONE, 1 - PW_EMAIL, 2 - PW_RBAC
// RBAC required display - is not displayed for console
// Email display if sufficient rights
/// Set/Unset the expansion level for an account
///- Get the command line arguments
///- Convert Account name to Upper Format
// Let set addon state only for lesser (strong) security level
// or to self account
//get int anyway (0 if error)
// Check for second parameter
// Check for account
// Check for invalid specified GM level.
// handler->getSession() == NULL only for console
// can set security level only for target with less security and to less security that we have
// This also restricts setting handler's own security.
// Check and abort if the target gm has a higher rank on one of the realms and the new realm is -1
// Check if provided realmID has a negative value other than -1
/// Set password for account
///- Get the command line arguments
/// can set password only for target with less security
/// This also restricts setting handler's own password
/// Set normal email for account
///- Get the command line arguments
/// can set email only for target with less security
/// This also restricts setting handler's own email.
/// Change registration email for account
//- We do not want anything short of console to use this by default.
//- So we force that.
///- Get the command line arguments
/// can set email only for target with less security
/// This also restricts setting handler's own email.
///- Get the account name from the command line
// Check if accounts exists
///- Get the account name from the command line
// Check if accounts exists
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Chat short output
// Console wide output
// "account" case, name can be get in same query
// "character" case, name need extract from another DB
// No SQL injection. id is uint32.
// Chat short output
// Console wide output
// Chat short output
// Console wide output
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Stores informations about a deleted character
///< the low GUID from the character
///< the character name
///< the account id
///< the account name
///< the date at which the character has been deleted
/**
// search by GUID
// search by name
// account name will be empty for not existed account
/**
/**
// account not exist
// check character count
// if (oldlevel > newlevel)
// Update level and reset XP, everything else will be updated at login
// Search in CharTitles.dbc
// send title in "id (idx:idx) - [namedlink locale]" format
//rename characters
// check online security
// check offline security
// Remove declined name from db
// check online security
// check offline security
// exception opt second arg: .character level $name
// current level will used
// invalid level
// hardcoded maximum level
// including player == NULL
// customize characters
/// @todo add text into database
/// @todo add text into database
/**
// if no characters have been found, output a warning
/**
// It is required to submit at least one argument
// GCC by some strange reason fail build code without temporary variable
// Drop not existed account cases
// update name
// if new account provided update deleted info
/**
// It is required to submit at least one argument
// Call the appropriate function to delete them (current account for deleted characters is 0)
/**
/*handler*/, char const* args)
// config option value 0 -> disabled and can't be used
// exception opt second arg: .character level $name
// current level will used
// hardcoded maximum level
// including chr == NULL
// use original string
// normalize the name if specified and check if it exists
// character name can't start from number
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*args*/)
// check online security
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// USAGE: .debug play cinematic #cinematicid
// #cinematicid - ID decimal number from CinemaicSequences.dbc (1st column)
// USAGE: .debug play movie #movieid
// #movieid - ID decimal number from Movie.dbc (1st column)
//Play sound
// USAGE: .debug playsound #soundid
// #soundid - ID decimal number from SoundEntries.dbc (1st column)
/*args*/)
//Send notification in channel
// notify type
// channel name
//Send notification in chat
/*args*/)
/*handler*/, char const* /*args*/)
/*handler*/, char const* /*args*/)
/*args*/)
/*args*/)
//target->SetVehicleId(id);
/*args*/)
//show animation
/*args*/)
// reset all states
//check updateIndex
//uint32 = 32 bits
//! Display case
/// @fixme: port master's HandleDebugMoveflagsCommand; flags need different handling
// Force new SMSG_UPDATE_OBJECT:CreateObject
/*args*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/**
/**
/**
/**
/*args*/, bool isInstance)
/// @sa HandleDeserterAdd()
/// @sa HandleDeserterAdd()
/// @sa HandleDeserterRemove()
/// @sa HandleDeserterRemove()
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*args*/)
// id or [name] Shift-click form |color|Hgameevent:id|h[name]|h|r
// id or [name] Shift-click form |color|Hgameevent:id|h[name]|h|r
// id or [name] Shift-click form |color|Hgameevent:id|h[name]|h|r
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Enables or disables hiding of the staff badge
/*args*/)
/// Display the list of GMs
/*args*/)
///- Get the accounts with GM Level >0
///- Cycle through them. Display username and GM level
//Enable\Disable Invisible mode
//Enable\Disable GM Mode
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/** \brief Teleport the GM to the specified creature
//teleport to creature
// "id" or number or [name] Shift-click form |color|Hcreature_entry:creature_id|h[name]|h|r
// User wants to teleport to the NPC's template entry
// Get the "creature_template.entry"
// number or [name] Shift-click form |color|Hcreature_entry:creature_id|h[name]|h|r
// Number is invalid - maybe the user specified the mob's name
// if creature is in same map with caster go at its current location
// stop flight if need
// save only in non-flight case
// stop flight if need
// save only in non-flight case
//teleport to grid
// center of grid
// stop flight if need
// save only in non-flight case
//teleport to gameobject
// number or [name] Shift-click form |color|Hgameobject:go_guid|h[name]|h|r
// by DB guid
// stop flight if need
// save only in non-flight case
// stop flight if need
// save only in non-flight case
// stop flight if need
// save only in non-flight case
//teleport at coordinates
// string or [name] Shift-click form |color|Harea:area_id|h[name]|h|r
// prevent accept wrong numeric args
// update to parent zone if exist (client map show only zones without parents)
// stop flight if need
// save only in non-flight case
//teleport at coordinates, including Z and orientation
// stop flight if need
// save only in non-flight case
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// by DB guid
// Activate
//spawn go
// number or [name] Shift-click form |color|Hgameobject_entry:go_id|h[name]|h|r
// report to DB errors log as in loading case
// fill the gameobject data and save to the db
// this will generate a new guid if the object is in an instance
/// @todo is it really necessary to add both the real and DB table guid here ?
// add go, temp only
// number or [name] Shift-click form |color|Hgameobject_entry:go_id|h[name]|h|r
//delete object by selection or guid
// number or [name] Shift-click form |color|Hgameobject:go_guid|h[name]|h|r
// by DB guid
// not save respawn time
//turn selected object
// number or [name] Shift-click form |color|Hgameobject:go_id|h[name]|h|r
// by DB guid
//move selected object
// number or [name] Shift-click form |color|Hgameobject:go_guid|h[name]|h|r
// by DB guid
//set phasemask for selected object
// number or [name] Shift-click form |color|Hgameobject:go_id|h[name]|h|r
// by DB guid
//show info of gameobject
// number or [name] Shift-click form |color|Hgameobject:go_id|h[name]|h|r
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Summon group of player
// check online security
// we are in instance, and can summon only player in our group with us as lead
// the last check is a bit excessive, but let it be, just in case
// check online security
// cannot summon from instance to instance
// stop flight if need
// save only in non-flight case
// before GM
// Get ALL the variables!
// Parse the guid to uint32...
// ... and try to extract a player out of it.
// If not, we return false and end right away.
// Next, we need a group. So we define a group variable.
// We try to extract a group from an online player.
// If not, we extract it from the SQL.
// If both fails, players simply has no party. Return false.
// We get the group members after successfully detecting a group.
// To avoid a cluster fuck, namely trying multiple queries to simply get a group member count...
// ... we simply move the group type and member count print after retrieving the slots and simply output it's size.
// While rather dirty codestyle-wise, it saves space (if only a little). For each member, we look several informations up.
// Define temporary variable slot to iterator.
// Check for given flag and assign it to that iterator
// Check if iterator is online. If is...
// ... than, it prints information like "is online", where he is, etc...
// ... else, everything is set to offline or neutral values.
// Now we can print those informations for every single member of each group!
// And finish after every iterator is done.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/** \brief GM command level 3 - Create a guild.
// if not guild name only (in "") then player name
// if not guild name only (in "") then player name
// player's guild membership checked in AddMember before add
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// check online security
/*args*/)
// check online security
/*args*/)
// check online security
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*args*/)
/*args*/)
/*args*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
/*args*/)
/*args*/)
/*args*/)
// skip server-side/triggered spells
// skip wrong class/race skills
// skip other spell families
// skip spells with first rank learned as talent (and all talents then also)
// skip broken spells
/*args*/)
// search highest talent rank
// ??? none spells in talent
// learn highest rank of talent and learn all non-talent spell ranks (recursive by tree)
/*args*/)
// not hunter pet
/*TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
// prevent learn talent for different family (cheating)
// search highest talent rank
// ??? none spells in talent
// learn highest rank of talent and learn all non-talent spell ranks (recursive by tree)
/*args*/)
// skipping UNIVERSAL language (0)
// only prof. with recipes have
//  Learns all recipes of specified profession and sets skill to max
//  Example: .learn all_recipes enchanting
// converting string that we try to find to lower case
// only prof with recipes have set
// wrong skill
// not high rank
// skip racial skills
// skip wrong class skills
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*args*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// number or [name] Shift-click form |color|Hcreature_entry:creature_id|h[name]|h|r
// inventory case
// mail case
// auction case
// guild bank case
// number or [name] Shift-click form |color|Hgameobject_entry:go_id|h[name]|h|r
/*args*/)
// handle list mail command
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// converting string that we try to find to lower case
// Search in AreaTable.dbc
// send area in "id - [name]" format
// converting string that we try to find to lower case
// converting string that we try to find to lower case
// Can be NULL at console call
// converting string that we try to find to lower case
// send faction in "id - [faction] rank reputation [visible] [at war] [own team] [unknown] [invisible] [inactive]" format
// or              "id - [faction] [no reputation]" format
// and then target != NULL also
// converting string that we try to find to lower case
// Search in `item_template`
// converting string that we try to find to lower case
// Search in ItemSet.dbc
// send item set in "id - [namedlink locale]" format
// converting string that we try to find to lower case
// can be NULL at console call
// converting string that we try to find to lower case
// can be NULL in console call
// converting string that we try to find to lower case
// Search in SkillLine.dbc
// send skill in "id - [namedlink locale]" format
// can be NULL at console call
// converting string that we try to find to lower case
// Search in Spell.dbc
// unit32 used to prevent interpreting uint8 as char at output
// find rank of learned spell for learning spell, or talent rank
// send spell in "id - [name, rank N] [talent] [passive] [learn] [known]" format
// include rank in link name
// can be NULL at console call
// unit32 used to prevent interpreting uint8 as char at output
// find rank of learned spell for learning spell, or talent rank
// send spell in "id - [name, rank N] [talent] [passive] [learn] [known]" format
// include rank in link name
// converting string that we try to find to lower case
// Search in TaxiNodes.dbc
// send taxinode in "id - [name] (Map:m X:x Y:y Z:z)" format
// Find tele in game_tele order by name
// converting string that we try to find to lower case
// can be NULL in console call
// title name have single string arg for player name
// converting string that we try to find to lower case
// Counter for figure out that we found smth.
// Search in CharTitles.dbc
// send title in "id (idx:idx) - [namedlink locale]" format
// if counter == 0 then we found nth
// search in Map.dbc
// NULL only if used from console
// empty accounts only
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// global announce
// announce to logged in GMs
/*handler*/, char const* args)
// notification player at the screen
// notification GM at the screen
// Enable\Dissable accept whispers (for GM)
// whisper on
// whisper off
// Remove all players from the Gamemaster's whisper whitelist
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 63? WHY?
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// Teleport to Player
// check online security
// only allow if gm mode is on
// if both players are in different bgs
// Note: should be changed so _player gets no Deserter debuff
// all's well, set bg id
// when porting out from the bg, it will be reset to 0
// remember current position as entry point for return at bg end teleportation
// we have to go to instance, and can go to player only if:
//   1) we are in his group (either as leader or as member)
//   2) we are not bound to any group and have GM mode on
// we are in group, we can go only if we are in the player group
// we are not in group, let's verify our GM mode
// if the player or the player's group is bound to another instance
// the player will not be bound to another one
// if no bind exists, create a solo bind
// if no bind exists, create a solo bind
// stop flight if need
// save only in non-flight case
// to point to see at target with same orientation
// check offline security
// to point where player stay (if loaded)
// stop flight if need
// save only in non-flight case
// Summon Player
// check online security
// only allow if gm mode is on
// if both players are in different bgs
// Note: should be changed so target gets no Deserter debuff
// all's well, set bg id
// when porting out from the bg, it will be reset to 0
// remember current position as entry point for return at bg end teleportation
// we are in an instance, and can only summon players in our group with us as leader
// the last check is a bit excessive, but let it be, just in case
// stop flight if need
// save only in non-flight case
// before GM
// check offline security
// in point where GM stay
/*args*/)
/*args*/)
// will resurrected at login without corpse
/*args*/)
// If player is not mounted, so go out :)
/*args*/)
// move item to other slot
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// Teleport player to last position
// check online security
// stop flight if need
/*args*/)
// save GM account without delay and output message
// save if the player has last been saved over 20 seconds ago
// Save all players in the world
/*args*/)
// kick player
// check online security
// No args required for players
// 7355: "Stuck"
//Not a supported argument
// [name] manual form
// item_id or [name] Shift-click form |color|Hitem:item_id:0:0:0|h[name]|h|r
// Subtract
// Adding items
// check space and find places
// convert to possible store amount
// can't add any
// remove binding (let GM give it to another player later)
// number or [name] Shift-click form |color|Hitemset:itemset_id|h[name]|h|r
// prevent generation all items with itemset field value '0'
// remove binding (let GM give it to another player later)
/*args*/)
// Weather is OFF
// *Change the weather of a cell
//0 to 3, 0: fine, 1: rain, 2: snow, 3: sand
//0 to 1, sending -1 is instand good weather
/*args*/)
// each skills that have max skill value dependent from level seted to current level max skill value
// number or [name] Shift-click form |color|Hskill:skill_id|h[name]|h|r
/**
// Define ALL the player variables!
// To make sure we get a target, we convert our guid to an omniversal...
// ... and make sure we get a target, somehow.
// if not, then return false. Which shouldn't happen, now should it ?
/* The variables we extract for the command. They are
// Account data print variables
// Mute data print variables
// Ban data print variables
// Character data print variables
//RACE_NONE, CLASS_NONE
// Position data print
// Guild data print variables defined so that they exist, but are not necessarily used
// Mail data print is only defined if you have a mail
// check online security
// get additional information from DB
// check offline security
// Query informations from the DB
// Query the prepared statement for login data
// Only fetch these fields if commander has sufficient rights)
// RBAC Perm. 48, Role 39
// If ip2nation table is populated, it displays the country
// Creates a chat link to the character. Returns nameLink
// Returns banType, banTime, bannedBy, banreason
// Can be used to query data from World database
// Can be used to query data from Characters database
// Used for "current xp" output and "%u XP Left" calculation
// We check if have a guild for the person, so we might not require to query it at all
// Guild Data - an own query, because it may not happen.
// Initiate output
// Output I. LANG_PINFO_PLAYER
// Output II. LANG_PINFO_GM_ACTIVE if character is gamemaster
// Output III. LANG_PINFO_BANNED if ban exists and is applied
// Output IV. LANG_PINFO_MUTED if mute is applied
// Output V. LANG_PINFO_ACC_ACCOUNT
// Output VI. LANG_PINFO_ACC_LASTLOGIN
// Output VII. LANG_PINFO_ACC_OS
// Output VIII. LANG_PINFO_ACC_REGMAILS
// Output IX. LANG_PINFO_ACC_IP
// Output X. LANG_PINFO_CHR_LEVEL
// Output XI. LANG_PINFO_CHR_RACE
// Output XII. LANG_PINFO_CHR_ALIVE
// Output XIII. LANG_PINFO_CHR_PHASE if player is not in GM mode (GM is in every phase)
// IsInWorld() returns false on loadingscreen, so it's more
// precise than just target (safer ?).
// However, as we usually just require a target here, we use target instead.
// Output XIV. LANG_PINFO_CHR_MONEY
// Position data
// Output XVII. - XVIX. if they are not empty
// Output XX. LANG_PINFO_CHR_PLAYEDTIME
// Mail Data - an own query, because it may or may not be useful.
// SQL: "SELECT SUM(CASE WHEN (checked & 1) THEN 1 ELSE 0 END) AS 'readmail', COUNT(*) AS 'totalmail' FROM mail WHERE `receiver` = ?"
// Define the variables, so the compiler knows they exist
// Fetch the fields - readmail is a SUM(x) and given out as char! Thus...
// ... while totalmail is a COUNT(x), which is given out as INt64, which we just convert on fetch...
// ... we have to convert it from Char to int. We can use totalmail as it is
// Output XXI. LANG_INFO_CHR_MAILS if at least one mail is given
/*args*/)
// accept only explicitly selected target (not implicitly self targeting case)
// mute player for some times
// find only player from same account if any
// must have strong lesser security level
// Target is online, mute will be in effect right away.
// Target is offline, mute will be in effect starting from the next login.
// unmute player
// find only player from same account if any
// must have strong lesser security level
/*args*/)
/*
// flat melee damage without resistence/etc reduction
// melee damage by specific school
// non-melee damage
// number or [name] Shift-click form |color|Hspell:spell_id|h[name]|h|r or Htalent form
// check online security
// check online security
// Repair items
// get entered name
// if no name entered use target
//prevent crash with creature as target
// if name entered
// effect
// stop combat + make player unattackable + duel stop + stop some spells
// if player class = hunter || warlock remove pet if alive
// not let dismiss dead pet
// save player
// Get entered name
// If no name was entered - use target
// Reset player faction + allow combat + allow duels
// Remove Freeze spell (allowing movement and spells)
// Save player
// Check for offline players
// If player found: delete his freeze aura
/*args*/)
// Get names from DB
// Header of the names
// Output of the results
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/**
// units
// unit locations
// path
/*args*/)
// grid tile location
// calculate navmesh tile location
// navmesh poly -> navmesh tile location
/*args*/)
/*args*/)
/*args*/)
// Get Creatures
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//Edit Player HP
//Edit Player Mana
// check online security
//Edit Player Energy
// char* pmana = strtok((char*)args, " ");
// if (!pmana)
//     return false;
// char* pmanaMax = strtok(NULL, " ");
// if (!pmanaMax)
//     return false;
// int32 manam = atoi(pmanaMax);
// int32 mana = atoi(pmana);
// check online security
//Edit Player Rage
// char* pmana = strtok((char*)args, " ");
// if (!pmana)
//     return false;
// char* pmanaMax = strtok(NULL, " ");
// if (!pmanaMax)
//     return false;
// int32 manam = atoi(pmanaMax);
// int32 mana = atoi(pmana);
// check online security
// Edit Player Runic Power
//Edit Player Faction
//Edit Player Spell
// check online security
//Edit Player Aspeed
// check online security
//target->SetSpeed(MOVE_TURN,    ASpeed, true);
//Edit Player Speed
// check online security
//Edit Player Swim Speed
// check online security
//Edit Player Walk Speed
// check online security
//Edit Player Fly
// check online security
//Edit Player or Creature Scale
// check online security
//Enable Player mount
// check online security
//new 2.1.0
//Edit Player money
// check online security
//Edit Unit field
// check online security
// check online security
// check online security
//morph creature or player
// check online security
//set temporary phase mask for player
//change standstate
// MALE
// FEMALE
// Set gender
// Change display ID
//demorph player or unit
/*args*/)
// check online security
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// for HandleNpcUnFollowCommand
//{ "weapon",    rbac::RBAC_PERM_COMMAND_NPC_ADD_WEAPON,    false, &HandleNpcAddWeaponCommand,         "", NULL },
//{ "name",       rbac::RBAC_PERM_COMMAND_NPC_SET_NAME,    false, &HandleNpcSetNameCommand,          "", NULL },
//{ "subname",    rbac::RBAC_PERM_COMMAND_NPC_SET_SUBNAME, false, &HandleNpcSetSubNameCommand,       "", NULL },
//add spawn of creature
// To call _LoadGoods(); _LoadQuests(); CreateTrainerSpells();
//add item in vendorlist
// FIXME: make type (1 item, 2 currency) an argument
//add maxcount, default: 0
//add incrtime, default: 0
//add ExtendedCost, default: 0
//add move for creature
/* FIXME: impossible without entry
// attempt check creature existence by DB data
// obtain real GUID for DB operations
// Update movement type
// dead creature will reset movement generator at respawn
/*args*/)
//change level of creature or pet
// number or [name] Shift-click form |color|Hcreature:creature_guid|h[name]|h|r
// Delete the creature
//del item from vendor list
// FIXME: make type (1 item, 2 currency) an argument
//set faction of creature
// Faction is set in creature_template - not inside creature
// Update in memory..
// ..and DB
//set npcflag of creature
//set data of creature for testing scripting
//npc follow handling
/*args*/)
// Follow player - Using pet's default dist and angle
/*args*/)
//move selected creature
// number or [name] Shift-click form |color|Hcreature:creature_guid|h[name]|h|r
/* FIXME: impossible without entry
// Attempting creature load from DB data
// dead creature will reset movement generator at respawn
//play npc emote
//set model of creature
/**HandleNpcSetMoveTypeCommand
// 3 arguments:
// GUID (optional - you can also select the creature)
// stay|random|way (determines the kind of movement)
// NODEL (optional - tells the system NOT to delete any waypoints)
//        this is very handy if you want to do waypoints, that are
//        later switched on/off according to special events (like escort
//        quests, etc)
//SF_LOG_ERROR("misc", "DEBUG: All 3 params are set");
// All 3 params are set
// GUID
// type
// doNotDEL
//SF_LOG_ERROR("misc", "DEBUG: doNotDelete = true;");
// Only 2 params - but maybe NODEL is set
//SF_LOG_ERROR("misc", "DEBUG: type_str, NODEL ");
// case .setmovetype $move_type (with selected creature)
// case .setmovetype #creature_guid $move_type (with selected creature)
/* impossible without entry
// attempt check creature existence by DB data
// now lowguid is low guid really existed creature
// and creature point (maybe) to this creature or NULL
// update movement type
//if (doNotDelete == false)
//    WaypointMgr.DeletePath(lowguid);
// update movement type
// dead creature will reset movement generator at respawn
//npc phase handling
//change phase of creature
// don't send update here for multiple phases, only send it once after adding all phases
//npc phase handling
//change phase of creature
//set spawn dist of creature
// dead creature will reset movement generator at respawn
//spawn time handling
// make some emotes
//show text emote by creature in chat
//npc unfollow handling
/*args*/)
/*creature->GetMotionMaster()->empty() ||*/
// reset movement
// make npc whisper to player
// check online security
// make an emote
// add creature, temp only
//npc tame handling
/*args*/)
// Everything looks OK, create new pet
// place pet before player
// set pet to defensive mode by default (some classes can't control controlled pets in fact).
// calculate proper level
// prepare visual effect for levelup
// add to world
// visual effect for levelup
// caster have pet now
/// @todo NpcCommands that need to be fixed :
/*handler*/, char const* /*args*/)
/*if (!*args)
/*handler*/, char const* /*args*/)
/* Temp. disabled
/*handler*/, char const* /*args*/)
/* Temp. disabled
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*args*/)
// Creatures with family 0 crashes the server
// Everything looks OK, create new pet
// just for nice GM-mode view
// prepare visual effect for levelup
// this enables pet details window (Shift+P)
// visual effect for levelup
// Check if pet already has it
// Check if spell is valid
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// .addquest #entry'
// number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
// check item starting quest (it can work incorrectly if added without item in inventory)
// ok, normal (creature/GO starting) quest
// .removequest #entry'
// number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
// remove all quest entries for 'entry' from quest log
// we ignore unequippable quest items in this case, its' still be equipped
// .quest complete #entry
// number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
// If player doesn't have the quest
//player->SendQuestUpdateAddCredit();
// .quest reward #entry
// number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
// If player doesn't have the quest
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//{ "db_script_string",              rbac::RBAC_PERM_COMMAND_RELOAD_, true,  &HandleReloadDbScriptStringCommand,            "", },
//reload commands
/*handler*/, const char* /*args*/)
/*args*/)
/*args*/)
/*args*/)
//HandleReloadQuestAreaTriggersCommand(handler, ""); -- reloaded in HandleReloadAllQuestCommand
/*args*/)
// will be reloaded from all_gossips
/*args*/)
/*args*/)
/*args*/)
// already reload from all_scripts
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/// dependent also from `gameobject` but this table not reloaded anyway
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
///- Reload dynamic data tables from the database
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*args*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// reset m_form if no aura
// reset only if player not in some form;
//-1 is default value
// set starting level
// reset level for pet
/* bool myClassOnly */);
// Try reset talents as Hunter Pet
// Command specially created as single command to prevent using short case names
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Send mail by command
// format: name "subject text" "mail text"
// msgSubject, msgText isn't NUL after prev. check
// from console show not existed sender
/// @todo Fix poor design
// Send items by mail
// format: name "subject text" "mail text" item1[:count1] item2[:count2] ... item12[:count12]
// msgSubject, msgText isn't NUL after prev. check
// extract items
// get all tail string
// get from tail next item str
// and get new tail
// parse item str
// from console show not existed sender
// fill mail
// save for prevent lost at next mail load, if send fail then item will deleted
/// Send money by mail
/// format: name "subject text" "mail text" money
// msgSubject, msgText isn't NUL after prev. check
// from console show not existed sender
/// Send a message to a player in game
/// - Find the player
///- Check that he is not logging out.
/// - Send the message
// Use SendAreaTriggerMessage for fastest delivery.
// Confirmation message
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Triggering corpses expire check in world
/*handler*/, char const* /*args*/)
/*args*/)
// Can't use sWorld->ShutdownMsg here in case of console command
/*args*/)
// Display the 'Message of the day' for the realm
/*args*/)
/*handler*/, char const* /*args*/)
/*handler*/, char const* args)
// Prevent interpret wrong arg value as 0 secs shutdown time
// Handle atoi() errors
// Exit code should be in range of 0-125, 126-255 is used
// in many shells for their own return codes and code > 255
// is not supported in many others
/*handler*/, char const* args)
//  Prevent interpret wrong arg value as 0 secs shutdown time
// Handle atoi() errors
// Exit code should be in range of 0-125, 126-255 is used
// in many shells for their own return codes and code > 255
// is not supported in many others
/*handler*/, char const* args)
// Prevent interpret wrong arg value as 0 secs shutdown time
// Handle atoi() errors
// Exit code should be in range of 0-125, 126-255 is used
// in many shells for their own return codes and code > 255
// is not supported in many others
/*handler*/, char const* args)
// Prevent interpret wrong arg value as 0 secs shutdown time
// Handle atoi() errors
// Exit code should be in range of 0-125, 126-255 is used
// in many shells for their own return codes and code > 255
// is not supported in many others
// Exit the realm
/*args*/)
// Define the 'Message of the day' for the realm
// Set whether we accept new clients
// Set the level of logging
/*handler*/, char const* args)
// set diff time record interval
/*handler*/, char const* args)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
// teleport player to given game_tele.entry
// References target's homebind
// id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
// check online security
// stop flight if need
// save only in non-flight case
// check offline security
//Teleport group to given game_tele.entry
// check online security
// id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
// check online security
// stop flight if need
// save only in non-flight case
// id, or string, or [name] Shift-click form |color|Htele:id|h[name]|h|r
// stop flight if need
// save only in non-flight case
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Target must exist and have administrative rights
// If already assigned, leave
// If assigned to different player other than current, leave
//! Console can override though
// Assign ticket
// Ticket should be assigned to the player who tries to close it.
// Console can override though
// Inform player, who submitted this ticket, that it is closed
/*args*/)
// Cannot comment ticket assigned to someone else
//! Console excluded
// Force abandon ticket
/*args*/)
// Ticket must be assigned
// Get security level of player, whom this ticket is assigned to
// Check security
//! If no m_session present it means we're issuing this command from the console
// copy assignedto name because we need it after the ticket has been unnassigned
// Target must exist and have administrative rights
// If already assigned, leave
// If assigned to different player other than current, leave
//! Console can override though
// Assign ticket
// Ticket should be assigned to the player who tries to close it.
// Console can override though
// Inform player, who submitted this ticket, that it is closed
/*args*/)
/*args*/)
// Cannot comment ticket assigned to someone else
//! Console excluded
/*args*/)
// Ticket must be assigned
// Get security level of player, whom this ticket is assigned to
// Check security
//! If no m_session present it means we're issuing this command from the console
// copy assignedto name because we need it after the ticket has been unnassigned
/*args*/)
/*args*/)
/*args*/)
/*args*/)
// Detect target's GUID
// Target must exist
// Ticket must exist
// Cannot add response to ticket, assigned to someone else
//! Console excluded
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// number or [name] Shift-click form |color|Htitle:title_id|h[name]|h|r
// check online security
// to be sure that title now known
// number or [name] Shift-click form |color|Htitle:title_id|h[name]|h|r
// check online security
// number or [name] Shift-click form |color|Htitle:title_id|h[name]|h|r
// check online security
//Edit Player KnownTitles
// check online security
// remove not existed titles
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/**
// optional
// path_id -> ID of the Path
// point   -> number of the waypoint (if not 0)
//Map* map = player->GetMap();
// HandleWpAddCommand
// optional
// Did player provide a path_id?
/*args*/)
// Check
// Query can't be a prepared statement
// Query can't be a prepared statement
// first arg: add del text emote spell waittime move
// Check
// Remember: "show" must also be the name of a column!
// Next arg is: <PATHID> <WPNUM> <ARGUMENT>
// Did user provide a GUID
// or did the user select a creature?
// -> variable lowguid is filled with the GUID of the NPC
// The visual waypoint
// User did select a visual waypoint?
// Check the creature
// Select waypoint number from database
// Since we compare float values, we have to deal with
// some difficulties.
// Here we search for all waypoints that only differ in one from 1 thousand
// (0.001) - There is no other way to compare C++ floats with mySQL floats
// See also: http://dev.mysql.com/doc/refman/5.0/en/problems-with-float.html
// We have the waypoint number and the GUID of the "master npc"
// Text is enclosed in "<>", all other arguments not
// Check for argument
// del
// What to do:
// Move the visual spawnpoint
// Respawn the owner of the waypoints
// re-create
// To call _LoadGoods(); _LoadQuests(); CreateTrainerSpells();
/// @todo Should we first use "Create" then use "LoadFromDB"?
//sMapMgr->GetMap(npcCreature->GetMapId())->Add(wpCreature2);
// move
// show_str check for present in list of correct values, no sql injection possible
// Query can't be a prepared statement
// show_str check for present in list of correct values, no sql injection possible
// Query can't be a prepared statement
// first arg: on, off, first, last
// second arg: GUID (optional, if a creature is selected)
// Did player provide a PathID?
// No PathID provided
// -> Player must have selected a creature
// PathID provided
// Warn if player also selected a creature
// -> Creature selection is ignored <-
//handler->PSendSysMessage("wpshow - show: %s", show);
// Show info for the selected waypoint
// Check if the user did specify a visual waypoint
// Delete all visuals for this NPC
// Set "wpguid" column to the visual waypoint
// To call _LoadGoods(); _LoadQuests(); CreateTrainerSpells();
// set "wpguid" column to "empty" - no visual waypoint spawned
//WorldDatabase.PExecute("UPDATE creature_movement SET wpguid = '0' WHERE wpguid <> '0'");
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
// Yells
// Quests
// Creatures
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*who*/) OVERRIDE { }
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*who*/) OVERRIDE { }
/*######
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
//Blackrock Battle Worg NPC ID
//Stormwind Infantry NPC ID
//Faction used by worgs to be able to attack infantry
//Default Blackrock Battle Worg Faction
//Worg Growl Spell
//Minimum health for AI staged fight between Blackrock Battle Worgs and Stormwind Infantry
//Stormwind Infantry Yell phrase from Group 1
//% Chance for Stormwind Infantry to Yell - May need further adjustment... should be low chance
/*######
/*diff*/) OVERRIDE
/*######
/*diff*/) OVERRIDE
/*######
/*diff*/) OVERRIDE
/*######
//If damage taken from player
//If damage taken from pet
//If damage taken from Blackrock Battle Worg
//We do not want to do damage if Blackrock Battle Worg is below preset HP level (currently 85% - Blizzlike)
//Chance to yell every 5 to 10 seconds
//Roll for random chance to Yell phrase
//Yell phrase
//After First yell, change time range from 10 to 120 seconds
//From 10 to 120 seconds
//Else do standard attack
/*######
//Restore our faction on reset
//If damage taken from player
//If damage taken from pet
//If damage taken from Stormwind Infantry
//We do not want to do damage if Stormwind Infantry is below preset HP level (currently 85% - Blizzlike)
//We must change our faction to one which is able to attack Stormwind Infantry (Faction 232 works well)
//Do Growl if ready
//Else do standard attack
//Reset my faction if not in combat
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Quest
// Creatures
/*who*/)OVERRIDE { }
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*######
// Quest
// Says
// Creatures
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// Yells
// Quests
// Gameobjects
// Creature
// Factions
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//Yenniku's Release
//stop combat
//unsure of this
//horde generic
/*who*/) OVERRIDE { }
//troll, bloodscalp
//Return since we have no target
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
// the real one to use might be 37099
// Combat spells
/*player*/, Creature* creature, const Quest *_Quest, uint32 /*slot*/) OVERRIDE
/*who*/) OVERRIDE { }
// Combat spells
// add a blink to simulate a stealthed movement and reappearing elsewhere
// if the victim is out of melee range she cast multi shot
/*######
/*who*/) OVERRIDE { }
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// I have a feeling this isn't blizzlike, but owell, I'm only passing by and cleaning up.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// check if creature is not outside of building
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// check if creature is not outside of building
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// not sure
// not sure
// not sure
// not sure
//20 to 30 seconds
/*who*/) OVERRIDE
//20 to 30 seconds
// check if creature is not outside of building
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
// check if creature is not outside of building
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//YELL_RESPAWN1                                 = -1810010, // Missing in database
//YELL_RESPAWN2                                 = -1810011, // Missing in database
// not sure
/*who*/) OVERRIDE
//20 to 30 seconds
// check if creature is not outside of building
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*areaTrigger*/)
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*type*/, uint32 pointId) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
// player is the spellcaster so register summon manually
// Never evade
// 96872 - Focused Fire
// ID - 96931 Eyes of Occu'thar
/*effIndex*/)
// ID - 96932 Eyes of Occu'thar
// 96942 / 101009 - Gaze of Occu'thar
/*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* TODO:
/*who*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*killer*/) OVERRIDE
// 88954 / 95173 - Consuming Darkness
// 88942 / 95172 - Meteor Slash
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//go_shadowforge_brazier
/*player*/, GameObject* go) OVERRIDE
// If used brazier open linked doors (North or South)
// npc_grimstone
//4 or 6 in total? 1+2+1 / 2+2+2 / 3+3. Depending on this, code should be changed.
// Dredge Worm
// Deep Stinger
// Dark Screecher
// Burrowing Thundersnout
// Cave Creeper
// Borer Beetle
// Gorosh
// Grizzle
// Eviscerator
// Ok'thor
// Anub'shiah
// Hedrum
/*at*/) OVERRIDE
// npc_grimstone
/// @todo implement quest part of event (different end boss)
/// @todo move them to center
/// @todo move them to center
//seems all are gone, so set timer to continue and discontinue this
//if quest, complete
// npc_phalanx
//Return since we have no target
//ThunderClap_Timer
//FireballVolley_Timer
//MightyBlow_Timer
// npc_kharan_mighthammer
/*sender*/, uint32 action) OVERRIDE
// npc_lokhtos_darkbargainer
/*sender*/, uint32 action) OVERRIDE
// npc_dughal_stormwing
/*
// npc_marshal_windsor
/*
//EMOTE_STATE_WORK
//EMOTE_STATE_WORK
// npc_marshal_reginald_windsor
/*
// npc_tobias_seecher
/*
// npc_rocknot
/*player*/, Creature* creature, Quest const* quest, uint32 /*item*/) OVERRIDE
//keep track of amount in instance script, returns SPECIAL if amount ok and event in progress
//doesn't work very well, leaving code here for future
//spell by trap has effect61, this indicate the bar go hostile
//for later, this event(s) has alot more to it.
//optionally, DONE can trigger bar to go hostile.
// Fix us
/*new npc_dughal_stormwing();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE { }
//Return since we have no target
//FireBlast_Timer
//Spirit_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE { }
//Return since we have no target
//ShadowBolt_Timer
//CurseOfTongues_Timer
//CurseOfWeakness_Timer
//DemonArmor_Timer
//EnvelopingWeb_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//uint32 Counter;
//Counter= 0;
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
//3 Hands of Thaurissan will be casted
//if (Counter < 3)
//{
//    HandOfThaurissan_Timer = 1000;
//    ++Counter;
//}
//else
//{
//Counter = 0;
//}
//AvatarOfFlame_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE { }
//Return since we have no target
//MightyBlow_Timer
//HamString_Timer
//Cleave_Timer
//Adds_Timer
// summon 3 Adds every 25s
//Summon Medics
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
//Return since we have no target
//WhirlWind_Timer
//MortalStrike_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE { }
//Return since we have no target
//GroundTremor_Timer
//Frenzy_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE { }
//Return since we have no target
//ShadowWordPain_Timer
//ManaBurn_Timer
//PsychicScream_Timer
//ShadowShield_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// not id or guid of doors but number of enum in blackrock_depths.h
/*who*/) OVERRIDE { }
//Return since we have no target
//FieryBurst_Timer
//WarStomp_Timer
// When he die open door to last chamber
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//These times are probably wrong
/*who*/) OVERRIDE { }
//Return since we have no target
//MindBlast_Timer
//ShadowWordPain_Timer
//Smite_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*sender*/, uint32 action) OVERRIDE
//are 5 minutes expected? go template may have data to despawn when used at quest
/*sender*/, uint32 action) OVERRIDE
//start event here
// was set before event start, so set again
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//ShadowVolley_Timer
//Immolate_Timer
//CurseOfWeakness_Timer
//DemonArmor_Timer
//Summon Voidwalkers
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Shadowforge Brazier North
// Shadowforge Brazier South
// Magmus door North
// Magmus door Soutsh
// Throne door
// if Magmus is dead open door to last boss
//reset
//start
//reset tomb of seven event
//event reseted, close exit door
//event reseted, open entrance door
//do not call EnterEvadeMode(), it will create infinit loops
//event started, close exit door
//event started, close entrance door
//event done, open exit door
//event done, open entrance door
// Check Killed bosses
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Not sure if right ID. 23931 would be a harder possibility.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Change model
// Combat (self cast)
// Combat (Self cast)
// Combat (Self cast)
// Combat
// Summons Rend near death
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*type*/, uint32 data) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Self on spawn
// Self on spawn missing from 335 dbc triggers SPELL_FIRE_SHIELD every 3 sec
// Triggered by SPELL_FIRE_SHIELD_TRIGGER
// Self on event start
// Self on event start
// Triggered by SPELL_EMBERSEER_GROWING
// Emberseer Full Strength
// Combat
// Combat
// Combat
// Blackhand Incarcerator Spells
// Emberseer on spawn
// Combat
// Combat
// Cast on player by altar
// Respawn
// Pre fight
// Combat
// Hack due to trigger spell not in dbc
// Make sure all players have aura from altar
// Apply auras on spawn and reset
// DoCast(me, SPELL_FIRE_SHIELD_TRIGGER); // Need to find this in old DBC if possible
// Hack for missing trigger spell
// Open doors on reset
// Opens 2 entrance doors
/*type*/, uint32 data) OVERRIDE
// Close these two doors on Blackhand Incarcerators aggro
/*who*/) OVERRIDE
// ### TODO Check combat timing ###
/*killer*/) OVERRIDE
// Activate all the runes
// Opens all 3 doors
// Complete encounter
/*caster*/, SpellInfo const* spell) OVERRIDE
// These two doors reopen on reset or boss kill
// This door opens on boss kill
// update all runes
// Respawn all Blackhand Incarcerators
// Set data on all Blackhand Incarcerators
// #### Spell isn't doing any damage ??? ####
// Check to see if all players in instance have aura SPELL_EMBERSEER_START before starting event
/*####
// OOC
// Combat
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// Used to close doors
// Had to do this because CallForHelp will ignore any npcs without LOS
// AI()->AttackStart(me->GetVictim());
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// sniffed
// On spawn during Gyth fight
// Rend Blackhand
// Victor Nefarius
/*
// 22 sec
// 60 sec
// 49 sec
// 60 sec
// 27 sec
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// move wave
// spawn wave
// move wave
// spawn wave
// move wave
// spawn wave
// move wave
// spawn wave
// move wave
// spawn wave
// move wave
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//DoCast(me, SPELL_ICEARMOR, true);
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//uint32 const DragonspireRunes[7] = { GO_HALL_RUNE_1, GO_HALL_RUNE_2, GO_HALL_RUNE_3, GO_HALL_RUNE_4, GO_HALL_RUNE_5, GO_HALL_RUNE_6, GO_HALL_RUNE_7 };
/*gameObject*/, uint32 eventId) OVERRIDE
/*#####
/*at*/) OVERRIDE
/*#####
/*at*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// These spells are actually called elemental shield
// What they do is decrease all damage by 75% then they increase
// One school of damage by 1100%
// Other spells
//Incinerate 23308, 23309
//Time lapse 23310, 23311(old threat mod that was removed in 2.01)
//Corrosive Acid 23313, 23314
//Ignite Flesh 23315, 23316
//Frost burn 23187, 23189
// Brood Affliction 23173 - Scripted Spell that cycles through all targets within 100 yards and has a chance to cast one of the afflictions on them
// Since Scripted spells arn't coded I'll just write a function that does the same thing
//Blue affliction 23153
//Black affliction 23154
//Red affliction 23155 (23168 on death)
//Bronze Affliction  23170
//Brood Affliction Green 23169
//Spell cast on player if they get all 5 debuffs
//The frenzy spell may be wrong
// Select the 2 breaths that we are going to use until despawned
// 5 possiblities for the first breath, 4 for the second, 20 total possiblites
// This way we don't end up casting 2 of the same breath
// TL TL would be stupid
// B1 - Incin
// B1 - TL
//B1 - Acid
//B1 - Ignite
//B1 - Frost
// We use this to store our last vulnerabilty spell so we can remove it later
/*who*/) OVERRIDE
// Remove old vulnerabilty spell
// Cast new random vulnerabilty on self
// Enrage if not already enraged and below 20%
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//This spell periodically triggers fire nova
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Victor Nefarius
// Nefarian
// UBRS
// Nefarius
// UBRS
// BWL
// SAY_VAEL_INTRO             = 14, Not used - when he corrupts Vaelastrasz
// Nefarian
// UBRS
// Victor Nefarius
// UBRS Spells
// Self Cast hits 10339
// Self Cast Depawn one sec after
// BWL Spells
// Nefarian
// wild magic
// beserk
// cat form
// corrupted healing
// syphon blessing
// totems
// infernals
// bow broke
// Paralise
// Death Grip
// 19484
// 22664
// 22674
// 22666
// drakonid
// nefarian spawn
// nefarian move
//events.ScheduleEvent(EVENT_MIND_CONTROL, urand(30000, 35000));
/*killer*/) OVERRIDE
/*summon*/) OVERRIDE { }
// Only do this if we haven't spawned nefarian yet
/*who*/) OVERRIDE
//events.ScheduleEvent(EVENT_TAILLASH, 10000);
/*Killer*/) OVERRIDE
// Cast NYI since we need a better check for behind target
// Phase3 begins when health below 20 pct
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*killer*/) OVERRIDE
/*who*/, uint32& damage) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Chain cleave is most likely named something different and contains a dummy effect
/*who*/) OVERRIDE
// now drop damage requirement to be able to take loot
// Speech
//Only cast if we are behind
/*if (!me->HasInArc(M_PI, me->GetVictim()))
// max 3 tries to get a random target with power_mana
// not aggro leader
// cast on self (see below)
// have the victim cast the spell on himself otherwise the third effect aura will be applied to Vael instead of the player
// Yell if hp lower than 15%
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Razorgore
// Vaelastrasz the Corrupt
// Broodlord Lashlayer
// 3 Dragons
// Chormaggus
// Nefarian
// Egg
// Door
// Door
// Door
// Door
// Door
// Egg
// MindControl
//! HACK, needed because of buggy CreatureAI after charm
// Misc
// Razorgore
// Vaelastrasz the Corrupt
// Broodlord Lashlayer
// 3 Dragons
// Chormaggus
// Nefarian
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// If we are <2% hp cast Armageddon
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Garr
// Adds
//These times are probably wrong
/*attacker*/, uint32& damage) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Golemagg
// Core Rager
/*attacker*/, uint32& /*damage*/) OVERRIDE
// These times are probably wrong
/*attacker*/, uint32& /*damage*/) OVERRIDE
// Mangle
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*victim*/) OVERRIDE
/*sender*/, uint32 /*action*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Ranged attack
// Server side effect
// Stealth aura
/*victim*/) OVERRIDE
//Become unbanished again
//DoCast(me, SPELL_RAGEMERGE); //"phase spells" didnt worked correctly so Ive commented them and wrote solution witch doesnt need core support
//Do nothing while banished
//Return since we have no target
//Say our dialog
//Creature spawning and ragnaros becomming unattackable
//is not very well supported in the core //no it really isnt
//so added normaly spawning and banish workaround and attack again after 90 secs.
//Root self
//DoCast(me, 23973);
// summon 8 elementals
//DoCast(me, SPELL_RAGSUBMERGE);
//DoCast(me, SPELL_RAGSUBMERGE);
//didnt work correctly in EAI for me...
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Teleporting him to a random player and casting Arcane Explosion after that.
// Blink is not working cause of LoS System we need to do this hardcoded.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Sulfuron Harbringer
// Adds
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*player*/)
// need 2 loops to check spawning executus/ragnaros
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*START ACID-AI*/
/*END ACID-AI*/
//dosen't work?
/*uiId*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// it's a hack - Mr. Smite should do that but his too far away
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*sender*/, uint32 action) OVERRIDE
//visual effects are not working!
//go->CastSpell(me, 12158); makes all die?!
//just in case
//We can't use it!
//We can't use it!
//We can't use it!
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/***********************************/
/*** OPERA WIZARD OF OZ EVENT *****/
/*********************************/
// Dorothee
// Tito
// Strawman
// Tinhead
// Roar
// Crone
// Cyclone
// Increment DeathCount
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*caster*/, const SpellInfo* Spell) OVERRIDE
/*
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE
/**************************************/
/**** Opera Red Riding Hood Event* ***/
/************************************/
/*sender*/, uint32 action) OVERRIDE
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/**********************************************/
/******** Opera Romeo and Juliet Event* ******/
/********************************************/
/**** Speech *****/
/*who*/) OVERRIDE { }
/*caster*/, const SpellInfo* Spell) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE;
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE
//anything below only used if incoming damage will kill
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
//will do this 2secs after spell hit. this is time to display visual as expected
/*done_by*/, uint32 &damage)
//anything below only used if incoming damage will kill
//this means already drinking, so return
//IS THIS USEFULL? Creature* Julianne = (Unit::GetCreature((*me), JulianneGUID));
//if this is true then we have to kill romulo too
//if not already returned, then romulo is alive and we can pretend die
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Flare spell info
//Visual effect + Flare damage
//Curator spell info
//Arcane Infusion: Transforms Curator and adds damage.
//This time may be wrong
//12 minutes
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//always decrease BerserkTimer
//if evocate, then break evocate
//may not be correct SAY (generic hard enrage)
//don't know if he's supposed to do summon/evocate after hard enrage (probably not)
//not supposed to do anything while evocate
//Summon Astral Flare
//Reduce Mana by 10% of max health
//if this get's us below 10%, then we evocate (the 10th should be summoned now)
//no AddTimer cooldown, this will make first flare appear instantly after evocate end, like expected
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*Victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Triggered so it doesn't interrupt her at all
//A little randomness on that spell
//Anywhere from 8 to 23 seconds, good luck having several of those in a row!
//20-30 secs sounds nice
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Only when mounted
//Attumen (@todo Use the summoning spell instead of Creature id. It works, but is not convenient for us)
//Occasionally yell
//only when mounted
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*source*/, const SpellInfo* spell) OVERRIDE
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE
//me->Relocate(newX, newY, newZ, angle);
//me->SendMonsterMove(newX, newY, newZ, 0, true, 1000);
//pAttumen->Relocate(newX, newY, newZ, -angle);
//pAttumen->SendMonsterMove(newX, newY, newZ, 0, true, 1000);
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Adds
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//remove aura from spell Garrote when Moroes dies
//Cast Vanish, then Garrote random victim
/*diff*/) OVERRIDE
//Shadow Priest
// 3 sec channeled
// 3 sec cast
//Retr Pally
//Holy Priest
//Holy Pally
//Arms Warr
//Arms Warr
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Left side
// Right side
// Back side
// Perseverence
// Serenity
// Dominance
// timer for phase switching
// berserking timer
// timer for beam checking
// guid's of portals
// guid's of auxiliary beaming portals
// guid's of portals' current targets
// the in-line checker
// check if target is between (not checking distance from the beam yet)
// check  distance from the beam
// auxiliary method for distance
// Blue Portal not on the left side (0)
// Here we handle the beams' behavior
// j = color
// the one who's been casted upon before
// temporary store for the best suitable beam reciever
// get the best suitable target
// alive
// closer than current best
// not exhausted
// not on another beam
// on the beam
// buff the target
// cast visual beam on the chosen target if switched
// simple target switching isn't working -> using BeamerGUID to cast (workaround)
// remove currently beaming portal
// create new one and start beaming on the target
// aggro target if Red Beam
// Massive Door switcher
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Void Zone
// NetherInfusion Berserk
// PORTAL PHASE
// Distribute beams and buffs
// Empowerment & Nether Burn
// BANISH PHASE
// Netherbreath
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// phase 1
// phase 2
// Not used in script
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//timer wrong between 45 and 60 seconds
//timer wrong (maybe)
/* The timer for this was never setup apparently, not sure if the code works properly:
//  Phase 1 "GROUND FIGHT"
// first take off 75%
// secound take off 50%
// third take off 25%
//Phase 2 "FLYING FIGHT"
// only once at the beginning of phase 2
//timer wrong
//timer wrong
//landing
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// 18 Coordinates for Infernal spawns
//Enfeeble is supposed to reduce hp to 1 and then heal player back to full when it ends
//Along with reducing healing and regen while enfeebled to 0%
//This spell effect will only reduce healing
//  SAY_SPECIAL1                = 3, Not used, needs to be implemented, but I don't know where it should be used.
//  SAY_SPECIAL2                = 4, Not used, needs to be implemented, but I don't know where it should be used.
//  SAY_SPECIAL3                = 5, Not used, needs to be implemented, but I don't know where it should be used.
//Enfeeble during phase 1 and 2
//Shadownova used during all phases
//Shadow word pain during phase 1 and 3 (different targeting rules though)
//Extra attack chance during phase 2
//Sunder armor during phase 2
//Passive proc chance for thrash
//Visual for axe equiping
//Amplifiy during phase 3
//Same as Nightbane.
//Infenals' hellfire aura
//The netherspite infernal creature
//Malchezar's axes (creatures), summoned during phase 3
//Infernal Effects
//Axes info
//---------Infernal code first
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/, const SpellInfo* spell) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// Open the door leading further in
//Infernal Cleanup
//damage
//begin + 1, so we don't target the one with the highest threat
//store the threat list in a different container
//cut down to size if we have more than 5 targets
/*diff*/)
// Let's not forget to reset that
// While shifting to phase 2 malchezaar stuns himself
//animation
//text
//passive thrash aura
//models
//damage
//Sigh, updating only works on main attack, do it manually ....
//remove thrash
//axe->getThreatManager().tauntApply(target); //Taunt Apply and fade out does not work properly
// So we'll use a hack to add a lot of threat to our target
//axe->getThreatManager().tauntFadeOut(axe->GetVictim());
//axe->getThreatManager().tauntApply(target);
//Time for global and double timers
// 15 secs in phase 3, 45 otherwise
// the tank
// anyone but the tank
//Check for base attack
//Check for offhand attack
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//  SAY_ATIESH                  = 9, Unused
//Spells
//Creature Spells
//Creatures
// Don't close the door right on aggro in case some people are still entering.
// Not in progress
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//store the threat list in a different container
//only on alive players
//cut down to size if we have more than 3 targets
//Cooldowns for casts
//Drink Interrupt
//Drink Interrupt Timer
//Don't execute any more code if we are drinking
//Normal casts
//Check for what spells are not on cooldown
//If no available spells wait 1 second and try again
//Flame Wreath check
/*pAttacker*/, uint32 &damage) OVERRIDE
/*pAttacker*/, const SpellInfo* Spell) OVERRIDE
//We only care about interrupt effects and only if they are durring a spell currently being casted
//Interrupt effect
//Normally we would set the cooldown equal to the spell duration
//but we do not have access to the DurationStore
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Summons demonic chains that maintain the ritual of sacrifice.
// Instant - Visual Effect
// Increases the caster's attack speed by 50% and the Physical damage it deals by 219 to 281 for 10 min.
// Hurls a bolt of dark magic at an enemy, inflicting Shadow damage.
// Teleports and adds the debuff
// Increases attack speed by 75%. Periodically casts Shadow Bolt Volley.
// Summons a Fiendish Imp.
// Summons Kil'rek
// Opens portal and summons Fiendish Portal, 2 sec cast
// Opens portal and summons Fiendish Portal, instant cast
// Blasts a target for 150 Fire damage.
// All damage taken increased by 25%.
// Increases the Fire damage taken by an enemy by 500 for 25 sec.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
// Door at Shade of Aran
// Door at Netherspite
// Side Entrance
// Door before Chess
// Door after Chess
// Door at Malchezaar
// 1 - OZ, 2 - HOOD, 3 - RAJ, this never gets altered.
/// @todo Set Object visibilities for Opera based on performance
// Do not load an encounter as "In Progress" - reset it instead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Barnes
// Berthold
// Image of Medivh
/*######
// Entries and spawn locations for creatures in Oz event
// Dorothee
// Roar
// Tinhead
// Strawman
// Grandmother
// Julianne
//resets count for this event, in case earlier failed
/*who*/) OVERRIDE { }
// In case database has bad flags
/*sender*/, uint32 action) OVERRIDE
// Check for death of Moroes and if opera event is not done already
/*###
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
// Check if Shade of Aran event is done
/*###
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//This yell should be done when the room is cleared. For now, set it as a movelineofsight yell.
// Phase 1 spells
// Deals 2700-3300 damage at current target
//       4950-6050
// Summons a phoenix (Doesn't work?)
// A spell Phoenix uses to damage everything around
// DMG if a Phoenix rebirth happen
// Damage part
// Heroic damage part
// Flamestrike indicator before the damage
// Summons the trigger + animation (projectile)
// Heroic only; 10k damage shield, followed by Pyroblast
// Heroic only; 45-55k fire damage
// Phase 2 spells
// Cast at the beginning of every Gravity Lapse
// Channeled; blue beam animation to every enemy in range
// Should teleport people to the center. Requires DB entry in spell_target_position.
// Hastens flyspeed and allows flying for 1 minute. For some reason removes 44226.
// Knocks up in the air and applies a 300 DPS DoT.
// Passive auras on Arcane Spheres
// Stuns him, making him take 50% more damage for 10 seconds. Cast after Gravity Lapse
/** Locations **/
//Heroic only
// 0 = No Gravity Lapse
// 1 = Casting Gravity Lapse visual
// 2 = Teleported people to self
// 3 = Knocked people up in the air
// 4 = Applied an aura that allows them to fly, channeling visual, relased Arcane Orbs.
// 0 = Not started
// 1 = Fireball; Summon Phoenix; Flamestrike
// 2 = Gravity Lapses
/// @todo Timers
/*killer*/) OVERRIDE
// Enable the Translocation Orb Exit
/*done_by*/, uint32 &damage) OVERRIDE
// Remove Gravity Lapse so that players fall to ground if they kill him when in air.
/*who*/) OVERRIDE
// Knockback into the air
// Use Fly Packet hack for now as players can't cast "fly" spells unless in map 530. Has to be done a while after they get knocked into the air...
// Also needs an exception in spell system.
// Use packet hack
//Return since we have no target
// *Heroic mode only:
// Below 50%
// Different yells at 50%, and at every following Gravity Lapse
// Don't interrupt the visual spell
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*killer*/, uint32 &damage) OVERRIDE
//Prevent glitch if in fake death
//Don't really die in all phases of Kael'Thas
//prevent death
/*killer*/) OVERRIDE
//If we are fake death, we cast revbirth and after that we kill the phoenix to spawn the egg.
//spell Burn should possible do this, but it doesn't, so do this for now.
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Apoko
//Kagani Nightstrike
//Elris Duskhallow
//Eramas Brightblaze
//Yazzaj
//Warlord Salaris
//Garaxxas
//Apoko
//Zelfan
//this mean she at some point evaded
//can be called if Creature are dead, so avoid
//it's empty, so first time
//pre-allocate size for speed
//fill vector array with entries from Creature array
//remove random entries
//summon all the remaining in vector
//object already removed, not exist
/*killer*/) OVERRIDE
//all 8 possible lackey use this common
// These guys does not follow normal threat system rules
// For later development, some alternative threat system should be made
// We do not know what this system is based upon, but one theory is class (healers=high threat, dps=medium, etc)
// We reset their threat frequently as an alternative until such a system exist
// in case she is not alive and Reset was for some reason called, respawn her (most likely party wipe after killing her)
/*killer*/) OVERRIDE
//should delrissa really yell if dead?
//increase local var, since we now may have four dead
//time to make her lootable and complete event if she died before lackeys
//Rogue
// ...? Hacklike
//Warlock
/*who*/) OVERRIDE
//Monk
//Mage
//if in melee range
//if anybody is in melee range than escape by blink
//Warrior
/*who*/) OVERRIDE
//if in melee range
//if nobody is in melee range than try to use Intercept
//Hunter
//attempt find go summoned from spell (casted by me)
//if we have a go, we need to wait (only one trap at a time)
//if go does not exist, then we can cast
//Shaman
// std::vector<Add*>::const_iterator itr = Group.begin() + rand()%Group.size();
// uint64 guid = (*itr)->guid;
// if (guid)
// {
//   Unit* pAdd = Unit::GetUnit(*me, (*itr)->guid);
//   if (pAdd && pAdd->IsAlive())
//   {
//    }
// }
//Engineer
/*
//CreatureAI* GetAI(Creature* creature) const OVERRIDE
//{
//    return new npc_high_explosive_sheepAI(creature);
//};
// new npc_high_explosive_sheep();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Crystal effect spells
// This spell triggers 44321, which changes scale and regens mana Requires an entry in spell_script_target
//Selin's spells
// Heroic only
//GUIDs per instance is static, so we only need to load them once.
// This will help us create a pointer to the crystal we are draining. We store GUIDs, never units in case unit is deleted/offline (offline if player of course).
//for (uint8 i = 0; i < CRYSTALS_NUMBER; ++i)
//Unit* unit = Unit::GetUnit(*me, FelCrystals[i]);
// Let the core handle setting death state, etc.
// Only need to set unselectable flag. You can't attack unselectable units so non_attackable flag is not necessary here.
// Set Inst data for encounter
//float ShortestDistance = 0;
//for (uint8 i =  0; i < CRYSTALS_NUMBER; ++i)
//pCrystal = Unit::GetUnit(*me, FelCrystals[i]);
// select nearest
// Store a copy of pCrystal so we don't need to recreate a pointer to closest crystal for the movement and yell.
// coords that we move to, close to the crystal.
//for (uint8 i = 0; i < CRYSTALS_NUMBER; ++i)
//Creature* pCrystal = (Unit::GetCreature(*me, FelCrystals[i]));
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
// Make the crystal attackable
// We also remove NON_ATTACKABLE in case the database has it set.
// Make an error message in case something weird happened here
/*killer*/) OVERRIDE
// Encounter complete!
// Heroic only
// If below 10% mana, start recharging
// Use Deal Damage to kill it, not setDeathState.
// No need to check if we are draining crystal here, as the spell has a stun.
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
// Set this to false if we are the Creature that Selin is draining so his AI flows properly
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//is this text for real?
//#define SAY_DEATH             "What...happen...ed."
// Pure energy spell info
// Vexallus spell info
// heroic spell
// heroic spell
// mod scale -10
// mod scale -5
// mod scale -5
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//spells are SUMMON_TYPE_GUARDIAN, so using setOwner should be ok
//used for check, when Vexallus cast adds 85%, 70%, 55%, 40%, 25%
//increase amount, unless we're at 10%, then we switch and return
//below are workaround summons, remove when summoning spells w/implicitTarget 73 implemented in the core
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//human form entry
// This is friendly keal that appear after used Orb.
// If we assume DB handle summon, summon appear somewhere outside the platform where Orb is
/*sender*/, uint32 action) OVERRIDE
// we must assume he appear as dragon somewhere outside the platform of orb, and then move directly to here
// some targeting issues with the spell, so use this workaround as temporary solution
// Transform and update entry, now ready for quest/read gossip
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*######
/*who*/) OVERRIDE
//SF_LOG_DEBUG("scripts", "npc_unworthy_initiateAI: move to %f %f %f", anchorX, anchorY, me->GetPositionZ());
/*id*/) OVERRIDE
/*id*/) const OVERRIDE
/*######
//SPELL_DUEL_TRIGGERED        = 52990,
/*sender*/, uint32 action) OVERRIDE
// other players cannot help
// beg
/// @todo spells
/*######
/*######
// for quest Into the Realm of Shadows(12687)
//creature->Respawn(true);
/*######
/*who*/) OVERRIDE
// correct way: 52312 52314 52555 ...
/// @todo Creatures must not be removed, but, must instead
//      stand next to Gothik and be commanded into the pit
//      and dig into the ground.
// Ghouls should display their Birth Animation
// Crawling out of the ground
//DoCast(me, 35177, true);
//me->MonsterSay("Mommy?", LANG_UNIVERSAL, 0);
/*diff*/) OVERRIDE
//ScriptedAI::UpdateAI(diff);
//Check if we have a current target
//If we are within range melee the target
/*####
// Modelid2 is a horse.
/*param*/) OVERRIDE
// Not 100% correct, but movement is smooth. Sometimes miner walks faster
// than normal, this speed is fast enough to keep up at those times.
/*seatId*/, bool apply) OVERRIDE
/*####
/*id = 0*/) OVERRIDE
// npc 28912 quest 17217 boss 29001 mob 29007 go 191092
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//How to win friends and influence enemies
// texts signed for creature 28939 but used for 28939, 28940, 28610
/*######
//not sure about this id
//NPC_DEATH_KNIGHT_MOUNT        = 29201,
//Scarlet courier
// not sure about this id
/*who*/) OVERRIDE
//Koltira & Valroth- Breakout
//SAY_VALROTH1                      = 0, Unused
/*######
//used by 29032, 29061, 29065, 29067, 29068, 29070, 29074, 29072, 29073, 29071 but signed for 29032
// speech for all
// Ellen Stanbridge
// Kug Ironjaw
// Donovan Pulfrost
// Yazmina Oakenthorn
// Antoine Brack
// Malar Bravehorn
// Goby Blastenheimer
// Iggy Darktusk
// Lady Eonys
// Valok the Righteous
/// @todo simplify text's selection
//case 5: //unknown
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// if you do not have a good server and do not want it to be laggy as hell
//Light of Dawn
// how many player queue to start the quest, or -
// *every 5 minutes. These have to be done in instance data
// how many of defender
// how many of earthshatter
// how many of abomination
// how many of behemoth
// how many of ghoul
// how many of warrior
// how many player queue to start the quest, or -
// *every 5 minutes. These have to be done in instance data
// how many of defender
// how many of earthshatter
// how many of abomination
// how many of behemoth
// how many of ghoul
// how many of warrior
// Total number
// pre text
// intro
// During the fight - Korfax, Champion of the Light
// Lord Maxwell Tyrosus
// Highlord Darion Mograine
// After the fight
// Highlord Tirion Fordring
// Highlord Darion Mograine
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Alexandros Mograine
// Highlord Darion Mograine
// Highlord Darion Mograine
// Darion Mograine
// Darion Mograine
// Highlord Alexandros Mograine
// Darion Mograine
// Highlord Alexandros Mograine
// Darion Mograine
// Highlord Alexandros Mograine
// Highlord Alexandros Mograine
// The Lich King
// Highlord Darion Mograine
// The Lich King
// The Lich King
// Highlord Tirion Fordring
// The Lich King
// The Lich King
// Lord Maxwell Tyrosus
// The Lich King
// Highlord Darion Mograine
// Highlord Darion Mograine
// Highlord Tirion Fordring
// The Lich King
// Highlord Tirion Fordring
// The Lich King
// The Lich King
// The Lich King
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Tirion Fordring
// Highlord Darion Mograine
// Emotes
// quest credit
// ---- Dark Knight npc --------------------
// Highlord Darion Mograine
// on players when begins
// Koltira Deathweaver & Orbaz Bloodbane are using the same abilities
// this guy fleed
// he also does SPELL_THE_LIGHT_OF_DAWN 53658
// all do SPELL_HERO_AGGRO_AURA    53627
// Lich King
// show up at end
// on Alexandros
// on Tirion
// not sure what is it for
// others
// giant guy
// just ghoul....
// use SPELL_CLEAVE 53631
// ghost
// ghost
// ---- Dawn npc --------------------
// Highlord Tirion Fordring
// others
// also does SPELL_HEROIC_LEAP 53625
// 0 Tirion Fordring loc
// 1 Tirion Fordring loc2
// 2 Tirion charges
// 3 Tirion run
// 4 Tirion relocate
// 5 Tirion forward
// 6 Tirion runs to Darion
// 9 Korfax loc1
// 10 Korfax loc2
// 11 Korfax kicked
// 12 Maxwell loc1
// 13 Maxwell loc2
// 14 maxwell kicked
// 15 Eligor loc1
// 16 Eligor loc2
// 17 eligor kicked
// 18 Koltira loc1
// 19 Koltira loc2
// 20 Thassarian loc1
// 21 Thassarian loc2
// 22 Alexandros loc1
// 23 Alexandros loc2
// 24 Darion loc1
// 25 Darion loc1
// 26 Lich King spawns
// 27 Lich king move forwards
// 28 Lich king kicked
// 29 Lich king moves forward
/*sender*/, uint32 action) OVERRIDE
// Darion Mograine
// Dawn
// Death
// 5 minutes
//UpdateWorldState(me->GetMap(), WORLD_STATE_COUNTDOWN, 0);
// need to fix, on player only
//Unit* pTirion = Unit::GetCreature(*me, uiTirionGUID);
//do not reset self if we are in battle
// ******* Before battle *****************************************************************
// countdown
//UpdateWorldState(me->GetMap(), WORLD_STATE_COUNTDOWN, 1);
// just delay
//UpdateWorldState(me->GetMap(), WORLD_STATE_REMAINS, 1);
// rise
// summon ghoul
// Dunno whats the summon spell, so workaround
// shack effect
// summon abomination
// shack effect
// summon warrior
// shack effect
// summon warrior
// shack effect
// summon announce
// charge begins
// ******* After battle *****************************************************************
// Tirion starts to speak
// summon gate
// Alexandros out
// makes darion turns back
// Darion's spirit out
// runs to father
// Tirion moves forward here
// lich king spawns
// just hide him
// Darion supports to jump to lich king here
// jumping charge
// doesn't make it looks well, so workarounds, Darion charges, looks better
// Lich king counterattacks
// Darion got kicked by lich king
// Lich king counterattacks
// Lich king - Apocalypse
//temp->CastSpell(pTirion, SPELL_APOCALYPSE, false); // not working
// Maxwell yells for attack
// They all got kicked
// make them stand up
// Darion stand up, "not today"
// Darion throws sword
// Ashbringer rebirth
// Show the cleansing effect (dawn of light)
//if (GameObject* go = me->GetMap()->GetGameObject(uiDawnofLightGUID))
//    go->SetPhaseMask(128, true);
// workarounds, light expoded, makes it cool
// Tiron charges
// jumping charge
// workarounds, make Tirion still running
// workarounds, he should kick back by Tirion, but here we relocate him
// 26
// Tirion runs to Darion
// Lich king disappears here
//if (GameObject* go = me->GetMap()->GetGameObject(uiDawnofLightGUID)) // Turn off dawn of light
//    go->SetPhaseMask(0, true);
// search players with in 50 yards for quest credit
// respawns another Darion for quest turn in
// Escort ends
// ******* During battle *****************************************************************
// Check spawns
// Check targets
// Battle end
// temp->DeleteThreatList();
// temp->GetMotionMaster()->MoveChase(pTarger, 20.0f);
// Death
// Dawn
/*######
// very sample, just don't make them aggreesive OVERRIDE
/*who*/) { } // very sample, just don't make them aggreesive OVERRIDE
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*####
//Nothing To DO
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//If we are <50% hp cast Arcane Bubble
//wait if we already casting
//AoESilence_Timer
//ArcaneExplosion_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
//If we are <50% hp cast Soul Siphon rank 1
//SoulSiphon_Timer
//SoulSiphon_Timer = 20000;
//CallOfTheGrave_Timer
//Terrify_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*Victim*/) OVERRIDE
//If we are <35% hp
//FlameShock_Timer
//FlameSpike_Timer
//FireNova_Timer
//ShadowBolt_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//this texts are already used by 3975 and 3976
//Phase 2, can't find real spell(Dim Fire?)
// SPELL_CONFL_SPEED           = 22587,       //8% increase speed, value 22587 from SPELL_CONFLAGRATION mains that spell?
//visual flying head
//visual buff, "head"
//at killing head, Phase 3
//Effects
// SPELL_RHYME_SMALL           = 42910,
// SPELL_ENRAGE_VISUAL         = 42438,       // he uses this spell?
// SPELL_WISP_INVIS            = 42823,
//not correct spell
//spawn point for pumpkin shrine mob
//spawn point for smoke
// needs assigned to db.
/*who*/) OVERRIDE { }
/*caster*/, const SpellInfo* spell) OVERRIDE
/*who*/) OVERRIDE { }
//DoCast(me, SPELL_HEAD_SPEAKS, true);
/*done_by*/, uint32 &damage) OVERRIDE
//me->GetMotionMaster()->MoveIdle();
//DoCast(me, SPELL_HEAD_SPEAKS, true); //this spell remove buff "head"
//if (instance)
//    instance->SetData(DATA_HORSEMAN_EVENT, NOT_STARTED);
//hide gameobject
/*who*/) OVERRIDE
//maybe possible when player dies from conflagration
/*killer*/) OVERRIDE
//me->GetMotionMaster()->MoveIdle();
//DoResetThreat();//not sure if need
/*done_by*/, uint32 &damage) OVERRIDE
//Head->CastSpell(Head, SPELL_HEAD_INVIS, false);
//test
//1 cleave per 2.0f-6.0fsec
//"body calls head"
//this visual aura some under ground
/*who*/) OVERRIDE { }
/*caster*/, const SpellInfo* spell) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*  if (soil->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER && player->getLevel() > 64)
//}
//hack, SpellHit doesn't calls if body has immune aura
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//If we are <30% hp goes Enraged
//Cleave_Timer
// Whirlwind_Timer
/*waypointId*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//If we are <25% hp cast Heal
//Fear_Timer
//Sleep_Timer
//PowerWordShield_Timer
//Dispel_Timer
//CurseOfBlood_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*Victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Any other Actions to do with vorrel? setStandState?
//If we are low on hp Do sayings
//ShadowWordPain_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Mograine says
//Whitemane says
//Mograine Spells
//Whitemanes Spells
//Incase wipe during phase that mograine fake death
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*doneBy*/, uint32 &damage) OVERRIDE
//On first death, fake death and open door, as well as initiate whitemane if exist
/*who*/, const SpellInfo* spell) OVERRIDE
//When hit with ressurection say text
//On ressurection, stop fake death and heal whitemane and resume fight
//This if-check to make sure mograine does not attack while fake death
//CrusaderStrike_Timer
//HammerOfJustice_Timer
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
//When casting resuruction make sure to delay so on rez when reinstate battle deepsleep runs out
//Cast Deep sleep when health is less than 50%
//while in "resurrect-mode", don't do anything
//If we are <75% hp cast healing spells at self or Mograine
// checking _bCanResurrectCheck prevents her healing Mograine while he is "faking death"
//PowerWordShield_Timer
//HolySmite_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
//LichSlap_Timer
//FrostboltVolley_Timer
//MindFlay_Timer
//FrostNova_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//case GAMEOBJECT_PUMPKIN_SHRINE:   return PumpkinShrineGUID;
//case DATA_HORSEMAN:               return HorsemanGUID;
//case DATA_HEAD:                   return HeadGUID;
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*summoner*/) OVERRIDE
// Script for Shadow Portal spell 17950
/*effIndex*/)
// Script for Shadow Portal spells 17863, 17939, 17943, 17944, 17946, 17948
// Hall of Secrects
// The Hall of the damned
// The Coven
// The Shadow Vault
// Barov Family Vault
// Vault of the Ravenian
// If only one player in threat list fail spell
// Not yet spawned
// Not yet spawned
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*done_by*/, uint32 &damage) OVERRIDE
//Summon Darkreaver's Fallen Charger
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//5 Flashheals will be casted
//3 Healing Touch will be casted
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//SPELL_ILLUSION              = 17773,
// Spells of Illusion of Jandice Barov
//uint32 Illusioncounter;
//Too much too low?
/*who*/) OVERRIDE
//Become visible again
//Jandice Model
//Do nothing while invisible
//Return since we have no target
//CurseOfBlood_Timer
//Cast
//45 seconds
//Illusion_Timer
//Interrupt any spell casting
// Invisible Model
//Summon 10 Illusions attacking random gamers
//25 seconds until we should cast this agian
//            //Illusion_Timer
//            if (Illusion_Timer <= diff)
//            {
//                  //Cast
//                DoCastVictim(SPELL_ILLUSION);
//
//                  //3 Illusion will be summoned
//                  if (Illusioncounter < 3)
//                  {
//                    Illusion_Timer = 500;
//                    ++Illusioncounter;
//                  }
//                  else {
//                      //15 seconds until we should cast this again
//                      Illusion_Timer = 15000;
//                      Illusioncounter = 0;
//                  }
//
//            } else Illusion_Timer -= diff;
// Illusion of Jandice Barov Script
/*who*/) OVERRIDE
//Return since we have no target
//Cleave_Timer
//Cast
//5-8 seconds
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//ShadowVolley_Timer
//BoneShield_Timer
//Minion_Timer
//Cast
//Summon 2 Bone Mages
//Cast
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Old ID  was 15570
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// This is actually a buff he gives himself
/*who*/)OVERRIDE { }
//IceArmor_Timer
//Frostbolt_Timer
//Freeze_Timer
//Fear_Timer
//ChillNova_Timer
//FrostVolley_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// 28371
//FireShield_Timer
//BlastWave_Timer
//Frenzy_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//door to open when talking to NPC's
//door to open when Fenrus the Devourer
//door to open when Wolf Master Nandos
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*aurEff*/, bool& isPeriodic, int32& amplitude)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//SPELL_POSSESS           = 17244
//uint32 Possess_Timer;
//Possess_Timer = 35000;
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//BansheeWail
//4 seconds until we should cast this again
//BansheeCurse
//18 seconds until we should cast this again
//Silence
//13 seconds until we should cast this again
//Possess
/*            if (Possess_Timer <= diff)
//Cast
//50 seconds until we should cast this again
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//triggers death pact (17471)
// Define Add positions
//    uint32 RaiseDead_Timer;
//        RaiseDead_Timer = 30000;
//can't use entercombat(), boss' dmg aura sets near players in combat, before entering the room's door
/*killer*/) OVERRIDE
//ShadowBolt
//Cleave
//13 seconds until we should cast this again
//MortalStrike
//RaiseDead
//            if (RaiseDead_Timer <= diff)
//          {
//      DoCast(me, SPELL_RAISEDEAD);
//                RaiseDead_Timer = 45000;
//            } else RaiseDead_Timer -= diff;
//SummonSkeletons
//34 seconds until we should cast this again
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//front, left
//front, right
//mid, left
//mid, right
//back, left
//back, mid
//back, right
//behind, left
//behind, right
//SPELL_SUMMONCRIMSONRIFLEMAN     = 17279
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
//Pummel
//Cast
//90% chance to cast
//12 seconds until we should cast this again
//KnockAway
//Cast
//80% chance to cast
//14 seconds until we should cast this again
//Shoot
//Cast
//1 seconds until we should cast this again
//SummonRifleman
//Cast
//30 seconds until we should cast this again
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Dathrohan spells
//AOE stun
//weapon dmg +3
//Transform
//restore full HP/mana, trigger spell Balnazzar Transform Stun
//Balnazzar spells
//probably incorrect
//G1 front, left
//G1 front, right
//G1 back left
//G1 back, right
//G2 front, left
//G2 front, right
//G2 back left
//G2 back, right
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//START NOT TRANSFORMED
//MindBlast
//CrusadersHammer
//CrusaderStrike
//HolyStrike
//BalnazzarTransform
//restore hp, mana and stun
//MindBlast
//ShadowShock
//PsychicScream
//DeepSleep
//MindControl
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//nothing to see here yet
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
//DrainingBlow
//CrowdPummel
//MightyBlow
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
//Frostbolt
//IceTomb
//DrainLife
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//EncasingWebs
//PierceArmor
//CryptScarabs_Timer
//RaiseUndeadScarab
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*#####
/*who*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Spell ID to summon this guy is 24627 "Summon Postmaster Malown"
//He should be spawned along with three other elites once the third postbox has been opened
/*who*/) OVERRIDE
// lasts 6 sec
// 2 sec stun
// lasts 2 mins
/*victim*/) OVERRIDE
//65% chance to cast
//45% chance to cast
//3% chance to cast
//3% chance to cast
//5% chance to cast
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
//Trample
//Knockout
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//Return since we have no target
//RavenousClaw
//Cast
//15 seconds until we should cast this again
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//change to DONE when crystals implemented
//if withRestoreTime true, then newState will be ignored and GO should be restored to original state after 10 seconds
//weird, but unless flag is set, client will not respond as expected. DB bug?
//change to DONE when crystals implemented
//change to DONE when crystals implemented
//change to DONE when crystals implemented
//a bit itchy, it should close the door after 10 secs, but it doesn't. skipping it for now.
//UpdateGoState(ziggurat4GUID, 0, true);
// Do not reset 1, 2 and 3. they are not set to done, yet .
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*######
/*who*/) OVERRIDE { }
/*######
// Spells
// Quest
// Creatures
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*######
/*who*/) OVERRIDE { }
/*caster*/, const SpellInfo* spell) OVERRIDE
/*killer*/) OVERRIDE
//100%, 50%, 33%, 25% chance to spawn
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// correct order goes form 1-6
/*diff*/) // correct order goes form 1-6
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*#####
/*at*/) OVERRIDE
/*#####
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Madrigosa not found, end intro
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Lady Sacrolash spells
//10 secs
//30-35 secs
//25 secs
//Shadow Image spells
//Misc spells
//Grand Warlock Alythess spells
//15secs
//30-35 secs
//on main target every 3 secs
//187366 GO
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// only if ALY death
//don't change target(healers)
//If we are within range melee the target
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/)OVERRIDE { }
//If we are within range melee the target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//YELL_KALECGOS                                 = 6, Not used. After felmyst's death spawned and say this
//Aura
//Land phase
// SPELL_ENCAPSULATE_EFFECT                      = 45665,
// SPELL_ENCAPSULATE_AOE                         = 45662,
//Flight phase
// fel to player, force cast 45392, 50000y selete target
// player summon vapor, radius around caster, 5y,
// vapor to fel, force cast 45389
// fel to vapor, green beam channel
// linked to 45389, vapor to self, trigger 45410 and 46931
// vapor damage, 4000
// vapor summon trail
// trail to self, trigger 45402
// trail damage, 2000 + 2000 dot
// summon blazing dead, 5min
// fel to self, speed burst
// fog to self, trigger 45782
// fog to player, force cast 45714
// player let fel cast 45717, script effect
// fel to player
// link to 45717
// madrigosa to self, trigger 46350
// 46411stun?
// become fel
//Other
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// workaround for linked aura
/*if (spell->Id == SPELL_VAPOR_FORCE)
// workaround for mind control
//me->AttackStop();
// core bug
//DoCast(me, SPELL_VAPOR_SELECT); need core support
//target->CastSpell(target, SPELL_VAPOR_SUMMON, true); need core support
// core bug
//DoTextEmote("takes a deep breath.", NULL);
/*who*/) OVERRIDE
//DoCast(me, SPELL_VAPOR_FORCE, true); core bug
/*diff*/) OVERRIDE
// core bug
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//over this, teleport object won't work, 0 disables check
//first reset at create
//dunno why it does not resets health at evade..
//boss is invisible, don't attack
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*id*/) OVERRIDE
// if demon is enraged
//dunno why it does not resets health at evade..
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/// @todo rewrite Armageddon
/*** Speech and sounds***/
/*** Spells used during the encounter ***/
/* Hand of the Deceiver's spells and cosmetics */
// ~30 yard range Shadow Bolt Volley for ~2k(?) damage
// They gain this at 20% - Immunity to Stun/Silence and makes them look angry!
// Creates a portal that spawns Felfire Fiends (LIVE FOR THE SWARM!1 FOR THE OVERMIND!)
// Channeling animation out of combat
/* Volatile Felfire Fiend's spells */
// Felfire Fiends explode when they die or get close to target.
/* Kil'Jaeden's spells and cosmetics */
// Surprisingly, this seems to be the right spell.. (Where is it used?)
// Emerge from the Sunwell
// 9k Shadow damage over 3 seconds. Spammed throughout all the fight.
// Chain Lightning, 4 targets, ~3k Shadow damage, 1.5fk mana burn
// Places a debuff on 5 raid members, which causes them to deal 2k Fire damage to nearby allies and selves. MIGHT NOT WORK
// when he use it?
// Summon shadow copies of 5 raid members that fight against KJ's enemies//dont work
//  45892  // right one for SPELL_SINISTER_REFLECTION but no EffectScriptEffect
// }
// }
// }- Spells used in Sinister Reflection creation
// }
// Bombard random raid members with Shadow Spikes (Very similar to Void Reaver orbs)
// Bombards the raid with flames every 3(?) seconds
// Begins a 8-second channeling, after which he will deal 50'000 damage to the raid
/* Armageddon spells wrong visual */
// Meteor spell trigger missile should cast Creature on himself
// Does the hellfire visual to indicate where the meteor missle lands
// Does the light visual to indicate where the meteor missle lands
// This shouldn't correct but same as seen on the movie
// Summons the triggers that cast the spells on himself need random target select
// This does the area damage
/* Shield Orb Spells*/
//45679 would be correct but triggers to often /// @todo fix console error
/* Anveena's spells and cosmetics (Or, generally, everything that has "Anveena" in name) */
// She hovers locked within a bubble
// Sunwell energy glow animation (Control mob uses this)
// This is cast on Kil'Jaeden when Anveena sacrifices herself into the Sunwell
/* Sinister Reflection Spells */
//SPELL_SR_PLAGU STRIKE                       = 58843, Dk Spell!
/*** Other Spells (used by players, etc) ***/
// Possess the blue dragon from the orb to help the raid.
// Visual for Entropius at the Epilogue
//Cast this spell when the go is activated
/*** Error messages ***/
/*** Others ***/
// Fight 3 adds
// Kil'Jaeden emerges from the sunwell
// At 85%, he gains few abilities; Kalecgos joins the fight
// At 55%, he gains even more abilities
// At 25%, Anveena sacrifices herself into the Sunwell; at this point he becomes enraged and has *significally* shorter cooldowns.
//Timers
//Phase 2 Timer
//Phase 3 Timer
//Phase 4 Timer
// Locations of the Hand of Deceiver adds
// Locations, where Shield Orbs will spawn
// middle pont of Sunwell
// First one spawns northeast of KJ
// Second one spawns southeast
// Third one spawns (?)
// Timers
//Kil Phase 1 -> Phase 2
//Kil Phase 2 -> Phase 3
//Kil Phase 3 -> Phase 4
//Kil Phase 4 -> Phase 5
// use in End sequence?
//AI for Kalecgos
/*diff*/) OVERRIDE
//AI for Kil'jaeden Event Controller
//AI for Kil'jaeden
/* Boolean */
// Scripted_NoMovementAI::InitializeAI();
//Phase 2 Timer
//Phase 3 Timer
//Phase 4 Timer
//      summoned->SetVisibility(VISIBILITY_OFF);  //with this we cant see the armageddon visuals
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// Reset the controller
/*who*/) OVERRIDE
//stop every cast Shadow spike will reactivate em all
// empowered orbs before darkness
//   ChangeTimers(true, 10000); // Kil should do an emote while screaming without attacking for 10 seconds
// 18 seconds in PHASE_SACRIFICE
// 25 seconds in PHASE_SACRIFICE
// 30-60seconds cooldown
//Phase 3
//Phase 3
/// @todo Timer
//Phase 3
// Begins to channel for 8 seconds, then deals 50'000 damage to all raid members.
//Phase 3
//Phase 4
// No, I'm not kidding
//Time runs over!
//Phase 3
//Phase 4
//Phase 5 specific spells all we can
//AI for Hand of the Deceiver
/// @todo Timers!
// So they don't all cast it in the same moment.
/*killer*/) OVERRIDE
// Gain Shadow Infusion at 20% health
// Shadow Bolt Volley - Shoots Shadow Bolts at all enemies within 30 yards, for ~2k Shadow damage.
// Felfire Portal - Creatres a portal, that spawns Volatile Felfire Fiends, which do suicide bombing.
//AI for Felfire Portal
//AI for Felfire Fiend
/*done_by*/, uint32 &damage) OVERRIDE
// Explode if it's close enough to it's target
//AI for Armageddon target
//AI for Shield Orbs
/*id*/) OVERRIDE
//AI for Sinister Reflection
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Muru & Entropius's spells
// Muru's spells
//(this trigger 46008)
// Entropius's spells
// Shadowsword Berserker's spells
// Shadowsword Fury Mage's spells
// Void Sentinel's spells
// Void Spawn's spells
//Dark Fiend Spells
//Black Hole Spells
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE
//Timer
/*caster*/, const SpellInfo* Spell) OVERRIDE
/*caster*/, const SpellInfo* Spell) OVERRIDE
//is this a correct timer?
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* Sunwell Plateau:
/** Creatures **/
/** GameObjects **/
// Kalecgos Encounter
// Felmysts Encounter
// Murus Encounter
/*** Misc ***/
/*** Creatures ***/
/*** GameObjects ***/
/*** Misc ***/
// Do not load an encounter as "In Progress" - reset it instead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// respawn any dead minions
/*who*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
// Being woken up from the altar, start the awaken sequence
/*victim*/) OVERRIDE
// we're still doing awaken animation
// dont do anything until we are done
// dont want to continue until we finish the AttackStart method
//Return since we have no target
// wake a wall minion
//If we are <66 summon the guardians
// EarthenGuardian1
// EarthenGuardian2
// EarthenGuardian3
// EarthenGuardian4
// EarthenGuardian5
// EarthenGuardian6
//If we are <33 summon the vault walkers
// VaultWalker1
// VaultWalker2
// VaultWalker3
// VaultWalker4
//Cast
//45 seconds until we should cast this agian
/*killer*/)
// open the vault door
// deactivate his minions
/* ScriptData
/*who*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
// time to wake up, start animation
// we're still in the awaken animation
// dont do anything until we are done
// AttackStart(Unit::GetUnit(*me, instance->GetData64(0))); // whoWokeArchaedasGUID
// dont want to continue until we finish the AttackStart method
//Return since we have no target
/* ScriptData
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
//Return since we have no target
/*attacker*/) OVERRIDE
// activate next stonekeeper
/* ScriptData
/*go*/) OVERRIDE
// activate archaedas
//This is the actual function called only once durring InitScripts()
//It must define all handled functions that are to be run in this script
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//Return since we have no target
//If we are <50% hp do knockaway ONCE
// current aggro target is knocked away pick new target
//Shouldn't cast this agian
//uiArcingTimer
//This is the actual function called only once durring InitScripts()
//It must define all handled functions that are to be run in this script
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//animation time
// minions lined up around the wall
// lock the door
//creature->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_ANIMATION_FROZEN);
// only want the first one we find
// if we get this far than all four are dead so open the door
//open next the door too
// only want the first one we find
// used when Archaedas dies.  All active minions must be despawned.
// first despawn any aggroed wall minions
// Vault Walkers
// Earthen Guardians
// first respawn any aggroed wall minions
// Vault Walkers
// Earthen Guardians
//save state
//archeadas defeat
//re open enter door
//if players opened the doors
// Archaedas
//close when event is started
// Stone Keeper
// Earthen Custodian
// Earthen Hallshaper
// Earthen Guardian
// Ironaya
// Vault Walker
// Archaedas
// end GetData64
/*gameObject*/, uint32 eventId) OVERRIDE
// activate the Stone Keepers
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*who*/) OVERRIDE
//Return since we have no target
//uiCslumberTimer
//Cast
//Stop attacking target thast asleep and pick new target
/*######
/*player*/, GameObject* go) OVERRIDE
//door animation and save state.
/*######
/*trigger*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*spell*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*obj*/, uint32 eventId) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Jin'do the Godbreaker
// ID - 97172 Shadows of Hakkar
//SAY_PLAYER_KILL             = 4, // missing data
// Spirit of Hakkar
// Jin'do the Godbreaker - Trigger
// Shadow of Hakkar
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// ID - 96457 Wave of Agony
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Bloodlord Mandokir
// Chained Spirit
// Ohgan
// Bloodlord Mandokir
// Bloodlord Mandokir
// Chained Spirit
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*type = 0 */) OVERRIDE
// Cooldown
/*who*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*diff*/) OVERRIDE
// correct?
/*type = 0 */) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE { }
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
// HACK: Need better way for pos calculation
/*effIndex*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// HACK: research better way
/*effIndex*/)
/*effIndex*/)
/*player*/, Unit* target)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// ID - 96842 Venomous Effusion
// ID - 97354 Blessing of the Snake God
// ID - 96560 Word of Hethiss
// ID - 96842 Bloodvenom
// ID - 96653 Venom Withdrawal
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// ID - 96319 Zanzil's Resurrection Elixir
// ID - 96319 Zanzil's Resurrection Elixir
// ID - 96338 Zanzil's Graveyard Gas
// ID - 96338 Zanzil's Graveyard Gas
// ID - 96316 Zanzil's Resurrection Elixir
// ID - 96316 Zanzil's Resurrection Elixir
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//{ GO_THE_CACHE_OF_MADNESS_DOOR,     DATA_xxxxxxx,   DOOR_TYPE_ROOM, BOUNDARY_NONE },
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// 6 - 9 used in Nesingwary script
/*######
/*######
/*######
/*######
/*######
/*######
/*######
// Existing SmartAI
/*######
/*######
/*######
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// **** This script is designed as an example for others to build on ****
// **** Please modify whatever you'd like to as this script is only for developement ****
// **** Script Info* ***
// This script's primary purpose is to show just how much you can really do with commandscripts
/*args*/)
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// **** This script is designed as an example for others to build on ****
// **** Please modify whatever you'd like to as this script is only for developement ****
// **** Script Info* ***
// This script is written in a way that it can be used for both friendly and hostile monsters
// Its primary purpose is to show just how much you can really do with scripts
// I recommend trying it out on both an agressive NPC and on friendly npc
// **** Quick Info* ***
// Functions with Handled Function marked above them are functions that are called automatically by the core
// Functions that are marked Custom Function are functions I've created to simplify code
//List of text id's. The text is stored in database, also in a localized version
//(if translation not exist for the textId, default english text will be used)
//Not required to define in this way, but simplify if changes are needed.
//These texts must be added to the creature texts of the npc for which the script is assigned.
// "Let the games begin."
// "I see endless suffering. I see torment. I see rage. I see everything.",
// "Muahahahaha",
// "These mortal infedels my lord, they have invaded your sanctum and seek to steal your secrets.",
// "You are already dead.",
// "Where to go? What to do? So many choices that all end in pain, end in death."
// "$N, I sentance you to death!"
// "The suffering has just begun!"
// "I always thought I was a good dancer."
// "Move out Soldier!"
// "Help $N! I'm under attack!"
// List of spells.
// Not required to define them in this way, but will make it easier to maintain in case spellId change
// any other constants
//List of gossip item texts. Items will appear in the gossip window.
// *** HANDLED FUNCTION ***
//This is the constructor, called only once when the Creature is first created
// *** CUSTOM VARIABLES ****
//These variables are for use only by this individual script.
//Nothing else will ever call them but us.
// Timer for random chat
// Timer for rebuffing
// Timer for spell 1 when in combat
// Timer for spell 1 when in combat
// Timer for spell 1 when in combat
// Timer until we go into Beserk (enraged) mode
// The current battle phase we are in
// Timer until phase transition
// *** HANDLED FUNCTION ***
//This is called after spawn and whenever the core decides we need to evade
// Start in phase 1
// 60 seconds
//  5 seconds
// between 10 and 20 seconds
// 19 seconds
//  2 minutes
// *** HANDLED FUNCTION ***
// Enter Combat called once per combat
//Say some stuff
// *** HANDLED FUNCTION ***
// Attack Start is called when victim change (including at start of combat)
// By default, attack who and start movement toward the victim.
//void AttackStart(Unit* who) OVERRIDE
//{
//    ScriptedAI::AttackStart(who);
//}
// *** HANDLED FUNCTION ***
// Called when going out of combat. Reset is called just after.
// *** HANDLED FUNCTION ***
//Our Receive emote function
/*player*/, uint32 uiTextEmote) OVERRIDE
// *** HANDLED FUNCTION ***
//Update AI is called Every single map update (roughly once every 50ms if a player is within the grid)
//Out of combat timers
//Random Say timer
//Random switch between 5 outcomes
//Say something agian in 45 seconds
//Rebuff timer
//Rebuff agian in 15 minutes
//Return since we have no target
//Spell 1 timer
//Cast spell one on our current target.
//Spell 2 timer
//Cast spell two on our current target.
//Beserk timer
//Spell 3 timer
//Cast spell one on our current target.
//Say our line then cast uber death spell
//Cast our beserk spell agian in 12 seconds if we didn't kill everyone
//Phase timer
//Go to next phase
/*sender*/, uint32 action) OVERRIDE
//Set our faction to hostile towards all
//This is the actual function called only once durring InitScripts()
//It must define all handled functions that are to be run in this script
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// CreatureAI functions
// Pure Virtual Functions (Have to be implemented)
//pTmpPlayer is the target of the text
//pTmpPlayer is the source of the text
/*who*/) OVERRIDE
// not a likely case, code here for the sake of example
//Must update npc_escortAI
//Combat check
//Out of combat but being escorted
/*sender*/, uint32 action) OVERRIDE
// nothing defined      -> trinity core handling
// no default handling  -> prevent trinity core handling
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// These texts must be added to the creature texts of the npc for which the script is assigned.
// "Normal select, guess you're not interested."
// "Wrong!"
// "You're right, you are allowed to see my inner secrets."
/*sender*/, uint32 action) OVERRIDE
//Read comment in enum
//Read comment in enum
//Read comment in enum
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*trigger*/) OVERRIDE
/*player*/, Item* /*item*/, SpellCastTargets const& /*targets*/) OVERRIDE
/*go*/) OVERRIDE
/*
//www.trinitycore.org/>
//getmangos.com/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// initialize script, this macro does compile time check for type of the function - prevents possible issues
// if you have assigned wrong type of function to a hook you'll receive type conversion error during build
// this line is required, otherwise you'll get XXXHandlerFunction - identifier not found errors
// function called on server startup
// checks if script has data required for it to work
/*spellInfo*/) OVERRIDE
// check if spellid 70522 exists in dbc, we will trigger it later
// function called just after script is added to spell
// we initialize local variables if needed
// return false - script will be immediately removed from the spell
// for example - we don't want this script to be executed on a creature
// if (GetCaster()->GetTypeID() != TYPEID_PLAYER)
//     return false;
// function called just before script delete
// we free allocated memory
// this hook is executed before anything about casting the spell is done
// after this hook is executed all the machinery starts
// cast is validated and spell targets are selected at this moment
// this is a last place when the spell can be safely interrupted
// this is a safe for triggering additional effects for a spell without interfering
// with visuals or with other effects of the spell
//GetCaster()->CastSpell(target, SPELL_TRIGGERED, true);
// in this hook you can add additional requirements for spell caster (and throw a client error if reqs're not passed)
// in this case we're disallowing to select non-player as a target of the spell
//if (!GetExplTargetUnit() || GetExplTargetUnit()->ToPlayer())
//return SPELL_FAILED_BAD_TARGETS;
/*effIndex*/)
/*effIndex*/)
// we're handling SPELL_EFFECT_DUMMY in effIndex 0 here
/*effIndex*/)
/*effIndex*/)
// make caster cast a spell on a unit target of effect
/*targetList*/)
// usually you want this call for Area Target spells
// register functions used in spell script - names of these functions do not matter
// we're registering our functions here
// function HandleDummy will be called when spell is launched, independant from targets selected for spell, just before default effect 0 launch handler
// function HandleDummy will be called when spell is launched at target, just before default effect 0 launch at target handler
// function HandleDummy will be called when spell hits it's destination, independant from targets selected for spell, just before default effect 0 hit handler
// function HandleDummy will be called when unit is hit by spell, just before default effect 0 hit target handler
// this will prompt an error on startup because effect 0 of spell 49375 is set to SPELL_EFFECT_DUMMY, not SPELL_EFFECT_APPLY_AURA
//OnEffectHitTarget += SpellEffectFn(spell_gen_49375SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
// this will make HandleDummy function to be called on first != 0 effect of spell 49375
//OnEffectHitTarget += SpellEffectFn(spell_gen_49375SpellScript::HandleDummy, EFFECT_FIRST_FOUND, SPELL_EFFECT_ANY);
// this will make HandleDummy function to be called on all != 0 effect of spell 49375
//OnEffectHitTarget += SpellEffectFn(spell_gen_49375SpellScript::HandleDummy, EFFECT_ALL, SPELL_EFFECT_ANY);
// bind handler to BeforeHit event of the spell
// bind handler to OnHit event of the spell
// bind handler to AfterHit event of the spell
// bind handler to OnUnitTargetSelect event of the spell
//OnUnitTargetSelect += SpellUnitTargetFn(spell_ex_5581SpellScript::FilterTargets, EFFECT_0, TARGET_UNIT_CASTER);
// function which creates SpellScript
// function called on server startup
// checks if script has data required for it to work
/*spellInfo*/) OVERRIDE
// check if spellid exists in dbc, we will trigger it later
// function called in aura constructor
// we initialize local variables if needed
// do not load script if aura is casted by player or caster not avalible
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// this hook allows you to prevent execution of AuraEffect handler, or to replace it with your own handler
//PreventDefaultAction();
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// this hook allows you to prevent execution of AuraEffect handler, or to replace it with your own handler
//PreventDefaultAction();
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// cast spell on target on aura apply
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// caster may be not avalible (logged out for example)
// cast spell on caster on aura remove
/*aurEff*/)
// aura targets damage self on tick
// we're doubling aura amount every tick
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// we're setting amount to 100
// amount will be never recalculated due to applying passive aura
/*aurEff*/, bool& isPeriodic, int32& amplitude)
// we're setting aura to be periodic and tick every 10 seconds
/*aurEff*/, SpellModifier*& spellMod)
// we don't want spellmod for example
/*
// function registering
// AURA_EFFECT_HANDLE_REAL_OR_REAPPLY_MASK - makes handler to be called when aura is reapplied on target
/*OnApply += AuraEffectApplyFn();
/*
// function which creates AuraScript
// example usage of OnEffectManaShield and AfterEffectManaShield hooks
// see spell_ex_absorb_aura, these hooks work the same as OnEffectAbsorb and AfterEffectAbsorb
// example usage of OnEffectAbsorb and AfterEffectAbsorb hooks
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
// absorb whole damage done to us
/*aurEff*/, DamageInfo & /*dmgInfo*/, uint32 & absorbAmount)
// function registering
// function which creates AuraScript
// in our script we allow only players to be affected
// function which creates AuraScript
// this function has to be added to function set in ScriptLoader.cpp
/* empty script for copypasting
//bool Validate(SpellInfo const* spellEntry){return true;} OVERRIDE
//bool Load(){return true;}
//void Unload(){ }
//void Function(SpellEffIndex effIndex) //OnEffect += SpellEffectFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_EFFECT_ANY);
//void Function() //OnHit += SpellEffectFn(spell_ex_SpellScript::Function);
/* empty script for copypasting
//bool Validate(SpellInfo const* spellEntry){return true;} OVERRIDE
//bool Load(){return true;}
//void Unload(){ }
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff, AuraEffectHandleModes mode) //OnEffectApply += AuraEffectApplyFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY, AURA_EFFECT_HANDLE_REAL);
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff, AuraEffectHandleModes mode) //OnEffectRemove += AuraEffectRemoveFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY, AURA_EFFECT_HANDLE_REAL);
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff) //OnEffectPeriodic += AuraEffectPeriodicFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY);
//void spell_ex_SpellScript::Function(AuraEffect* aurEff) //OnEffectUpdatePeriodic += AuraEffectUpdatePeriodicFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY);
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff, int32& amount, bool& canBeRecalculated) //DoEffectCalcAmount += AuraEffectCalcAmountFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY);
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff, bool& isPeriodic, int32& amplitude) //OnEffectCalcPeriodic += AuraEffectCalcPeriodicFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY);
//void spell_ex_SpellScript::Function(AuraEffect const* aurEff, SpellModifier*& spellMod) //OnEffectCalcSpellMod += AuraEffectCalcSpellModFn(spell_ex_SpellScript::Function, EFFECT_ANY, SPELL_AURA_ANY);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Perhaps not right ID
/*who*/) OVERRIDE { }
//Return since we have no target
//        //MarkOfFrostTimer
//        if (MarkOfFrostTimer <= diff)
//        {
//            DoCastVictim(SPELL_MARKOFFROST);
//            MarkOfFrostTimer = 25000;
//        } else MarkOfFrostTimer -= diff;
//ChillTimer
//BreathTimer
//ManaStormTimer
//ReflectTimer
//CleaveTimer
//EnrageTimer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*####
/// @todo verify location and creatures amount.
/*who*/) OVERRIDE
/// @todo find companions, make them follow Torek, at any time (possibly done by core/database in future?)
/*####
/*who*/) OVERRIDE { }
// rider
// sorceress
// razortail
// witch
// priest
// myrmidon
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*who*/) OVERRIDE { }
//Random switch between 4 texts
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*######
/*######
/*who*/)OVERRIDE { }
// will complete Tree's company quest for all nearby players that are disguised as trees
/*########
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//possible creatures to be spawned
/*who*/) OVERRIDE { }
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*######
/*type*/, uint32 id)
//Rebuff agian in 5 minutes
// Special Brew
// Ghostly
// Hex
// Hex
// Hex
// Grow
// Launch (Whee!)
// 17009
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
// Quest
// General spells
// Risen Husk specific
// Risen Spirit specific
// Events
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//guessed, may be different
//helps hendel
//appears once hendel gives up
/// @todo develop this further, end event not created
/*player*/, Creature* creature, const Quest* quest) OVERRIDE
/*######
/*Id*/) OVERRIDE
/*Diff*/) OVERRIDE
/*######
/*killer*/) OVERRIDE
/*spellInfo*/) OVERRIDE
// This is actually correct
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*######
// We also emote cry here (handled in creature_text.emote)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*####
/*attacker*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action)
/*#####
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*###
/*sender*/, uint32 action) OVERRIDE
/*###
//gossip item text best guess
//trigger creatures to kill
/*sender*/, uint32 action) OVERRIDE
//'kill' our trigger to update quest status
//'kill' our trigger to update quest status
/*####
/*#####
/* ContentData
//65yds
//in ms. appear after event completed or failed (should be = Adds despawn time)
// Creature 0 - Anachronos, 1 - Fandral, 2 - Arygos, 3 - Merithra, 4 - Caelestrasz
//Morph
//EmoteLiftoff
// spell
//fly
//remove flags
//Morph
//EmoteLiftoff
// spell
//fly
//remove flags
//Morph
//EmoteLiftoff
// spell
//fly
//remove flags
//Both run through the armies
// Sands will stop
// Summon Gate
//spell 1-> Arcane cosmetic (Mobs freeze)
//Spell 2-> Arcane long cosmetic (barrier appears) (Barrier -> Glyphs)
//BarrieR
//Glyphs
// Roots
//Root Text
//falls knee
//Give Scepter
//->Equip hammer~Scepter, throw it at door
//Throw hammer at door.
//fandral goes away
//Cordinates for Spawns
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
// 2 waves of warriors
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Kaldorei Infantry
//Anubisath Conqueror
//Anubisath Conqueror
//Anubisath Conqueror
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Wasp
//Qiraj Tank
//Qiraj Tank
//Qiraj Tank
//Qiraj Tank
//Qiraj Tank
//Qiraj Tank
//Anubisath Conqueror
//Anubisath Conqueror
//Anubisath Conqueror
// Kaldorei Soldier
// Anubisath Conqueror
// Qiraji Wasps
// Qiraji Tanks
// Kaldorei Soldier
// Stop Time
// Poison Cloud
// Frost Debuff (need correct spell)
// Fire Explosion (need correct spell however this one looks cool)
/*#####
//both run to the gate
//Text: sands will stop
//Arcane Channeling
/*######
/*who*/) OVERRIDE { }
/*slayer*/) OVERRIDE;
//all but Kaldorei Soldiers
/*#####
//1-4 Wave
//only so event can restart
/*slayer*/)
/*#####
/* Unit* Fandral = */ trigger->SummonCreature(15382, -8028.462f, 1535.843f, 2.61f, 3.141592f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 220000);
/*###
// For random summoning
// 1 or 2 or 3
// 2 or 3
// 3
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*######
// below here is temporary workaround, to be removed when spell works properly
/*who*/) OVERRIDE { }
/*######
/*creature*/, Quest const* quest)
//Quest: To The Master's Lair
//(Flight through Caverns)
/*creature*/, uint32 /*sender*/, uint32 action)
//(Flight through Caverns)
/*######
/*who*/) OVERRIDE
/*####
//we are doing the post-event, or...
//something happened, so just complete
//...we are doing regular speech check
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*####
//The follow is over (and for later development, run off to the woods before really end)
//call not needed here, no known abilities
/*void UpdateFollowerAI(const uint32 Diff) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//guessed, possible not needed for this quest
//not always use
//only aggro text if not player and only in this area
//appears to be pretty much random (possible only if escorter not in combat with who yet?)
/*######
/*caster*/, const SpellInfo* spell) OVERRIDE
/*who*/) OVERRIDE { }
/*player*/, uint32 emote) OVERRIDE
/*#####
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE { }
// unsummon challengers
// unsummon bigWill
//creature->GetMotionMaster()->MovePoint(0, -1693, -4343, 4.32f);
//creature->GetMotionMaster()->MovePoint(1, -1684, -4333, 2.78f);
/*#####
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*#####
/// @todo verify abilities/timers
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
// Escort texts
// After lighting the altar cinematic
// channeled spell by Ranshalla while waiting for the torches / altar
// is respawned in script
// are respawned in script
// dummy member for the first priestess (right)
// dummy member for the second priestess (left)
// dummy member to check the priestess movement
// dummy member to indicate the event end
// trigger rest of event
// DialogueHelper (imported from SD)
///< To be said text entry
///< Entry of the mob who should say
///< Time delay until next text of array is said (0 stops)
// The array MUST be terminated by {0, 0, 0}
// The array MUST be terminated by {0, 0, 0, 0, 0}
/// Function to initialize the dialogue helper for instances. If not used with instances, GetSpeakerByEntry MUST be overwritten to obtain the speakers
/// Set if take first entries or second entries
// Find textEntry
/// Will be called when a dialogue step was done
/*entry*/) { }
/// Will be called to get a speaker, MUST be implemented if not used in instances
/*entry*/) { return NULL; }
// Last Dialogue Entry done?
// Get Text, SpeakerEntry and Timer
// Simulate Case
// Use Speaker if directly provided
// Increment position
// start the altar channeling
// start the escort here
// show the gem
// move priestess 1 near me
// summon voice and guard of elune
// move priestess 2 near me
// move the owlbeast
// move the first priestess up
// move second priestess up
// despawn the gem
// turn towards the player
// 0 right priestess summon loc
// 1 left priestess summon loc
// 2 guard of elune summon loc
// 3 right priestess move loc
// 4 left priestess move loc
// 5 guard of elune move loc
// 6 right priestess second move loc
// 7 left priestess second move loc
/*#####
// Called when the player activates the torch / altar
// Called when Ranshalla starts to channel on a torch / altar
// Check if we are using the fire or the altar and remove the no_interact flag
// Yell and set escort to pause
// Summon 2 Elune priestess and make each of them move to a different spot
// Left priestess should have a distinct move point because she is the one who starts the dialogue at point reach
// Start the dialogue when the priestess reach the altar (they should both reach the point in the same time)
// Cavern 1
// Cavern 2
// Cavern 3
// Cavern 4
// Cavern 5
// Search for all nearest lights and respawn them
// Summon the 2 priestess
// Stop the escort and turn towards the altar
// Start the altar channeling
// make the gem respawn
// move near the escort npc
// summon the Guardian of Elune
// summon the Voice of Elune
// move near the escort npc and continue dialogue
// make the voice of elune leave
// make the first priestess leave
// make the second priestess leave
// Turn towards the player
// Turn towards the altar and kneel - quest complete
/*#####
/*player*/, GameObject* go) OVERRIDE
// Check if we are using the torches or the altar
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*go*/) OVERRIDE
/*player*/, GameObject* go) OVERRIDE
/*killer*/) OVERRIDE
//we are not a normal spawn.
/*sender*/, uint32 /*action*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* Encounter 0 = Gelihast
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//Must update npc_escortAI
//Return since we have no target
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//summons two creatures
/*who*/) OVERRIDE { }
/*done_by*/, uint32 &damage) OVERRIDE
/* This script is merely a placeholder for the Doomfire that triggers Doomfire spell. It will
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*done_by*/, uint32 &damage) OVERRIDE
/* This is the script for the Doomfire Spirit Mob. This mob simply follow players or
//will update once TargetGUID is 0. In case noone actually moves(not likely) and this is 0
//when UpdateAI needs it, it will be forced to select randomPoint
/*who*/) OVERRIDE { }
/*done_by*/, uint32 &damage) OVERRIDE
/* Finally, Archimonde's script. His script isn't extremely complex, most are simply spells on timers.
// When ~30 wisps are summoned, Archimonde dies
// 10 minutes
// This checks if he's too close to the World Tree (75 yards from a point on the tree), if true then he will enrage
/*who*/) OVERRIDE
// First we check if our current victim is in melee range or not.
// Cast Finger of Death
// This target is closest, he is our new tank
//this is code doing close to what the summoning spell would do (spell 31903)
// Do not let the raid skip straight to Archimonde. Visible and hostile ONLY if Azagalor is finished.
// To simplify the check, we simply summon a Creature in the location and then check how far we are from the creature
//all members of raid must get this buff
// Don't do anything after this point.
//not on tank
//replace with spell cast 31903 once implicitTarget 73 implemented
//supposedly three doomfire can be up at the same time
/*waypointId*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Not used?
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//Must update npc_escortAI
//Return since we have no target
//never on tank
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*waypointId*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//Must update npc_escortAI
//Return since we have no target
/*spell*/) OVERRIDE
// Remove aura
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//Must update npc_escortAI
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*sender*/, uint32 action) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
//despawn the alliance veins
// Only let them start the Horde phases if Anetheron is dead.
/*sender*/, uint32 action) OVERRIDE
// Only let them get item if Azgalor is dead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Locations for summoning gargoyls and frost wyrms in special cases
//spawn point for the gargoyles near the horde gate
//spawn point for the frost wyrm near the horde gate
//spawn point for the gargoyles and wyrms near the horde tower
// Locations for summoning waves in Alliance base
// Locations for summoning waves in Horde base
// Lady Jaina's waypoints when retreathing
//next to the small stairs
//center of alliance base
//spawn points for the infernals in the horde base
//spawn points for the infernals in the horde base used in the cleaning wave
//spawn points of the ancient gem veins
//alliance
//alliance
//alliance
//alliance
//alliance
//alliance
//alliance
//horde
//horde
//horde
//horde
//horde
//horde
//horde
//gargoyle spawn points in the alliance overrun
//garg1
//garg2
//garg3
//garg4
//garg5
//spawn points for the fire visuals (GO) in the alliance base
//spawn points for the fire visuals (GO) in the horde base
// GUIDs
// Timers
// Misc
// Set faction properly based on Creature entry
//Bools
//Flags
//Initialize spells
//Reset Instance Data for trash count
//Reset World States
//Visibility
/*who*/)
//GARGOYLE
//summon at tower
//summon at gate
//FROST_WYRM,
//summon at gate
//GIANT_INFERNAL
// Increment Enemy Count to be used in World States and instance script
//no repu for solo farming
// Check if Creature is a boss.
// 1 in 4 chance we give a rally yell. Not sure if the chance is offilike.
//reset infernal count every new wave
// Subtract 9 from it to give the proper wave number if we are greater than 8
// Set world state to our current wave number
// Set world state to our current wave number
// Enable world state
// Enable world state
// Send data for instance script to update count
// Set world state for waves to 0 to disable it.
// Set World State for enemies invading to 1.
//move to center of alliance base
//move to center of alliance base
//cant talk after overrun event started
//prevent any buggers
//summon fires
//thrall
//summon fires
//jaina
//thrall
// Reset world state for enemies to disable it
/*killer*/)
//despawn all wave's summons
//reset encounter if boss is despawned (ex: thrall is killed, boss despawns, event stucks at inprogress)
//reset damage on die
// First get all creatures.
//make them friendly so mobs won't attack them
//do some talking
//all alive guards walk near here
// First get all creatures.
//make them friendly so mobs won't attack them
//execute once
//alliance
//summon fires
//summon 25 ghouls
//summon 3 abominations
//summon 5 gargoyles
//horde
//summon fires
//summon infernals
//summon 25 ghouls
//summon 5 abominations
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//infernal visual
//World Trigger (Tiny)
//invisible model
//basic waypoints from spawn to leader
//random rush starts from here
//basic waypoints from spawn to leader
//first WP in the base, after the gate
//waypoints for the frost wyrms in horde base
//waypoints for the gargoyles in horde base
//waypoints for the gargoyls and frost wyrms in horde base in wave 1/3
//waypoints in the alliance base used in the end in the cleaning wave
//0spawn
//1 start
//2 end
//3 start
//4
//5
//6 start
//7
//8
//9
//10 start
//11
//12
//13 start
//14
//15
//16 start
//17
//18
//19
//20
//21
//35//start 22
//34 23
//33 24
//32 25
//31 26
//30 27
//29 28
//28 29
//27 30
//26 31
//25 32
//24 33
//23 34
//22 start
//36 abo start
//37
//38
//39
//40
//41
//42
//43 end1
//44 end2
//45 garg1
//46 garg2
//47 garg3
//48 garg4
//49 garg5
//50 garg target1
//51 garg target2
//52 garg target3
//53 garg target4
//54 garg target5
//waypoints in the horde base used in the end in the cleaning wave
//0 start
//15 end
//16 start
//19 end 1
//20 end 2
//store raid's damage
/*diff*/)
//+OverrunType 0 - 4
/*killer*/)
//signal trash is dead
//no loot
//call once!
/*who*/) OVERRIDE { }
//2.alliance boss down, attack thrall
//do overrun
//HordeWPs[7] infront of thrall
//2.alliance boss down, attack thrall
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
//2.alliance boss down, attack thrall
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
//2.alliance boss down, attack thrall
/*victim*/) OVERRIDE
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
//2.alliance boss down, attack thrall
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
//2.alliance boss down, attack thrall
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
//2.alliance boss down, attack thrall
/*who*/) OVERRIDE { }
//2.alliance boss down, use horde WPs
//use alliance WPs
/*killer*/) OVERRIDE
//signal trash is dead
/*who*/) OVERRIDE { }
//fly path FlyPathWPs
//fly path FlyPathWPs
//alliance
/*killer*/) OVERRIDE
//float attackRadius = me->GetAttackDistance(who);
/*who*/) OVERRIDE
//Check if we have a target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* Battle of Mount Hyjal encounters:
//don't know how long it expected
// Do not load an encounter as IN_PROGRESS - reset it instead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//Time slows down, reducing attack, casting and movement speed by 70% for 6 sec.
//Stops time in a 50 yard sphere for 2 sec.
//Used only on the tank
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//A cresting wave of chaotic magic splashes over enemies in front of the caster, dealing 3230 to 3570 Shadow damage and 380 to 420 Shadow damage every 3 sec. for 15 sec.
//Inflicts 4163 to 4837 Shadow damage to an enemy.
//Puts an enemy to sleep for up to 10 sec. Any damage caused will awaken the target.
//Heals the caster for half the damage dealt by a melee attack.
// Quest credit
// Non-existing spell as encounter credit, created in spell_dbc
/*who*/) OVERRIDE
//Return since we have no target
//Handle Escape Event: Don't forget to add Player::RewardPlayerAndGroupAtEvent
/*killer*/) OVERRIDE
// give achievement credit and LFG rewards to players. criteria use spell 58630 which doesn't exist, but it was created in spell_dbc
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//Encases the targets in chains, dealing 1800 Physical damage every 1 sec. and stunning the target for 5 sec.
//Meathook belches out a cloud of disease, dealing 1710 to 1890 Nature damage and interrupting the spell casting of nearby enemy targets for 4 sec.
//Increases the caster's Physical damage by 10% for 30 sec.
//seen on video 13, 17, 15, 12, 16
//approx 3s
//made it up
/*who*/) OVERRIDE
//Return since we have no target
//anyone but the tank
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//30s DBM
//approx 6 sec after summon ghouls
// approx 10s
//on a video approx 24s after aggro
/*who*/) OVERRIDE
//Return since we have no target
//Curse of twisted flesh timer
//Shadow bolt timer
//Steal Flesh timer
//Summon ghouls timer
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Arthas
//First Act
//Second Act - City Streets
//Third Act - Town Hall
//Fourth Act - Fire Corridor
//Fifth Act - Mal'Ganis Fight
//Malganis
//Epoch
//Uther
//Jaina
//Cityman
//Crazyman
//Drakonian
// Locations for necromancers and add to spawn
// Locations for rifts to spawn and draconians to go
/*sender*/, uint32 action) OVERRIDE
//This one is a workaround since the very beggining of the script is wrong.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//After reset
//After waypoint 0
//After waypoint 1
//After waypoint 3
//After Gossip 1 (waypoint 8)
//After waypoint 9
//After waypoint 10
//After waypoint 11
//There's no one else to transform
//Summon wave group
//Wait group to die
//If group is dead
//Summon Boss
//Wait Boss death
//After Gossip 2 (waypoint 22)
//After waypoint 23
//Make them unattackable
//Make them unattackable
//Make them unattackable
//After waypoint 26, 29, 31
//Make cratures attackable
//Make Epoch attackable
//After Gossip 4
//After Gossip 5
//After waypoint 55
//After waypoint 56
//Rewards: Achiev & Chest ;D
//Look behind
//Battling skills
/*caster*/, SpellInfo const* spell) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Culling of Stratholme encounters:
// Summon Chromie and global whisper
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*######################
/*who*/) OVERRIDE
//This is not correct. Should taunt Thrall before engage in combat
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
//Holy_Light
//Cleanse
//Hammer of Justice
//Holy Shield
//Devotion_Aura
//Consecration
//DoCastVictim(SPELL_CONSECRATION);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*###################
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
//Sand Breath
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*######
/*player*/, GameObject* go) OVERRIDE
/*######
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/// @todo make this work
//Return since we have no target
//Whirlwind
//Fear
//Mortal Strike
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//Thrall texts
//Taretha texts
//Misc for Thrall
//if thrall dies during escort?
//Misc Creature entries
//I'm glad Taretha is alive. We now must find a way to free her...
//What do you mean by this? Is Taretha in danger?
//tarren mill is beyond these trees
//Thank you friends, I owe my freedom to you. Where is Taretha? I hoped to see her
//gossip items
/*sender*/, uint32 action) OVERRIDE
//not really needed, because it will not despawn if player is too far
//me->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO, THRALL_WEAPON_INFO);
//me->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO+1, 781);
//me->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO+2, THRALL_SHIELD_INFO);
//me->SetUInt32Value(UNIT_VIRTUAL_ITEM_INFO+3, 1038);
//temporary, skarloc should rather be triggered to walk up to thrall
//possibly regular patrollers? If so, remove this and let database handle them
//make horsie run off
//trigger epoch Yell("Thrall! Come outside and face your fate! ....")
//from here, thrall should not never be allowed to move to point 106 which he currently does.
//trigger taretha to run down outside
//kill credit Creature for quest
//alot will happen here, thrall and taretha talk, erozion appear at spot to explain
//last waypoint, just set Thrall invisible, respawn is turned off
/*who*/) OVERRIDE
/// @todo make Scarloc start into event instead, and not start attack directly
/*victim*/) OVERRIDE
// Don't do a yell if he kills self (if player goes too far or at the end).
/// @todo add his abilities'n-crap here
/*######
//Thank you for helping Thrall escape, friends. Now I only hope
//Yes, friends. This man was no wizard of
/*sender*/, uint32 action) OVERRIDE
/*who*/) OVERRIDE { }
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE
//Despawn Time Keeper
/*killer*/) OVERRIDE
// FIXME: later should be removed
/*victim*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//Not Implemented (Heroic mode)
/*who*/) OVERRIDE
//Despawn Time Keeper
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Only in Heroic
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//Not Implemented (Heroic mod)
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Despawn Time Keeper
//Return since we have no target
// Only in Heroic
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//protector of current portal
//time to next portal, or 0 if portal boss need to be killed
//what other conditions to check?
//this may be completed further out in the post-event
//normalize Z-level if we can, if rift is not at ground level.
//add delay timer?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/* ContentData
//where does this belong?
//aura(portal on ground effect)
//aura
//summon
//aura
//aura
/*who*/) OVERRIDE
//if (instance && instance->GetData(TYPE_MEDIVH) == IN_PROGRESS)
//return;
//ScriptedAI::AttackStart(who);
/*who*/) OVERRIDE { }
/*caster*/, const SpellInfo* spell) OVERRIDE
//if we reach this it means event was running but at some point reset.
/// @todo start the post-event here
//if (!UpdateVictim())
//return;
//DoMeleeAttackIfReady();
//spawns for portal waves (in order)
/*who*/) OVERRIDE { }
//normalize Z-level if we can, if rift is not at ground level.
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Egg Pile
// The Molten Eggs begin to crack and splinter!
// Harbinger of Flame
// Blazing Monstrosity
// Egg Pile
// Blazing Monstrosity
// Harbinger of Flame
// Egg Pile
/*time*/, uint32 /*diff*/)
/*target*/)
// cast time is longer, but thanks to UNIT_STATE_CASTING check it won't trigger more often (need this because this creature gets a stacking haste aura)
/*killer*/) OVERRIDE
/*target*/)
/*seat*/, bool apply) OVERRIDE
// Our passenger is another vehicle (boardable by players)
// Hack to relocate vehicle on vehicle so exiting players are not moved under map
/*summoner*/) OVERRIDE
/*pointId*/) OVERRIDE
/*target*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
// Cannot wait for object update to process facing spline, it's needed in next spell cast
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Cannot directly start attacking here as the creature is not yet on map
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Right, let's go! Just need to input the final entry sequence into the door mechanism... and...
// That did the trick! The control room should be right behind this... oh... wow...
// What? This isn't the control room! There's another entire defense mechanism in place, and the blasted Rock Troggs broke into here somehow. Troggs. Why did it have to be Troggs!
// Ok, let me think a moment.
// Mirrors pointing all over the place.
// Four platforms with huge elementals.
// I got it! I saw a tablet that mentioned this chamber. This is the Vault of Lights! Ok, simple enough. I need you adventurers to take out each of the four elementals to trigger the opening sequence for the far door!
// One down!
// Another one down! Just look at those light beams! They seem to be connecting to the far door!
// One more elemental to go! The door is almost open!
// That''s it, you''ve done it! The vault door is opening! Now we can... oh, no!
// We''ve done it! The control room is breached!
// Here we go! Now this should only take a moment...
// Set to combat automatically, Brann's event won't repeat
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*summoner*/) OVERRIDE
// Never evade
/*player*/, uint32 sender, uint32 action) OVERRIDE
/*effIndex*/)
// Do our own calculations for the destination position.
/// TODO: Remove this once we find a general rule for WorldObject::MovePosition (this spell shouldn't take the Z change into consideration)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Spell not in DBC, no SMSG_SPELL_START/GO for it
/*execTime*/, uint32 /*diff*/)
// delete event
// Send packet to all players in Tomb of the Earthrager
/*attacker*/, uint32& damage) OVERRIDE
// Holds the summoners of Jeweled Scarab
// Remove it to prevent a single trigger from spawning multiple npcs.
// Cast visual
// Summon after 5 seconds.
// Holds the summoners of Dustbone Horror
/*value*/) OVERRIDE
// All summons died
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Spell not in DBC, it is not cast either, according to sniffs
// Do not melee in the disperse phase
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Ready to be shielded for the first time
// First shield already happened, ready to be shielded a second time
// Already shielded twice, ready to finish the encounter normally.
/*attacker*/, uint32& damage) OVERRIDE
// Increase the phase
// Target only the bottom ones
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Get the closest statue face (any of its eyes)
// Remove the eye.
// Find the second eye.
/*effIndex*/)
/*index*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Needs to be set to IN_PROGRESS or else the gameobjects state won't be updated
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
//Wrath
//EntanglingRoots
//CorruptForces
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//KnockAwayTimer
//TrampleTimer
//Landslide
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Too much too low?
/*who*/) OVERRIDE { }
//Become visible again
//Noxxion model
//me->m_canMove = true;
//Do nothing while invisible
//Return since we have no target
//ToxicVolleyTimer
//UppercutTimer
//AddsTimer
//Interrupt any spell casting
//me->m_canMove = true;
// Invisible Model
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
//DustfieldTimer
//BoulderTimer
//RepulsiveGazeTimer
//ThrashTimer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Say
// Emote
// Phase 1 spells
// Phase 2 spells
//Not much choise about these. We have to make own defintion on the direction/start-end point
// 20x in "array"
// 11x in "array"
// 7x in "array"
// 7x in "array"
// 12x in "array"
// 12x in "array"
// 12x in "array"
// 12x in "array"
//SPELL_BREATH                = 21131,                  // 8x in "array", different initial cast than the other arrays
// Phase 3 spells
//west
//east
//north-west
//north-east
//south-east
//south-west
//south
//north
//Whelps
//Lair Guard
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*pCaster*/, const SpellInfo* Spell) OVERRIDE
//Workaround - Couldn't find a way to group this spells (All Eruption)
//Common to PHASE_START && PHASE_END
//Specific to PHASE_START || PHASE_END
// Phase PHASE_END
// Eruption
// Phase PHASE_START and PHASE_END
// Phase PHASE_START and PHASE_END
// Phase PHASE_START and PHASE_END
// Phase PHASE_START and PHASE_END
// Phase PHASE_BREATH
/// @todo: In what cases is this null? What should we do?
// Phase PHASE_BREATH
// Phase PHASE_BREATH
// Phase PHASE_BREATH
// Phase PHASE_BREATH
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Eruption is a BFS graph problem
//One map to remember all floor, one map to keep floor that still need to erupt and one queue to know what needs to be removed
//THIS GOB IS A TRAP - What shall i do? =(
//Cast it spell? Copyed Heigan method
//pFloorEruption->GetGOInfo()->trap.spellId
//Get all immediatly nearby floors
//remove all that are not present on FloorEruptionGUID[1] and update treeLen on each GUID
//Used to mark the liftoff phase
/*source*/, Unit const* /*target = NULL*/, uint32 /*miscValue1 = 0*/) OVERRIDE
// Criteria for achievement 4403: Many Whelps! Handle It! (10 player) Hatch 50 eggs in 10s
// Criteria for achievement 4406: Many Whelps! Handle It! (25 player) Hatch 50 eggs in 10s
// Criteria for achievement 4404: She Deep Breaths More (10 player) Everybody evade Deep Breath
// Criteria for achievement 4407: She Deep Breaths More (25 player) Everybody evade Deep Breath
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//AmnenarsWrath_Timer
//FrostBolt_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*###
/*sender*/, uint32 action) OVERRIDE
/*######
/*player*/, GameObject* go) OVERRIDE
//basic support, not blizzlike data is missing...
//from acid
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// big fat fugly hack
/*diff*/)
/*data*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//: public std::binary_function<GameObject, GameObject, bool>
// XFurry was wrong...
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/// @todo These below are probably incorrect, taken from SD2
// Omnomnom
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Enrage
/*killer*/) OVERRIDE
// Unknown purpose
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Should perhaps be triggered by an aura? Couldn't find any though
// Yelled by Ossirian the Unscarred
/*attacker*/, uint32& /*damage*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// TARGET_DEST_CASTER_FRONT
// TARGET_DEST_CASTER_LEFT
// TARGET_DEST_CASTER_RIGHT
//events.ScheduleEvent(EVENT_WIDE_SLASH, 11000);
/*attacker*/, uint32& /*damage*/) OVERRIDE
// Messing up mana-drain channel
//if (me->HasUnitState(UNIT_STATE_CASTING))
//    return;
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// You spin me right round, baby
// right round like a record, baby
// right round round round
/// @todo This number is completly random!
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// No kiting!
/*go*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// The time of our retribution is at hand! Let darkness reign in the hearts of our enemies! Sound: 8645 Emote: 35
// Before for the first wave
// Beginning the event
// Yell when realm complete quest 8743 for world event
// Warriors, Captains, continue the fight! Sound: 8640
// 03:58:27, 03:58:49
// 03:58:29, 03:58:50
/*killer*/) OVERRIDE
//SAY_DEATH
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Only Spell with right dmg.
//Changed cause 25790 is casted on gamers too. Same prob with old explosion of twin emperors.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Unlootable if death
//Return since we have no target
//Cleave_Timer
//ToxicVolley_Timer
//Checking if Vem is dead. If yes we will enrage.
/*killer*/) OVERRIDE
// Unlootable if death
/*who*/) OVERRIDE
//Return since we have no target
//Charge_Timer
//me->SendMonsterMove(target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, true, 1);
//KnockBack_Timer
//Enrage_Timer
/*killer*/) OVERRIDE
// Unlootable if death
/*who*/) OVERRIDE
//Return since we have no target
//Fear_Timer
//Casting Heal to other twins or herself.
//Checking if Vem is dead. If yes we will enrage.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
// Main Phase 1 - EYE
// Main Phase 2 - CTHUN
// ***** Main Phase 1 ********
//Eye Spells
//Probably not the right spell but looks similar
//Eye Tentacles Spells
//Claw Tentacles Spells
// ***** Main Phase 2 ******
//Body spells
//SPELL_CARAPACE_CTHUN                        = 26156   //Was removed from client dbcs
//Probably not the right spell but looks similar
//Eye Tentacles Spells
//SAME AS PHASE1
//Giant Claw Tentacles
//Also casts Hamstring
//Giant Eye Tentacles
//CHAIN CASTS "SPELL_GREEN_BEAM"
//Stomach Spells
//Text emote
// ****** Out of Combat ******
// Random Wispers - No txt only sound
// The random sound is chosen by the client.
//Stomach Teleport positions
//Flesh tentacle positions
//Kick out position
//Global variables
//Eye beam phase
//Dark Glare phase
//Phase information
//First dark glare in 50 seconds
//Eye beam phase 50 seconds
//Always spawns 5 seconds before Dark Beam
//4 per Eye beam phase (unsure if they spawn during Dark beam)
//Dark Beam phase 35 seconds (each tick = 1 second, 35 ticks)
//Reset flags
//Reset Phase
//to avoid having a following void zone
/*who*/) OVERRIDE
//Check if we have a target
//No instance
// EyeTentacleTimer
//Spawn the 8 Eye Tentacles in the corret spots
//south
//south west
//west
//north west
//north
//north east
// east
// south east
//BeamTimer
//SPELL_GREEN_BEAM
//Correctly update our target
//Beam every 3 seconds
//ClawTentacleTimer
//Spawn claw tentacle on the random target
//One claw tentacle every 12.5 seconds
//PhaseTimer
//Switch to Dark Beam
//Remove any target
//Select random target for dark beam to start on
//Face our target
//Add red coloration to C'thun
//Freeze animation
//Darkbeam for 35 seconds
//Set angle and cast
//Actual dark glare cast, maybe something missing here?
//Increase tick
//1 second per tick
//PhaseTimer
//Switch to Eye Beam
//4 per Eye beam phase (unsure if they spawn during Dark beam)
//Remove Red coloration from c'thun
//set it back to aggressive
//Eye Beam for 50 seconds
//Transition phase
//Remove any target
//Dead phase
/*done_by*/, uint32 &damage) OVERRIDE
//No instance
//Only if it will kill
//Fake death in phase 0 or 1 (green beam or dark glare phase)
//Remove Red coloration from c'thun
//Reset to normal emote state and prevent select and attack
//Remove Target field
//Death animation/respawning;
//Allow death here
//Prevent death in these phases
//Out of combat whisper timer
//Global variables
//-------------------
//Phase transition
//Body Phase
//Stomach map, bool = true then in stomach
//One random wisper every 90 - 300 seconds
//Phase information
//Emerge in 10 seconds
//No hold player for transition
//Body Phase
//15 seconds into body phase (1 min repeat)
//15 seconds into body phase (1 min repeat)
//Every 4 seconds
//Every 10 seconds
//Always 3.5 seconds after Stomach Enter Timer
//Target to be teleported to stomach
//Clear players in stomach and outside
//Reset flags
/*who*/) OVERRIDE
//Get all players in map
//Check for valid player
//Only units out of stomach
//Get random but only if we have more than one unit on threat list
//Check if we have a target
//No target so we'll use this section to do our random wispers instance wide
//WisperTimer
//Play random sound to the zone
//One random wisper every 90 - 300 seconds
//No instance
// EyeTentacleTimer
//Spawn the 8 Eye Tentacles in the corret spots
//south
//south west
//west
//north west
//north
//north east
// east
// south east
// every 30sec in phase 2
//Transition phase
//PhaseTimer
//Switch
//Switch to c'thun model
//Emerging phase
//AttackStart(Unit::GetUnit(*me, HoldpPlayer));
//Place all units in threat list on outside of stomach
//Outside stomach
//Spawn 2 flesh tentacles
//Spawn flesh tentacle
//Body Phase
//Remove Target field
//Weaken
//Kick all players out of stomach
//Check for valid player
//Only move units in stomach
//Teleport each player out
//Cast knockback on them
//Remove the acid debuff
//Stomach acid
//Apply aura to all players in stomach
//Check for valid player
//Only apply to units in stomach
//Cast digestive acid on them
//Check if player should be kicked from stomach
//Teleport each player out
//Cast knockback on them
//Remove the acid debuff
//Stomach Enter Timer
//Set target in stomach
//Check for valid player
//GientClawTentacleTimer
//Spawn claw tentacle on the random target
//One giant claw tentacle every minute
//GiantEyeTentacleTimer
//Spawn claw tentacle on the random target
//One giant eye tentacle every minute
//Weakened state
//PhaseTimer
//Switch
//Remove purple coloration
//Spawn 2 flesh tentacles
//Spawn flesh tentacle
/*killer*/) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE
//No instance
//Not weakened so reduce damage by 99%
//Prevent death in non-weakened state
//Weakened - takes normal damage
/*killer*/) OVERRIDE
//Mind flay half a second after we spawn
//This prevents eyes from overlapping
/*who*/) OVERRIDE
//Check if we have a target
//KillSelfTimer
//MindflayTimer
//Mindflay every 10 seconds
/*killer*/) OVERRIDE
//First rupture should happen half a second after we spawn
/*who*/) OVERRIDE
//Check if we have a target
//EvadeTimer
//Dissapear and reappear at new position
//GroundRuptureTimer
//HamstringTimer
/*killer*/) OVERRIDE
//First rupture should happen half a second after we spawn
/*who*/) OVERRIDE
//Check if we have a target
//EvadeTimer
//Dissapear and reappear at new position
//GroundRuptureTimer
//ThrashTimer
//HamstringTimer
/*killer*/) OVERRIDE
//Green Beam half a second after we spawn
/*who*/) OVERRIDE
//Check if we have a target
//BeamTimer
//Beam every 2 seconds
/*killer*/) OVERRIDE
//GetAIs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Enrage for his spawns
/*who*/) OVERRIDE
//Return since we have no target
//MortalWound_Timer
//Summon 1-3 Spawns of Fankriss at random time.
// Teleporting Random Target to one of the three tunnels and spawn 4 hatchlings near the gamer.
//We will only telport if fankriss has more than 3% of hp so teleported gamers can always loot.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//Return since we have no target
//Frenzy_Timer
// Wyvern Timer
//Spit Timer
//NoxiousPoison_Timer
//PoisonBolt only if frenzy or berserk
//FrenzyBack_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// The Birth Animation
/*who*/) OVERRIDE
//Return since we have no target
//Sweep_Timer
//SandBlast_Timer
//Submerge_Timer
//Cast
//ChangeTarget_Timer
//Back_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Not sure if right ID.
//Guard Spell
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
//Return since we have no target
//Attack random Gamers
//Attack random Gamers
//If she is 20% enrage
//After 10 minutes hard enrage
/*who*/) OVERRIDE
//Return since we have no target
//Attack random Gamers
//Attack random Gamers
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*victim*/) OVERRIDE
// Shift the boss and images (Get it? *Shift*?)
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/// @todo For some weird reason boss does not cast this
// Spell actually works, tested in duel
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// CTRA watches for this spell to start its teleport timer
// visual
//8657 - Aggro - To Late
//8658 - Kill - You will not
//8659 - Death
//8660 - Death - Feel
//8661 - Aggro - Let none
//8661 - Kill - your fate
// VL will not come to melee when attacking
// first heal immediately when they get close together
/*done_by*/, uint32 &damage) OVERRIDE
/*killer*/) OVERRIDE
// I hope AI is not threaded
/*victim*/) OVERRIDE
/// @todo we should activate the other boss location so he can start attackning even if nobody
// is near I dont know how to do that
// add health so we keep same percentage for both brothers
// this spell heals caster and the other brother so let VN cast it
// mechanics handled by veknilash so they teleport exactly at the same time and to correct coordinates
//me->MonsterYell("Teleporting ...", LANG_UNIVERSAL, 0);
//DoYell(nearu->GetName(), LANG_UNIVERSAL, 0);
// update important timers which would otherwise get skipped
/*CREATURE_Z_ATTACK_RANGE*/7 /*there are stairs*/)
//if (who->HasStealthAura())
//    who->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
//Added. Can be removed if its included in DB.
//Return since we have no target
//UnbalancingStrike_Timer
//Heal brother when 60yrds close
//Teleporting to brother
//Added. Can be removed if its included in DB.
//Return since we have no target
// reset arcane burst after teleport - we need to do this because
// when VL jumps to VN's location there will be a warrior who will get only 2s to run away
// which is almost impossible
//ShadowBolt_Timer
//Blizzard_Timer
//Heal brother when 60yrds close
//Teleporting to brother
//VL doesn't melee
//DoMeleeAttackIfReady();
// VL doesn't melee
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Removed from client, in world.spell_dbc
// damage reduction spell - removed from DBC
// aura which procs at damage - should trigger the slow spells - removed from DBC
// removed from DBC
// summons npc 15667 using spells from 25865 to 25884; All spells have target coords - removed from DBC
// removed from DBC
/// @todo Visci isn't in room middle
/// @todo Not sure if its correct
/*damage*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*type*/, uint32 id) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//If Vem is dead...
//Storing Skeram, Vem and Kri.
//not active in AQ40
// end GetData64
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// just initialization of variable
/*nears*/)
// should never happen
/*if (bli < 3)
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//Naralex sleeps again!
//The fanglords are dead!
/*sender*/, uint32 action) OVERRIDE
/*slayer*/) OVERRIDE
//CAST_AI(npc_escort::npc_escortAI, me->AI())->SetCanDefend(false);
//CAST_AI(npc_escort::npc_escortAI, me->AI())->SetCanDefend(true);
//CAST_AI(npc_escort::npc_escortAI, me->AI())->SetCanDefend(false);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// areatrigger sets faction to enemy
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Creatures
// Paths
/* list of wave spawns: 0 = wave ID, 1 = creature id, 2 = x, 3 = y
// starts out passive (in a cage)
// starts out passive (in a cage)
// starts out passive (in a cage)
// starts out passive (in a cage)
// starts out passive (in a cage)
//give players a few seconds before wave 2 starts to rebuff
// beginning 2nd wave!
//give NPCs time to return to their home spots
// move NPCs to bottom of stair
// move NPCS to their final positions
//pop a add from list, send him up the stairs...
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//while in cages (so the trolls won't attack them while they're caged)
//after release (so they'll be hostile towards trolls)
/*sender*/, uint32 action) OVERRIDE
//this is wrong, spell should never be used unless me->GetVictim() dodge, parry or block attack. Skyfire support required.
//weegli doesn't fight - he goes & blows up the door
/*param*/) OVERRIDE
/*######
/*player*/, GameObject* go) OVERRIDE
//set bly & co to aggressive & start moving to top of stairs
/*######
/*sender*/, uint32 action) OVERRIDE
//here we make him run to door, set the charge and run away off to nowhere
//if event can proceed to end
//if event not started
//if event are in progress
/*if (instance)
//keep back & toss bombs/shoot
/*killer*/) OVERRIDE
/*if (instance)
/*type*/, uint32 /*id*/) OVERRIDE
/// @todo leave the area...
/*param*/) OVERRIDE
// in case he gets interrupted
/*######
/*player*/, GameObject* go) OVERRIDE
// randomly summon a zombie or dead hero the first time a grave is used
/*######
/*at*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*####
/*type*/, uint32 id) OVERRIDE
// Rebuff again in 2 minutes
//DoMeleeAttackIfReady();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// TO-DO: This should be done with SmartAI, but yet it does not correctly support vehicles's AIs.
//        Even adding ReactState Passive we still have issues using SmartAI.
/*seatId*/, bool apply) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*who*/) OVERRIDE { }
// @fixme: phase 4 is missing...
/*######
/*######
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
//It's the same dragon for both quests.
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
/*pDone_by*/, uint32& /*uiDamage*/) OVERRIDE
/*diff*/) OVERRIDE
/*######
// Maybe is not working.
/*######
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
//Talk(SAY_NESINGWARY_1);
/*######
/*######
//The spell who makes the npc follow the player is missing, also we can use FollowerAI!
/*diff*/) OVERRIDE
/*######
//The client doesen't update with the new orientation :l
/*killer*/) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
/*######
/*uiId*/) OVERRIDE
/*######
/*uiId*/) OVERRIDE
/*######
/*uiId*/) OVERRIDE
/*######
/*uiId*/) OVERRIDE
/*######
//We make sure that the npc is not attacking the player!
/*uiDiff*/) OVERRIDE
/*######
/*who*/) OVERRIDE
/*######
/*killer*/) OVERRIDE
/*######
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*######
/*uiId*/) OVERRIDE
/*######
/*######
// Quest
// Spells
//25402-25405 credit markers
/*######
/*******************************************************
//Timer until recast
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
//not working
//player aura
/*iParam*/) OVERRIDE
/*iId*/) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*******************************************************
/*uiDiff*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*******************************************************
// All outdoor guards are within 35.0f of these NPCs
/*who*/)OVERRIDE { }
/*who*/)OVERRIDE { }
// If player has Disguise aura for quest A Meeting With The Magister or An Audience With The Arcanist, do not teleport it away but let it pass
// Horde unit found in Alliance area
// In my line of sight, "outdoors", and behind me
// Teleport the Horde unit out
// In my line of sight, and "indoors"
// Teleport the Horde unit out
// Alliance unit found in Horde area
// In my line of sight, "outdoors", and behind me
// Teleport the Alliance unit out
// In my line of sight, and "indoors"
// Teleport the Alliance unit out
/*diff*/)OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Quest
// Movie
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
// Strengthen the Ancients: On Interact Dummy to Woodlands Walker
/*effIndex*/)
// friendly version
// enemy version
// Bark of the Walkers
/*effIndex*/)
/*######
// Quest data
// Gossip data
// Spells data
// ID - 52421 Wyrmrest Defender: On Low Health Boss Emote to Controller - Random /self/
// casted to heal drakes
// Texts data
/*sender*/, uint32 action) OVERRIDE
// Makes player cast trigger spell for 49207 on self
// The gossip should not auto close
// Check system for Health Warning should happen first time whenever get under 30%,
// after it should be able to happen only after recovery of last renew is fully done (20 sec),
// next one used won't interfere
/*caster*/, SpellInfo const* spell) OVERRIDE
// Both below are for checking low hp warning
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*######
// Creature
// RWORG
// Quest
// Spell
// vehicle aura
// Text
// Um... I think one of those wolves is back...
// He's going for Mr. Floppy!
// Oh, no! Look, it's another wolf, and it's a biiiiiig one!
// He's gonna eat Mr. Floppy! You gotta help Mr. Floppy! You just gotta!
// There's a big meanie attacking Mr. Floppy! Help!
// Let's get out of here before more wolves find us!
// Don't go toward the light, Mr. Floppy!
// Mr. Floppy, you're ok! Thank you so much for saving Mr. Floppy!
// I think I see the camp! We're almost home, Mr. Floppy! Let's go!
// Mr. Floppy revives
// The Ravenous Worg chomps down on Mr. Floppy
// Are you ready, Mr. Floppy? Stay close to me and watch out for those wolves!
// Thank you for helping me get back to the camp. Go tell Walter that I'm safe now!
// emily
/*Who*/) OVERRIDE
// mrfloppy
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE
/*######
// Sound
// Spell
// Tallhorn Stage
//Gameobject
/*diff*/) OVERRIDE
// Amberpine Woodsman
// Creature
/*######
// Quest
// Spell
// Text
/*diff*/) OVERRIDE
/*Venture co. Straggler - when you cast Smoke Bomb, he will yell and run away*/
// Quest
// Spell
// Text
/*######
// Creature
// Items
// Spells
// for 1 minute !
// Text
// Removes SPELL_WARTSBGONE_LIP_BALM
/*sender*/, uint32 /*action*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//10 sec cooldown on potion
/*killer*/) OVERRIDE
/*######
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// looks the same but has different abilities
/// @todo make prisoners help (unclear if summoned or using npc's from surrounding cages (summon inside small cages?))
/*killer*/) OVERRIDE
// will eventually reset the event if something goes wrong
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//We need more info about it.
/*sender*/, uint32 action) OVERRIDE
/*######
//wrong faction in db?
/*uiId*/) OVERRIDE
/*######
/*######
/*######
// Cast Defend spells to max stack size
/*attacker*/, uint32& damage) OVERRIDE
/*who*/)OVERRIDE { }
// Battle for Crusaders' Pinnacle
// "The Blessed Banner of the Crusade has been planted.\n Defend the banner from all attackers!"
// "BY THE LIGHT! Those damned monsters! Look at what they've done to our people!"
// "Burn it down, boys. Burn it all down."
// "Let 'em come. They'll pay for what they've done!"
// "We've done it, lads! We've taken the pinnacle from the Scourge! Report to Father Gustav at once and tell him the good news! We're gonna get to buildin' and settin' up! Go!"
// "Leave no survivors!"
// "Cower before my terrible creations!"
// "Feast my children! Feast upon the flesh of the living!"
// "Lay down your arms and surrender your souls!"
// Dalfors spawn point
// Dalfors intro pos
// Dalfors fight pos
// priest1 spawn point
// priest1 intro pos
// priest2 spawn point
// priest2 intro pos
// priest3 spawn point
// priest3 intro pos
// mason1 spawn point
// mason1 intro pos
// mason1 action pos
// mason2 spawn point
// mason2 intro pos
// mason2 action pos
// mason3 spawn point
// mason3 intro pos
// mason3 action pos
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
// triggers SAI actions on npc
// triggers SAI actions on npc
// triggers SAI actions on npc
/*######
// Spells
// Points
// Events
/*caster*/, SpellInfo const* spell) OVERRIDE
/*######
// this will prevent the event to start without morbidus being alive
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
// if we will have other way to assign this to only one npc remove this part
// me->RestoreFaction();
/*killer*/) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
/*player*/, Creature* creature, Quest const* /*_Quest*/) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*uiDiff*/) OVERRIDE
/*######
// Spells
// Yells
// Quests
//approx 3 to 4 seconds
//approx 3 to 4 seconds
/*killer*/) OVERRIDE
/*#####
// unused
// unused
// end
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// Freya's Presence
// Cultist Saboteur
// Servant of Freya
// will target plants
// Freya Dummy could be scripted with the following code
// Revive plants
// Couldn't find a spell that does this
// Kill nearby enemies
// Lifeforce has a cast duration, it should be cast at all saboteurs one by one
/*######
/*effIndex*/)
// fall to EVENT_MISS
/// @todo Make crunchy perform emote eat when he reaches the bird
/*######
/*This quest precisly needs core script since battle vehicles are not well integrated with SAI,
// Spells
// NPCs
/*######
// Vic's Flying Machine
// Engine on Fire
// Land Flying Machine
// Land Flying Machine Credit
/*seatId*/, bool apply) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
// player should be on seat 1
/*diff*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/////////////////////
///npc_injured_goblin
/////////////////////
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*player*/, Creature* creature, Quest const* quest) OVERRIDE
/*######
//Quest Menu
//Trainer Menu
//Vendor Menu
/*sender*/, uint32 action) OVERRIDE
/*######
/*diff*/) OVERRIDE
/*######
// drake reached village
// for each prisoner on drake, give credit
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*seatId*/, bool apply) OVERRIDE
/*waypointId*/) OVERRIDE
/*killer*/) OVERRIDE
/*apply*/) OVERRIDE
/*seat*/, bool apply) OVERRIDE
//! We need to manually reinstall accessories because the vehicle itself is friendly to players,
//! so EnterEvadeMode is never triggered. The accessory on the other hand is hostile and killable.
/*spell*/) OVERRIDE
/* aurEff */)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Demolisher engineers spells
// Spirit guide
/*sender*/, uint32 action) OVERRIDE
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*diff*/) OVERRIDE
/*creature*/, uint32 /*sender*/, uint32 /*action*/) OVERRIDE
// Tabulation madness in the hole!
/// @todo: move this to conditions or something else
// Player::PrepareQuestMenu(guid)
//else if (status == QUEST_STATUS_AVAILABLE)
//    qm.AddMenuItem(quest_id, 2);
// Horde attacker
// Horde defender
// Alliance attacker
// Alliance defender
/*spell*/) OVERRIDE
/*effIndex*/)
// Wintergrasp Tower Cannon
// check if we are in Wintergrasp at all, SotA uses same teleport spells
/*effindex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*####
// pointer check not needed
// pointer check not needed
/*####
// Little Hack for kneel - Thanks Illy :P
/*who*/)OVERRIDE { }
/*caster*/, const SpellInfo* spell) OVERRIDE
/*####
// air
// fire
// earth
// water
// water
// earth
// air
// fire
// fiend of water spell
// fiend of air spell
// fiend of earth spell
// fiend of fire spell
// stinkbeard || orinoko || korrak
//yggdras
// elementals
// caster location
// caster location
// caster location
// caster location
// caster location
// caster location
// caster location
/*id*/) OVERRIDE
/*####
/*pointId*/) OVERRIDE
//DoCastVictim(SPELL_SUMMON_WHISKER); petai is not working correctly???
/*####
/*who*/) OVERRIDE
/*####
/*####
/*####
// ugly hack? we are not in a instance sorry. :(
/*####
// Sometimes it is 0, why?
// this spell (what spell) is not supported ... YET!
/*####
/*uiId*/) OVERRIDE
/*######
/*sender*/, uint32 /*action*/) OVERRIDE
// Store creature heading
/*######
// From quest template
/*######
// Creature
// Item
// Quest
// Spells
// Spell Fetch Easy
// Spell Have Easy
// Spell Fetch Medium
// Spell Have Medium
// Spell Fetch Hard
// Spell Have Hard
// Text
// Text Easy
// Text Medium
// Text Hard
/*sender*/, uint32 /*action*/) OVERRIDE
/*go*/) OVERRIDE
/*#####
/*spellInfo*/) OVERRIDE
/*aurEff*/)
/*#####
/*spellInfo*/) OVERRIDE
/* effIndex */)
/*#####
/*spellInfo*/) OVERRIDE
/* effIndex */)
/*#####
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Victim
// Random Victim 100Y
// Self
// Random Victim 100Y
// Killer 3Y
// Self - Duration 8 Sec
// Self
// Self
// To make the mushrooms visible
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32 &damage) OVERRIDE
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Enraged if too far away from home
// 2x 30178  -- 2x every 10secs
// 1x 30176  -- every 25%
// Spells Adds
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
// 33% chance of dialog
/*killer*/) OVERRIDE
//HACK: No, AI. Replace with proper db content?
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//Dummy
//casted on player during insanity
// returns the percentage of health after taking the given damage.
/*pAttacker*/, uint32 &damage) OVERRIDE
// Not good target or too many players
// First target - start channel visual and set self as unnattackable
// Channel visual
// Unattackable
// phase mask
// summon twisted party members for this target
// Summon clone
// clone
// set phase
// Visible for all players in insanity
// Used for Insanity handling
// Cleanup
/*who*/) OVERRIDE
// Check if all summons in this phase killed
// Not all are dead
// Roll Insanity
// if there is still some different mask cast spell for it
//Return since we have no target
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Self
// 40Y
// 40Y
// 30Y
// 30Y
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
// ------------------------------------------------------------------------------------------------------------
// Jedogas Aufseher - Entry: 30181
// ------------------------------------------------------------------------------------------------------------
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Trigger Spell + add aura
// 1x 30106
// 1x 31686
// 1x 31687
/*who*/) OVERRIDE
//DoCast(me, SPELL_FLAME_SPHERE_SUMMON_1);
//DoCast(me, H_SPELL_FLAME_SPHERE_SUMMON_1);
//DoCast(me, H_SPELL_FLAME_SPHERE_SUMMON_2);
/*doneBy*/, uint32& damage) OVERRIDE
/*killer*/) OVERRIDE
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*player*/, GameObject* go) OVERRIDE
// maybe these are hacks :(
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//this is not the correct visual effect
//SPELL_IMPALE_TARGET                           = 53458,
// not in db
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Victim
// Victim
// Victim
// Victim
// Self
// Self
//when Hadronox kills any enemy (that includes a party member) she will regain 10% of her HP if the target had Leech Poison on
// not sure if this aura check is correct, I think it is though
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
// Without he comes up through the air to players on the bridge after krikthir if players crossing this bridge!
// Draws all players (and attacking Mobs) to itself.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//maybe 53361
//AOE Effect 140, maybe 52439
//Summon 3x 28735
//maybe is another spell
//the spell is not working properly
/*who*/) OVERRIDE
//WowWiki say "Curse of Fatigue-Kirk'thir will cast Curse of Fatigue on 2-3 targets periodically."
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
//The spell is not working propperly
/*who*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Sartharion Yell
// whisper, shared by two dragons
//Sartharion Spells
// Increases the caster's attack speed by 150% and all damage it deals by 500% for 5 min.
// Inflicts 35% weapon damage to an enemy and its nearest allies, affecting up to 10 targets.
// Inflicts 8750 to 11250 Fire damage to enemies in a cone in front of the caster.
// Inflicts 10938 to 14062 Fire damage to enemies in a cone in front of the caster.
// A sweeping tail strike hits all enemies behind the caster, inflicting 3063 to 3937 damage and stunning them for 2 sec.
// A sweeping tail strike hits all enemies behind the caster, inflicting 4375 to 5625 damage and stunning them for 2 sec.
// Sartharion's presence bolsters the resolve of the Twilight Drakes, increasing their total health by 25%. This effect also increases Sartharion's health by 25%.
// (Real spell casted should be 57578) 57571 then trigger visual missile, then summon Lava Blaze on impact(spell 57572)
// currently used for hard enrage after 15 minutes
// possibly used when player get too far away from dummy creatures (2x Creature entry 30494)
// enter phase. Player get this when click GO
// Twilight Shift Aura
// leave phase
// leave phase (probably version to make all leave)
//Mini bosses common spells
// makes immune to shadow damage, applied when leave phase
//Miniboses (Vesperon, Shadron, Tenebron)
// Inflicts 8788 to 10212 Fire damage to enemies in a cone in front of the caster.
// Inflicts 6938 to 8062 Fire damage to enemies in a cone in front of the caster.
// Deals 9488 to 13512 Shadow damage to any enemy within the Shadow fissure after 5 sec.
// Deals 6188 to 8812 Shadow damage to any enemy within the Shadow fissure after 5 sec.
//Vesperon
//In portal is a disciple, when disciple killed remove Power_of_vesperon, portal open multiple times
// Acolyte of Vesperon
// Vesperon's presence decreases the maximum health of all enemies by 25%.
// (Shadow only) trigger 57935 then 57988
// (Fire and Shadow) trigger 58835 then 57988
//Shadron
//In portal is a disciple, when disciple killed remove Power_of_vesperon, portal open multiple times
// Acolyte of Shadron
// Shadron's presence increases Fire damage taken by all enemies by 100%.
// TARGET_SCRIPT shadron
// TARGET_SCRIPT sartharion
// Twilight Fissure
//Tenebron
//in the portal spawns 6 eggs, if not killed in time (approx. 20s)  they will hatch,  whelps can cast 60708
// Tenebron's presence increases Shadow damage taken by all enemies by 100%.
//Tenebron, dummy spell
// doesn't work, will spawn NPC_TWILIGHT_WHELP
// doesn't work, will spawn NPC_SHARTHARION_TWILIGHT_WHELP
//Whelps
// Reduces the armor of an enemy by 1500 for 15s
//flame tsunami
// the visual dummy
// SPELL_EFFECT_138 some leap effect, causing caster to move in direction
// periodic damage, npc has this aura
// for the flame waves
// adds spawning from flame strike
//using these custom points for dragons start and end
//each dragons special points. First where fly to before connect to connon, second where land point is.
//init
//end
//points around raid "isle", counter clockwise. should probably be adjusted to be more alike
/*######
// Drakes respawning system
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// me->ResetLootMode() is called from Reset()
// AddDrakeLootMode() should only ever be called from FetchDragons(), which is called from Aggro()
// Has two Drake loot modes
// Add 3rd Drake loot mode
// Has one Drake loot mode
// Add 2nd Drake loot mode
// Has no Drake loot modes
// Add 1st Drake loot mode
//if at least one of the dragons are alive and are being called
// Selects a random Fire Cyclone and makes it cast Lava Strike.
// FIXME: Frequency of the casts reduced to compensate 100% chance of spawning a Lava Blaze add
//Return since we have no target
//spell will target dragons, if they are still alive at 35%
//soft enrage
// m_bIsSoftEnraged is used while determining Lava Strike cooldown.
// hard enrage
// flame tsunami
// flame breath
// Tail Sweep
// Cleave
// Lavas Strike
// call tenebron
// call shadron
// call vesperon
//to control each dragons common abilities
//        debug_log("dummy_dragonAI: %s reached point %u", me->GetName(), uiPointId);
//if healers messed up the raid and we was already initialized
//this is end, if we reach this, don't do much
//get amount of common points
//increase
//if we have reached a point bigger or equal to count, it mean we must reset to point 0
//used when open portal and spawn mobs in phase
//"opens" the portal and does the "opening" whisper
//there are 4 portal spawn locations, each are expected to be spawned with negative spawntimesecs in database
//using a grid search here seem to be more efficient than caching all four guids
//in instance script and calculate range to each.
//By using SetRespawnTime() we will actually "spawn" the object with our defined time.
//Once time is up, portal will disappear again.
//Unclear what are expected to happen if one drake has a portal open already
//Refresh respawnTime so time again are set to 30secs?
/*killer*/) OVERRIDE
// not if solo mini-boss fight
// Twilight Revenge to main boss
//                debug_log("dummy_dragonAI: %s moving to point %u", me->GetName(), m_uiWaypointId);
/*######
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//if no target, update dummy and return
// shadow fissure
// Hatch Egg
// shadow breath
/*######
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//if no target, update dummy and return
// shadow fissure
// Portal Event
// shadow breath
/*######
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
//if no target, update dummy and return
// shadow fissure
// Portal Event
// shadow breath
/*######
//if not solo figth, buff main boss, else place debuff on mini-boss. both spells TARGET_SCRIPT
/*killer*/) OVERRIDE
//not solo fight, so main boss has deduff
//event not in progress, then solo fight and must remove debuff mini-boss
/*######
/*killer*/) OVERRIDE
// remove twilight torment on Vesperon
// Components of spell Twilight Torment
/*######
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
// Twilight Fissure
// Wrong, can't find proper visual
////twilight realm
//DoCastVictim(57620, true);
//DoCastVictim(57874, true);
/*######
//Return since we have no target
// twilight torment
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Obsidian Sanctum encounters:
//three dragons below set to active state once created.
//we must expect bigger raid to encounter main boss, and then three dragons must be active due to grid differences
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Your power wanes, ancient one.... Soon you will join your friends.
// Ah, the entertainment has arrived.
// Baltharus leaves no survivors! - This world has enough heroes.
// Twice the pain and half the fun.
// I... didn't see that coming....
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*who*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
// Setting DATA_BALTHARUS_SHARED_HEALTH to 0 when killed would bug the boss.
// This is here because DamageTaken wont trigger if the damage is deadly.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Alexstrasza has chosen capable allies.... A pity that I must END YOU!
// You thought you stood a chance? - It's for the best.
// Turn them to ash, minions!
// HALION! I...
// General Zarithrian
// Zarithrian Spawn Stalker
// Onyx Flamecaller
// General Zarithrian
// Onyx Flamecaller
// East
// West
/*who*/) OVERRIDE
// Override to not set adds in combat yet.
/*killer*/) OVERRIDE
/*target*/) const OVERRIDE
// Can't use room boundary here, the gameobject is spawned at the same position as the boss. This is just as good anyway.
/*who*/) OVERRIDE
// Prevent EvadeMode
/*summoner*/) OVERRIDE
// Let Zarithrian count as summoner. _instance cant be null since we got GetRubySanctumAI
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Shared
// Without pressure in both realms, %s begins to regenerate.
// Halion
// Meddlesome insects! You are too late. The Ruby Sanctum is lost!
// Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!
// The heavens burn!
// You will find only suffering within the realm of twilight! Enter if you dare!
// Relish this victory, mortals, for it will be your last! This world will burn with the master's return!
// Another "hero" falls.
// Not good enough.
// Your efforts force %s further out of the physical realm!
// Your companions' efforts force %s further into the physical realm!
// Twilight Halion
// Beware the shadow!
// I am the light and the darkness! Cower, mortals, before the herald of Deathwing!
// Your companions' efforts force %s further into the twilight realm!
// Your efforts force %s further out of the twilight realm!
// The orbiting spheres pulse with dark energy!
// Halion
// Combustion & Consumption
// Aura created in spell_dbc.
// Twilight Halion
// Living Inferno
// Halion Controller
// Meteor Strike
// Shadow Orb
// Unknown dummy effect (EFFECT_0)
// Misc
// Phase spell from phase 2 to phase 3
// Phase spell from phase 1 to phase 2
// Summons go 202794
// Custom spell created in spell_dbc.
// Aura not found in DBCs.
// Halion
// Twilight Halion
// Meteor Strike
// Halion Controller
// Meteor Strike
// Halion Controller
// Orb Carrier
/*who*/) OVERRIDE
/*who*/, SpellInfo const* spellInfo) OVERRIDE
// Phase 1: We always can evade. Phase 2 & 3: We can evade if and only if the controller tells us to.
/*killer*/) OVERRIDE
// Don't consider copied damage.
// Flame ring is activated 5 seconds after starting encounter, DOOR_TYPE_ROOM is only instant.
// Using AddAura because no spell cast packet in sniffs.
// We use explicit targeting here to avoid conditions + SPELL_ATTR6_CANT_TARGET_SELF.
// Never evade
// Victims should not be in the Twilight Realm
// Ensure looting
// Don't consider copied damage.
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// Summon Twilight portals
// Hardcoding doesn't really matter here.
// The IsInCombat() check is needed because that check should be false when Halion is
// not engaged, while it would return true without as UpdateVictim() checks for
// combat state.
// Just check if physical Halion is spawned
//// @todo Find out a better scaling, if any.
// [0   , 0.98[: Corporeality goes down
// [0.98, 0.99]: Do nothing
// ]0.99, 1.01[: Twilight Mending
// [1.01, 1.02]: Do nothing
// ]1.02, +oo [: Corporeality goes up
// [0   , 0.98[: Corporeality goes down
// ]0.99, 1.01[: Twilight Mending
// ]1.02, +oo [: Corporeality goes up
// if (itr == DATA_HALION)
/*diff*/) OVERRIDE
/// According to sniffs this spell is cast every 1 or 2 seconds.
/// However, refreshing it looks bad, so just cast the spell if
/// we are not channeling it.
/// Workaround: This is here because even though the above spell has SPELL_ATTR1_CHANNEL_TRACK_TARGET,
/// we are having two creatures involded here. This attribute is handled clientside, meaning the client
/// sends orientation update itself. Here, no packet is sent, and the creature does not rotate. By
/// forcing the carrier to always be facing the rotation focus, we ensure everything works as it should.
// setInFront
// Let Halion Controller count as summoner
// Unknown purpose
// Exact distance
/*diff*/) OVERRIDE { }
/*summoner*/) OVERRIDE
// Let Halion Controller count as summoner.
// Should never happen
// Let Halion Controller count as summoner
// Needs more researches.
/*diff*/) OVERRIDE { }
/*summoner*/) OVERRIDE
/*killer*/) OVERRIDE
//! Need sniff data
/*who*/) OVERRIDE
/*summoner*/) OVERRIDE
/*killer*/) OVERRIDE
// Not used, not seen in sniffs. Just in case.
/// Because WDB template has non-existent spell ID, not seen in sniffs either, meh
/*diff*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/)
/*spell*/) OVERRIDE
/// We were purged. Force removed stacks to zero and trigger the appropriated remove handler.
// Prevent any stack from being removed at this point.
/*mode*/)
// Stacks marker
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*handle*/)
/*aurEff*/, AuraEffectHandleModes /*handle*/)
/*spell*/) OVERRIDE
// In case cutter caster werent found for some reason
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// You will sssuffer for this intrusion! (17528)
// Burn in the master's flame! (17532)
// %s becomes enraged!
// Halion will be pleased. (17530) - As it should be.... (17529)
// Unknown dummy effect
// Event group
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*player*/)
// Reopen rings on wipe or success
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*areaTrigger*/) OVERRIDE
// Only trigger once
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
// Eadric the Pure
// Argent Confessor Paletress
// Memory of X
// Eadric the Pure
// Paletress
// Memory of X (Summon)
// Memory
/*done_by*/, uint32 &damage) OVERRIDE
/*Data*/) OVERRIDE
/*uiValue*/) OVERRIDE
/*done_by*/, uint32 &damage) OVERRIDE
/*killer*/) OVERRIDE
// THIS AI NEEDS MORE IMPROVEMENTS
/*uiData*/) OVERRIDE
/*killer*/) OVERRIDE
// 66545 - Summon Memory
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//phase 1
//in this phase should rise herald (the spell is missing)
//phase 2 - During this phase, the Black Knight will use the same abilities as in phase 1, except for Death's Respite
//phase 3
//Return since we have no target
/*pDoneBy*/, uint32& uiDamage) OVERRIDE
/*killer*/) OVERRIDE
/*waypointId*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Vehicle
// Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
//not implemented in the AI yet...
// Ambrose Boltspark && Eressea Dawnsinger || Mage
// Colosos && Runok Wildmane || Shaman
// Jaelyne Evensong && Zul'tore || Hunter
//not implemented in the AI yet...
// Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
/*
/*
/*uiData*/) OVERRIDE
/*who*/) OVERRIDE
//dosen't work at all
// Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
// THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
/*killer*/) OVERRIDE
// Ambrose Boltspark && Eressea Dawnsinger || Mage
// THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
/*killer*/) OVERRIDE
// Colosos && Runok Wildmane || Shaman
// THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
/*killer*/) OVERRIDE
// Jaelyne Evensong && Zul'tore || Hunter
// THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
/*killer*/) OVERRIDE
// Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
// THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Champions
// Coliseum Announcer || Just NPC_JAEREN must be spawned.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*uiData*/) OVERRIDE
//movement done.
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Known bugs:
// Anubarak - underground phase partially not worked
//          - tele after impale hit a permafrost doesn't work (the entire tele spell should be better)
// Scarab   - Kill credit isn't crediting?
// Burrow
// Scarab
//Passive - Triggered
// Burrower
//Passive - Triggered
//Frost Sphere
//Spike
// Anub'arak
// Anub'arak
// clean up spawned Frost Spheres
/*who*/) OVERRIDE
//Summon Scarab Swarms neutral at random places
/*killer*/) OVERRIDE
// despawn frostspheres and Burrowers on death
/*who*/) OVERRIDE
// Despawn Scarab Swarms neutral
// Spawn Burrow
// Spawn 6 Frost Spheres at start
/* WORKAROUND
/*It seems that this spell have something more that needs to be taken into account
// Just to make sure it won't happen again in this phase
/* Bosskillers don't recognize */
/*who*/, uint32& damage) OVERRIDE
// we are close to the ground
// we are in air
//At hit the ground
// make sure the spike has everyone on threat list
/*who*/, uint32& uiDamage) OVERRIDE
// After the spikes hit the icy surface they can't move for about ~5 seconds
// make sure the Spine will really follow the one he should
/*effIndex*/)
// make sure Impale doesnt do damage if we are standing on permafrost
/*spell*/) OVERRIDE
// Damage
// Heal
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// generic
// druid healer
// shaman healer
//friendly only
// paladin healer
// priest healer
// priest dps
// warlock
// mage
// hunter
// druid dps
// warrior
// death knight
// used at spellscript
// rogue
// shaman dps (some spells taken from shaman healer)
// paladin dps
// warlock pet
// hunter pet
// generic
// druid healer
// shaman healer
// paladin healer
// priest healer
// priest dps
// warlock
// mage
// hunter
// druid dps
// warrior
// death knight
// rogue
// shaman dps
// paladin dps
// warlock pet
//DoCast(me, SPELL_PVP_TRINKET);
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*casting*/)
// make sure that every bosses separate events dont mix with these _events
/********************************************************************
// alliance = 1
/********************************************************************
/********************************************************************
/*pSummoned*/) OVERRIDE
/*
//Am i alliance?
/*spell*/) OVERRIDE
/*spell*/) OVERRIDE
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// immune to all CC on Heroic (stuns, banish, interrupt, etc)
// player should run away from raid because he triggers Legion Flame
// used by trigger npc
// +20% of spell damage per stack, stackable up to 5/10 times, must be dispelled/stealed
// jumps to nearby targets
// does heavy damage to the tank, interruptable
// target must be healed or will trigger Burning Inferno
// triggered by Incinerate Flesh
// summons Infernal Volcano
// summons Felflame Infernal (3 at Normal and inifinity at Heroic)
// summons Nether Portal
// summons Mistress of Pain (1 at Normal and infinity at Heroic)
// unused
// Mistress of Pain spells
// special effect preventing more specific spells be cast on the same player within 10 seconds
// Lord Jaraxxus
// Mistress of Pain
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
/*summoner*/) OVERRIDE
// makes immediate corpse despawn of summoned Felflame Infernals
/*killer*/) OVERRIDE
// used to despawn corpse immediately
/*diff*/) OVERRIDE { }
/*summoner*/) OVERRIDE
// makes immediate corpse despawn of summoned Mistress of Pain
/*killer*/) OVERRIDE
// used to despawn corpse immediately
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*aurEff*/)
// get a list of players with mana
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Known bugs:
// Gormok - Snobolled (creature at back)
// Gormok
// Acidmaw & Dreadscale
// Icehowl
//Gormok
//Snobold
//Acidmaw & Dreadscale
//In 60s it diameter grows from 10y to 40y (r=r+0.25 per second)
//Icehowl
// Gormok
// Snobold
// Acidmaw & Dreadscale
// Icehowl
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*who*/, uint32& damage) OVERRIDE
// despawn the remaining passengers on death
//Workaround for Snobold
/*killer*/) OVERRIDE
// looping through Gormoks seats
// commented out while SPELL_SNOBOLLED gets fixed
//if (Unit* target = ObjectAccessor::GetPlayer(*me, m_uiTargetGUID))
// commented out while SPELL_SNOBOLLED gets fixed
//if (Unit* target = ObjectAccessor::GetPlayer(*me, m_uiTargetGUID))
// do melee attack only when not on Gormoks back
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
// prevent losing 2 attempts at once on heroics
/*who*/) OVERRIDE
// if the worm was mobile before submerging, make him stationary now
/*diff*/) OVERRIDE
/*effIndex*/)
/*killer*/) OVERRIDE
// Middle of the room
// Landed from Hop backwards (start trample)
// Finish trample
/*who*/) OVERRIDE
// 1: Middle of the room
//Invalid (Do nothing more than move)
// 2: Hop Backwards
//Invalid (Do nothing more than move)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Known bugs:
//    - They should be floating but they aren't respecting the floor =(
//    - Hardcoded bullets spawner
/*currTime*/, uint32 /*diff*/)
/* Uncomment this once that they are floating above the ground
/*killer*/) OVERRIDE
// Called when sister pointer needed
/*who*/) OVERRIDE
// Vortex
// Shield + Pact
/*diff*/) OVERRIDE
/*effIndex*/)
/*aurEff*/, DamageInfo & dmgInfo, uint32 & /*absorbAmount*/)
// Twin Vortex part
// Picking floating balls
// need to do the things in this order, else players might have 100 charges of Powering Up without anything happening
// 2 lines together add the correct amount of buff stacks
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Special state is set at Faction Champions after first champ dead, encounter is still in combat
// make sure Anub'arak isnt missing and floor is destroyed after a crash
// Cleanup Icehowl
// Cleanup Jaraxxus
//Means the first blood
// Cleanup chest
// decrease attempt counter at wipe
// if theres no more attemps allowed
//Achievements
/*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/) OVERRIDE
/*uiGrandCrusaderAttemptsLeft == 50 && !bHasAtAnyStagePlayerEquippedTooGoodItem*/;
// Achievement stuff
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Known Bugs:
// - Need better implementation of Gossip and correct gossip text and option
// Highlord Tirion Fordring - 34996
// Varian Wrynn
// Garrosh
// Wilfred Fizzlebang
// Lord Jaraxxus
//  The Lich King
// Highlord Tirion Fordring - 36095
/*who*/) OVERRIDE { }
/*sender*/, uint32 /*action*/) OVERRIDE
// if Jaraxxus is spawned, but the raid wiped
//1-shot Fizzlebang
/*who*/) OVERRIDE { }
// keep the raid in combat for the whole encounter, pauses included
//Summoning crusaders
//Summoning crusaders
//Crusaders battle end
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// fears the group, can be resisted/dispelled
// casted on the current tank, adds debuf
// debuff --> Armor reduced by 75%
// dummy
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// unused
// unused
/* victim */) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Skeletal Spells (phase 1)
// casted at end of phase 1, starts phase 2
// Flesh Spells (phase 2)
// Channeled spell ending phase two and returning to phase 1. This ability will stun the party for 6 seconds.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// can't find any sniffs
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// 49380, 59803 - Consume
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 49555, 59807 - Corpse Explode
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 49405 - Invader Taunt Trigger
/*effIndex*/)
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// pre-fight
// pre-cast soulstorm
// Used by Soul Fragment (Aura)
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32& /*damage*/) OVERRIDE
/*aurEff*/)
// use the same target for first and second effect
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Initial spell cast at begining of wailing souls phase
// the beam visual
// the actual spell
//    68871, 68873, 68875, 68876, 68899, 68912, 70324,
// 68899 trigger 68871
/*who*/) OVERRIDE
// Prevent double spawn
/*killer*/) OVERRIDE
/*target*/, const SpellInfo* spell) OVERRIDE
// Return since we have no target
// PI/2 in 15 sec = PI/30 per tick
//Remove any target
// no other events during wailing souls
// first one after 3 secs.
// wailing soul event
// 69051 - Mirrored Soul
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 69023 - Mirrored Soul (Proc)
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*aurEff*/, ProcEventInfo& eventInfo)
// 69048 - Mirrored Soul (Target Selector)
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Jaina/Sylvanas Intro
/****************************************SYLVANAS************************************/
// End of Intro
//Return since we have no target
/*sender*/, uint32 action) OVERRIDE
// End of Intro
//Return since we have no target
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Forge of Souls encounters:
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/// @todo not in dbc. Add in DB.
/*who*/) OVERRIDE
/// @todo adjust timer.
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// Return since we have no target
/// @todo adjust timer.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/// @todo Check timer
/// @todo Check timer
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//EVENT_ESCAPE_16,
// Jaina/Sylavana
// Falric and Marwyn
// Jaina Ice Barrier
// Jaina Ice Prison
// Sylvanas Cloak of Darkness
// Sylvanas Dark Binding
// Lich King Remorseless Winter
// Lich King Soul Reaper
// Lich King Fury of FrostMourne
// Jaina
// Sylvanas
// Sylvanas Jump
// Visual effect and icewall summoning
// Raging Ghoul
// Witch Doctor
// Lumbering Abomination
// 2 Loralen Follows
// 9 Sylvanas Follows
// 10 Loralen follows
// leave the throne room
// adjust route
// stop for talking
// attack the first icewall
// attack the second icewall
// attack the third icewall
// attack the fourth icewall
// face the Lich king
// final position
// first icewall
// second icewall
// third icewall
// fourth icewall
// Jaina/Sylvanas Intro Start Position
// Jaina/Sylvanas walks to throne
// Lich King walks to throne
// Lich King walks away
// Lich King Spawn Position 2
// Lich King First summons
// Jaina Spawn Position 2
// Sylvanas Spawn Position 2
// Falric start position
// Marwyn start position
// Lich King Final Pos
// Chest position
// Final portal position
// AI of Part1
/*sender*/, uint32 action) OVERRIDE
// Begining of intro is differents between fActions as the speech sequence and timers are differents.
// A2 Intro Events
// H2 Intro Events
// spawn UTHER during speach 2
// Remaining Intro Events common for both faction
// Spawn LK in front of door, and make him move to the sword.
// The Lich King banishes Uther to the abyss.
// He steps forward and removes the runeblade from the heap of skulls.
// summon Falric and Marwyn. then go back to the door
/// @todo Loralen/Koreln shall run also
// Loralen or Koreln disappearAndDie()
/// @todo Loralen/Koreln shall run also
// AI of Part2
// dummy
// object
// icewall number
/*Killer*/) OVERRIDE
// called by InstanceScript when we need to start the escaping event
/*sender*/, uint32 action) OVERRIDE
// ICEWALL BROKEN
// last wall, really far
// FINAL PART
// Ghostly Priest
// Phantom Mage
// Phantom Hallucination (same as phantom mage + HALLUCINATION_2 when dies)
// Shadowy Mercenary
// Spectral Footman
// Tortured Rifleman
// Ghostly Priest
// Phantom Mage
// Shadowy Mercenary
// Spectral Footman
// Tortured Rifleman
/*who*/) OVERRIDE
/// @todo adjust timers
// find an ally with missing HP
// no friendly unit with missing hp. re-check in just 5 sec.
/*who*/) OVERRIDE
/// @todo adjust timers
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/// @todo adjust timers
/*who*/) OVERRIDE
/// @todo adjust timers
/*who*/) OVERRIDE
/// @todo adjust timers
//General
// 73076 on hc
// 70399 on hc
// Reflection
// 70400 on hc
// 73046 on hc
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*victim*/) OVERRIDE
/*trigger*/) OVERRIDE
/*trigger*/) OVERRIDE
/*at*/) OVERRIDE
/*killer*/) OVERRIDE
/*(Unit *target = SelectTarget(SELECT_TARGET_RANDOM, 0, 150.0f))*/
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Jaina Spawn Position
// Sylvanas Spawn Position
// Frostsworn General
// Jaina Spawn Position 2
// Sylvanas Spawn Position 2
// wave scheduling,checked when wave npcs die
// because the current npc returns IsAlive when OnUnitDeath happens
// we check if the number of dead npcs is equal to the list-1
/*go*/, uint32 eventId) OVERRIDE
// spawning all wave npcs at once
// iterate each wave
//despawn wave npcs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32& /*uiDamage*/) OVERRIDE
/*type*/) const OVERRIDE
//Temporary Line of Sight Check
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//ick's spell
//krick's spell
//krick's spell
//special spell 1
//special spell 1
//special spell 2
//special spell 3
//visual on exploding orb
//grow effect on exploding orb
//need to check growing stacks
//damage done by orb while exploding
//krick's selfcast in intro
// Krick
// Ick
// OUTRO
//special spell selection (one of event 5, 6 or 7)
// Krick OUTRO
// Krick's Outro Position
// Scourgelord Tyrannus Outro Position (Tele to...)
// Sylvanas / Jaine Outro Spawn Position (NPC_SYLVANAS_PART1)
// Sylvanas / Jaine Outro Move Position (1)
// Tyrannus fly down Position (not sniffed)
// Krick's Choke Position
// Kirck's Death Position
// Tyrannus fly up (not sniffed)
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//select one of these three special events
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
/// @todo Tyrannus starts killing Krick.
// there shall be some visual spell effect
//not sure if it's the right spell :/
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
// don't really know if we need it
// End of OUTRO. for now...
/*aurEff*/)
// don't know correct range
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// store target because aura gets removed
/*effIndex*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Gorkun
//Tyrannus
//Jaina
//Sylvanas
// Rimefang
//tyrannus combat start position
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Prevent corpse despawning
// Stop combat for Rimefang
//Talk(SAY_GORKUN_INTRO_2, pGorkunOrVictus);
//set rimefang also infight
/*type*/) OVERRIDE
/*victim*/, uint32& damage, DamageEffectType /*damageType*/) OVERRIDE
/*target*/, uint32& addHealth) OVERRIDE
/*diff*/) OVERRIDE { }
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*at*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// positions for Martin Victus (37591) and Gorkun Ironskull (37592)
// position for Jaina and Sylvanas
// No 3rd set for Alliance?
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Ymirjar Flamebearer
//Iceborn Proto-Drake
// Geist Ambusher
// Ymirjar Flamebearer
/*who*/) OVERRIDE
/*who*/) OVERRIDE
// the max range is determined by aggro range
/*aurEff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//events.Reset(); -> done in _Reset();
// Note: This should not be called, but before use SetBossState function we should use BossAI
//        in all the bosses of the instance
/*who*/) OVERRIDE
// Note: This should not be called, but before use SetBossState function we should use BossAI
//        in all the bosses of the instance
/*killer*/) OVERRIDE
// Note: This should not be called, but before use SetBossState function we should use BossAI
//        in all the bosses of the instance
// Note: This should not be called, but before use SetBossState function we should use BossAI
//        in all the bosses of the instance
/*attacker*/, uint32& damage) OVERRIDE
// what if the elemental is more than 80 yards from drakkari colossus ?
/*attacker*/, uint32& damage) OVERRIDE
// to prevent spell spaming
// not sure about this, the idea of this code is to prevent bug the elemental
// if it is not in a acceptable distance to cast the charge spell.
/*if (me->GetDistance(colossus) > 80.0f)
// we do this checks to see if the creature is one of the creatures that sorround the boss
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Eck goes berserk, increasing his attack speed by 150% and all damage he deals by 500%.
//Eck bites down hard, inflicting 150% of his normal damage to an enemy.
//Eck spits toxic bile at enemies in a cone in front of him, inflicting 2970 Nature damage and draining 220 mana every 1 sec for 3 sec.
//Eck leaps at a distant target.  --> Drops aggro and charges a random player. Tank can simply taunt him back.
//Eck leaps at a distant target.
//60-90 secs according to wowwiki
/*who*/) OVERRIDE
//Return since we have no target
//Berserk on timer or 20% of health
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Spells
//Yells
/*who*/) OVERRIDE
// 5 UNIQUE party members
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Periodic, The caster transforms into a powerful mammoth, increasing Physical damage done by 25% and granting immunity to Stun effects.
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* GunDrak encounters:
// Make sure that they start out as unusuable
// Make sure that they start out as unusuable
// Make sure that they start out as unusuable
// Can't spawn here with SpawnGameObject because go isn't added to world yet...
// Spawn the support for the bridge if necessary
// If there is nothing to activate, then return
// Add the GO that solidifies the bridge so you can walk on it
// This is a workaround to make the beam cast properly. The caster should be ID 30298 but since the spells
// all are with scripted target for that same ID, it will hit itself.
// Set the trigger model to invisible
// Don't save in between last statue and bridge turning in case of crash leading to stuck instance
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Blood Queen Lana'Thel
// Prince Keleseth
// Prince Taldaram
// Prince Valanar
// Heroic mode
// Prince Keleseth
// Dark Nucleus
// Prince Taldaram
// Ball of Flame
// cast from creature_template_addon (needed cast before entering world)
// Ball of Inferno Flame
// Prince Valanar
// Kinetic Bomb
// Shock Vortex
// Keleseth
// Taldaram
// Valanar
/*eventTime*/, uint32 /*diff*/)
/*type*/, uint32 data) OVERRIDE
// kill all prices
// make sure looting is allowed
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*target*/, uint32& damage, DamageEffectType damageType) OVERRIDE
// was in sniff. don't ask why
// does not melee
/*who*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
// first try at distance
// too bad for you raiders, its going to boom
/*target*/, uint32& damage, DamageEffectType damageType) OVERRIDE
// was in sniff. don't ask why
/*who*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*target*/, uint32& damage, DamageEffectType damageType) OVERRIDE
// was in sniff. don't ask why
// summon a visual trigger
// remove Feign Death from princes
/*type*/) OVERRIDE
// need to clear states now because this call is before AuraEffect is fully removed
/*target*/, uint32& damage, DamageEffectType damageType) OVERRIDE
/*damage*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// SPELL_FLAME_SPHERE_SPAWN_EFFECT
// SPELL_FLAME_SPHERE_DEATH_EFFECT
/*effIndex*/)
/*aurEff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Blood Infusion
// Blah, credit the quest
// already in evade mode
// victim can be NULL when this is processed in the same update tick as EVENT_AIR_PHASE
// both spells have SPELL_ATTR5_SINGLE_TARGET_SPELL, no manual removal needed
// offtank for this encounter is the player standing closest to main tank
// helper for shortened code
/*spell*/) OVERRIDE
// Shadowmourne questline
/*effIndex*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// this needs to be done BEFORE charm aura or we hit an assert in Unit::SetCharmedBy
/*spell*/) OVERRIDE
// mark targets now, effect hook has missile travel time delay (might cast next in that time)
// 70871 - Essence of the Blood Queen
/*spellInfo*/) OVERRIDE
// we can do this, unitList is MAX 4 in size
/*spell*/) OVERRIDE
// this is an additional effect to be executed
// do not convert to 0.01f - we need tick number/10 as INT (damage increases every 10 ticks)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Deathbringer Saurfang
// High Overlord Saurfang
// kneel after WP reached
// Muradin Bronzebeard
/// @todo ALLIANCE OUTRO
// Lady Jaina Proudmoore
// King Varian Wrynn
// Deathbringer Saurfang
// Intro
// Additional cast, does not replace
// Blood Beast
// Heroic only
// Outro
// Helper to get id of the aura on different modes (HasAura(baseId) wont work)
// 4537, 4613 are achievement IDs
// waypoint id
// High Overlord Saurfang/Muradin Bronzebeard
// front left
// front right
// back middle
// back left
// back right
// High Overlord Saurfang/Muradin Bronzebeard
// front left
// front right
// back middle
// back left
// back right
// we dont actually use it, just check if exists
// oh just screw intro, enter combat - no exploits please
/*killer*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
// AT 30%, not below
//instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MARK_OF_THE_FALLEN_CHAMPION);
/*killer*/) OVERRIDE
// Mark of the Fallen Champion, triggered id
/*caster*/, SpellInfo const* spell) OVERRIDE
// intro setup
// controls what events will execute
// faster than iterating all auras to find Frenzy
// Prevent crashes
// say
// say
// cast
// move
/*caster*/, SpellInfo const* spell) OVERRIDE
// for the packet logs.
// move
// say
// say
// say
// move
// move
// say
/*sender*/, uint32 action) OVERRIDE
// Prevent crashes
// temp until outro fully done - to put deathbringer on respawn timer (until next reset)
/*caster*/, SpellInfo const* spell) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*aurEff*/)
/*aurEffect*/, int32& amount, bool& canBeRecalculated)
/*spellInfo*/) OVERRIDE
// make this the default handler
/*spellInfo*/) OVERRIDE
// make this the default handler
// initialize variable
// select one random target, with preference of ranged targets
// get target count at range
// set the upper cap
// use the same target for first and second effect
/*effIndex*/)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Festergut
// 72214 is the proper way (with proc) but atm procs can't have cooldown for creatures
// Stinky
// Used for HasAura checks
/*killer*/) OVERRIDE
// just cast and dont bother with target, conditions will handle it
/*target*/) OVERRIDE
/*killer*/) OVERRIDE
/*effIndex*/)
// Get Inhaled Blight id for our difficulty
// ...and remove it
/*spell*/) OVERRIDE
/*effIndex*/)
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Lady Deathwhisper
// Darnavan
// Lady Deathwhisper
// Prefight, during intro
// Achievement
// does not exist in dbc but still can be used for criteria check
// Both Adds
// Fanatics
//  Adherents
// Vengeful Shade
// Darnavan
// Lady Deathwhisper
// Phase 1 only
// Phase 2 only
// Shared adds events
// Cult Fanatic
// Cult Adherent
// Darnavan
// 1 Left Door 1 (Cult Fanatic)
// 2 Left Door 2 (Cult Adherent)
// 3 Left Door 3 (Cult Fanatic)
// 4 Right Door 1 (Cult Adherent)
// 5 Right Door 2 (Cult Fanatic)
// 6 Right Door 3 (Cult Adherent)
// 7 Upper (Random Cultist)
/*time*/, uint32 /*diff*/)
// phase-independent events
// phase one only
// Full House achievement
/*damageDealer*/, uint32& damage) OVERRIDE
// phase transition
// on heroic mode Lady Deathwhisper is immune to taunt effects in phase 2 and continues summoning adds
// Vengeful Shade
// Wave adds
// CAN be NULL
// We should not melee attack when barrier is up
// summoning function for first phase
// Summon first add, replace it with Darnavan if weekly quest is active
// summoning function for second phase
// helper for summoning wave mobs
/* = 0*/) OVERRIDE
// noone to empower
// select random cultist
/*caster*/, SpellInfo const* spell) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*target*/, SpellInfo const* spell) OVERRIDE
/*victim*/) OVERRIDE
/*aurEff*/)
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Lord Marrowgar
// Bone Spike
// Coldflame
// Manual marking for targets hit by Bone Slice as no aura exists for this purpose
// These units are the tanks in this encounter
// and should be immune to Bone Spike Graveyard
//DATA_SPIKE_IMMUNE_1,          = 2, // Reserved & used
//DATA_SPIKE_IMMUNE_2,          = 3, // Reserved & used
// Check if it is one of the tanks soaking Bone Slice
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// reset
// no break here
// We should not melee attack when storming
// 10 seconds since encounter start Bone Slice replaces melee attacks
// lock movement
/*= 0 */) const OVERRIDE
/*= 0 */) OVERRIDE
/*killer*/) OVERRIDE
/*seat*/, bool apply) OVERRIDE
/// @HACK - Change passenger offset to the one taken directly from sniffs
/// Remove this when proper calculations are implemented.
/// This fixes healing spiked people
// select any unit but not the tank (by owners threatlist)
// or the tank if its solo
/*spell*/) OVERRIDE
// Mark the unit as hit, even if the spell missed or was dodged/parried
// This spell can miss all targets
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Festergut
// Rotface
// Professor Putricide
// always used for phase2 change, DO NOT GROUP WITH SAY_TRANSFORM_1
// Festergut
// Professor Putricide
// phase transition
// protects the tank
// Slime Puddle
// Gas Cloud
// Volatile Ooze
// Choking Gas Bomb
// Mutated Abomination vehicle
// Unholy Infusion
// Festergut
// Rotface
// Professor Putricide
// all phases
// all phases
// P1 && P2
// phase transition not heroic
//emote 432 (release gas)
//emote 432 (release ooze)
// used in Rotface encounter
// also despawns the vehicle
// Found unit is Mutated Abomination, remove it
// Found unit is not Mutated Abomintaion, leave it
// No unit found, remove from SummonList
/*killer*/) OVERRIDE
// blizzard casts this spell 7 times initially (confirmed in sniff)
// no possible aura seen in sniff adding the aurastate
// no possible aura seen in sniff adding the aurastate
/*attacker*/, uint32& /*damage*/) OVERRIDE
// needed here for delayed gate close
// needed here for delayed gate close
// stop attack
// operating on new phase already
// init random sequence of floods
// cast from self for LoS (with prof's GUID for logs)
// cast variables
// half gets ooze variable
// and half gets gas
// remove Tear Gas
// external of EventMap because event phase gets reset on evade
/*target*/, SpellInfo const* spell) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*aurEff*/)
// set up initial variables and check if caster is creature
// this will let use safely use ToCreature() casts in entire script
// despawn next update
// value seen in sniff
// this is here only because on retail you dont actually enter HEROIC mode for ICC
// 2 of them are spawned at green place - weird trick blizz
/*effIndex*/)
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// VEHICLE_SPELL_RIDE_HARDCODED is used according to sniff, this is ok
// the only purpose of this hook is to fail the achievement
/*effIndex*/)
// Removes aura with id stored in effect value
// Stinky and Precious spell, it's here because its used for both (Festergut and Rotface "pets")
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// KNOWN BUGS:
// ~ No Slime Spray animation directly at target spot
// Rotface
// every 20 seconds
// hastens every 1:30
// Oozes
// combine 2 Small Oozes
// combine 2 Large Oozes
// combine Large and Small Ooze
// 2 Small Oozes summon a Large Ooze
// passive damage aura - small
// passive damage aura - large
// damage boost and counter for explosion
// prevents getting hit by infection
// Precious
// Professor Putricide
// Rotface
// Precious
/*killer*/) OVERRIDE
// reset
/*target*/, SpellInfo const* spell) OVERRIDE
/*who*/) OVERRIDE
// don't enter combat
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
// register in Rotface's summons - not summoned with Rotface as owner
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*effIndex*/)
// get 2 targets except 2 nearest
// .resize() runs pop_back();
// remove targets with this aura already
// tank is not on this list
/*effIndex*/)
/*effIndex*/)
// no idea why, but this does not trigger explosion on retail (only small+large do)
// just for safety
/*effIndex*/)
// explode!
/*spell*/) OVERRIDE
// let Rotface handle the cast - caster dies before this executes
/*aurEff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// You are fools to have come to this place! The icy winds of Northrend will consume your souls!
// Suffer, mortals, as your pathetic magic betrays you!
// %s prepares to unleash a wave of blistering cold!
// Can you feel the cold hand of death upon your heart?
// Aaah! It burns! What sorcery is this?!
// Your incursion ends here! None shall survive!
// Now feel my master's limitless power and despair!
// %s fires a frozen orb towards $N!
// Perish!
// A flaw of mortality...
// Enough! I tire of these games!
// Free...at last...
// Sindragosa
// Spinestalker
// Rimefang
// Frostwarden Handler
// Frost Infusion
// Sindragosa
// Spinestalker
// Rimefang
// Trash
// event groups
/*eventTime*/, uint32 /*updateTime*/)
/*eventTime*/, uint32 /*updateTime*/)
/* killer */) OVERRIDE
// Sindragosa enters combat as soon as she lands
// trigger Asphyxiation
/*attacker*/, uint32& /*damage*/) OVERRIDE
// random number close to ground, get exact in next call
/* = 0 */) OVERRIDE
/*killer*/) OVERRIDE
// Remove object
// Increase add count
// this cannot be in Reset because reset also happens on evade
// this cannot be in Reset because reset also happens on evade
/*killer*/) OVERRIDE
// Increase add count
// this cannot be in Reset because reset also happens on evade
// this cannot be in Reset because reset also happens on evade
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// Increase add count
// this cannot be in Reset because reset also happens on evade
// This is shared AI for handler and whelps
// Increase add count
// this cannot be in Reset because reset also happens on evade
// Frostwing Whelp only
// This script should execute only in Icecrown Citadel
// random number close to ground, get exact in next call
// Check difficulty and quest status
// Check if player has Shadow's Edge equipped and not ready for infusion
/*spell*/) OVERRIDE
/*mode*/)
/*spell*/) OVERRIDE
/*aurEff*/)
/*spell*/) OVERRIDE
/*aurEff*/)
/*spell*/) OVERRIDE
/*spell*/) OVERRIDE
/*spell*/) OVERRIDE
// caster is Frostwarden Handler, target is player, caster of triggered is whelp
/*aurEff*/)
/*areaTrigger*/) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// The Lich King
// not said on heroic
// not said on heroic
// Highlord Tirion Fordring
// Terenas Menethil (outro)
// Terenas Menethil (Frostmourne)
// The Lich King
// raging spirits also get it
// Phase 1
// Phase Transition
// Phase 2
// Val'kyr Shadowguard vehicle aura
// cast on selected target
// removes unselectable flag
// Phase 3
// Heroic version, weird because it has all 4 difficulties just like above spell
/// @todo Cast every 3 seconds during Frostmourne phase, targets a Wicked Spirit amd activates it
// Frostmourne
// Heroic
// Passive proc healing
// Used when Terenas Menethil dies
// Deals increasing damage
// (Heroic)
// (Heroic)
// Spirit Bomb (Heroic)
// Outro
// visual
// animation
// real summon
// Shambling Horror
// The Lich King
// intro events
// combat events
// heroic only
// normal mode only
// heroic only
// heroic only
// Shambling Horror
// Raging Spirit
// Strangulate Vehicle (Harvest Soul)
// only set on heroic mode when all players are sent into frostmourne
// globally used number for charge spell effects
// Summon Shambling Horror, Remorseless Winter, Quake, Summon Val'kyr Periodic, Harvest Soul, Vile Spirits
// Raise Dead, Light's Blessing
// separate sound, not attached to any text
/*time*/, uint32 /*diff*/)
/*time*/, uint32 /*diff*/)
/*time*/, uint32 /*diff*/)
/*killer*/) OVERRIDE
// Reset The Frozen Throne gameobjects
// Reset any light override
// The Lich King must not select targets in frostmourne room if he killed everyone outside
// schedule talks
/*attacker*/, uint32& /*damage*/) OVERRIDE
// stop here. rest will get scheduled from MovementInform
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*target*/, SpellInfo const* spell) OVERRIDE
// schedule for next update cycle, current update must finalize movement
// delay berserk timer, its not ticking during phase transitions
// delay berserk timer, its not ticking during phase transitions
// check phase first to prevent updating victim and entering evade mode when not wanted
// during Remorseless Winter phases The Lich King is channeling a spell, but we must continue casting other spells
// for some reason blizz sends 2 emotes in row here so (we handle one in Talk)
// clear state to ensure check in DoCastAOE passes
// clear state to ensure check in DoCastAOE passes
// will stop running UpdateVictim (no evading)
// summons bombs randomly
// summons bombs on players
// set flight
///@TODO: Wrong Packet, Send correct one.
//WorldPacket data(SMSG_PLAY_MUSIC, 4);
//data << uint32(musicId);
//data << uint64(me->GetGUID());
//SendPacketToPlayers(&data);
// Light.dbc entry (map default)
// Light.dbc entry (override)
// Send packet to all players in The Frozen Throne
/*caster*/, SpellInfo const* spell) OVERRIDE
// remove glow on ashbringer
/*player*/, uint32 sender, uint32 action) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*summoner*/) OVERRIDE
// player is the spellcaster so register summon manually
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
// schedule siphon life event (heroic only)
/*target*/) OVERRIDE
/* = 0*/) OVERRIDE
// no melee attacks
// this will let us easily access all creatures of this entry on heroic mode when its time to teleport back
// no running back home
/*attacker*/, uint32& damage) OVERRIDE
/*summoner*/) OVERRIDE
// fighting Spirit Warden
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
// approximation, gets more precise later
/*victim*/) OVERRIDE
/*diff*/) OVERRIDE
// no melee attacks
/*summoner*/) OVERRIDE
// no melee attacks
/*aurEff*/)
// multiply, starting from 2nd tick
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
//values.AddSpellMod(SPELLVALUE_AURA_STACK, 2);
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*mode*/)
/*mode*/)
/*mode*/)
// this means the stack increased so don't process as if dispelled
// add as marker (spell has no effect 1)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*effIndex*/)
/*spell*/) OVERRIDE
// if there is at least one affected target cast the explosion
/*spell*/) OVERRIDE
// HACK: target player should cast this spell on defile
// however with current aura handling auras cast by different units
// cannot stack on the same aura object increasing the stack count
// spirit bombs get higher
/*spell*/) OVERRIDE
/*aurEff*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
// for this spell, all units are in target map, however it should select one to attack
// this spell has SPELL_AURA_BLOCK_SPELL_FAMILY so every next cast of this
// searcher spell will be blocked
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// m_originalCaster to allow stacking from different casters, meh
/*aurEff*/)
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// shouldn't be needed, this is channeled
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// m_originalCaster to allow stacking from different casters, meh
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// The Lich King
// Valithria Dreamwalker
// Valithria Dreamwalker
// The Lich King
// Risen Archmage
// Blazing Skeleton
// Suppresser
// Blistering Zombie
// Gluttonous Abomination
// Dream Cloud
// Nightmare Cloud
// Valithria Dreamwalker
// The Lich King
// Risen Archmage
// Blazing Skeleton
// Suppresser
// Gluttonous Abomination
// Dream Cloud
// Nightmare Cloud
// look for all permanently spawned Risen Archmages that are not yet in combat
/*time*/, uint32 /*diff*/)
/*time*/, uint32 /*diff*/)
/*currTime*/, uint32 /*diff*/)
// immune to percent heals
// Glyph of Dispel Magic - not a percent heal by effect, its cast with custom basepoints
/*target*/) OVERRIDE
// encounter complete
// call EnterCombat on one of them, that will make it all start
/*attacker*/, uint32& damage) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
// this display id was found in sniff instead of the one on aura
// does not enter combat
/*diff*/) OVERRIDE
// check evade every second tick
// check if there is any player on threatlist, if not - evade
// found any player, return
/*target*/) OVERRIDE
// must not be in dream phase
/*target*/) OVERRIDE
/*summoner*/) OVERRIDE
// this code will never be reached while channeling
// this creature has REACT_PASSIVE so it does not always have victim here
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
/*clicker*/, bool& result) OVERRIDE
/*diff*/) OVERRIDE
// remove corpse immediately
// trigger
// must use originalCaster the same for all clouds to allow stacking
// first 3 ticks have amplitude 1 second
// remaining tick every 500ms
/*aurEff*/)
/*aurEff*/)
// impossible with TARGET_UNIT_CASTER
//if (!GetHitUnit())
//    return;
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Weekly quest support
// * Deprogramming                (DONE)
// * Securing the Ramparts        (DONE)
// * Residue Rendezvous           (DONE)
// * Blood Quickening             (DONE)
// * Respite for a Tormented Soul
// Highlord Tirion Fordring (at Light's Hammer)
// The Lich King (at Light's Hammer)
// Highlord Bolvar Fordragon (at Light's Hammer)
// High Overlord Saurfang (at Light's Hammer)
// Muradin Bronzebeard (at Light's Hammer)
// Deathbound Ward
// Rotting Frost Giant
// Sister Svalna
// happens when she kills a captain
// happens when a captain resurrected by her dies
// Ready your arms, my Argent Brothers. The Vrykul will protect the Frost Queen with their lives.
// Even dying here beats spending another day collecting reagents for that madman, Finklestein.
// Enough idle banter! Our champions have arrived - support them as we push our way through the hall!
// You may have once fought beside me, Crok, but now you are nothing more than a traitor. Come, your second death approaches!
// Draw them back to us, and we'll assist you.
// Quickly, push on!
// Her reinforcements will arrive shortly, we must bring her down quickly!
// Foolish Crok. You brought my reinforcements with you. Arise, Argent Champions, and serve the Lich King in death!
// I'll draw her attacks. Return our brothers to their graves, then help me bring her down!
// Come, Scourgebane. I'll show the master which of us is truly worthy of the title of "Champion"!
// Rotting Frost Giant
// Frost Freeze Trap
// Alchemist Adrianna
// Crok Scourgebane
// Sister Svalna
// Captain Arnath
// Captain Brandon
// Captain Grondel
// Captain Rupert
// Invisible Stalker (Float, Uninteractible, LargeAOI)
// Helper defines
// Captain Arnath
// Captain Rupert
// Highlord Tirion Fordring (at Light's Hammer)
// The Lich King (at Light's Hammer)
// Highlord Bolvar Fordragon (at Light's Hammer)
// High Overlord Saurfang (at Light's Hammer)
// Muradin Bronzebeard (at Light's Hammer)
// Rotting Frost Giant
// Frost Freeze Trap
// Crok Scourgebane
// Sister Svalna
// Captain Arnath
// Captain Brandon
// Captain Grondel
// Captain Rupert
// Invisible Stalker (Float, Uninteractible, LargeAOI)
// Sister Svalna
// return, this creature is never dead if event is reset
/*currTime*/, uint32 /*diff*/)
// at Light's Hammer
// IMPORTANT NOTE: This is triggered from per-GUID scripts
// of The Damned SAI
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/) OVERRIDE
// Load Grid with Sister Svalna
/* = 0*/) OVERRIDE
// pause pathing until trash pack is cleared
// get spawns by home position
// at waypoints 1 and 2 she kills one captain
// get all nearby vrykul
// at waypoints 1 and 2 she kills one captain
/*attacker*/, uint32& damage) OVERRIDE
// check wipe
// wipe
// do not see targets inside Frostwing Halls when we are not there
/*killer*/) OVERRIDE
/*target*/) OVERRIDE
// do not see targets inside Frostwing Halls when we are not there
// not yet following
/*caster*/, SpellInfo const* spell) OVERRIDE
// do not see targets inside Frostwing Halls when we are not there
// Distance from the center of the spire
// Default to no script
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// First effect
// Second effect
// Select valid targets for jump
/*effIndex*/)
/*effIndex*/)
//pos.m_positionZ = caster->GetBaseMap()->GetHeight(caster->GetPhaseMask(), pos.GetPositionX(), pos.GetPositionY(), caster->GetPositionZ(), true, 50.0f);
//pos.m_positionZ += 0.05f;
/*areaTrigger*/) OVERRIDE
// Process relocation now, to preload the grid and initialize traps
/*areaTrigger*/) OVERRIDE
/*areaTrigger*/) OVERRIDE
/*areaTrigger*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/// @todo Gauntlet event before Sindragosa
/*go*/, uint32 sender, uint32 action) OVERRIDE
/*areaTrigger*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
// this doesnt have to only store questgivers, also can be used for related quest spawns
// 10 and 25 man versions
// when changing the content, remember to update SetData, DATA_BLOOD_QUICKENING_STATE case for NPC_ALRIN_THE_AGILE index
// Deprogramming
// Securing the Ramparts
// Securing the Ramparts
// Securing the Ramparts
// Residue Rendezvous
// Blood Quickening
// Blood Quickening
// Blood Quickening
// Respite for a Tormented Soul
// no break;
// we can only do this because there are no gaps in their entries
// Teleporter visual at center
// Remove corpse as soon as it dies (and respawn 10 seconds later)
// Weekly quest spawn prevention
/*guidLow*/, CreatureData const* data)
/*DATA_FROSTWYRM_OWNER*/) == DATA_SPINESTALKER)
// these 2 gates are functional only on 25man modes
// TEMP HACK UNTIL GUNSHIP SCRIPTED
// no break
// set the platform as active object to dramatically increase visibility range
// note: "active" gameobjects do not block grid unloading
// skip if nothing changes
// 5 is the index of Blood Quickening
/*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/) OVERRIDE
// Only one criteria for both modes, need to do it like this
// no break
// no break
// no break
// no break
// no break
// no break
// no break
// DONE means finished (not success/fail)
/*source*/, uint32 eventId) OVERRIDE
// Harvest Soul (normal mode)
// Muradin Bronzebeard or High Overlord Saurfang
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// This spawns 5 corpse scarabs on top of player
// This spawns 10 corpse scarabs on top of dead guards
// respawn guard using home position,
// otherwise, after a wipe, they respawn where boss was at wipe moment.
/// Force the player to spawn corpse scarabs via spell, @todo Check percent chance for scarabs, 20% at the moment
/*killer*/) OVERRIDE
// start achievement timer (kill Maexna within 20 min)
/*who*/) OVERRIDE
// check if it is an actual killed guard
//Cast Impale on a random target
//Do NOT cast it when we are afflicted by locust swarm
/// @todo Add Text
/// @todo Add Text
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/// @todo Add Text
/// @todo Add Text
/*killer*/) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Thane waypoints
// Lady waypoints
// Baron waypoints
// Sir waypoints
// switch to "who" if nearer than current target.
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Achievements related to the 4-horsemen are given through spell 59450 which does not exist.
// There is thus no way it can be given by casting the spell on the players.
/*who*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Do not let Gluth be affected by zombies' debuff
/// @todo use a script text
/*who*/) OVERRIDE
/// @todo Add missing text
/// @todo Add missing text
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Gothik
// wave setups are not the same in heroic and normal difficulty,
// mode is 0 only normal, 1 both and 2 only heroic
// but this is handled in DoGothikSummon function
// Predicate function to check that the r   efzr unit is NOT on the same side as the source.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*who*/, uint32& damage) OVERRIDE
// if group is not splitted, open gate and merge both sides at ~ 2 minutes (wave 11)
//! Magic numbers fail
//! Magic numbers fail
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
//not sure
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// 25-man: 55011
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/// @todo Add missing texts for both phase switches
/*eff*/)
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//when shappiron dies. dialog between kel and lich king (in this order)
//not used
//not used
//not used
//not used
//not used
//when cat dies, not used
//when each of the 4 wing bosses dies
//start of phase 3
//lich king answer
//start of phase 1
//28408 script effect
//spells for chained
//warlock
//shaman
//mage
//rogue
//paladin
//priest
//hunter
//warrior
//druid
//death knight
// Abomination spells
// Soldiers of the Frozen Wastes
// Unstoppable Abominations
// Soul Weavers
// Guardians of Icecrown
//LEFT_FAR
//LEFT_MIDDLE
//WINDOW_PORTAL05
//RIGHT_FAR
//RIGHT_MIDDLE
//WINDOW_PORTAL04
//LEFT_FAR
//LEFT_MIDDLE
//WINDOW_PORTAL02
//RIGHT_FAR
//RIGHT_MIDDLE
//WINDOW_PORTAL03
//creatures in corners
//Unstoppable Abominations
//Soldiers of the Frozen Wastes
//Soul Weavers
// predicate function to select not charmed target
// adds spawn by the trigger. kept in separated list (i.e. not in summons)
//5 seconds for summoning each Guardian of Icecrown in phase 3
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//start phase 3 when we are 45% health
//here Lich King should respond to KelThuzad but I don't know which Creature to make talk
//so for now just make Kelthuzad says it.
/// @todo Add missing text
//core has 2000ms to set unit flag charm
/*at*/) OVERRIDE
// Note: summon must be done by trigger and not by KT.
// Otherwise, they attack immediately as KT is in combat.
/*killer*/) OVERRIDE
/*spell*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*summon*/, Unit* /*killer*/) OVERRIDE
// needs to be confirmed
/*source*/, Unit* target) OVERRIDE
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
// will be cast immediately
/// @todo Add missing text
/// @todo Add missing text
/*param*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// 25-man: 54835
// 25-man: 54814
// Teleport position of Noth on his balcony
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*Victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Cast Hateful strike on the player with the highest
//amount of HP within melee distance
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Razuvious - NO TEXT sound only
//8852 aggro01 - Hah hah, I'm just getting warmed up!
//8853 aggro02 Stand and fight!
//8854 aggro03 Show me what you've got!
//8861 slay1 - You should've stayed home!
//8863 slay2-
//8858 cmmnd3 - You disappoint me, students!
//8855 cmmnd1 - Do as I taught you!
//8856 cmmnd2 - Show them no mercy!
//8859 cmmnd4 - The time for practice is over! Show me what you've learned!
//8861 Sweep the leg! Do you have a problem with that?
//8860 death - An honorable... death...
//8947 - Aggro Mixed? - ?
/*victim*/) OVERRIDE
// Damage done by the controlled Death Knight understudies should also count toward damage done by players
/*killer*/) OVERRIDE
/// @todo this may affect other creatures
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// The Hundred Club
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*type*/, uint32 id) OVERRIDE
//DoCastAOE(SPELL_SUMMON_BLIZZARD);
// make sure everyone is in threatlist
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Stalagg
//Feugen
// Thaddius DoAction
//generic
//the coils (emotes "Tesla Coil overloads!")
//Thaddius
// init is a bit tricky because thaddius shall track the life of both adds, but not if there was a wipe
// and, in particular, if there was a crash after both adds were killed (should not respawn)
// Moreover, the adds may not yet be spawn. So just track down the status if mob is spawn
// and each mob will send its status at reset (meaning that it is alive)
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// REACT_AGGRESSIVE only reset when he takes damage.
/*who*/) OVERRIDE
/*pDoneBy*/, uint32 & /*uiDamage*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// magnetic pull is not working. So just jump.
// reset aggro to be sure that feugen will not follow the jump
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*spell*/) OVERRIDE
// if (GetSpellInfo()->Id == SPELL_NEGATIVE_CHARGE)
/*effIndex*/)
/*spell*/) OVERRIDE
/* effIndex */)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// 0  H      x
//  1        ^
//   2       |
//    3  y<--o
// This Function is called in CheckAchievementCriteriaMeet and CheckAchievementCriteriaMeet is called before SetBossState(bossId, DONE),
// so to check if all bosses are done the checker must exclude 1 boss, the last done, if there is at most 1 encouter in progress when is
// called this function then all bosses are done. The one boss that check is the boss that calls this function, so it is dead.
/*source*/, Unit const* /*target = NULL*/, uint32 /*miscvalue1 = 0*/)
// Criteria for achievement 2176: And They Would All Go Down Together 15sec of each other 10-man
// Criteria for achievement 2177: And They Would All Go Down Together 15sec of each other 25-man
// Difficulty checks are done on DB.
// Criteria for achievement 2186: The Immortal (25-man)
// The Four Horsemen
// Maexxna
// Thaddius
// Loatheb
// Kel'Thuzad
// Criteria for achievement 2187: The Undying (10-man)
// The Four Horsemen
// Maexxna
// Loatheb
// Thaddius
// Kel'Thuzad
/* The Arachnid Quarter */
// Grand Widow Faerlina
/* The Plague Quarter */
// Heigan the Unclean
/* The Military Quarter */
// Gothik the Harvester
// The Four Horsemen
/* The Construct Quarter */
// Thaddius
/* Frostwyrm Lair */
// Sapphiron
// Kel'Thuzad
/* The Immortal / The Undying */
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
// =========== INTRO BEFORE WE START ENCOUNTER ===============
// =========== PHASE ONE ===============
// =========== PHASE TWO ===============
// =========== PHASE THREE =============
// ========== MISC MECHANICS ===========
// This should be fixed someday in core, we can't call new movement from MovementInform
// There is something that is still loading when we first enter instance and it breaks
// first visual cast of intro portal beam mechanic, so we need short delay from the event.
// If Malygos is too close to destroy platform point and transition from II to III is hit,
// this event will be sheduled to start after 5 seconds so there is enough time for "dimension change".
// ============ NEXUS LORDS ============
// ======== SCIONS OF ETERNITY =========
// ======== WYRMREST SKYTALON ==========
// Intro
// Malygos cast on portal to activate it during PHASE_NOT_STARTED
// Phase I
// it's the berserk spell that will hit only Malygos after 10 min of 60670
// seems that frezze object animation
// visual effect
// this spell must handle all the script - casted by the boss and to himself
// teleport - (casted to all raid), caster vortex bunnies, targets players.
// Phase II
// Light blue animation cast by arcane NPCs when spawned on Hover Disks
// casted by npc Arcane Overload ID: 30282
// SPELL_ARCANE_OVERLOAD_2               = 56435, // Triggered by 56432 - resizing target
// SPELL_ARCANE_OVERLOAD_3               = 56438, // Triggered by 56432 - damage reduction
// SPELL_SURGE_OF_POWER_TRIGGERED        = 56548,
// used by Nexus Lords
// used by Nexus Lords
// used by Scions of Eternity
// the actual damage - cast by affected player by script spell
// Transition /II-III/
// After implicitly hit player targets they will force cast 56070 on self
// Phase III
// used in 25 player mode for selecting targets for warnings and then sends to actual spell
// Phase I and III
// Outro
// Needed for melee hover disks /when Nexus Lords die/
// Malygos
// Caster hover disk despawn action
// Nexus Lord's action used to shedule casting spell that determine disk's target to chase
// Malygos
// SAY_START_P_TWO                  = 5, // Unused by Blizzard for some reason on any version
// SAY_START_P_THREE                = 11, // Unused by Blizzard for some reason on any version
// Alexstrasza
// Power Sparks
// First melee hover disk wps
// Second melee hover disk wps
// Third melee hover disk wps
// Forth melee hover disk wps
// Point destroy platform
// Point Vortex
// Point land after Vortex
// Point Surge of Power phase II
// Point idle phase III
// Alexstrasza's spawn position
// Heart of Magic spawn position
// Lights
// Data (setters/getters)
// phase 2
// Target guids
// used to store last Arcane Overload guid
// DATA_SECOND_SURGE_TARGET_GUID = 15,
// DATA_THIRD_SURGE_TARGET_GUID  = 16,
// Used to check if summons guids come from vehicles
// We determine if Malygos will be realocated to spawning position on reset triggered by boss despawn on evade
// Get initial fly speed, otherwise on each wipe fly speed would add up if we get it
// EnterEvadeMode and Reset() links are cut for the sake of properly functioning despawner.
// TO DO: find what in core is making boss slower than in retail (when correct speed data) or find missing movement flag update or forced spline change
// the vortex execution continues in the dummy effect of this spell (see it's script)
// Vehicles shouldn't be despawned with 0 delay if the call comes from virtual function that overrides PassengerBoarded.
// Aside from that he doesn't despawn both vehicles and arcane overloads right away, but with some delay.
// Teleport to spawn position, we can't use normal relocate
// Respawn Iris
// There are moments where boss will do nothing while being attacked
/*who*/) OVERRIDE
// We can't call full function here since it includes DoZoneInCombat(),
// if someone does it will be returned with a warning.
// periodic aura, first tick in 10 minutes
// Set speed to normal value
// Sometimes threat can remain, so it's a safety measure
// we can't cast if we are casting already unless in PHASE_NOT_STARTED channeling PORTAL_BEAM
// at 50% hp Malygos switchs to phase 2 and removes hovering until reset or end of encounter
// this is not the best way.
// Hardcodded retail value, reason is Z getters can fail... (TO DO: Change to getter when height calculation works on 100%!)
/*killer*/) OVERRIDE
// Used to generate perfect cyclic movements (Enter Circle).
// Don't use any height getters unless all bugs are fixed.
// Function that will change lights of map for all players on map.
// Light.dbc entry (map default)
// Light.dbc entry (override)
// Send packet to all players in Eye of Eternity
// Counter for phases used with a getter.
// Keeps count of arcane trash.
// In retail they use 2 preparing pulses with 7 sec CD, after they pass 2 seconds.
// Last Arcane Overload summoned to know to which should visual be cast to (the purple ball, not bubble).
// Last hit player by Arcane Barrage, will be removed if targets > 1.
// All these three are used to keep current tagets to which warning should be sent.
// Prevent text spamming on killed player by helping implement a CD.
// Used to control attacking (Move Chase not being applied after Stop Attack, only few times should act like this).
// Checks if boss pass through evade on reset.
// Prevents some events being sheduled during Vortex takeoff/land.
// Checks if 10 or 25 man arcane trash will be spawned.
// Used to prevent Malygos casting Arcane Overload shields while leaving platform.
// At first movement start he throws one shield asap, so this check is needed for it only.
// Used to prevent starting Cyclic Movement called in Arcane Bomb event.
// Used to prevent starting some movements right when Destroy Platfrom event starts.
// Used to store base fly speed to prevent stacking on each evade.
/*caster*/, SpellInfo const* spell) OVERRIDE
/*diff*/) OVERRIDE
// When duration of opened riff visual ends, closed one should be cast
// Talk range was not enough for this encounter
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
// not supposed to hide the fact it's there by not selectable
// TO DO: These were a bit faster than what they should be. Not sure what is the reason.
/*seat*/, bool apply) OVERRIDE
/*action*/) OVERRIDE
// how many points are triggered
// TO DO: Something is wrong with calculations for flying creatures that are on WP/Cyclic path.
// They should get the same difference as to when at ground from run creature switch to walk.
/*seat*/, bool apply) OVERRIDE
// Don't use any height getters unless all bugs are fixed.
/*action*/) OVERRIDE
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
/*target*/) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*action*/) OVERRIDE
// If evade is hit during phase II shields should disappear with no delay
/*caster*/, SpellInfo const* spell) OVERRIDE
// SmartAI does not work correctly for vehicles
/*unit*/, int8 /*seat*/, bool apply) OVERRIDE
// We shouldn't use SAI for stuff that aren't within boss main mechanic
// and SAI type of despawn can cause problems here.
/*summoner*/) OVERRIDE
// For some great reason the spell doesn't time it...
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*effIndex*/)
/*spell*/) OVERRIDE
// Resize list only to objects that are vehicles.
/*effIndex*/)
// Both missiles should start approx at same time (with SPELL_ARCANE_STORM_EXTRA_VISUAL having advantage - it should lead)
/*effIndex*/)
// Each player will enter to the trigger vehicle (entry 30090) which is already spawned (each one can hold up to 5 players, it has 5 seats,
// the players enter the vehicles casting SPELL_VORTEX_4 or SPELL_VORTEX_5.
// the rest of the vortex execution continues when SPELL_VORTEX_2 is removed.
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Teleport spell - I'm not sure but might be it must be casted by each vehicle when it's passenger leaves it.
/*effIndex*/)
// If max possible targets are more than 1 then Scions wouldn't select previosly selected target,
// in longer terms this means if spell picks target X then 2nd cast of this spell will pick smth else
// and if 3rd picks X again 4th will pick smth else (by not limiting the cast to certain caster).
// Remove players not on Hover Disk from second list
// if it's empty than we can have player on Hover disk as target.
// Finally here we remove all targets that have been damaged by Arcane Barrage
// and have 2 seconds long aura still lasting. Used to give healers some time.
// Now we resize the list to max output targets which can be only 1
// to take it's guid and send/store it to DATA_LAST_TARGET_BARRAGE_GUID.
// Same target is never picked until next pick pass. This doesn't mean
// that it can't be hit more than once. In fact all is chance and raid speed.
// There is some proc in this spell I have absolutely no idea of use, but just in case...
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
// Adjust effect summon position to lower Z
/*effIndex*/)
/*spell*/) OVERRIDE
// This spell hits only vehicles (SMSG_SPELL_GO target)
// Remove all objects that aren't* vehicles.
// But in fact it selects 3 targets (SMSG_SPELL_GO target are not filtered)
// SetGuid in Malygos AI is reserved for 14th, 15th and 16th Id for the three targets
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// TO DO: This is hack, core doesn't have support for these flags,
// remove line below if it ever gets supported otherwise object won't be accessible.
/*target*/) OVERRIDE
// Only melee disks can be used
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// just in case
/// @todo this should be handled in map, maybe add a summon function in map
// There is no other way afaik...
// Player continues to be moving after death no matter if spline will be cleared along with all movements,
// so on next world tick was all about delay if box will pop or not (when new movement will be registered)
// since in EoE you never stop falling. However root at this precise* moment works,
// it will get cleared on release. If by any chance some lag happen "Reload()" and "RepopMe()" works,
// last test I made now gave me 50/0 of this bug so I can't do more about it.
/*obj*/, uint32 eventId)
// ACTION_LAND_ENCOUNTER_START
// each trigger have to cast the spell to 5 players.
/*value*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Works wrong (affect players, not rifts)
//Don't work, using WA
//No idea, when it's used
//Chaotic Rift visual
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// Not blizzlike, hack to avoid an exploit
//DoCast(Rift, SPELL_CHARGE_RIFT);
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//not used
//Yell
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE
//Return since we have no target
/*killer*/)  OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Spells
//Yell
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/* = 0 */) OVERRIDE
/*player*/, GameObject* go) OVERRIDE
// maybe these are hacks :(
/// @todo the caster should be boss but not the player
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//These times are probably wrong
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
//Return since we have no target
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*attacker*/, uint32& /*damage*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*aurEff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Alliance npcs are spawned by default, if you are alliance, you will fight against horde npcs.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
// start achievement timer (kill Eregos within 20 min)
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Types of drake mounts: Ruby(Tank),  Amber(DPS),  Emerald(Healer)
//Two Repeating phases
// http://www.wowhead.com/achievement=2044
// http://www.wowhead.com/achievement=2045
// http://www.wowhead.com/achievement=2046
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/* Checks for present drakes vehicles from each type and deactivate achievement that corresponds to each found
// TO-DO: See why the spell is not casted
/*attacker*/, uint32& /*damage*/) OVERRIDE
// not sure about the amount, and if we should despawn previous spawns (dragon trashs)
//Return since we have no target
/*killer*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Dummy --> Channeled, shields the caster from damage.
//Urom throws a bomb, hitting its target with the highest aggro which inflict directly 650 frost damage and drops a frost zone on the ground. This zone deals 650 frost damage per second and reduce the movement speed by 35%. Lasts 1 minute.
//Summons an assortment of creatures and teleports the caster to safety.
//Teleports to the center of Oculus
//Deals arcane damage to a random player, and after 6 seconds, deals zone damage to nearby equal to the health missing of the target afflicted by the debuff.
// He always cast it on reset or after teleportation
/*who*/) OVERRIDE
// teleport to next platform and spawn adds
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// we cast the spell as triggered or the summon effect does not occur
/*pCaster*/, const SpellInfo* pSpell) OVERRIDE
//! Unconfirmed, previous below
//me->AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY); // with out it the npc will fall down while is casting
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Damage 5938 to 6562, effec2 Triggers 54069, effect3 Triggers 56251
//Effect    Send Event (12229)
//Effect    Send Event (10665)
/*SPELL_CALL_AZURE_RING_CAPTAIN_2               = 51006, //Effect    Send Event (10665)
//Effect    Send Event (18455)*/
// not sure if this is handled by a timer or hp percentage
/*who*/) OVERRIDE
//Return since we have no target
// not sure how blizz handles this, i cant see any pattern between the differnt spells
/*killer*/) OVERRIDE
// we cast the spell as triggered or the summon effect does not occur
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
/*diff*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// flags taken from sniffs
// UNIT_FLAG_UNK_9 -> means passive but it is not yet implemented in core
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* The Occulus encounters:
/*unit*/, uint32 eventId)
// used by condition system
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*Ruby Drake,
//Apply Aura: Periodic Trigger, Interval: 3 seconds ---> 49464
//Allows you to ride on the back of an Amber Drake. ---> Dummy
//(60 yds) - Instant - Breathes a stream of fire at an enemy dragon, dealing 6800 to 9200 Fire damage and then jumping to additional dragons within 30 yards. Each jump increases the damage by 50%. Affects up to 5 total targets
//Instant - Allows the Ruby Drake to generate Evasive Charges when hit by hostile attacks and spells.
//Instant - 5 sec. cooldown - Allows your drake to dodge all incoming attacks and spells. Requires Evasive Charges to use. Each attack or spell dodged while this ability is active burns one Evasive Charge. Lasts 30 sec. or until all charges are exhausted.
//you do not have acces to until you kill Mage-Lord Urom
//Instant - 10 sec. cooldown - Redirect all harmful spells cast at friendly drakes to yourself for 10 sec.
/*Amber Drake,
//Apply Aura: Periodic Trigger, Interval: 3 seconds ---> 49460
//Allows you to ride on the back of an Amber Drake. ---> Dummy
//(60 yds) - Instant - Deals 4822 to 5602 Arcane damage and detonates all Shock Charges on an enemy dragon. Damage is increased by 6525 for each detonated.
// SPELL_AMBER_STOP_TIME                                        //Instant - 1 min cooldown - Halts the passage of time, freezing all enemy dragons in place for 10 sec. This attack applies 5 Shock Charges to each affected target.
//you do not have access to until you kill the  Mage-Lord Urom.
//(60 yds) - Channeled - Channels a temporal rift on an enemy dragon for 10 sec. While trapped in the rift, all damage done to the target is increased by 100%. In addition, for every 15, 000 damage done to a target affected by Temporal Rift, 1 Shock Charge is generated.
/*Emerald Drake,
//Apply Aura: Periodic Trigger, Interval: 3 seconds ---> 49346
//Allows you to ride on the back of an Amber Drake. ---> Dummy
//(60 yds) - Instant - Poisons the enemy dragon, leeching 1300 to the caster every 2 sec. for 12 sec. Stacks up to 3 times.
//(60 yds) - Instant - Consumes 30% of the caster's max health to inflict 25, 000 nature damage to an enemy dragon and reduce the damage it deals by 25% for 30 sec.
// you do not have access to until you kill the Mage-Lord Urom
//(60 yds) - Channeled - Transfers 5% of the caster's max health to a friendly drake every second for 10 seconds as long as the caster channels.
/*sender*/, uint32 action) OVERRIDE
//Verdisa
//Belgaristrasz
//Eternos
/*type*/, uint32 id) OVERRIDE
// When Belgaristraz finish his moving say grateful text
// The gossip flag should activate when Drakos die and not from DB
// On retail this kills abusive call of drake during engaged Eregos
// TO DO: Drake Ques should be casted from vehicle to player, however the way core handle triggered spells from auras break it no matter the conditions. So this change the caster and give the same result until someone fix triggered spells from auras that involve implicit targets or make exception for this case.
// Needed this for proper animation after spawn, the summon in air fall to ground bug leave no other option for now, if this isn't used the drake will only walk on move.
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*effIndex*/)
// Adjust effect summon position
/*effIndex*/)
// Used to cast visual effect at proper position
/*effIndex*/)
/*aurEff*/, int32& amount, bool& canBeRecalculated)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//SPELL_DEFENSIVE_AURA                    = 41105,
//SPELL_BERSEKER_AURA                     = 41107,
//SPELL_BATTLE_AURA                       = 41106,
//OTHER SPELLS
//SPELL_CHARGE_UP                         = 52098,      // only used when starting walk from one platform to the other
// triggered part of above
/*######
/*who*/) OVERRIDE
//must get both lieutenants here and make sure they are with him
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/// @todo remove when removal is done by the core
//Return since we have no target
// Change stance
//wait for current spell to finish before change stance
//not much point is this, better random target and more often?
/*######
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//Spark of Ionar
// Distance to boss - prevent runs through the whole instance
/*######
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
//make sparks come back
//should never be empty here, but check
/*pDoneBy*/, uint32 &uiDamage) OVERRIDE
//Return since we have no target
// Splitted
// Return sparks to where Ionar splitted
// Lightning effect and restore Ionar
// Health check
/*######
/*pDoneBy*/, uint32 &uiDamage) OVERRIDE
// Despawn if the encounter is not running
// Prevent them to follow players through the whole instance
// No melee attack at all!
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*######
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
//Return since we have no target
// this flag breaks movement
// Pause Pulsing Shockwave aura
// Health check
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Molten Golem
/*######
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// Only shatter brittle golems
// Why healing when just summoned?
// When to start shatter? After 60, 40 or 20% hp?
// Should he stomp even if he has no brittle golem to shatter?
// Shatter Golems 3 seconds after Shattering Stomp
// Health check
// 1 - Start run to Anvil
// Set Next Phase
// 2 - Check if reached Anvil
// This is handled in: void JustReachedHome() OVERRIDE
// 3 - Cast Temper on the Anvil
// Delay 2 seconds before next phase can begin
// Set Next Phase
// 4 - Wait for delay to expire
// 5 - Spawn the Golems
// Reset back to Phase 0 for next time
/*######
/*pDoneBy*/, uint32 &uiDamage) OVERRIDE
// me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);  //Set in DB
// me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE); //Set in DB
/*pCaster*/, const SpellInfo* pSpell) OVERRIDE
// This is the dummy effect of the spells
// Return since we have no target or if we are frozen
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*target*/, const SpellInfo* pSpell) OVERRIDE
//this part should be in the core
/// @todo we need eventmap to kill this stuff
//clear this, if we are still performing
//and correct movement, if not already
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Periodic Trigger (interval 2s) spell = 50841
// Periodic Trigger (interval 2s) spell = 50841
// Periodic Trigger 2s interval, spell =50835
// left
// right
/*if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
/*killer*/) OVERRIDE
/// @todo: add emote
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Kadrak
// Marnak
// Abedneum
/*GetCreatureListWithEntryInGrid(lKaddrakGUIDList, me, CREATURE_KADDRAK, 50.0f);
/*sender*/, uint32 action) OVERRIDE
/*done_by*/, uint32 & /*damage*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*= NULL*/) const OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Algalon the Observer
// Algalon Stalker
// Triggers Living Constellation
// Living Constellation
// Collapsing Star
// Black Hole
// Worm Hole
// Celestial Planetarium Access
// Brann Bronzebeard
// Algalon the Observer
// Living Constellation
/*diff*/)
// delete event
/*execTime*/, uint32 /*diff*/)
/*diff*/)
/*target*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
//! Workaround for Creature::_IsTargetAcceptable returning false
//! for creatures that start combat in REACT_PASSIVE and UNIT_FLAG_NOT_SELECTABLE
//! causing them to immediately evade
/*type*/) const OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
// Start Algalon event
/*aurEff*/)
/*aurEff*/)
/*aurEff*/)
/*effIndex*/)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// General
// Hard enrage, don't know the correct ID.
// spell_dbc
// Steelbreaker
// Runemaster Molgeim
// This is the spell that summons the rune
// Spell that summons
// Stormcaller Brundir
// General
// Steelbreaker
// Molgeim
// Brundir
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//DoCastAOE(SPELL_SUPERCHARGE, true);
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//DoCastAOE(SPELL_SUPERCHARGE, true);
// Should be interruptable unless overridden by spell (Overload)
// Reset immumity, Brundir should be stunnable by default
/*who*/) OVERRIDE
// Apply immumity to stuns
/*killer*/) OVERRIDE
//DoCastAOE(SPELL_SUPERCHARGE, true);
// Prevent to have Brundir somewhere in the air when he die in Air phase
//me->SetLevitate(true);
//me->SetLevitate(false);
// Prevention to go outside the room or into the walls
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*effIndex*/)
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Auriaya
// Feral Defender
// Sanctum Sentry
// Auriaya
// Sanctum Sentry
// Feral Defender
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Passive
//TOWER Additional SPELLS
// Tower of Storms
// Tower of Flames
// Tower of Frost
// Tower of Nature
// Tower of Nature
//TOWER ap & health spells
//Additional Spells
// Hard mode starter
// Trigger tied to towers
// Tower of Storms
// Tower of Flames
// Tower of Frost
// Tower of Nature
// 2911, 2912 are achievement IDs
// Other Actions are in Ulduar.h
// Amount of seats depending on Raid mode
//resets shutdown counter to 0.  2 or 4 depending on raid mode
/*who*/) OVERRIDE
//void ActiveTower
/*killer*/) OVERRIDE
// Set Field Flags 67108928 = 64 | 67108864 = UNIT_FLAG_UNK_6 | UNIT_FLAG_SKINNABLE
// Set DynFlags 12
// Set NPCFlags 0
/*caster*/, SpellInfo const* spell) OVERRIDE
// Only on HardMode
// Will select target in spellscript
// Tower of Storms
// Tower of Flames
// Tower of Frost
// Tower of Nature
// Tower destruction, debuff leviathan loot and reduce active tower count
// Activate hard-mode enable all towers, apply buffs on leviathan
// Triggered by 2 Collossus near door
// position center
//! Copypasta from DoSpellAttackIfReady, only difference is the target - it cannot be selected trough GetVictim this way -
//! I also removed the spellInfo check
// unselectable
// unselectable
/*clicker*/, bool& result) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
//check next 30 seconds
/*who*/, uint32& damage) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*diff*/) OVERRIDE
/*waypointId*/) OVERRIDE
/*diff*/) OVERRIDE
//npc lore keeper
// Start encounter
/*sender*/, uint32 action) OVERRIDE
//make sure leviathan is loaded
// spawn the vehicles
/// @todo Delorah->AI()->Talk(xxxx, Branz); when reached at branz
//enable hardmode
////npc_brann_bronzebeard this requires more work involving area triggers. if reached this guy speaks through his radio..
//#define GOSSIP_ITEM_1  "xxxxx"
//#define GOSSIP_ITEM_2  "xxxxx"
//
/*
//bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) OVERRIDE
//{
//    player->PlayerTalkClass->ClearMenus();
//    switch (action)
//    {
//        case GOSSIP_ACTION_INFO_DEF+1:
//            if (player)
//            {
//                player->PrepareGossipMenu(creature);
//
//                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
//                player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
//            }
//            break;
//        case GOSSIP_ACTION_INFO_DEF+2:
//            if (player)
//                player->CLOSE_GOSSIP_MENU();
//            if (Creature* Lorekeeper = creature->FindNearestCreature(NPC_LOREKEEPER, 1000, true)) //lore keeper of lorgannon
//                Lorekeeper->RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
//            break;
//    }
//    return true;
//}
//bool OnGossipHello(Player* player, Creature* creature) OVERRIDE
//{
//    InstanceScript* instance = creature->GetInstanceScript();
//    if (instance && instance->GetData(BOSS_LEVIATHAN) !=DONE)
//    {
//        player->PrepareGossipMenu(creature);
//
//        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
//        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
//    }
//    return true;
//}
//
/*player*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Check presence of dummy aura indicating cooldown
//! Currently this doesn't work: if we call PreventHitAura(), the existing aura will be removed
//! because of recent aura refreshing changes. Since removing the existing aura negates the idea
//! of a cooldown marker, we just let the dummy aura refresh itself without executing the other spelleffects.
//! The spelleffects can be executed by letting the dummy aura expire naturally.
//! This is a temporary solution only.
//PreventHitAura();
/*eff*/)
// Actually should/could use basepoints (100) for this spell effect as percentage of health, but oh well.
// For achievement
/*aurEff*/, AuraEffectHandleModes /*mode*/)
//! This could probably in the SPELL_EFFECT_SEND_EVENT handler too:
/*aurEff*/, AuraEffectHandleModes /*mode*/)
//! No players, only vehicles (@todo check if blizzlike)
//! NPC entries must match
//! NPC must be a valid vehicle installation
//! Entity needs to be in appropriate area
//! Vehicle must be in use by player
//! In the end, only one target should be selected
/*eff*/)
// Chase target
// use 99 because it is 3d search
// now we use *2 because the location of the seat is not correct
// new npc_brann_bronzebeard();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Freya
// Elder Brightleaf / Elder Ironbranch / Elder Stonebark
// Freya
// Stonebark
// Ironbranch
// Brightleaf
// Trigger 62221
// Stack Removing of Attuned to Nature
// Achievement spells
// Wave summoning spells
// Detonating Lasher
// Ancient Water Spirit
// Storm Lasher
// Snaplasher
// Ancient Conservator
// Not used, triggered by SPELL_SUMMON_PERIODIC
// Healthly Spore
// Eonar's Gift
// Nature Bomb
// Unstable Sun Beam
// Or maybe 62866?
// Sun Beam
// Attuned To Nature spells
// Freya
// Elder Stonebark
// Elder Ironbranch
// Elder Brightleaf
// Normal wave is one minute
// If difference between waveTime and WAVE_TIME is bigger then TIME_DIFFERENCE, schedule EVENT_WAVE in 10 seconds
// Death Grip
// Summoner is a player, who should have root aura on self
/*killer*/) OVERRIDE
//! Why?
// If set to 6 The Bombs appear during the Final Add wave
// This must be casted by Target self
// For achievement check
// For getting time difference for Deforestation achievement
// Elementals must be killed within 12 seconds of each other, or they will all revive and heal
// Do *NOT* merge this bool with bool few lines below!
// Check if all Trio NPCs are dead - achievement check
// Type must be in format of a binary mask
// Handling received data
// We have created "instances" for keeping informations about last 6 death lashers - needed because of respawning
// Time
// Type
// Check for achievement completion
// Check for proper functionality of binary masks (overflow would not be problem)
// Count binary mask
// Time check
// Binary mask check - verification of lasher types
// Random order of spawning waves
/*killer*/) OVERRIDE
//! Freya's chest is dynamically spawned on death by different spells.
/* 0Elder, 1Elder, 2Elder, 3Elder */
/* 10N */    {62950, 62953, 62955, 62957},
/* 25N */    {62952, 62954, 62956, 62958}
// Need to have it there, or summoned units would do nothing untill attacked
/*who*/) OVERRIDE
/*who*/) OVERRIDE
/*who*/) OVERRIDE
// Switching to other target - modify aggro of new target by 20% from current target's aggro
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
/*killer*/) OVERRIDE
/*effIndex*/)
// Not good at all, but this prevents having roots in a different position then player
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Saronite Vapor
// Vezax
// Saronite Animus
// Saronite Vapor
// HardMode
// Check against getting a HardMode achievement before killing Saronite Animus
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// If Shaman has Shamanistic Rage and use it during the fight, it will cast Corrupted Rage on him
/*  Player Range Check
/*killer*/) OVERRIDE
// Death Grip jump effect
/*who*/, uint32& damage) OVERRIDE
// This can't be on JustDied. In 63322 dummy handler caster needs to be this NPC
// if caster == target then damage mods will increase the damage taken
/*spellInfo*/)
/*spell*/) OVERRIDE
/*mode*/)
// mana restore - bp * 2^stackamount
/*player*/, Unit* target) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* @todo Achievements
// Hodir
// Needed for Achievement Getting Cold In Here
// Player + Helper
// Helper
// Player + Helper
// Helper
// Druids
// Shamans
// Mages
// Priests
// Hodir
// Priest
// Shaman
// Druid
// Mage
// 2967, 2968 are achievement IDs
// Field Medic Penny    &&  Battle-Priest Eliza
// Eivi Nightfeather    &&  Tor Greycloud
// Elementalist Mahfuun &&  Spiritwalker Tara
// Missy Flamecuffs     &&  Amira Blazeweaver
// Field Medic Jessi    &&  Battle-Priest Gina
// Ellie Nightfeather   &&  Kar Greycloud
// Elementalist Avuun   &&  Spiritwalker Yona
// Sissy Flamecuffs     &&  Veesha Blazeweaver
// Prevents to have Ice Block on other place than target is
// Prevents to have Ice Block on other place than target is
/*damage*/) OVERRIDE
/*who*/) OVERRIDE
/*who*/, uint32& damage) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/, const SpellInfo* spell) OVERRIDE
/*aurEff*/)
/*aurEff*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Iron Construct
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Shattered Achievement
/*attacker*/, uint32& damage) OVERRIDE
/*uiDiff*/) OVERRIDE
// Water pools
//model 2 in db cannot overwrite wdb fields
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Passive
// Not found in DBC
// guess
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Prevent corpse from despawning.
/*seatId*/, bool apply) OVERRIDE
// absence of break intended
// One of the above spells is a channeled spell, we need to clear this unit state for MoveChase to work
// Victim gets 67351
/*effIndex*/)
// predicate function to select non main tank target
// Remove "main tank" and non-player targets
// Maximum affected targets per difficulty mode
// Return a random amount of targets based on maxTargets
// For subsequent effects
// Shared between effects
/*effIndex*/)
/*effIndex*/)
//! Proper exit position does not work currently,
//! See documentation in void Unit::ExitVehicle(Position const* exitPosition)
//! This will be called when Right Arm (vehicle) has sustained a specific amount of damage depending on instance mode
//! What we do here is remove all harmful aura's related and teleport to safe spot.
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Remove pending passengers before exiting vehicle - might cause an Uninstall
// Temporarily relocate player to vehicle exit dest serverside to send proper fall movement
// beats me why blizzard sends these 2 spline packets one after another instantly
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Leviathan MK II
// VX 001
// Aerial Command Unit
// Additonal spells
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/// @todo Harpoon chain from 62505 should not get removed when other chain is applied
// Expedition Commander
// Expedition Engineer
// unused
// Razorscale Controller
// Razorscale
// Additonal Spells
// Devouring Flame Spells
// HarpoonSpells
// MoleMachine Spells
// Dark Rune Watcher
// Dark Rune Guardian
// Dark Rune Sentinel
// Razorscale Controller
// 2919, 2921 are achievement IDs
/*caster*/, SpellInfo const* spell) OVERRIDE
/*killer*/) OVERRIDE
//only nearest broken harpoon
/*player*/, GameObject* go) OVERRIDE
// Do not let Razorscale be affected by Battle Shout buff
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
// Adds will come in waves from mole machines. One mole can spawn a Dark Rune Watcher
// with 1-2 Guardians, or a lone Sentinel. Up to 4 mole machines can spawn adds at any given time.
// Safe range is between 500 and 650
// Safe range is between -235 and -145
// Ground level
/*sender*/, uint32 action) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//SPELLS @todo
//
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Cast by 33337 at Heartbreak:
// Summons 33344
// Summons 33343
// Summons 33346
// Cast by 33329 on 33337 (visual?)
// Triggers 62826 - needs spellscript for periodic tick to cast one of the random spells above
// Cast on self?
//------------------VOID ZONE--------------------
// Life Spark
//----------------XT-002 HEART-------------------
// Channeled
//---------------XM-024 PUMMELLER----------------
// Scrabot:
//------------------BOOMBOT-----------------------
// Achievement-related spells
// Life Spark
// Pummeller
// Timers may be off
/*-------------------------------------------------------
///----------------------------------------------------
/*who*/) OVERRIDE
//Tantrum is casted a bit slower the first time.
/*killer*/) OVERRIDE
/*attacker*/, uint32& /*damage*/) OVERRIDE
/*seatId*/, bool apply) OVERRIDE
// Need this so we can properly determine when to expose heart again in damagetaken hook
// WIll make creature untargetable
// Channeled
// Start "end of phase 2 timer"
// Phase 2 has officially started
// Achievement related
// Did a scrapbot recover XT-002's health during the encounter?
// Are we in hard mode? Or: was the heart killed during phase 2?
// Did someone die because of Gravity Bomb damage?
/*-------------------------------------------------------
///----------------------------------------------------
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*-------------------------------------------------------
///----------------------------------------------------
// Unapply vehicle aura again
/*-------------------------------------------------------
///----------------------------------------------------
/*-------------------------------------------------------
///----------------------------------------------------
/*time*/, uint32 /*diff*/)
// This hack is here because we suspect our implementation of spell effect execution on targets
// is done in the wrong order. We suspect that EFFECT_0 needs to be applied on all targets,
// then EFFECT_1, etc - instead of applying each effect on target1, then target2, etc.
// The above situation causes the visual for this spell to be bugged, so we remove the instakill
// effect and implement a script hack for that.
// For achievement
// HACK/workaround:
// these values aren't confirmed - lack of data - and the values in DB are incorrect
// these values are needed for correct damage of Boom spell
/// @todo proper waypoints?
/*who*/, uint32& damage) OVERRIDE
// Prevent recursive calls
// Visual only seems to work if the instant kill event is delayed or the spell itself is delayed
// Casting done from player and caster source has the same targetinfo flags,
// so that can't be the issue
// See BoomEvent class
// Schedule 1s delayed
/*diff*/) OVERRIDE
// No melee attack
/*-------------------------------------------------------
///----------------------------------------------------
// first one is immediate.
/*spell*/) OVERRIDE
/*mode*/)
// Heartbreak aura indicating hard mode
/*spell*/) OVERRIDE
/*mode*/)
// Heartbreak aura indicating hard mode
/*eff*/)
/*spell*/) OVERRIDE
/*effIndex*/)
// This should probably be incorporated in a dummy effect handler, but I've had trouble getting the correct target
// Weighed randomization (approximation)
/*eff*/)
/*eff*/)
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Sara
// screams randomly in a whole instance, unused on retail
// screams randomly in a whole instance, unused on retail
// Yogg-Saron
// Voice of Yogg-Saron
// Brain of Yogg-Saron
// Ominous Cloud
// Keepers
// Yogg-Saron illusions
// Neltharion
// Ysera
// Malygos
// Immolated Champion
// The Lich King
// Garona
// King Llane
// Voice of Yogg-Saron
//SPELL_CLEAR_INSANE                      = 63122,  // when it should be casted?
// Sara
// red beam
// yellow beam
// Ominous Cloud
// Guardian of Yogg-Saron
// Yogg-Saron
// Brain of Yogg-Saron
// Tentacles
// used by Corruptor Tentacle and Crusher Tentacle only
// Crusher Tentacle
//SPELL_CRUSH_2                           = 65201,  // triggered by SPELL_CRUSH, basepoints of SPELL_MALADY_OF_THE_MIND
// Constrictor Tentacle
// Corruptor Tentacle
// Immortal Guardian
// Keepers at Observation Ring
// Keepers
// Mimiron
// Freya
// Sanity Well
// Thorim
// Hodir
// Death Orb
// Death Ray
// Laughing Skull
// Descend Into Madness
// Illusions
// Suit of Armor
// Dragon Consorts & Deathsworn Zealot
// Garona
// King Llane
// The Lich King
// Turned Champion
// Player self cast spells
// Voice of Yogg-Saron
// handled by Voice, timer starts at the beginning of the fight (Yogg-Saron is not spawned at this moment)
// Sara
// Tentacles
// Yogg-Saron
// only on 25-man with 0-3 keepers active (Hard Mode)
// Guardian of Yogg-Saron
// Immortal Guardian
// Keepers
// Chamber Illusion
// Icecrown Illusion
// Stormwind Illusion
// Freya
// Hodir
// Thorim
// Mimiron
// Freya
// Hodir
// Thorim
// Mimiron
// Garona end position
// Saurfang end position
/*time*/, uint32 /*diff*/)
// TODO: MoveInLineOfSight doesn't work for such a big distance
// not sure, spoken by Sara (sound), regarding to wowwiki Voice whispers it
/*who*/) OVERRIDE
// 15 minutes
// don't despawn Yogg-Saron's corpse, remove him from SummonList!
// don't summon tentacles when illusion is shattered, delay them
// cast it again after a short while, players can survive
// wowwiki says 80 secs, wowhead says something about 90 secs
// called once for each target on aura remove
/*attacker*/, uint32& damage) OVERRIDE
/*target*/, SpellInfo const* spell) OVERRIDE
/*who*/) OVERRIDE
// almost never casted at scheduled time, why?
// Sara does nothing in phase 3
/*caster*/, SpellInfo const* spell) OVERRIDE
/*killer*/) OVERRIDE
// timer guessed
// timer guessed
/*attacker*/, uint32& damage) OVERRIDE
// it doesn't seem to hit Yogg-Saron here
/*diff*/) OVERRIDE { }
// make sure doors won't be opened
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
// Guardian can be summoned both by Voice of Yogg-Saron and by Ominous Cloud
/*seatId*/, bool apply) OVERRIDE
/*diff*/) OVERRIDE
/*summoner*/) OVERRIDE
// update timers when the Diminish Power is not being channeled so the next one
// is not cast immediately after interrupt
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*attacker*/, uint32& damage) OVERRIDE
// or set immune to damage? should be done here or in SPELL_WEAKENED spell script?
// not visible here
/*action*/) OVERRIDE
/*diff*/) OVERRIDE { }
/*summoner*/) OVERRIDE
// can we skip removing this aura somehow?
/*who*/) OVERRIDE
// setting the phases is only for Thorim and Mimiron
/*summoner*/) OVERRIDE
// i think the first Talk should be delayed as in this moment
// players are too far away to be able to see it
// same here
// "A thousand deaths..."
// TODO: use "or one murder." sound and split the text in DB
// don't evade, otherwise the Lunatic Gaze aura is removed
/*diff*/) OVERRIDE { }
// 63744, 63745, 63747, 65206
/*effIndex*/)
/*effIndex*/)
// 63795, 65301
// 63830, 63881
/*spell*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 63802
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 63803
// 63030
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 64465
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 64466
/*effIndex*/)
// 64467
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// it works, but is it scripted correctly? why is it aura with 2500ms duration?
// 64132
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 64131
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 64125
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// should tentacle die or just release its target?
// 64148
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// not sure about SPELL_WEAKENED part, where should it be handled?
// 64161
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/)
// 64069
/*effIndex*/)
// 65238
/*effIndex*/)
// 63882
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// TODO: set better movement
// 63993
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 64010, 64013
/*mode*/)
// 64012
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 63305
/*spellInfo*/) OVERRIDE
// 64059
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 63050
// don't target players outside of room or handle it in SPELL_INSANE_PERIODIC?
/*spellInfo*/) OVERRIDE
/*aurEff*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 63120
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 64555
/*effIndex*/)
// 64164, 64168
// 62650, 62670, 62671, 62702
// 63984
/*effIndex*/)
// 64184
// 64172
/*effIndex*/)
// 64174
/*spellInfo*/) OVERRIDE
/*aurEff*/, DamageInfo& dmgInfo, uint32& absorbAmount)
// or absorbAmount = dmgInfo.GetDamage() - GetTarget()->GetHealth() + 1
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Creatures
// GameObjects
// Miscellaneous
// Keepers at Observation Ring
// Keepers in Yogg-Saron's room
// Razorscale
// XT-002 Deconstructor
// Assembly of Iron
// Hodir
// Freya
// Yogg-Saron
// Algalon
//! These creatures are summoned by something else than Algalon
//! but need to be controlled/despawned by him - so they need to be
//! registered in his summon list
/*gameObject*/, uint32 eventId) OVERRIDE
// Flame Leviathan's Tower Event triggers
/*ACTION_SANITY_WELLS*/);
/*ACTION_FLASH_FREEZE*/);
// get item level (recheck weapons)
// get item level (armor cannot be swapped in combat)
/*type*/, uint64 /*data*/) OVERRIDE
// Razorscale
// XT-002 Deconstructor
// Assembly of Iron
// Freya
// Yogg-Saron
// Algalon
/* = NULL */, uint32 /* = 0 */) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*gameObject*/, uint32 sender, uint32 action) OVERRIDE
//count of 2 collossus death
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Ingvar (Human)
// Ingvar (Undead)
// Annhylde The Caller
// Ingvar Spells human form
// Spawn resurrect effect around Ingvar
// Ingvar Spells undead form
// Spells for Annhylde
// Heal Max + DummyAura
// Channeling Beam of Annhylde
// Some Emote Dummy?
/*doneBy*/, uint32& damage) OVERRIDE
/// @todo: should be death persistent
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
// PHASE ONE
// PHASE TWO
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*diff*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
// checked from sniffs - the player casts the spell
// I could not found any spell casted for this
/*doneBy*/, uint32& damage) OVERRIDE
// There are some issues with pets
// they will still attack. I would say it is a PetAI bug
// from sniffs
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*source*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// signed for 24200, but used by 24200, 27390
// signed for 24201, but used by 24201, 27389
// Spells of Skarvald and his Ghost
// Spells of Dalronn and his Ghost
/*who*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
/*actionId*/)
//DoCast(me, SPELL_SUMMON_SKARVALD_GHOST, true);
/*who*/) OVERRIDE
/*actionId*/)
//DoCast(me, SPELL_SUMMON_DALRONN_GHOST, true);
//give a 100ms pause to try cast other spells
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/* aurEff */, AuraEffectHandleModes /* mode */)
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//Orb spells
//not in db
//SAY_DEATH                                = 2 Missing in database
/// There is a good reason to store them like this, we are going to shuffle the order.
/// This ensures a random order and only executes each phase once.
/*who*/) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
//Talk(SAY_DEATH);
/*victim*/) OVERRIDE
//send orb to summon spot
//ravenous furbolg's spells
//Return since we have no target
/*killer*/) OVERRIDE
//frenzied worgen's spells
//Return since we have no target
/*killer*/) OVERRIDE
//ferocious rhino's spells
//Return since we have no target
/*killer*/) OVERRIDE
//massive jormungar's spells
//Return since we have no target
/*killer*/) OVERRIDE
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
// Boss
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// Triggers Left
// 8
// 9
//10
//11
//12
//13
//14
//15
//16
//17
//18
//19
//20
//21
//22
//23
//24
//25
//26
//27
//28
//29
//30
//31
//32
//33
//34
//35
//36
//37
// Triggers Right
//38
//39
//40
//41
//42
//43
//44
//45
//46
//47
//48
//49
//50
//51
//52
//53
//54
//55
//56
//57
//58
//59
//60
//61
//62
//63
//64
//65
//66
//67
//68
// Breach Zone
//69
//70
//71
// Skadi Spells
//isn't being casted =/
//random target, but not the tank approx. every 20s
/*who*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
//Return since we have no target
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// caster effect only, triggers event 17841
// triggers 48277 & 59930, needs NPC_RITUAL_TARGET as spell_script_target
// Ritual Channeler spells
// Scourge Hulk spells
// Svala
// Svala Sorrowgrave
// Image of Arthas
// Image of Arthas
// Svala after transformation
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*target*/, const SpellInfo* spell) OVERRIDE
// spectators flee event
//Return since we have no target
//SACRIFICING
// spawn ritual channelers
// Prevent knocking back a ritual player
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Script Data Start
//not in db
// Achievement King's Bane
/*who*/) OVERRIDE
// should be on spirit
//Return since we have no target
// Normal spells ------------------------------------------------------------------------
// Abilities ------------------------------------------------------------------------------
//DoCast(me, SPELL_SUMMON_SPIRIT_FOUNT); // works fine, but using summon has better control
// only one orb
// overtime
// overtime
//DoCast(me, SPELL_SUMMON_AVENGING_SPIRIT); // works fine, but using summon has better control
// overtime
// Health check -----------------------------------------------------------------------------
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Utgarde Pinnacle encounters:
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Not in use
// Spells Archavon
// Archavon Warders
// Archavon
// 15s cd
// 30s cd
// 45s cd
// 300s cd
//mob
// set = 20s cd, unkown cd
// set = 30s cd
// set= 10s cd
/*who*/) OVERRIDE
// Below UpdateAI may need review/debug.
//10y~80y, ignore range
/*######
//npc 32353
/*who*/) OVERRIDE
// 58941 - Rock Shards
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Cast every 45 sec on a random Tempest Minion
// Cast when Overcharged reaches 10 stacks. Mob dies after that
/*######
// AttackStart has NULL-check for victim
/*######
/*killer*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Koralon
// Flame Warder
// Spells Koralon
// don't know the real relation to SPELL_FLAME_CINDER_A atm.
// Spells Flame Warder
/*who*/) OVERRIDE
/// @todo check timer
// 1st after 15sec, then every 45sec
// 1st after 75sec, then every 45sec
/// @todo check timer
/*######
/*who*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// Toravon
// don't know cd... using 20 secs.
// Every 38 sec. cast. (after SPELL_FROZEN_ORB)
// Frost Warder
// don't know cd... using 20 secs.
// Frozen Orb
// priodic dmg aura
// make visible
// Frozen Orb Stalker
// summon orb
// 1 in 10 mode and 3 in 25 mode
/*who*/) OVERRIDE
/*######
/*who*/) OVERRIDE
/*######
// if after this time there is no victim -> destroy!
/*who*/) OVERRIDE
/*######
/*diff*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Vault of Archavon encounters:
// on every death of Archavon, Emalon and Koralon check our achievement
/*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/) OVERRIDE
// instance difficulty check is already done in db (achievement_criteria_data)
// int() for Visual Studio, compile errors with abs(time_t)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
//spam stormstrike in hc mode if spawns are dead
//If one of the adds is dead spawn heals faster
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/// @todo get those positions from spawn of creature 29326
/*who*/) OVERRIDE
// call when explode shall stop.
// either when "hit" by a bubble, or when there is no bubble left.
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Only in heroic
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//Spells
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//NPC_ETHEREAL_SPHERE2                      = 32582, // heroic only?
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
// extra one for heroic
/*killer*/) OVERRIDE
//Return since we have no target
//Is it blizzlike?
// not working right
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
//Return since we have no target
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, Unit* target) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* Violet Hold encounters:
/* Violet hold bosses:
// WP 1
// WP 2
// WP 3
// WP 4
// WP 5
// WP 6
//Cyanigosa's prefight event data
// to kill with crystal
// SPECIAL: pre event animations, IN_PROGRESS: event itself
// Start event
// might not have been reset after a wipe on a boss.
// generic boss state changes
// respawn but avoid to be looted again
// no break
// portals should spawn if other portal is dead and doors are closed
// 1 minute waiting time after each boss fight
// if main event is in progress and players have wiped then reset instance
// Cyanigosa is spawned but not tranformed, prefight event
// if there are NPCs in front of the prison door, which are casting the door seal spell and doors are active
// if door integrity is > 0 then decrase it's integrity state
// else set door state to active (means door will open and group have failed to sustain mob invasion on the door)
// just to make things easier we'll get the gameobject from the map
// the orb
// visuals
// Kill all mobs registered with SetData64(ADD_TRASH_MOB)
/*go*/, uint32 uiEventId)
// Activation by player's will throw event signal
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
//{1825.736084f, 807.305847f, 44.363785f}
//{1825.736084f, 807.305847f, 44.363785f}
//{1825.736084f, 807.305847f, 44.363785f}
//{1825.736084f, 807.305847f, 44.363785f}
//{1827.100342f, 801.605957f, 44.363358f}
//{1827.100342f, 801.605957f, 44.363358f}
//{1826.889648f, 803.929993f, 44.363239f}
/*sender*/, uint32 action) OVERRIDE
// Allow to start event if not started or wiped
// Allow to teleport inside if event is in progress
// 0 - elite mobs   1 - portal guardian or portal keeper with regular mobs
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
//Massive usage of instance, global check
//Don't spawn mobs on boss encounters
// spawn elite mobs and then set portals visibility to make it look like it dissapeard
// if all spawned elites have died kill portal
// spawn portal guardian or portal keeper with regular mobs
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// add the zones affected by the pvp buff
// add buffs
// remove buffs
// send world state update
// send world state update
// complete quest objective
// send these updates to only the ones in this objective
// send this too, sometimes the slider disappears, dunno why :(
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 0 guid, btw it isn't even used in killedmonster function :S
// roosts and bomb wagons are spawned when someone uses the matching destroyed roost
//    m_TypeId = OUTDOOR_PVP_NA; _MUST_ be set in ctor, because of spawns cleanup
// add the zones affected by the pvp buff
// halaa
// add buffs
// remove buffs
/*go*/)
//Adding items
// check space and find places
// bomb id count
// convert to possible store amount
// can't add any
// let the controlling faction advance in phase
// update the guard count for the players in zone
// if the guards have been killed, then the challenger has one hour to take over halaa.
// in case they fail to do it, the guards are respawned, and they have to start again.
// send this too, sometimes the slider disappears, dunno why :(
// send these updates to only the ones in this objective
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*diff*/)
// remove buffs
// remove aura
// reward player
// add 19 honor
// add 20 cenarion circle repu
// complete quest
// remove aura
// reward player
// add 19 honor
// add 20 cenarion circle repu
// complete quest
// if it was dropped away from the player's turn-in point, then create a silithyst mound, if it was dropped near the areatrigger, then it was dispelled by the outdoorpvp, so do nothing
// 5.0f is safe-distance
// he dropped it further, summon mound
// 5.0f is safe-distance
// he dropped it further, summon mound
// despawn go
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// lock timer is down, release lock
// worldstateui update timer is down, update ui with new time data
// remove buffs
// add the zones affected by the pvp buff
// can update even in locked state if gathers the controlling faction
// if gathers the other faction, then only update if the pvp is unlocked
// if changing from controlling alliance to horde
// if changing from controlling horde to alliance
// send this too, sometimes the slider disappears, dunno why :(
// send these updates to only the ones in this objective
// send this too, sometimes it resets :S
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// if changing from controlling alliance to horde
// if changing from controlling horde to alliance
// send this too, sometimes the slider disappears, dunno why :(
// send these updates to only the ones in this objective
// remove buffs
// remove flag
// add the zones affected by the pvp buff
// though the update function isn't used, the handleusego is!
/*diff*/)
// only one gotype is used in the whole outdoor pvp, no need to call it a constant
// rem gy
// add gy
// only one gotype is used in the whole outdoor pvp, no need to call it a constant
// rem gy
// add gy
// add field scouts here
// add neutral banner
// nothing to do here
// if ally already controls the gy and taken back both beacons, return, nothing to do for us
// ally doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
// if horde already controls the gy and taken back both beacons, return, nothing to do for us
// horde doesn't control the gy, but controls the side beacons -> add gossip option, add neutral banner
// if the graveyard is not neutral, then leave it that way
// if the graveyard is neutral, then we have to dispel the buff from the flag carrier
// gy was neutral, thus neutral banner was spawned, it is possible that someone was taking the flag to the gy
// remove flag from carrier, reset flag carrier guid
// send worldstateupdate
/*gso*/)
/*gossipid*/)
// if the flag is already taken, then return
/*player*/, uint32 spellId)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
// When Kazzak kills a player (not pets/totems), he regens some health
/*killer*/) OVERRIDE
// Return since we have no target
/*spell*/) OVERRIDE
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// Remove aura
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//remove enrage before casting earthquake because enrage + earthquake = 16000dmg over 8sec and all dead
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
//Support for quest: You're Fired! (10821)
/*######
/// @todo add support for quest 10512 + Creature abilities
/*uiDiff*/) OVERRIDE
/*######
//Used by 20021, 21817, 21820, 21821, 21823 but not existing in database
/*who*/) OVERRIDE { }
//in case Creature was not summoned (not expected)
//we are nihil, so say before transform
//take off to location above
//anything below here is not interesting for Nihil, so skip it
/*######
/*who*/) OVERRIDE { }
/// @todo Move the below to updateAI and run if this statement == true
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//reset global var
/*######
/*uiDiff*/) OVERRIDE { }
/*######
/*type*/, uint32 id) OVERRIDE
/*diff*/) OVERRIDE
/*######
// Called by color clusters script (go_simon_cluster) and used for knowing the button pressed by player
/*data*/) OVERRIDE
// Used for getting involved player guid. Parameter id is used for defining if is a large(Monument) or small(Relic) node
/*
// We are checking for displayid because all simon nodes have 4 clusters with different entries
// Called when despawning the bunny. Sets all the node GOs to their default states.
/*
/*
// Remove any existant glowing auras over clusters and set clusters ready for interating with them.
/*
// Casts a spell and plays a sound depending on parameter color.
/*
// break since we don't need glowing auras for large clusters
// Handles the spell rewards. The spells also have the QuestCompleteEffect, so quests credits are working.
/*
// Cast SPELL_BAD_PRESS_DAMAGE with scaled basepoints when the visual hits the target.
// Need Fix: When SPELL_BAD_PRESS_TRIGGER hits target it triggers spell SPELL_BAD_PRESS_DAMAGE by itself
// so player gets damage equal to calculated damage  dbc basepoints for SPELL_BAD_PRESS_DAMAGE (~50)
// Checks if player has already die or has get too far from the current node
/*sender*/, uint32 /*action*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*######
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// Change faction so mobs attack
// Spawn two Haal'eshi Talonguard
// Spawn two Haal'eshi Windwalker
// Award quest credit
/*who*/) OVERRIDE
/*######
//check for creature every 5 sec
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//all the textId's for the below is unknown, but i do believe the gossip item texts are proper.
/*sender*/, uint32 action) OVERRIDE
/*#####
/*who*/) OVERRIDE
/*target*/, const SpellInfo* pSpell) OVERRIDE
/*######
/*who*/) OVERRIDE { }
// 18840: Sunspring, 18841: Laughing, 18842: Garadar, 18843: Bleeding
/*######
// first quest
// 2nd quest
// 3rd quest
/*#####
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// This function is for when we summoned enemies to fight - so that does NOT mean we should make our totem count in this!
/*target*/, const SpellInfo* spell) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
//used by 20209, 20417, 20418, 20440, signed for 20209
//ACID mobs should cast this
//ACID mobs should cast this (Manaforge Ara-version)
/*who*/) OVERRIDE { }
/*void SpellHit(Unit* caster, const SpellInfo* spell) OVERRIDE
//we have no way of telling the Creature was hit by spell -> got aura applied after 10-12 seconds
//then no way for the mobs to actually stop the shutdown as intended.
/*killer*/) OVERRIDE
/*######
/// @todo clean up this workaround when Skyfire adds support to do it properly (with gossip selections instead of instant summon)
//b'naar
//coruu
//duro
//ara
/*######
// The Speech of Dawnforge, Ardonis & Pathaleon
// Entries of Arcanist Ardonis, Commander Dawnforge, Pathaleon the Curators Image
// Ardonis
// Dawnforge
// Pathaleon
/*who*/) OVERRIDE { }
// Emote Ardonis and Pathaleon
//Calculate the angle to Pathaleon
//Turn Dawnforge and update
//Turn Ardonis and update
//Set them to kneel
//Set them back to each other
//Turn Dawnforge and update
//Turn Ardonis and update
//Set state
//Is event even running?
//Phase timing
//Phase 1 Dawnforge say
//Phase 2 Ardonis say
//Phase 3 Dawnforge say
//Phase 4 Pathaleon spawns up to phase 9
//spawn pathaleon's image
//Phase 5 Pathaleon say
//Phase 6
//Subphase 1: Turn Dawnforge and Ardonis
//Subphase 2 Dawnforge say
//Phase 7 Pathaleons say 3 Sentence, every sentence need a subphase
//Subphase 1
//Subphase 2
//Subphase 3
//Phase 8 Dawnforge & Ardonis say
//Phase 9 Pathaleons Despawn, Reset Dawnforge & Ardonis angle
//hide pathaleon, unit will despawn shortly
//Phase 10 Dawnforge say
/*at*/) OVERRIDE
//if player lost aura or not have at all, we should not try start event.
/*######
//WHISPER_DABIRI          = 0, not existing in database
//OnQuestAccept:
//if (quest->GetQuestId() == QUEST_DIMENSIUS)
//creature->AI()->Talk(WHISPER_DABIRI, player);
/*sender*/, uint32 action) OVERRIDE
/*######
// Spells
// 25-40
// 5-8 sec cd
//void SpellHit(Unit* /*caster*/, const SpellInfo* /*spell*/) OVERRIDE
/*caster*/, const SpellInfo* /*spell*/) OVERRIDE
//{
//    DoCast(me, SPELL_DE_MATERIALIZE);
//}
// if the mob is rooted/slowed by spells eg.: Entangling Roots, Frost Nova, Hamstring, Crippling Poison, etc. => remove it
// some code to cast spell Mana Burn on random target which has mana
// 8-18 sec cd
// start: support for quest 10190
// end: support for quest 10190
/*######
/*killer*/) OVERRIDE
//first spawn
/*######
//Find Object and "work"
// take the GO -> animation
//return and quest_complete
/*killer*/) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*#####
/*###
// Factions
// Not sure if this is correct, it was taken off of Mordenai.
// Spells
// Creatures
/*
// so it's in the air, not ground*/
/*#####
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
//correct id not known
//correct id not known
//correct id not known
//correct id not known
//correct id not known
//correct id not known
/*######
/*sender*/, uint32 action) OVERRIDE
/*####
/*####
// Red Lightning Bolt
// Mark of Stormrage
// Dragonaw Faction
// Dragonaw Trasform
//OVERLORD_SAY_3                  = 2,
// missing text "Lord Illidan, this is the Dragonmaw that I, and others, have told you about. He will lead us to victory!"
/*####
//guessed
//this is very unclear, random say without no real relevance to script/event
//unknown where they actually appear
//don't always use
//only aggro text if not player
//appears to be random
/// @todo add more abilities
/*#####
/* ContentData
//65yds
//in ms. appear after event completed or failed (should be = Adds despawn time)
// Creature 0 - Torloth, 1 - Illidan
// Torloth stand
//Cordinates for Spawns
//Cords used for:
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Soldier
//Illidari Mind Breaker
//Illidari Mind Breaker
//Illidari Highlord
//Illidari Highlord
//Illidari Highlord
//Illidari Highlord
//Torloth The Magnificent
//Illidari Soldier
//Illidari Mind Breaker
//Illidari Highlord
//Torloth The Magnificent
// Illidari Soldier Cast - Spellbreaker
// Illidari Mind Breake Cast - Focused Bursts
// Illidari Mind Breake Cast - Psychic Scream
// Illidari Mind Breake Cast - Mind Blast
// Illidari Highlord Cast - Curse of Flames
// Illidari Highlord Cast - Flamestrike
// Torloth the Magnificent Cast - Cleave
// Torloth the Magnificent Cast - Shadowfury
// Torloth the Magnificent Cast - Spell Reflection
/*######
/*who*/)OVERRIDE { }
//Cleave
//Shadowfury
//Spell Reflection
/*#####
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
//Illidari Soldier
//Illidari Mind Breaker
// Illidari Highlord
//Illidari Soldier
//Spellbreaker
//Illidari Mind Breaker
//Focused Bursts
//Psychic Scream
//Mind Blast
//Illidari Highlord
//Curse Of Flames
//Flamestrike
//1 Wave
//1-3 Wave
// Torloth
/*#####
/*go*/, Quest const* quest) OVERRIDE
/*####
// QUESTS
// Totem
// SPIRITS
// SOULS
// wrong model
// SPELL KILLCREDIT - not working!?! - using KilledMonsterCredit
// KilledMonsterCredit Workaround
// Captured Spell / Buff
// Factions
/*who*/)OVERRIDE { }
/*killer*/) OVERRIDE
// always spawn spirit on death
// if totem around
// move spirit to totem and cast kill count
//credit = SPELL_FIERY_SOUL_CAPTURED_CREDIT;
//credit = SPELL_EARTHEN_SOUL_CAPTURED_CREDIT;
//credit = SPELL_AIRY_SOUL_CAPTURED_CREDIT;
//credit = SPELL_WATERY_SOUL_CAPTURED_CREDIT;
// Spawn Soul on Kill ALWAYS!
// FIND TOTEM, PROCESS QUEST
// Spawn chest GO
// Despawn the tuber
// @Workaround: find how to properly despawn the GO
/*caster*/, const SpellInfo* spell) OVERRIDE
// Disable trigger and force nearest boar to walk to him
// Respawn the tuber
// @Workaround: find how to properly respawn the GO
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// Factions
// Quests
// Spells
/*
/*sender*/, uint32 action) OVERRIDE
// Aldor vendor
// Scryers vendor
/*######
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
//6th too this
/*sender*/, uint32 action) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*who*/) OVERRIDE { }
//DoCast(me, SPELL_QUID9889);        //not using spell for now
/*######
/*who*/) OVERRIDE { }
//Summon Wood Mites
/*######
/*who*/) OVERRIDE { }
/*######
/*who*/) OVERRIDE { }
//Summon Lots of Wood Mights
/*######
//SPELL_FREE_WEBBED       = 38950
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*######
/*sender*/, uint32 action) OVERRIDE
/*who*/) OVERRIDE { }
/*######
/*killer*/) OVERRIDE
/*######
/*go*/, uint32 action)
/*######
/*sender*/, uint32 action) OVERRIDE
/*########
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*sender*/, uint32 action) OVERRIDE
//set a "fake" mana value, we can't depend on database doing it in this case
//check which Creature we are dealing with
//mark of lore
//mark of war
/*######
/*who*/) OVERRIDE { }
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Avatar of Martyred
/*who*/) OVERRIDE
/*who*/) OVERRIDE
//SPELL_STOLEN_SOUL_VISUAL has shapeshift effect, but not implemented feature in Skyfire for this spell.
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//When Exarch Maladar is defeated D'ore appear.
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//need to find better visual
/*who*/) OVERRIDE
//Inhibitmagic_Timer
//Return since we have no target
//Attractmagic_Timer
//Carnivorousbite_Timer
//FocusFire_Timer
// Summon Focus Fire & Emote
/*who*/) OVERRIDE
//Return since we have no target
//FieryBlast_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Summons NPC_BEACON
// Ethereal Beacon
// Summon 18430
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//expire movement, will prevent from running right back to victim after cast
//(but should MoveChase be used again at a certain time or should he not move?)
// Send Shaffar to fight
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//_Reset();
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/, uint32 &damage) OVERRIDE
// TODO: Add pathing for Brood of Anzu
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//37865
//15305
// Spawns 19203
// Spawns 19205
// Spawns 19204
// Spawns 19206
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//front
//back
//left
//right
/* ELEMENTALS */
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//who->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//second top aggro target in normal, random target in heroic correct?
//may not be correct time to cast
//Spell doesn't work, but we use for visual effect at least
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*waypointId*/) OVERRIDE
// this will not work, because he is immune to banish
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//debuff applied to each member of party
//below, not used
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// enrage at 20%
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Spell
// Text
// database should have `RegenHealth`=0 to prevent regen
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// Select nearest most aggro target if top aggro too far
// 33923, 38796 - Sonic Boom
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 33666, 38795 - Sonic Boom Effect
/// @todo: find correct value
// 39365 - Thundering Storm
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Spirit of Olum
// Wrathbone Flayer
// Wrathbone Flayer
// ########################################################
// Spirit of Olum
// ########################################################
/*sender*/, uint32 action) OVERRIDE
// ########################################################
// Wrathbone Flayer
// ########################################################
/*killer*/) OVERRIDE { }
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Speech'n'Sound
//Spells
// This spell is AoE whereas it shouldn't be
// 1000 Physical damage + knockback + script effect (should handle threat reduction I think)
// 1000 Physical damage + Stun (used in phase 2?)
//This is used to sort the players by distance in preparation for the Bloodboil cast.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Note: This seems like a very complicated fix. The fix needs to be handled by the core, as implementation of limited-target AoE spells are still not limited.
// Get the Threat List
// He doesn't have anyone in his threatlist, useless to continue
//store the threat list in a different container
//only on alive players
//Sort the list of players
//Resize so we only get top 5
//Aura each player in the targets list with Bloodboil. Aura code copied+pasted from Aura command in Level3.cpp
/*SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SPELL_BLOODBOIL);
// Only cast it five times.
//CastBloodboil(); // Causes issues on windows, so is commented out.
// If VMaps are disabled, this spell can call the whole instance
/* These spells do not work, comment them out for now.
//Cast this without triggered so that it appears in combat logs and shows visual.
// Encounter is a loop pretty much. Phase 1 -> Phase 2 -> Phase 1 -> Phase 2 till death or enrage
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Other defines
// Akama
// Illidan
// Maiev Shadowsong
// Flame of Azzinoth
// Normal Form
// 41032 is bugged, cannot be block/dodge/parry// Reduces Max. Health by 60% for 7 seconds. Can stack 19 times. 1.5f second cast
// Flying (Phase 2)
// Animation for the spell above
// Demon Form
// The actual damage. Have each player cast it on itself (workaround)
// Other Illidan spells
// Before beginning encounter, this is how he appears (talking to skully).
// Phase Normal spells
// Phase Flight spells
// Glaives cast it on Flames. Not sure if this is the right spell.
// Akama spells
// Not sure where this is really used...
// Maiev spells
// Put this in DB for cage trap GO.
// Summons a Cage Trap GO (bugged) on the ground along with a Cage Trap Disturb Trigger mob (working)
// bugged visual
/**** Creature Summon and Recognition IDs ****/
/*** Phase Names ***/
// Maiev uses the same phase
// normal phase
// flight phase
// demon phase
// sequence phase
/* ################## TO DO CONVERT THIS UGLINESS TO CREATURE TEXT ##################
// 9
// 14
// 15
// Emote dead for now. Kill him later
// 19 Maiev disappear
// 21
// the distance between two glaives is 36
// start point, pass through glaive point
// Bottom of the first stairs, at the doors
// Top of the first stairs
// Bottom of the second stairs (left from the entrance)
// Top of the second stairs
// Bottom of the third stairs
// Top of the third stairs
// Before the door-thingy
// Somewhere further
// In front of Illidan - (8)
// in front of the door-thingy (the other one!)
// Down the first flight of stairs
// Down the second flight of stairs
// Final location - back at the initial gates. This is where he will fight the minions! (12)
// 755.762f, 304.0747f, 312.1769f -- This is where Akama should be spawned
// For the demon transformation
// stunned, cannot cast demon form
/*who*/) OVERRIDE
// appear at victim
// 10000 is official-like?
// in case someone is revived
/************************************** Illidan's AI* **************************************/
/*MovementType*/, uint32 /*Data*/) OVERRIDE
// change hover point
// handle flight sequence
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// do not let maiev tank him
/*caster*/, const SpellInfo* spell) OVERRIDE
// Re-equip our warblades!
// Make the Creature do some animation!
// Have the Creature yell out some text
// Play some sound on the creature
// lift off
// land
// Trigger->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
// Just in case the database has it as a different faction
// Record GUID in order to check if they're dead later on to move to the next phase
// Glaives do some random Beam type channel on it.
// If Maiev cannot be summoned, reset the encounter and post some errors to the console.
// lift off
// move to center
// +5, for SPELL_THROW_GLAIVE bug
// throw one glaive
// throw another
// summon flames
// fly to hover point
// return to center
// glaive return
// Make it look like the Glaive flies back up to us
// disappear but not die for now
// land
// attack
// It's morphin time!
// Requip warglaives if needed
// Unequip warglaives if needed
// Depending on whether we summoned Maiev, we switch to either phase 5 or 3
// Event is enabled
// No event with higher priority
// PHASE_NORMAL
// The buff actually lasts forever.
// no longer exists in 3.0f.2
// DoCastVictim(SPELL_SHEAR);
// PHASE_NORMAL_2
// PHASE_NORMAL_MAIEV
// do not start Event when changing hover point
/********************************** End of Illidan AI* *****************************************/
/******* Functions and vars for Akama's AI* *****/
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// Do not let dread aura hurt her.
// This is in fact Illidan's phase.
// reappear after 1 minute
// close all doors at create
// open all doors, raid wiped
// skip first wp
// Database sometimes has strange values..
// Do not call reset in Akama's evade mode, as this will stop him from summoning minions after he kills the first bit
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*Data*/) OVERRIDE
// if door not spawned, don't crash server
// Invisible but spell visuals can still be seen.
// chain lightning
// summon minion
// channel failed
// spirit appear
// spirit help
// open the gate
// Creature* Elite = me->SummonCreature(ILLIDARI_ELITE, x, y, z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 30000);
/*sender*/, uint32 /*action*/) OVERRIDE
// only on players.
// Leave her invisible until she has to talk
// Equip our warglaives!
// Maiev is now visible
// onoz she looks like she teleported!
// Have her face us
// Face her, so it's not rude =P
// Have Maiev add a lot of threat on us so that players don't pull her off if they damage her via AOE
// Force Maiev to attack us.
// Animate his kneeling + stun him
// Akama->GetMotionMaster()->MoveIdle();
// Illidan must not die until Akama arrives.
// Make Maiev leave
// Kill ourself.
// This function does most of the talking
/*who*/)OVERRIDE { }
// Check if who is Illidan
// Dispel his enrage
// if (GameObject* CageTrap = instance->instance->GetGameObject(instance->GetData64(CageTrapGUID)))
//    CageTrap->SetLootState(GO_JUST_DEACTIVATED);
// if (IllidanGUID && !SummonedBeams)
// {
//    if (Unit* Illidan = Unit::GetUnit(*me, IllidanGUID)
//    {
//        /// @todo Find proper spells and properly apply 'caged' Illidan effect
//    }
// }
// Grid search for nearest live Creature of entry 23304 within 10 yards
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*diff*/) OVERRIDE
// Only cast the below on players.
// Kill our target if we're very close.
/*caster*/, const SpellInfo* spell) OVERRIDE
// appear when hit by Illidan's glaive
// Shadowfiends interact with Illidan, setting more targets in Illidan's hashmap
/*who*/) OVERRIDE
// summon only in 1. phase
// do not stack
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Speech'n'Sounds
//Spells
//43267
// Shadow
// Fire
// Nature
// Arcane
// Frost
// Holy
// Timers may be incorrect
// 0 - Sinister, 1 - Vile, 2 - Wicked, 3 - Sinful
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Randomly cast one beam.
// Random Prismatic Shield every 15 seconds.
// Select 3 random targets (can select same target more than once), teleport to a random location then make them cast explosions until they get away from each other.
// Just make them explode three times... they're supposed to keep exploding while they are in range, but it'll take too much code. I'll try to think of an efficient way for it later.
//Enrage
//Random taunts
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Sound'n'speech
//Suffering
//Desire
//Anger
//Spells
// linked aura, need core support
// periodic trigger 41294
// dummy, select target
// force taunt
// force cast 41520
// cast 41377 after 6 sec
//dropout 'head'
/*who*/) OVERRIDE
/*killer*/) OVERRIDE;
// This makes it so that the unit has the same amount of threat in Reliquary's threatlist as in the target creature's (One of the Essences).
/*killer*/) OVERRIDE
// Reset if event is begun and we don't have a threatlist
// I R ANNNGRRRY!
// Release the cube
// Ribs: open
//rotate and disappear
/*killer*/)
/*done_by*/, uint32 &damage) OVERRIDE
/*who*/) OVERRIDE
// linked aura need core support
/*victim*/) OVERRIDE
// No point continuing if empty threatlist.
// Only alive players
// No targets added for some reason. No point continuing.
// Sort players by distance.
// Only need closest target.
// Get the first target.
//Supposed to be cast on nearest target
//Return since we have no target
/*caster*/, const SpellInfo* spell) OVERRIDE
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
//Return since we have no target
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
// Akama Ending cinematic text
// Akama
// On Spawn
// Cast on self hits Shade
// Cast on self hits Shade
// Combat
// Combat
// Shade
// self cast hits Akama
// Cast on death
// must hit shade
// the one he cast
// Ashtongue Channeler
// Cast on Shade
// Creature Spawner
// Ashtongue Defender
// Ashtongue Rogue
// Ashtongue Elementalist
// Ashtongue Spiritbinder
// Akama
// Shade
// Creature spawner
// Channeler
// Ashtongue Sorcerer
// Ashtongue Defender
// Ashtongue Rogue
// Ashtongue Elementalist
// Ashtongue Spiritbinder
// ########################################################
// Shade of Akama
// ########################################################
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*caster*/, SpellInfo const* spell) OVERRIDE
// ########################################################
// Akama
// ########################################################
/*killer*/) OVERRIDE
/*caster*/, SpellInfo const* spell) OVERRIDE
/*who*/) OVERRIDE
/*sender*/, uint32 action) OVERRIDE
// ########################################################
// Ashtongue Channeler
// ########################################################
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// ########################################################
// Creature Generator Akama
// ########################################################
// left
// right
// ########################################################
// Ashtongue Sorcerer
// ########################################################
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE { }
// ########################################################
// Ashtongue Defender
// ########################################################
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
// ########################################################
// Ashtongue Rogue
// ########################################################
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
// ########################################################
// Ashtongue Elementalist
// ########################################################
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
// ########################################################
// Ashtongue Spiritbinder
// ########################################################
/*killer*/) OVERRIDE
/*summoner*/) OVERRIDE
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Spells
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//DoCast(target, SPELL_VOLCANIC_SUMMON);//movement bugged
//DoCast(me, SPELL_VOLCANIC_ERUPTION);
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*info*/) OVERRIDE
//wait 3secs before casting
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Speech'n'sound
//Spells
// Shadowy Constructs use this when they get within melee range of a player
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/* Comment it out for now. NOTE TO FUTURE DEV: UNCOMMENT THIS OUT ONLY AFTER MIND CONTROL IS IMPLEMENTED
// Only the ghost can deal damage.
// No threat list. Don't continue.
// Player that gets killed by Shadow of Death and gets turned into a ghost
// Start off unattackable so that the intro is done properly
/*who*/) OVERRIDE { }
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/************************************************************************/
/** NOTE FOR FUTURE DEVELOPER: PROPERLY IMPLEMENT THE GHOST PORTION *****/
/**  ONLY AFTER TrinIty FULLY IMPLEMENTS MIND CONTROL ABILITIES      *****/
/**   THE CURRENT CODE IN THIS FUNCTION IS ONLY THE BEGINNING OF    *****/
/**    WHAT IS FULLY NECESSARY FOR GOREFIEND TO BE 100% COMPLETE    *****/
/************************************************************************/
/*float x, y, z;
// Use same function as Doom Blossom to set Threat List.
// someone's trying to solo.
//MindControlGhost();
/*** NOTE FOR FUTURE DEV: UNCOMMENT BELOW ONLY IF MIND CONTROL IS FULLY IMPLEMENTED **/
/*if (ShadowOfDeathTimer <= diff)
// Make it VERY close but slightly less so that we can check if the aura is still on the player
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
/*who*/) OVERRIDE
//must let target summon, otherwise you cannot click the spine
//DoCast(me, SPELL_NEEDLE_SPINE, true);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Speech'n'Sounds
// High Nethermancer Zerevor's spells
// Lady Malande's spells
// Gathios the Shatterer's spells
// Veras Darkshadow's spells
// Gathios
// Veras
// Malande
// Zerevor
// Need to get proper timers for this later
// Gathios
// Veras
// Malande
// Zerevor
// Serves as the counter for both the aggro and enrage yells
// 15 minutes
// finds and stores the GUIDs for each Council member using instance data system.
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// Reuse for Enrage Yells
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// Start the event for the Voice Trigger
//me->SummonCreature(AKAMAID, 746.466980f, 304.394989f, 311.90208f, 6.272870f, TEMPSUMMON_DEAD_DESPAWN, 0);
// This is the evade/death check.
//If all members evade, we reset so that players can properly reset the event
// If even one member dies, kill the rest, set instance data, and kill self.
// Load GUIDs on first aggro because the Creature guids are only set as the creatures are created in world-
// this means that for each creature, it will attempt to LoadGUIDs even though some of the other creatures are
// not in world, and thus have no GUID set in the instance data system. Putting it in aggro ensures that all the creatures
// have been loaded and have their GUIDs set in the instance data system.
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// He chooses Lady Malande most often
// But there is a chance he picks someone else.
// No need to create another pointer to us using Unit::GetUnit
// is in ~10-40 yd range
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Don't cast any other spells if global cooldown is still ticking
// almost 1, 12 minutes
// Give the Mage some time to spellsteal Dampen.
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Cast Envenom. This is cast 4 seconds after Vanish is over
// Disappear and stop attacking, but follow a random unit
// Chase a unit. Check before DoMeleeAttackIfReady prevents from attacking
// Become attackable and poison current target
// Make Veras attack his target for a while, he will cast Envenom 4 seconds after.
// Appear 2 seconds before becoming attackable (Shifting out of vanish)
// SPELL_REFLECTIVE_SHIELD
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Karathress spells
//Sharkkis spells
//Tidalvess spells
// Spell obsolete
//Caribdis Spells
//Yells and Quotes
//Summoned Unit GUIDs
//entry and position for Seer Olum
//don't know what use this
//Fathom-Lord Karathress AI
//10 minutes
// 20 - 60 seconds
//Respawn of the 3 Advisors
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//support for quest 10944
//Only if not incombat check if the event is started
//Return since we have no target
//someone evaded!
//CataclysmicBolt_Timer
//select a random unit other than the main tank
//if there aren't other units, cast on the tank
//SearNova_Timer
//Enrage_Timer
//Blessing of Tides Trigger
//Fathom-Guard Sharkkis AI
/*killer*/) OVERRIDE
//Only if not incombat check if the event is started
//Return since we have no target
//someone evaded!
//LeechingThrow_Timer
//Multishot_Timer
//TheBeastWithin_Timer
//Pet_Timer
//uint32 spell_id;
//spell_id = SPELL_SUMMON_FATHOM_LURKER;
//spell_id = SPELL_SUMMON_FATHOM_SPOREBAT;
//DoCast(me, spell_id, true);
//Fathom-Guard Tidalvess AI
/*killer*/) OVERRIDE
//Only if not incombat check if the event is started
//Return since we have no target
//someone evaded!
//FrostShock_Timer
//Spitfire_Timer
//PoisonCleansing_Timer
//Earthbind_Timer
//Fathom-Guard Caribdis AI
/*killer*/) OVERRIDE
//Only if not incombat check if the event is started
//Return since we have no target
//someone evaded!
//WaterBoltVolley_Timer
//TidalSurge_Timer
// Hacky way to do it - won't trigger elseways
//Cyclone_Timer
//DoCast(me, SPELL_SUMMON_CYCLONE); // Doesn't work
//Heal_Timer
// It can be cast on any of the mobs
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//this spell need verification
//not in use yet(in use ever?)
//channeled Hydross Beam Helper (not in use yet)
//invisible
//invisible
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Return since we have no target
// corrupted form
//MarkOfCorruption_Timer
//VileSludge_Timer
//PosCheck_Timer
// switch to clean form
// spawn 4 adds
// clean form
//MarkOfHydross_Timer
//WaterTomb_Timer
//PosCheck_Timer
// switch to corrupted form
// spawn 4 adds
//EnrageTimer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// set it only once on Creature create (no need do intro if wiped)
// Called when a tainted elemental dies
// the next will spawn 50 seconds after the previous one's death
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// remove old tainted cores to prevent cheating in phase 2
// this is EnterCombat(), so were are 100% in combat, start the event
// AttackStart() sets UNIT_FLAG_IN_COMBAT, so this msut be before attacking
// Shoot
// Used in Phases 1 and 3 after Entangle or while having nobody in melee range. A shot that hits her target for 4097-5543 Physical damage.
// Multishot
// Used in Phases 1 and 3 after Entangle or while having nobody in melee range. A shot that hits 1 person and 4 people around him for 6475-7525 physical damage.
// to prevent abuses during phase 2
// Return since we have no target
// ShockBlastTimer
// Shock Burst
// Randomly used in Phases 1 and 3 on Vashj's target, it's a Shock spell doing 8325-9675 nature damage and stunning the target for 5 seconds, during which she will not attack her target but switch to the next person on the aggro list.
// random cooldown
// StaticChargeTimer
// Static Charge
// Used on random people (only 1 person at any given time) in Phases 1 and 3, it's a debuff doing 2775 to 3225 Nature damage to the target and everybody in about 5 yards around it, every 1 seconds for 30 seconds. It can be removed by Cloak of Shadows, Iceblock, Divine Shield, etc, but not by Cleanse or Dispel Magic.
// cast Static Charge every 2 seconds for 20 seconds
// EntangleTimer
// Entangle
// Used in Phases 1 and 3, it casts Entangling Roots on everybody in a 15 yard radius of Vashj, immobilzing them for 10 seconds and dealing 500 damage every 2 seconds. It's not a magic effect so it cannot be dispelled, but is removed by various buffs such as Cloak of Shadows or Blessing of Freedom.
// Phase 1
// Start phase 2
// Phase 2 begins when Vashj hits 70%. She will run to the middle of her platform and surround herself in a shield making her invulerable.
// Phase 3
// SummonSporebatTimer
// summon sporebats faster and faster
// Melee attack
// CheckTimer - used to check if somebody is in melee range
// if in melee range
// if nobody is in melee range
// Phase 2
// ForkedLightningTimer
// Forked Lightning
// Used constantly in Phase 2, it shoots out completely randomly targeted bolts of lightning which hit everybody in a roughtly 60 degree cone in front of Vashj for 2313-2687 nature damage.
// EnchantedElementalTimer
// TaintedElementalTimer
// CoilfangEliteTimer
// CoilfangStriderTimer
// CheckTimer
// Start Phase 3
// set life 50%
// return to the tank
// Enchanted Elemental
// If one of them reaches Vashj he will increase her damage done by 5%.
// walk
// run
//search for nearest waypoint (up on stairs)
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// Tainted Elemental
// This mob has 7, 900 life, doesn't move, and shoots Poison Bolts at one person anywhere in the area, doing 3, 000 nature damage and placing a posion doing 2, 000 damage every 2 seconds. He will switch targets often, or sometimes just hang on a single player, but there is nothing you can do about it except heal the damage and kill the Tainted Elemental
/*killer*/) OVERRIDE
// PoisonBoltTimer
// DespawnTimer
// call Unsummon()
// to prevent crashes
//Toxic Sporebat
//Toxic Spores: Used in Phase 3 by the Spore Bats, it creates a contaminated green patch of ground, dealing about 2775-3225 nature damage every second to anyone who stands in it.
/*who*/) OVERRIDE
// Random movement
// toxic spores
// CheckTimer
// check if vashj is death
// remove
// invisible
/*who*/) OVERRIDE { }
// start visual channel
/*item*/, SpellCastTargets const& targets) OVERRIDE
// get and remove channel
// call Unsummon()
// remove this item
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Spells used by Leotheras The Blind
// Spells used in banish phase
// Spells used by Greyheart Spellbinders
// Spells used by Inner Demons and Creature ID
//Misc.
/* = 0 */) OVERRIDE
/* = 0 */) const OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
//Original Leotheras the Blind AI
//clear guids
/*bool DoEvade = true*/)
// Check first that object is in an angle in front of this one before LoS check
// channelers == 0 remove banish aura
// removing banish aura
// Leotheras is getting immune again
// changing model to bloodelf
// and reseting equipment
// channelers != 0 apply banish aura
// removing Leotheras banish immune to apply AURA_BANISH
// changing model
// and removing weapons
//Despawn all Inner Demon summoned
//delete creature
//remove this once SPELL_INSIDIOUS_WHISPER is supported by core
/*killer*/) OVERRIDE
//despawn copy
/*who*/) OVERRIDE
//Return since we have no target
//no need to check every update tick
// reseting after changing forms and after ending whirlwind
// when changing forms seting timers (or when ending whirlwind - to avoid adding new variable i use Whirlwind_Timer to countdown 2s while whirlwinding)
//Enrage_Timer (10 min)
//Whirldind Timer
// while whirlwinding this variable is used to countdown target's change
//Switch_Timer
//switch to demon form
//ChaosBlast_Timer
// will cast only when in range of spell
//DoCastVictim(SPELL_CHAOS_BLAST, true);
//Summon Inner Demon
//SpellInfo* spell = GET_SPELL(SPELL_INSIDIOUS_WHISPER);
//Safe storing of creatures
//Update demon count
//Switch_Timer
//switch to nightelf form
//at this point he divides himself in two parts
//set nightelf final form
//Leotheras the Blind Demon Form AI
/*killer*/) OVERRIDE
//invisibility (blizzlike, at the end of the fight he doesn't die, he disappears)
/*who*/) OVERRIDE
//Return since we have no target
//ChaosBlast_Timer
// will cast only when in range od spell
//DoCastVictim(SPELL_CHAOS_BLAST, true);
//Do NOT deal any melee damage to the target.
/*false*/);
/*killer*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Ambusher spells
// Guardian spells
// Wrong SpellId. Can't find the right one.
// MOVE_AMBUSHER_1 X, Y, Z
//check if players fished
// give time to get in range when fight starts
// after avery spout
// give time to get in range when fight starts
// never reached
// never reached
// will be false at combat start
// submerge anim
// we start invis under water, submerged
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// boss is invisible, don't attack
/*id*/) OVERRIDE
// boss is invisible, don't attack
// wait 500ms before emerge anim
// never reached
// wait 3secs for emerge anim, then attack
// fresh fished from pool
// check if should evade
// 60secs submerged
// whirl directly after spout
// Whirl directly after a Spout and at random times
//check if there are players in melee range
// only knock back players in arc, in 100yards, not in water
// if on players in melee range cast Waterbolt
// submerged
// shouldn't be any
// directly cast Spout after emerging!
// check if should evade
// spawn adds
// add global cooldown
// add global cooldown
// 25%
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Yell
// Emotes
// Water Globule
// Creatures
//Morogrim Tidewalker AI
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Return since we have no target
//Earthquake_Timer
//TidalWave_Timer
//WateryGrave_Timer
//Teleport 4 players under the waterfalls
//target players only
//Start Phase2
//WateryGlobules_Timer
//one unit can't cast more than one spell per update, so some players have to cast for us XD
/*who*/) OVERRIDE { }
//no attack radius check - it attacks the first target that moves in his los
//who->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
//Return since we have no target
//despawn
//do NOT deal any melee damage to the target.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Spells
// Creatures
// Misc
//NOTE: there are 6 platforms
//there should be 3 shatterers and 2 priestess on all platforms, total of 30 elites, else it won't work!
//delete all other elites not on platforms! these mobs should only be on those platforms nowhere else.
/* Serpentshrine cavern encounters:
/*player*/, GameObject* go) OVERRIDE
//Water checks
/*i->GetSource()->GetPositionZ() <= -21.434931f*/player->IsInWater())
//spawn frenzy
//remove stress from core
//+1 died
//Lady Vashj
//Lady Vashj
// Do not load an encounter as "In Progress" - reset it instead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
//LightningCloud_Timer
//cast twice in Heroic mode
//LungBurst_Timer
//EnvelopingWinds_Timer
//cast twice in Heroic mode
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*killer*/) OVERRIDE
/*victim*/) OVERRIDE
/*who*/) OVERRIDE
//no known summon spells exist
//we should be at least at this range for repair
//we can stop movement at this range to repair but not required
/*who*/) OVERRIDE
//react only if attacked
/*who*/) OVERRIDE { }
//are we already channeling? Doesn't work very well, find better check?
//me->GetMotionMaster()->MovementExpired();
//me->GetMotionMaster()->MoveIdle();
//me->GetMotionMaster()->MovementExpired();
//me->GetMotionMaster()->MoveFollow(pMekgineer, 0, 0);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//hack, due to really weird spell behaviour :(
/*who*/) OVERRIDE { }
/*caster*/)
/*done_by*/, uint32 &damage) OVERRIDE
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*caster*/, const SpellInfo* spell) OVERRIDE
//hack :(
/*killer*/) OVERRIDE
//Reflection_Timer
//Impale_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// 1 mushroom after 5s, then one per 10s. This should be different in heroic mode
/*who*/) OVERRIDE
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
// Evade if too far
// Spore Striders
// Levitate
// Chain Lightning
// Static Charge
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// AoE Ground Slam applying Ground Slam to everyone with a script effect (most likely the knock back, we can code it to a set knockback)
// Spell is self cast by target
// Knockback spell until correct implementation is made
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//This to emulate effect1 (77) of SPELL_GROUND_SLAM, knock back to any direction
//It's initially wrong, since this will cause fall damage, which is by comments, not intended.
//this part should be in the core
/// @todo use eventmap to kill this stuff
//clear this, if we are still performing
//and correct movement, if not already
/// @todo: convert this shit to eventmap
// Growth
// Gruul can cast this spell up to 30 times
//Give a little time to the players to undo the damage from shatter
// Hurtful Strike
// Reverberation
// Cave In
// Ground Slam, Gronn Lord's Grasp, Stoned, Shatter
/*spell*/) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// High King Maulgar
// Olm the Summoner
// Kiggler the Craed
// Blindeye the Seer
// Krosh Firehand
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//ArcingSmash_Timer
//Whirlwind_Timer
//MightyBlow_Timer
//Entering Phase 2
//Charging_Timer
//Intimidating Roar
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//DarkDecay_Timer
//Summon_Timer
//DeathCoil Timer /need correct timer
//Kiggler The Crazed AI
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//GreaterPolymorph_Timer
//LightningBolt_Timer
//ArcaneShock_Timer
//ArcaneExplosion_Timer
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//GreaterPowerWordShield_Timer
//Heal_Timer
//PrayerofHealing_Timer
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//GreaterFireball_Timer
//SpellShield_Timer
//BlastWave_Timer
//15 yard radius minimum
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
// END
// no break;
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
/*player*/, GameObject* go) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*######
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// Disabled until Core Support for mind control
/* // Disabled until Core Support for mind control
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//Final exit door
//The Maker Front door
//The Maker Rear door
//Broggok Front door
//Broggok Rear door
//Kelidan exit door
//The Maker prison cell front right
//The Maker prison cell back right
//The Maker prison cell front left
//The Maker prison cell back left
//Broggok prison cell front right
//Broggok prison cell back right
//Broggok prison cell front left
//Broggok prison cell back left
//Broggok lever
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//only two may be wrong, perhaps increase timer and spawn periodically instead.
//if unit dosen't have this flag, then no pulling back (script will attempt cast, even if orbital strike was resisted)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE { }
// phase 1 - the flight
// phase 2 - land fight
/*who*/) OVERRIDE
/*who*/) OVERRIDE
// circle around the platform
// go to the middle and begin the fight
// adds do the job now
// don't think this is necessary..
//me->Kill(me);
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
//who->RemoveSpellsCausingAura(SPELL_AURA_MOD_STEALTH);
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//must be cast with 30561 as the proc spell
//core bug, does not support target 8
//Casted by the cubes when channeling ends
//39176
//core bug, does not support target 7
//count of clickers needed to interrupt blast nova
//debris
/*who*/) OVERRIDE
// to avoid multiclicks from 1 cube
//function to interrupt channeling and debuff clicker with mind exh(used if second person clicks with same cube or after dispeling/ending shadow grasp DoT)
// cannot interrupt triggered spells
// now checking if every clicker has debuff from manticron(it is dispelable atm rev 6110 : S)
// if not - apply mind exhaustion and delete from clicker's list
// if 5 clickers from other cubes apply shadow cage
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE
// to avoid earthquake interruption
// to avoid blastnova interruption
// blast nova
// shadow cage and earthquake
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
//Manticron Cube
// if exhausted or already channeling return
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// core bug, does not support target 7
// core bug, does not support target 7
// hall
// six columns
// Reset all channelers once one is reset.
// Event start.
// Let all five channelers aggro.
// Release Magtheridon after two minutes.
// Add buff and check if all channelers are dead.
//Channeler->CastSpell(Channeler, SPELL_SOUL_TRANSFER, true);
// true - collapse / false - reset
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// 30741 heroic
// core bug spell attack caster :D
// Summon the ShadowFissure NPC
// this is wrong, a temporary solution. spell consumption already has the purple visual, but doesn't display as it should
// cast on entry 17083 which then makes sound 1343
// 30948 cast on self by 17687
// Fel Orc Convert
// ########################################################
// Grand Warlock Nethekurse
// ########################################################
//HasTaunted = false;
// how long before getting bored and kills his minions?
/*killer*/) OVERRIDE
/// @todo kill the peons first
/*who*/) OVERRIDE
//triggered spell of consumption does not properly show it's SpellVisual, wrong spellid?
/*victim*/) OVERRIDE
//bool HasTaunted;
// ########################################################
// Fel Orc Convert
// ########################################################
//we don't want any assistance (WE R HEROZ!)
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE
/*killer*/) OVERRIDE
// ########################################################
// Lesser Shadow Fissure
// ########################################################
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// Omrogg Heads
// ########################################################
// Warbringer_Omrogg
// ########################################################
//End boss can use this later. O'mrogg must be defeated(DONE) or he will come to aid.
/*who*/) OVERRIDE
//summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
//summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
// ########################################################
// Omrogg Heads
// ########################################################
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
// y -8
// y -8
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// to prevent loops
//Return since we have no target
// stop bladedance
//move in bladedance
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*#####
/*who*/)OVERRIDE { }
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*for questId 10886 (heroic mode only)
/*#####
//phase 2(acid mobs)
//phase 3
//phase 4(acid mobs)
//phase 5(acid mobs)
//phase 6
//TARGET_SCRIPT
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE
//continue beam omega pod, unless we are about to summon skyriss
/*#####
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
//entry 21466
//entry 21467
/*who*/) OVERRIDE { }
/*killer*/) OVERRIDE
//won't yell killing pet/other unit
//should have a better way to do this. possibly spell exist.
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
//door opened when Wrath-Scryer Soccothrates dies
//door opened when Dalliah the Doomsayer dies
//pod first boss wave
//pod second boss wave
//pod third boss wave
//pod fourth boss wave
//pod fifth boss wave
// warden shield
//shield 'protecting' mellichar
//skyriss will kill this unit
/* Arcatraz encounters:
/*case WARDENS_SHIELD:
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/, uint32 &damage) OVERRIDE
/*effIndex*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*if (me->HasAura(SPELL_TREE_FORM, 0) || me->HasAura(SPELL_TRANQUILITY, 0))
//one random seedling every 5 secs, but not in tree form
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*killer*/, uint32 &damage) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// DBC: 34727, 34731, 34733, 34734, 34736, 34739, 34741 (with Ancestral Life spell 34742)   // won't work (guardian summon)
//50 yards from Warp Splinter's spawn point
/*#####
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*#####
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
//Check for War Stomp
//Check for Arcane Volley
//Check for Summon Treants
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Flame Buffet - every 1, 5 secs in phase 1 if there is no victim in melee range and after Dive Bomb in phase 2 with same conditions
// Randomly after changing position in phase after watching tons of movies, set probability 20%
// Rebirth - beginning of second phase(after losing all health in phase 1)
// Rebirth(another, without healing to full HP) - after Dive Bomb in phase 2
// Melt Armor - every 60 sec in phase 2
// Charge - 30 sec cooldown
// Bosskillers says 30 sec cooldown, wowwiki says 30 sec colldown, DBM and BigWigs addons says ~47 sec
// after watching tonns of movies, set cooldown to 40+rand()%5.
// 10 minutes after phase 2 starts(id is wrong, but proper id is unknown)
// Al'ar summons one Ember of Al'ar every position change in phase 1 and two after Dive Bomb. Also in phase 2 when Ember of Al'ar dies, boss loses 3% health.
// When Ember of Al'ar dies, it casts Ember Blast
// Flame Patch - every 30 sec in phase 2
//
// better not use the same xy coord
//me->SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, 10);
//me->SetFloatValue(UNIT_FIELD_COMBAT_REACH, 10);
/*who*/) OVERRIDE
// after enterevademode will be set walk movement
/*killer*/) OVERRIDE
/*who*/) OVERRIDE { }
/*killer*/, uint32 &damage) OVERRIDE
//me->SendUpdateObjectToAllExcept(NULL);
/*id*/) OVERRIDE
// sometimes IsInCombat but !incombat, faction bug?
// next platform
// flame quill
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
//me->SetVisibility(VISIBILITY_OFF);
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// x,          y,      z,         o
/* not used                        // x,          y,      z,         o
//twice in phase one
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Target the tank ?
//Phase1_Timer
//After these 50 seconds she portals to the middle of the room and disappears, leaving 3 light portals behind.
//10 seconds after Solarian disappears, 12 mobs spawn out of the three portals.
//Check Phase3_Timer
//15 seconds later Solarian reappears out of one of the 3 portals. Simultaneously, 2 healers appear in the two other portals.
//Fear_Timer
//VoidBolt_Timer
//When Solarian reaches 20% she will transform into a huge void walker.
//To make sure she wont be invisible or not selecatble
/*who*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Final heal only on duration end
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Kael'thas Speech
// Thaladred the Darkener speech
//Lord Sanguinar speech
// Grand Astromancer Capernian speech
// Master Engineer Telonicus speech
// Phase 2 spells
// Phase 4 spells
//wrong but works with CastCustomSpell
// Phase 5 spells
// Thaladred the Darkener spells
// Lord Sanguinar spells
// Grand Astromancer Capernian spells
//Master Engineer Telonicus spells
//Nether Vapor spell
//Phoenix spell
//Phoenix egg and phoenix model
//she casts away from the target
//const float KAEL_VISIBLE_RANGE          = 50.0f;
//Base AI for Advisors
//reset encounter
/*Target*/)
// double health for phase 3
//Prevent glitch if in fake death
//Don't really die in phase 1 & 3, only die after that
//prevent death
//Kael'thas AI
//generic
//generic timer
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
// if not phoenix, then it's one of the 7 weapons
/*killer*/) OVERRIDE
//Phase 1
//Subphase switch
//Subphase 1 - Start
//start advisor within 7 seconds
//Subphase 1 - Unlock advisor
//Subphase 2 - Start
//start advisor within 12.5 seconds
//Subphase 2 - Unlock advisor
//Subphase 3 - Start
//start advisor within 7 seconds
//Subphase 3 - Unlock advisor
//Subphase 4 - Start
//start advisor within 8.4 seconds
//Subphase 4 - Unlock advisor
//End of phase 1
//Spawn weapons
//Respawn advisors
// Sometimes people can collect Aggro in Phase 1-3. Reset threat before releasing Kael.
//Return since we have no target
//Fireball_Timer
//interruptable
//apply resistance
//ArcaneDisruption_Timer
//DoCast(unit, SPELL_MIND_CONTROL);
//Phoenix_Timer
//Phase 4 specific spells
//ShockBarrier_Timer
//Chain Pyros (3 of them max)
//Phase 5
//GravityLapse_Timer
// 1) Kael'thas will portal the whole raid right into his body
//Use work around packet to prevent player from being dropped from combat
// 2) At that point he will put a Gravity Lapse debuff on everyone
//Gravity lapse - needs an exception in Spell system to work
//Using packet workaround
//Cast nether vapor aura on self
//Remove flight
//Using packet workaround
//ShockBarrier_Timer
//NetherBeam_Timer
//Thaladred the Darkener AI
/*killer*/) OVERRIDE
//Faking death, don't do anything
//Return since we have no target
//Gaze_Timer
//Silence_Timer
//PsychicBlow_Timer
//Lord Sanguinar AI
/*killer*/) OVERRIDE
//Faking death, don't do anything
//Return since we have no target
//Fear_Timer
//approximately every 30 seconds
//Grand Astromancer Capernian AI
/*killer*/) OVERRIDE
//Faking Death, don't do anything
//Return since we have no target
//Yell_Timer
//Fireball_Timer
//Conflagration_Timer
//ArcaneExplosion_Timer
//if in melee range
//Do NOT deal any melee damage.
//Master Engineer Telonicus AI
/*killer*/) OVERRIDE
//Faking Death, do nothing
//Return since we have no target
//Bomb_Timer
//RemoteToy_Timer
//Flame Strike AI
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
//Timer
//Phoenix AI
/*killer*/) OVERRIDE
//is this spell in use anylonger?
//DoCast(me, SPELL_EMBER_BLAST, true);
//spell Burn should possible do this, but it doesn't, so do this for now.
//Phoenix Egg AI
//ignore any
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
// Pounding
//cast time(3000) + cooldown time(12000)
// Arcane Orb
// exclude pets & totems, 18 yard radius minimum
// Single Target knock back, reduces aggro
//Drop 25% aggro
//Berserk
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* The Eye encounters:
// Do not load an encounter as "In Progress" - reset it instead.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*who*/) OVERRIDE
//Check if we have a current target
//Knockaway_Timer
// current aggro target is knocked away pick new target
//Countercharge_Timer
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/// @todo expect cast this about 5 times in a row (?), announce it by emote only once
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*victim*/) OVERRIDE
/*spell*/) OVERRIDE
// if (GetSpellInfo()->Id == SPELL_NEGATIVE_CHARGE)
/*effIndex*/)
/*spell*/) OVERRIDE
/* effIndex */)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Not scripted
// Not scripted
// Not scripted
// Not scripted
// Not scripted
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*who*/) OVERRIDE
//Check_Timer
//remove
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/* ScriptData
// Not scripted
// Not scripted
// Not scripted
// Not scripted
// Used by Nether Wraith
// Used by Nether Wraith
/*who*/) OVERRIDE
/*victim*/) OVERRIDE
/*killer*/) OVERRIDE
/*attacker*/, uint32& damage) OVERRIDE
// Heroic only
/*who*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//github.com/scriptdev2/scriptdev2/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Not needed to be despawned now
// Find victim of Summon Gargoyle spell
/*killer*/) OVERRIDE
// Stop Feeding Gargoyle when it dies
// Fly away when dismissed
// Stop Fighting
// Sanctuary
//! HACK: Creature's can't have MOVEMENTFLAG_FLYING
// Fly Away
// Despawn as soon as possible
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*who*/) OVERRIDE { }
/*diff*/) OVERRIDE { }
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Viper
// Venomous Snake
// Viper
/*who*/) OVERRIDE { }
// Add delta to make them not all hit the same time
// Start attacking attacker of owner on first ai update after spawn - move in line of sight may choose better target
// Redefined for random target selection:
// Viper
//33% chance to cast
// Venomous Snake
// 33% chance to cast
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Inherit Master's Threat List (not yet implemented)
// here mirror image casts on summoner spell (not present in client dbc) 49866
// here should be auras (not present in client dbc): 35657, 35658, 35659, 35660 selfcasted by mirror images (stats related?)
// Clone Me!
// Do not reload Creature templates on evade mode enter - prevent visual lost
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*killer*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Earth Elemental
// Fire Elemental
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Gorefiend's Grasp - 108199
// Called by Death Coil (damage) - 47632, Frost Strike - 49143 and Runic Strike - 56815
// Runic Empowerment - 81229
// Called by Death Coil (damage) - 47632, Frost Strike - 49143 and Runic Strike - 56815
// Runic Corruption - 51462
// Raise Dead - 46584
/*effIndex*/)
// 50462 - Anti-Magic Shell (on raid member)
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
/// @todo this should absorb limited amount of damage, but no info on calculation formula
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
// 48707 - Anti-Magic Shell (on self)
/*spellInfo*/) OVERRIDE
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
/*dmgInfo*/, uint32 & absorbAmount)
// damage absorbed by Anti-Magic Shell energizes the DK with additional runic power.
// This, if I'm not mistaken, shows that we get back ~20% of the absorbed damage as runic power.
// 50461 - Anti-Magic Zone
/*spellInfo*/) OVERRIDE
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
// 48721 - Blood Boil
/*spellInfo*/) OVERRIDE
// 50453 - Bloodworms Health Leech
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 47541, 52375, 59134, -62900 - Death Coil
/*spell*/) OVERRIDE
/*effIndex*/)
// 52751 - Death Gate
// 49560 - Death Grip
/*effIndex*/)
// Deterrence
// 48743 - Death Pact
// Check if we have valid targets, otherwise skip spell casting here
// 49998 - Death Strike
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Call CalculateAmount() to constantly fire the AuraEffect's HandleCalcAmount method
// 89832 - Death Strike (Save damage taken in last 5 sec)
/*aurEff*/, ProcEventInfo& eventInfo)
// Cheap hack to have update calls
/*aurEff*/, bool& isPeriodic, int32& amplitude)
/*aurEff*/)
// Move backwards all datas by one
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// 47496 - Explode, Ghoul spell for Corpse Explosion
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Corpse Explosion (Suicide)
// 48792 - Icebound Fortitude
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// Glyph of Icebound Fortitude
// 73975 - Necrotic Strike
/*aurEff*/, int32& amount, bool & /*canBeRecalculated*/)
// 59754 Rune Tap - Party
// 50421 - Scent of Blood
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 55090 - Scourge Strike
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Death Knight T8 Melee 4P Bonus
// 55233 - Vampiric Blood
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// 5.4.8 18414
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Will make the yellow arrow on eclipse bar point to the blue side (lunar)
// Will make the yellow arrow on eclipse bar point to the yellow side (solar)
// 1850 - Dash
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// do not set speed if not in cat form
// 48517 - Eclipse (Solar)
// 48518 - Eclipse (Lunar)
/*spellInfo*/) override
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 2912, 5176, 78674 - Starfire, Wrath, and Starsurge
// No boomy, no deal.
// -13
// If we are set to fill the lunar side or we've just logged in with 0 power..
// If the energize was due to 0 power, cast the eclipse marker aura
// The energizing effect brought us out of the solar eclipse, remove the aura
// 20
// If we are set to fill the solar side or we've just logged in with 0 power..
// If the energize was due to 0 power, cast the eclipse marker aura
// The energizing effect brought us out of the lunar eclipse, remove the aura
// If we are set to fill the solar side or we've just logged in with 0 power (confirmed with sniffs)
// 15
// If the energize was due to 0 power, cast the eclipse marker aura
// -15
// The energizing effect brought us out of the lunar eclipse, remove the aura
// The energizing effect brought us out of the solar eclipse, remove the aura
// 54832 - Glyph of Innervate
/*spellInfo*/) override
// Not proc from self Innervate
/*eventInfo*/)
// 54846 - Glyph of Starfire
/*spellInfo*/) override
/*effIndex*/)
// 54845 - Glyph of Starfire
/*spellInfo*/) override
// 29166 - Innervate
/*canBeRecalculated*/)
// 33763 - Lifebloom
/*spell*/) override
/*mode*/)
// Final heal only on duration end
// final heal
// restore mana
// final heal
// restore mana
// -48496 - Living Seed
/*spellInfo*/) override
// 48504 - Living Seed (Proc)
/*spellInfo*/) override
/*eventInfo*/)
// -16972 - Predatory Strikes
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 62606 - Savage Defense
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// Set absorbtion amount to unlimited
/*dmgInfo*/, uint32 & absorbAmount)
// 52610 - Savage Roar
/*spellInfo*/) override
/*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 50286 - Starfall (Dummy)
/*effIndex*/)
// Shapeshifting into an animal form or mounting cancels the effect
// Any effect which causes you to lose control of your character will supress the starfall effect.
// -78892 - Stampede
/*spellInfo*/) override
// 61336 - Survival Instincts
/*spell*/) override
/*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 40121 - Swift Flight Form (Passive)
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// 70691 - Item T10 Restoration 4P Bonus
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Max absorb stored in 1 dummy effect
/*aurEff*/, DamageInfo& /*dmgInfo*/, uint32& absorbAmount)
// 28764 - Adaptive Warding (Frostfire Regalia Set)
/*spellInfo*/) OVERRIDE
// eventInfo.GetSpellInfo()
// find Mage Armor
// 17619 - Alchemist Stone
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Remove all auras with spell id 46221, except the one currently being applied
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 41337 Aura of Anger
// Spells
// Models
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Apply model goblin
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// alliance
// Dun Baldar North Marshal
// Dun Baldar South Marshal
// Icewing Marshal
// Stonehearth Marshal
// Vandar Stormspike
// horde
// East Frostwolf Warmaster
// Tower Point Warmaster
// Iceblood Warmaster
// West Frostwolf Warmaster
// Drek'thar
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/* DOCUMENTATION: Break-Shield spells
// Also on ToC5 mounts
// On spells wich trigger the damaging spell (and also the visual)
// On damaging spells, for removing a defend layer
// Remove dummys from rider (Necessary for updating visual shields)
// 46394 Brutallus Burn
/*spellInfo*/) OVERRIDE
// search for nearby enemy corpse in range
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/* effIndex */)
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 63845 - Create Lance
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Defend spells casted by NPCs (add visuals)
// Remove Defend spell from player when he dismounts
// Defend spells casted by players (add/remove visuals)
// 70769 Divine Storm!
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
// Here the target is the water spout and determines the position where the player is knocked from
// This method relies on the Dalaran Sewer map disposition and Water Spout position
// What we do is knock the player from a position exactly behind him and at the end of the pipe
/*spellInfo*/) OVERRIDE
/* effIndex */)
// This hook is executed for every target, make sure we only credit instance once
// Creatures
// Spells
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/* effIndex */)
// Transporter Malfunction - 1/6 polymorph
// Evil Twin               - 4/6 evil twin
// Transporter Malfunction - 1/6 miss the target
/*canBeRecalculated*/)
/*spellInfo*/) OVERRIDE
/* effIndex */)
/*effIndex*/)
// 32748 - Deadly Throw Interrupt
// 44835 - Maim Interrupt
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// prevents falling damage
// A better research is needed
// There is no spell for this, the following calculation was based on void Spell::CalculateJumpSpeeds
/*effIndex*/)
// raid buff
// single-target buff
/*spellInfo*/) OVERRIDE
/*mode*/)
// Final heal only on duration end
// final heal
/* DOCUMENTATION: Charge spells
// On spells wich trigger the damaging spell (and also the visual)
// If target isn't a training dummy there's a chance of failing the charge
// On damaging spells, for removing a defend layer
// Remove dummys from rider (Necessary for updating visual shields)
/*effIndex*/)
// 28702 - Netherbloom
/*spellInfo*/) OVERRIDE
// 25% chance of casting a random buff
// triggered spells are 28703 to 28707
// Note: some sources say, that there was the possibility of
//       receiving a debuff. However, this seems to be removed by a patch.
// don't overwrite an existing aura
// 28720 - Nightmare Vine
/*spellInfo*/) OVERRIDE
// 25% chance of casting Nightmare Pollen
// 27539 - Obsidian Armor
/*spellInfo*/) OVERRIDE
// eventInfo.GetSpellInfo()
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Set rep to baserep + basepoints (expecting spillover for oposite faction -> become hated)
// Not when player already has equal or higher rep with this faction
// EFFECT_INDEX_2 most likely update at war state, we already handle this in SetReputation
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 45472 Parachute
/*spellInfo*/) OVERRIDE
/*aurEff*/)
/*aurEff*/)
/*effIndex*/)
// revive the pet if it is dead
/*effIndex*/)
// learn random explicit discovery recipe (if any)
/*effIndex*/)
/*spell*/) OVERRIDE
/*mode*/)
// cast speed aura
/*spell*/) OVERRIDE
// Definitely not a good thing, but currently the only way to do something at cast start
// Should be replaced as soon as possible with a new hook: BeforeCastStart
// Player cannot transform to human form if he is forced to be worgen for some reason (Darkflight)
// Basepoints 1 for this aura control whether to trigger transform transition animation or not.
/*effIndex*/)
/* effIndex */)
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/// @todo this check is maybe wrong
/*spellInfo*/) OVERRIDE
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*spellInfo*/) OVERRIDE
// This is only needed because spells cast from spell_linked_spell are triggered by default
// Spell::SendSpellCooldown() skips all spells with TRIGGERED_IGNORE_SPELL_AND_CATEGORY_CD
/*mode*/)
// store stack apply times, so we can pop them while they expire
// on stack 15 cast the achievement crediting spell
/*aurEff*/)
// pop stack if it expired for us
// player can only have one of these items
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
/// @todo Reserach coeffs for different vehicles
/// @todo Research possibility of scaling down
/* effIndex */)
/*spellInfo*/) OVERRIDE
/*aurEff*/)
/*mode*/)
/*mode*/)
// Running Wild
/*                          */
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// 45102 Romantic Picnic
// Holiday - Valentine - Romantic Picnic Near Basket Check
// Holiday - Valentine - Romantic Picnic Meal Periodic - effect dummy
// Holiday - Valentine - Romantic Picnic Meal Eat Visual
//SPELL_MEAL_PARTICLE             = 45114, // Holiday - Valentine - Romantic Picnic Meal Particle - unused
// Holiday - Valentine - Romantic Picnic Drink Visual
// Romantic Picnic periodic = 5000
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/)
// Every 5 seconds
// If our player is no longer sit, remove all auras
// unknown use, it targets Romantic Basket
// For nearby players, check if they have the same aura. If so, cast Romantic Picnic (45123)
// required by achievement and "hearts" visual
// && (*itr)->getStandState() == UNIT_STAND_STATE_SIT)
// break;
// 24750 Trick
/*spell*/) OVERRIDE
/*effIndex*/)
// 24751 Trick or Treat
/*spell*/) OVERRIDE
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
// 26275 - PX-238 Winter Wondervolt TRAP
/*spellInfo*/) OVERRIDE
// Love is in the Air
// Hallow's End
// Winter Veil
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*spellInfo*/) OVERRIDE
/*aurEff*/)
// crow trigger+visual + (Dummy: cdr at 20% target HP NYI)
// 53209 - Chimera Shot
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 77767 - Cobra Shot
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 82926 - Fire!
// -19572 - Improved Mend Pet
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*eventInfo*/)
// -19464 Improved Serpent Sting
// 53412 - Invigoration
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 53478 - Last Stand Pet
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 53271 - Masters Call
/*effIndex*/)
/*effIndex*/)
// Cannot be processed while pet is dead
// 34477 - Misdirection
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*eventInfo*/)
/*eventInfo*/)
// 35079 - Misdirection (Proc)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 54044 - Pet Carrion Feeder
/*spellInfo*/) OVERRIDE
// search for nearby enemy corpse in range
/*effIndex*/)
// 55709 - Pet Heart of the Phoenix
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// -53228 - Rapid Recuperation
/*spellInfo*/) OVERRIDE
/*aurEff*/, ProcEventInfo& eventInfo)
// This effect only from Rapid Fire (ability cast)
// This effect only from Rapid Killing (focus regen)
// 23989 - Readiness
/*effIndex*/)
// immediately finishes the cooldown on your other Hunter abilities except Bestial Wrath
///! If spellId in cooldown map isn't valid, the above will return a null pointer.
// 82925 - Ready, Set, Aim...
/*spellInfo*/) OVERRIDE
/*mode*/)
// 37506 - Scatter Shot
/*effIndex*/)
// break Auto Shot and autohit
// -53302 - Sniper Training
/*spellInfo*/) OVERRIDE
// 56641 - Steady Shot
/*spellInfo*/) OVERRIDE
// 1515 - Tame Beast
// use SMSG_PET_TAME_FAILURE?
//  53434 - Call of the Wild
// 34497 - Thrill of the Hunt
/*spellInfo*/) OVERRIDE
// -56333 - T.N.T.
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*eventInfo*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Generic script for handling item dummy effects which trigger another spell.
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 23780 - Aegis of Preservation
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 26400 - Arcane Shroud
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// 64411 - Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
/*spellInfo*/) OVERRIDE
// The shield can grow to a maximum size of 20,000 damage absorbtion
// Refresh and return to prevent replacing the aura
// 8342  - Defibrillate (Goblin Jumper Cables) have 33% chance on success
// 22999 - Defibrillate (Goblin Jumper Cables XL) have 50% chance on success
// 54732 - Defibrillate (Gnomish Army Knife) have 67% chance on success
/*spellInfo*/) OVERRIDE
// 33896 - Desperate Defense
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// http://www.wowhead.com/item=6522 Deviate Fish
// 8063 Deviate Fish
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/item=47499 Flask of the North
// 67019 Flask of the North
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/item=10645 Gnomish Death Ray
// 13280 Gnomish Death Ray
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// failure
// http://www.wowhead.com/item=27388 Mr. Pinchy
// 33060 Make a Wish
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/item=32686 Mingo's Fortune Giblets
// 40802 Mingo's Fortune Generator
// Selecting one from Bloodstained Fortune item
// 71875, 71877 - Item - Black Bruise: Necrotic Touch Proc
/*spellInfo*/) OVERRIDE
// http://www.wowhead.com/item=10720 Gnomish Net-o-Matic Projector
// 13120 Net-o-Matic
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 2% for 30 sec self root (off-like chance unknown)
// 2% for 20 sec root, charge to target (off-like chance unknown)
// http://www.wowhead.com/item=8529 Noggenfogger Elixir
// 16589 Noggenfogger Elixir
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 17512 - Piccolo of the Flaming Fire
// http://www.wowhead.com/item=6657 Savory Deviate Delight
// 8213 Savory Deviate Delight
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Flip Out - ninja
// Yaaarrrr - pirate
// 48129 - Scroll of Recall
// 60320 - Scroll of Recall II
// 60321 - Scroll of Recall III
// Scroll of Recall
// Scroll of Recall II
// Scroll of Recal III
// ALLIANCE from 60323 to 60330 - HORDE from 60328 to 60335
// 71169 - Shadow's Fate (Shadowmourne questline)
// 71903 - Item - Shadowmourne Legendary
/*spellInfo*/) OVERRIDE
// cant collect shards while under effect of Chaos Bane buff
// this can't be handled in AuraScript of SoulFragments because we need to know victim
// 71905 - Soul Fragment
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// http://www.wowhead.com/item=7734 Six Demon Bag
// 14537 Six Demon Bag
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Fireball (25% chance)
// Frostball (25% chance)
// Chain Lighting (20% chance)
// Polymorph (10% chance)
// 30% chance to self-cast
// Enveloping Winds (15% chance)
// Summon Felhund minion (5% chance)
// 28862 - The Eye of Diminution
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// http://www.wowhead.com/item=44012 Underbelly Elixir
// 59640 Underbelly Elixir
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*spell*/) OVERRIDE
// needed because this spell shares GCD with its triggered spells (which must not be cast with triggered flag)
/*effIndex*/)
// learn random explicit discovery recipe (if any)
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// "I was pure once"
// "Fought for righteousness"
// "I was once called Ashbringer"
// "Betrayed by my order"
// "Destroyed by Kel'Thuzad"
// "Made to serve"
// "My son watched me die"
// "Crusades fed his rage"
// "Truth is unknown to him"
// "Scarlet Crusade  is pure no longer"
// "Balnazzar's crusade corrupted my son"
// "Kill them all!"
// Ashbringers effect (spellID 28441) retriggers every 5 seconds, with a chance of making it say one of the above 12 sounds
/*aurEff*/)
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
//5 different spells used depending on mounted speed and if mount can fly or not
// Flying Reindeer
//310% flying Reindeer
// Flying Reindeer
//280% flying Reindeer
// Flying Reindeer
//60% flying Reindeer
// Reindeer
//100% ground Reindeer
// Reindeer
//60% ground Reindeer
/*spell*/) OVERRIDE
/* effIndex */)
// Nigh-Invulnerability   - success
// Complete Vulnerability - backfire in 14% casts
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
//cast spell Raptor Capture Credit
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/* effIndex */)
/*spell*/) OVERRIDE
/* effIndex */)
/*effIndex*/)
/*effIndex*/)
// 23074 Arcanite Dragonling
// 23133 Gnomish Battle Chicken
// 23076 Mechanical Dragonling
// 23075 Mithril Mechanical Dragonling
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// obsolete SpellID
// Time Warp - 80353
//
// Time Warp - 80353
/*spellInfo*/) override
// 11113 - Blast Wave
/*spellInfo*/) override
// 11958 - Cold Snap
/*effIndex*/)
// immediately finishes the cooldown on Frost spells
// 42955 Conjure Refreshment
/// Updated 4.3.4
// 42955 - Conjure Refreshment
/*spellInfo*/) override
/*effIndex*/)
// 116 - Frostbolt
/// Updated 4.3.4
/*effIndex*/)
// 56372 - Glyph of Ice Block
/*spellInfo*/) override
/*eventInfo*/)
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// Remove Frost Nova cooldown
// 56374 - Glyph of Icy Veins
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// 56375 - Glyph of Polymorph
/*spellInfo*/) override
/*aurEff*/, ProcEventInfo& eventInfo)
// SW:D shall not be removed.
// 44457 - Living Bomb
/*mode*/)
// -11119 - Ignite
/*spellInfo*/) override
// 86181 - Nether Vortex
/*spellInfo*/) override
/// @todo move out of here and rename - not a mage spell
// 32826 - Polymorph (Visual)
/*spellInfo*/) override
// check if spell ids exist in dbc
/*effIndex*/)
// add dummy effect spell handler to Polymorph visual
// 82676 - Ring of Frost
/// Updated 4.3.4
/*spellInfo*/) override
/*aurEff*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Get the last summoned RoF, save it and despawn older ones
// 82691 - Ring of Frost (freeze efect)
/// Updated 4.3.4
/*spellInfo*/) override
/*spellInfo*/) override
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 33395 Water Elemental's Freeze
/// Updated 4.3.4
/*spellInfo*/) override
// 5.4.8 18414
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Warrior spell : Enrage 12880
/*canBeRecalculated*/)
// Called by Power Word : Shield - 17, Power Word : Shield (Divine Insight) - 123258, Spirit Shell - 114908, Angelic Bulwark - 114214 and Divine Aegis - 47753
// Mastery : Shield Discipline - 77484
// Called by 100780 / 108557 / 115698 / 115687 / 115693 / 115695 - Jab (and overrides)
// 115636 - Mastery : Combo Breaker
// Called by 45470 - Death Strike (Heal)
// 77513 - Mastery : Blood Shield
// Check the Mastery aura while in Blood presence
// Called by 133 - Fireball, 44614 - Frostfire Bolt, 108853 - Inferno Blast, 2948 - Scorch and 11366 - Pyroblast
// 12846 - Mastery : Ignite
// Called by 35395 - Crusader Strike, 53595 - Hammer of the Righteous, 24275 - Hammer of Wrath, 85256 - Templar's Verdict and 53385 - Divine Storm
// 76672 - Mastery : Hand of Light
// Called by 403 - Lightning Bolt, 421 - Chain Lightning, 51505 - Lava Burst and 117014 - Elemental Blast
// 77222 - Mastery : Elemental Overload
/*spellEntry*/)
// Every Lightning Bolt, Chain Lightning and Lava Burst spells have duplicate vs 75% damage and no cost
// Lava Burst
// Lightning Bolt
// Chain Lightning
// Elemental Blast
// Nature visual
// Frost visual
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*
// 117952 - Crackling Jade Lightning
/*spellInfo*/) override
/*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 117959 Crackling - Jade Lightning
/*spellInfo*/) override
/*eventInfo*/)
// Just prevention against buggers
/*spellInfo*/) override
/*effIndex*/)
/*spellInfo*/) override
/*effIndex*/)
/*spellInfo*/) override
/*effIndex*/)
/*spellInfo*/) override
// Roll - 109132 or Roll (3 charges) - 121827
/*spell*/)
// Disable - 116095
/*spell*/)
// last tick of duration
/*mode*/)
// Paralysis - 115078
// Spinning Crane Kick - 107270
/*spell*/)
// Brewing: Tigereye Brew - 123980
/*spell*/)
/*mode*/)
// Tigereye Brew - 116740
/*spell*/)
/*canBeRecalculated*/)
// Max bonus = 60%
// Removes at most 10 stacks
// One of the stacks is already removed automatically
// Tiger Strikes - 120273
/*spell*/)
/*aurEff*/, ProcEventInfo& eventInfo)
// Zen Pilgrimage - 126892
/*spell*/)
/*effIndex*/)
// Zen Pilgrimage: Return - 126895
/*spell*/)
/*effIndex*/)
// Enveloping Mist - 124682
// Surging Mist - 116694
// Renewing Mist - 119611
// Remove other players jade statue
/*spell*/)
// Spreads Renewing Mists 3 times maximum
// Spreads Renewing Mists 3 times maximum
/*aurEff*/, AuraEffectHandleModes mode)
// Healing Sphere 115460
/*eff*/)
/*######
/*who*/) override
/*who*/) override
/*respawnDelay*/) override
// 102141 - Transcendence
// 119996 - Transcendence Transfer
// Touch of Karma - 122470
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// Diffuse Magic - 122783
// need to check auraEffect pointer here !!
// tehee
// Summon Black Ox Statue - 115315
// Remove other players jade statue
// 1 statue max
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Remove other players' ox statue
// Guard - 115295
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// For Black Ox Statue
// Glyph of Zen Flight - 125893
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Summon Jade Serpent Statue - 115313
// Remove other players jade statue
// 1 statue max
// Fists of Fury (stun effect) - 120086
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Chi Wave (damage) - 132467 and Chi Wave (heal) - 132463
// Chi Wave (talent) - 115098
// Grapple Weapon - 117368
// Chi Wave (healing bolt) - 132464
// Serpent's Zeal - 127722
// Remove other players jade statue
// you gain Serpent's Zeal causing you to heal nearby injured targets equal to 25% of your auto-attack damage. Stacks up to 2 times.
// Eminence - statue
// Dampen Harm - 122278
/*auraEffect*/, int32& amount, bool& /*canBeRecalculated*/)
// The next 3 attacks within 45 sec that deal damage equal to 10% or more of your total health are reduced by half
// Bear Hug - 127361
// Zen Flight - 125883
// In Kalimdor or Eastern Kingdom with Flight Master's License
// In Pandaria with Wisdom of the Four Winds
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// Called by Jab - 100780
// Power Strikes - 121817
// Spinning Fire Blossom - 123408
// Spinning Fire Blossom - 115073
// Called by Uplift - 116670 and Uplift - 130316
// Thunder Focus Tea - 116680
// Called by Spinning Crane Kick - 107270
// Teachings of the Monastery - 116645
// Glyph of Mana Tea - 115294
// Mana Tea - 115294
// remove one charge per tick instead of remove aura on cast
// "Cancelling the channel will not waste stacks"
// Brewing : Mana Tea - 123766
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Called by : Fortifying Brew - 115203, Chi Brew - 115399, Elusive Brew - 115308, Tigereye Brew - 116740
// Purifying Brew - 119582, Mana Tea - 115294, Thunder Focus Tea - 116680 and Energizing Brew - 115288
// Healing Elixirs - 122280
// This effect cannot occur more than once per 18s
// Zen Sphere - 124081
// Zen Sphere - 124081
// Chi Burst - 123986
// Chi Burst will always heal the Monk, but not heal twice if Monk targets himself
// Energizing Brew - 115288
// Spear Hand Strike - 116705
// Tiger's Lust - 116841
// Flying Serpent Kick - 115057
/*spell*/)
// Chi Torpedo - 115008 or Chi Torpedo (3 charges) - 121828
// Purifying Brew - 119582
// Clash - 122057 and Clash - 126449
// Keg Smash - 121253
// Prevent to receive 2 CHI more than once time per cast
// Elusive Brew - 115308
// Soothing Mist - 115175
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Remove other players jade statue
/*aurEff*/)
// 25% to give 1 chi per tick
/*mode*/)
// Blackout Kick - 100784
// Second effect by spec : Instant heal or DoT
// Your Blackout Kick always deals 20% additional damage over 4 sec regardless of positioning but you're unable to trigger the healing effect.
// If behind : 20% damage on DoT
// else : 20% damage on instant heal
// Brewmaster : Training - you gain Shuffle, increasing parry chance and stagger amount by 20%
// Provoke - 115546
/*effIndex*/)
// Brewing : Tigereye Brew - 123980
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*
// Set absorbtion amount to unlimited
// If damage kills us
// Cast healing spell, completely avoid damage
// Max heal when defense skill denies critical hits from raid bosses
// Formula: max defense at level + 140 (raiting from gear)
// Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
// 31821 - Aura Mastery
/*spellInfo*/) override
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 64364 - Aura Mastery Immune
/*spellInfo*/) override
// 53651 - Beacon of Light
/*spellInfo*/) override
// 37877 - Blessing of Faith
/*spellInfo*/) override
/*effIndex*/)
// ignore for non-healing classes
// 33695 - Exorcism and Holy Wrath Damage
// -75806 - Grand Crusader
/*spellInfo*/) override
/*eventInfo*/)
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// -9799 - Eye for an Eye
/*spellInfo*/) override
// 6940 - Hand of Sacrifice
/*aurEff*/, DamageInfo & /*dmgInfo*/, uint32 & splitAmount)
// 20473 - Holy Shock
// can't use other spell than holy shock due to spell_ranks dependency
/*effIndex*/)
// 37705 - Healing Discount
/*spellInfo*/) override
/*eventInfo*/)
// 31789 - Righteous Defense
/*spellInfo*/) override
//! WORKAROUND
//! target select will be executed in hitphase of effect 0
//! so we must handle trigger spell also in hit phase (default execution in launch phase)
//! see issue #3718
// 85285 - Sacred Shield
// 85256 - Templar's Verdict
/// Updated 4.3.4
/*spellEntry*/) override
/*effIndex*/)
// 7.5*30% = 225%
// 1 Holy Power
// 2 Holy Power
// 3*30 = 90%
// 3 Holy Power
// 7.5*30% = 225%
// 20154, 21084 - Seal of Righteousness - melee proc dummy (addition ${$MWS*(0.022*$AP+0.044*$SPH)} damage)
/*spellInfo*/) override
//new spell_pal_ardent_defender();
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Intellect
// Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// Increase crit spell from spell crit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Agility
// Increase crit from SPELL_AURA_MOD_WEAPON_CRIT_PERCENT
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// Increase crit melee from melee crit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
// Increase hit melee from meele hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_EXPERTISE
// Increase Expertise from Expertise ratings
//                    case SPELL_SHAMAN_PET_HIT:
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// Glyph of felguard
/* aurEff */ect = owner->GetAuraEffect(56246, EFFECT_0))
/* aurEff */ect->GetAmount());
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
//the damage bonus used for pets is either fire or shadow damage, whatever is higher
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Intellect
// Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// Increase crit spell from spell crit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Agility
// Increase crit from SPELL_AURA_MOD_WEAPON_CRIT_PERCENT
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// Increase crit melee from melee crit ratings
// this doesnt actually fit in here
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
// Increase hit melee from meele hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// Wild Hunt rank 1
// Wild Hunt rank 2
// If pet has Wild Hunt
// Then get the SpellProto and add the dummy effect value
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
//Hunter contribution modifier
// Wild Hunt rank 1
// Wild Hunt rank 2
// If pet has Wild Hunt
// Then get the SpellProto and add the dummy effect value
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
//Hunter contribution modifier
// Wild Hunt rank 1
// Wild Hunt rank 2
// If pet has Wild Hunt
// Then get the SpellProto and add the dummy effect value
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
// Increase hit melee from meele hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_EXPERTISE
// Increase Expertise from Expertise ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Intellect
// CritSpell += owner->GetSpellCritFromIntellect();
// Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
// CritSpell += owner->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_CRIT_CHANCE);
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// CritSpell += owner->GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
// Increase crit spell from spell crit ratings
// CritSpell += owner->GetRatingBonusValue(CR_CRIT_SPELL);
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Crit from Agility
// CritMelee += owner->GetMeleeCritFromAgility();
// Increase crit from SPELL_AURA_MOD_WEAPON_CRIT_PERCENT
// CritMelee += owner->GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
// Increase crit from SPELL_AURA_MOD_CRIT_PCT
// CritMelee += owner->GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
// Increase crit melee from melee crit ratings
// CritMelee += owner->GetRatingBonusValue(CR_CRIT_MELEE);
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// Cobra Reflexes
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// Ravenous Dead. Check just if owner has Ravenous Dead since it's effect is not an aura
// Ravenous Dead edits the original scale
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, AuraEffectHandleModes /*mode*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// Ravenous Dead
// Check just if owner has Ravenous Dead since it's effect is not an aura
// Ravenous Dead edits the original scale
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
// Increase hit melee from meele hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_SPELL_HIT_CHANCE
// Increase hit spell from spell hit ratings
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
/* aurEff */, int32& amount, bool& /*canBeRecalculated*/)
// For others recalculate it from:
// Increase hit from SPELL_AURA_MOD_HIT_CHANCE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// obsolete
/*spellInfo*/) OVERRIDE
// Proc only with Penance, Holy Fire, Smite
/*spellInfo*/) OVERRIDE
// Proc only with Power Word: Shield or Leap of Faith
// 47515 - Divine Aegis
/*spellInfo*/) OVERRIDE
// Multiple effects stack, so let's try to find this aura.
// 37594 - Greater Heal Refund
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 92833 - Leap of Faith
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 7001 - Lightwell Renew
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// Bonus from Glyph of Lightwell
// 28305 - Mana Leech (Passive) (Priest Pet Aura)
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*eventInfo*/)
// 49821 - Mind Sear
// 47540 - Penance
// can't use other spell than this penance due to spell_ranks dependency
/*effIndex*/)
// 17 - Power Word: Shield
/*spellInfo*/) OVERRIDE
// +80.68% from sp bonus
// Borrowed Time
// Improved PW: Shield: its weird having a SPELLMOD_ALL_EFFECTS here but its blizzards doing :)
// Improved PW: Shield is only applied at the spell healing bonus because it was already applied to the base value in CalculateSpellDamage
// Focused Power
// 33110 - Prayer of Mending Heal
/*effIndex*/)
// 139 - Renew
/*spellInfo*/) OVERRIDE
/*mode*/)
// Divine Touch
// 32379 - Shadow Word Death
// Pain and Suffering reduces damage
// 15473 - Shadowform
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 15286 - Vampiric Embrace
/*spellInfo*/) OVERRIDE
// Not proc from Mind Sear
// 15290 - Vampiric Embrace (heal)
// 34914 - Vampiric Touch
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
/*effIndex*/)
// http://www.wowhead.com/quest=55 Morbent Fel
// 8913 Sacred Cleansing
// 9712 - Thaumaturgy Channel
/*spellInfo*/) OVERRIDE
/*aurEff*/)
// http://www.wowhead.com/quest=5206 Marauders of Darrowshire
// 17271 Test Fetid Skull
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/quest=6124 Curing the Sick (A)
// http://www.wowhead.com/quest=6129 Curing the Sick (H)
// 19512 Apply Salve
/*effIndex*/)
// http://www.wowhead.com/quest=10255 Testing the Antidote
// 34665 Administer Antidote
// http://www.wowhead.com/quest=11396 Bring Down Those Shields (A)
// http://www.wowhead.com/quest=11399 Bring Down Those Shields (H)
// 43874 Scourge Mur'gul Camp: Force Shield Arcane Purple x3
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 50133 Scourging Crystal Controller
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// Make sure nobody else is channeling the same target
// 43882 Scourging Crystal Controller Dummy
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/quest=11515 Blood for Blood
// 44936 Quest - Fel Siphon Dummy
// http://www.wowhead.com/quest=11587 Prison Break
// 45449 Arcane Prisoner Rescue
// Summon Arcane Prisoner - Male
// Summon Arcane Prisoner - Female
// Arcane Prisoner Kill Credit
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/quest=11730 Master and Servant
// 46023 The Ultrasonic Screwdriver
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// http://www.wowhead.com/quest=12459 That Which Creates Can Also Destroy
// 49587 Seeds of Nature's Wrath
/*effIndex*/)
// http://www.wowhead.com/quest=12634 Some Make Lemonade, Some Make Liquor
// 51840 Despawn Fruit Tosser
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// sometimes, if you're lucky, you get a dwarf
// http://www.wowhead.com/quest=12683 Burning to Help
// 52308 Take Sputum Sample
/*effIndex*/)
// http://www.wowhead.com/quest=12851 Going Bearback
// 54798 FLAMING Arrow Triggered Effect
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Already in fire
// http://www.wowhead.com/quest=12937 Relief for the Fallen
// 55804 Healing Finished
/*spellEntry*/) OVERRIDE
/*effIndex*/)
/*spellEntry*/) OVERRIDE
// 8593 Symbol of life dummy
/*effIndex*/)
// http://www.wowhead.com/quest=12659 Scalps!
// 52090 Ahunae's Knife
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
/*
//www.wowhead.com/quest=13280 King of the Mountain
/*effIndex*/)
/*spellEntry*/) OVERRIDE
/*effIndex*/)
// http://old01.wowhead.com/quest=9452 - Red Snapper - Very Tasty!
/*effIndex*/)
// Hodir's Helm KC Bunny
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// player must cast kill credit and do emote text, according to sniff
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
/*effIndex*/)
// http://www.wowhead.com/quest=12372 Defending Wyrmrest Temple
// 49370 - Wyrmrest Defender: Destabilize Azure Dragonshrine Effect
// NPCs
// Spells
/*effIndex*/)
// ID - 50287 Azure Dragon: On Death Force Cast Wyrmrest Defender to Whisper to Controller - Random (casted from Azure Dragons and Azure Drakes on death)
/*effIndex*/)
// "Bombing Run" and "Bomb Them Again!"
// Spell
// NPCs
// 40113 Knockdown Fel Cannon: The Aggro Check Aura
/*aurEff*/)
// On trigger proccing
// 40112 Knockdown Fel Cannon: The Aggro Check
/*effIndex*/)
// Check if found player target is on fly mount or using flying form
// 40119 Knockdown Fel Cannon: The Aggro Burst
/*aurEff*/)
// On each tick cast Choose Loc to trigger summon
// 40056 Knockdown Fel Cannon: Choose Loc
/*effIndex*/)
// Check for player that is in 65 y range
// Check if found player target is on fly mount or using flying form
// Summom Fel Cannon (bunny version) at found player
// 39844 - Skyguard Blasting Charge
// 40160 - Throw Bomb
// This spell will be cast only if caster has one of these auras
/*spell*/) OVERRIDE
/* effIndex */)
/*effIndex*/)
// Adjust effect summon position
/*spellInfo*/) OVERRIDE
/*aurEff*/)
// 13291 - Borrowed Technology/13292 - The Solution Solution /Daily//13239 - Volatility/13261 - Volatiliy /Daily//
// NPCs
// Spells
/*spell*/) OVERRIDE
/*effIndex*/)
// TO DO: Being triggered is hack, but in checkcast it doesn't pass aurastate requirements.
// Beside that the decoy won't keep it's freeze animation state when enter.
/*effIndex*/)
// Adjust effect summon position
/*effIndex*/)
// Adjust effect summon position
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 50% chance
/*effIndex*/)
// Burst at the Seams
// Damage spell
// Abomination self damage spell
// Burst at the Seams:Bone
// Explode Abomination:Meat
// Explode Abomination:Bloody Meat
// Credit for Drakkari Skullcrusher
// Summon Drakkari Chieftain
// Drakkari Chieftain Kill Credit
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
// 48682 - Escape from Silverbrook - Periodic Dummy
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 48681 - Summon Silverbrook Worgen
// 51858 - Siphon of Acherus
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 51769 - Emblazon Runeblade
// 51770 - Emblazon Runeblade
/*effIndex*/)
/*spell*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
// 93072 - Get Our Boys Back Dummy
/*spellInfo*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// 13877, 33735, (check 51211, 65956) - Blade Flurry
/*spellInfo*/) OVERRIDE
// 31228 - Cheat Death
/*spellInfo*/) OVERRIDE
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// Set absorbtion amount to unlimited
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
// hp > 10% - absorb hp till 10%
// hp lower than 10% - absorb everything
// -51625 - Deadly Brew
/*spellInfo*/) OVERRIDE
// -51664 - Cut to the Chase
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// 2818 - Deadly Poison
// at this point CastItem must already be initialized
// Deadly Poison
// item combat enchantments
// not holding enchantment id
// Proc only rogue poisons
// Do not reproc deadly
// 31666 - Master of Subtlety
/*spellInfo*/)
/*aurEff*/)
// 31130 - Nerves of Steel
/*aurEff*/, int32 & amount, bool & /*canBeRecalculated*/)
// Set absorbtion amount to unlimited
/*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
// reduces all damage taken while stun or fear
// 58428 - Overkill
/*spellInfo*/)
/*aurEff*/)
// 14185 - Preparation
/*effIndex*/)
// immediately finishes the cooldown on certain Rogue abilities
// 73651 - Recuperate
/*aurEff*/)
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// Improved Recuperate
// 1943 - Rupture
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// 1 point:  ${($m1 + $b1*1 + 0.015 * $AP) * 4} damage over 8 secs
// 2 points: ${($m1 + $b1*2 + 0.024 * $AP) * 5} damage over 10 secs
// 3 points: ${($m1 + $b1*3 + 0.03 * $AP) * 6} damage over 12 secs
// 4 points: ${($m1 + $b1*4 + 0.03428571 * $AP) * 7} damage over 14 secs
// 5 points: ${($m1 + $b1*5 + 0.0375 * $AP) * 8} damage over 16 secs
// 1784 - Stealth
/*spellInfo*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Master of Subtlety
// Overkill
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Master of subtlety
// 57934 - Tricks of the Trade
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*eventInfo*/)
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// maybe handle by proc charges
// 59628 - Tricks of the Trade (Proc)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// -51556 - Ancestral Awakening
/*spellInfo*/) OVERRIDE
// 52759 - Ancestral Awakening
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 2825 - Bloodlust
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
// 1064 - Chain Heal
/// Updated 4.3.4
/*effIndex*/)
// Check if the target has Riptide
// Consume it
// Riptide increases the Chain Heal effect by 25%
// 974 - Earth Shield
/*spellInfo*/) OVERRIDE
/*aurEff*/, int32& amount, bool & /*canBeRecalculated*/)
// Glyph of Earth Shield
//! WORKAROUND
//! this glyph is a proc
/*eventInfo*/)
//! HACK due to currenct proc system implementation
/*eventInfo*/)
/// @hack: due to currenct proc system implementation
// 86185 Feedback
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// will prevent default effect execution
// 1535 Fire Nova
/// Updated 4.3.4
/*effIndex*/)
// 77794 - Focused Insight
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 55440 - Glyph of Healing Wave
/*spellInfo*/) OVERRIDE
// Not proc from self heals
// 52041 - Healing Stream Totem
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/* effIndex */)
// Soothing Rains
// 32182 - Heroism
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
// 23551 - Lightning Shield
/*spellInfo*/) OVERRIDE
// 23552 - Lightning Shield
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 23572 - Mana Surge
/*spellInfo*/) OVERRIDE
// 60103 - Lava Lash
/// Updated 4.3.4
/*effIndex*/)
// Damage is increased by 25% if your off-hand weapon is enchanted with Flametongue.
/*spellInfo*/) OVERRIDE
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 16191 - Mana Tide
/// Updated 4.3.4
/*canBeRecalculated*/)
///@TODO: Exclude the "short term" buffs from the stat value
// -30881 - Nature's Guardian
/*spellInfo*/) OVERRIDE
//! HACK due to currenct proc system implementation
// 88756 - Rolling Thunder
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 82984 - Telluric Currents
/*spellInfo*/) OVERRIDE
// 51490 - Thunderstorm
// Glyph of Thunderstorm
// 51562 - Tidal Waves
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 114049 - Ascendance
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// -85113 - Aftermath
/*spellInfo*/) OVERRIDE
// 710 - Banish
/// Casting Banish on a banished target will cancel the effect
/// Check if the target already has Banish, if so, do nothing.
// No need to remove old aura since its removed due to not stack by current Banish aura
// 17962 - Conflagrate - Updated to 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 6201 - Create Healthstone
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 48018 - Demonic Circle: Summon
/// Updated 4.3.4
/*aurEff*/, AuraEffectHandleModes mode)
// If effect is removed by expire remove the summoned demonic circle too.
/*aurEff*/)
// Here we check if player is in demonic circle teleport range, if so add
// WARLOCK_DEMONIC_CIRCLE_ALLOW_CAST; allowing him to cast the WARLOCK_DEMONIC_CIRCLE_TELEPORT.
// If not in range remove the WARLOCK_DEMONIC_CIRCLE_ALLOW_CAST.
// 48020 - Demonic Circle: Teleport
/// Updated 4.3.4
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 47193 - Demonic Empowerment
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 47422 - Everlasting Affliction
/// Updated 4.3.4
/*effIndex*/)
// Refresh corruption on target
// 77799 - Fel Flame - Updated to 4.3.4
/*effIndex*/)
// -47230 - Fel Synergy
/*spellInfo*/) OVERRIDE
// TARGET_UNIT_PET
// 63310 - Glyph of Shadowflame
/*spellInfo*/) OVERRIDE
// 755 - Health Funnel
/// Updated 4.3.4
/*aurEff*/, AuraEffectHandleModes /*mode*/)
/*aurEff*/, AuraEffectHandleModes /*mode*/)
//! HACK for self damage, is not blizz :/
// 6262 - Healthstone
// -18119 - Improved Soul Fire
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 1454 - Life Tap
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// Shouldn't Appear in Combat Log
// Improved Life Tap mod
// Mana Feed
// 687 - Demon Armor
// 28176 - Fel Armor
/*spellInfo*/) OVERRIDE
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// 6358 - Seduction (Special Ability)
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// SW:D shall not be removed.
// 27285 - Seed of Corruption
/// Updated 4.3.4
// -18094 - Nightfall
// 56218 - Glyph of Corruption
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// -7235 - Shadow Ward
/*aurEff*/, int32& amount, bool& canBeRecalculated)
// +80.68% from sp bonus
// -30293 - Soul Leech
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 86121 - Soul Swap
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 86211 - Soul Swap Override - Also acts as a dot container
//! Forced to, pure virtual functions must have a body when linking
//! Soul Swap Copy Spells - 92795 - Simply copies spell IDs.
// 86213 - Soul Swap Exhale
/*spellInfo*/) OVERRIDE
// Soul Swap Exhale can't be cast on the same target than Soul Swap
/*effIndex*/)
// Remove Soul Swap Exhale buff
// Add a cooldown on Soul Swap if caster has the glyph
// 29858 - Soulshatter
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 30108, 34438, 34439, 35183 - Unstable Affliction
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
// backfire damage and silence
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
// Bloodthirst - 23881
/*SpellEntry*/)
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*effIndex*/)
/// Updated 4.3.4
/*effIndex*/)
// Called By Thunder Clap - 6343, Mortal Strike - 12294, Bloodthirst - 23881 and Devastate - 20243
// Deep Wounds - 115767
// Item - Warrior T16 DPS 4P Bonus - 144441
/// Updated 4.3.4
/*effIndex*/)
// Sudden Death rage save
/// Formula taken from the DBC: "${10+$AP*0.437*$m1/100}"
/// Formula taken from the DBC: "${$ap*0.874*$m1/100-1} = 20 rage"
// 58387 - Glyph of Sunder Armor
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// 59725 - Improved Spell Reflection
// 5246 - Intimidating Shout
// -84583 Lambs to the Slaughter
/*spellInfo*/) OVERRIDE
/*aurEff*/, ProcEventInfo& eventInfo)
/// Updated 4.3.4
// 12975 - Last Stand
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// add dummy effect spell handler to Last Stand
// 7384 - Overpower
/*effIndex*/)
// 97462 - Rallying Cry
/*spellInfo*/) OVERRIDE
/*effIndex*/)
// 94009 - Rend
// $0.25 * (($MWB + $mwb) / 2 + $AP / 14 * $MWS) bonus per tick
// 20230 - Retaliation
/*spellInfo*/) OVERRIDE
// check attack comes not from behind
// 64380, 65941 - Shattering Throw
// remove shields, will still display immune to damage part
/// Updated 4.3.4
/*spellInfo*/) OVERRIDE
/*effIndex*/)
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
/*aurEff*/, int32& amount, bool& /*canBeRecalculated*/)
// 52437 - Sudden Death
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// Remove cooldown on Colossus Smash
// correct?
// 12328, 18765, 35429 - Sweeping Strikes
/*spellInfo*/) OVERRIDE
/*eventInfo*/)
// -46951 - Sword and Board
/*spellInfo*/) OVERRIDE
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// Remove cooldown on Shield Slam
// 32216 - Victorious
// 82368 - Victorious
/*aurEff*/, ProcEventInfo& /*eventInfo*/)
// 50720 - Vigilance
/*spellInfo*/) OVERRIDE
/*aurEff*/, AuraEffectHandleModes /*mode*/)
// 50725 Vigilance
// Remove Taunt cooldown
/*spellEntry*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
// this checks GetBattleground() for NULL already
/*source*/, Unit* target) OVERRIDE
/*target*/) OVERRIDE
/*target*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*######
/*trigger*/) OVERRIDE
/*#####
/*trigger*/) OVERRIDE
/*######
/*trigger*/) OVERRIDE
/*######
/*trigger*/) OVERRIDE
/*#####
/*######
/*######
/*trigger*/) OVERRIDE
/*######
// in seconds
// Initialize for cooldown
// Second trigger happened too early after first, skip for now
/*######
/*######
/* trigger */) OVERRIDE
/// The npc would search an alternative way to get to the last waypoint without this unit state.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*type*/, uint32 lang, std::string& msg, Player* receiver)
//! NOTE:
//! LANG_ADDON can only be sent by client in "PARTY", "RAID", "GUILD", "BATTLEGROUND", "WHISPER"
/*type*/, uint32 /*lang*/, std::string& msg, Channel* channel)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ContentData
/*######
/*go*/) OVERRIDE
/*######
/*go*/) OVERRIDE
/*######
/*go*/) OVERRIDE
/*######
/*######
/*go*/) OVERRIDE
/*######
/*go*/) OVERRIDE
/*######
/// @todo use gossip option ("Transcript the Tablet") instead, if Skyfire adds support.
/*#####
/*go*/) OVERRIDE
/*######
//good guys
//bad guys
/*######
/*######
/*player*/, GameObject* go) OVERRIDE
/*######
/*######
/*######
//stuns player
/*go*/) OVERRIDE
//implicitTarget=48 not implemented as of writing this code, and manual summon may be just ok for our purpose
//player->CastSpell(player, SPELL_SUMMON_RIZZLE, false);
/*######
/*go*/) OVERRIDE
/*######
/*go*/) OVERRIDE
/*######
/* != GAMEOBJECT_TYPE_QUESTGIVER) */
/* return true*/
/*sender*/, uint32 action) OVERRIDE
/*######
/* != GAMEOBJECT_TYPE_QUESTGIVER) */
/* return true*/
/*sender*/, uint32 action) OVERRIDE
/*######
/*######
/*######
/*######
/*######
/*######
/*go*/) OVERRIDE
/*######
/*######
/// Due to the fact that this GameObject triggers CMSG_GAMEOBJECT_USE
/// _and_ CMSG_GAMEOBJECT_REPORT_USE, this GossipHello hook is called
/// twice. The script's handling is fine as it won't remove two charges
/// on the well. We have to find how to segregate REPORT_USE and USE.
/*######
/// @todo prisoner should help player for a short period of time
/*######
//FIX: Summon minion tadpole
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
/*player*/, GameObject* go) OVERRIDE
/*######
/*########
/*########
/*######
/*######
/*go*/, uint32 /*sender*/, uint32 /*action*/) OVERRIDE
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
//Always decrease our global cooldown first
//Buff timer (only buff when we are alive and not in combat
//Find a spell that targets friendly and applies an aura (these are generally buffs)
//Cast the buff spell
//Set our global cooldown
//Set our timer to 10 minutes before rebuff
//Try again in 30 seconds
//Return since we have no target
// Make sure our attack is ready and we arn't currently casting
//If we are within range melee the target
//Select a healing spell if less than 30% hp
//No healing spell available, select a hostile spell
//20% chance to replace our white hit with a spell
//Cast the spell
//Set our global cooldown
//Only run this code if we arn't already casting
//Select a healing spell if less than 30% hp ONLY 33% of the time
//No healing spell available, See if we can cast a ranged spell (Range must be greater than ATTACK_DISTANCE)
//Found a spell, check if we arn't on cooldown
//If we are currently moving stop us and set the movement generator
//Cast spell
//Set our global cooldown
//If no spells available and we arn't moving run to target
//Cancel our current spell and then mutate new movement generator
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*#####
/*targets*/) OVERRIDE
//for special scripts
// allow use in flight only
// error
/*#####
/*item*/, SpellCastTargets const& /*targets*/) OVERRIDE
/*#####
/*#####
/*targets*/) OVERRIDE
/*#####
/*pItemProto*/) OVERRIDE
// Cracked Egg
/*#####
/*pItemProto*/) OVERRIDE
// Ripe Disgusting Jar
/*#####
/*item*/, SpellCastTargets const & /*targets*/) OVERRIDE
/*#####
/*item*/, const SpellCastTargets & /*targets*/) OVERRIDE
/*######
/*item*/, const SpellCastTargets & /*targets*/) OVERRIDE
/*targets*/) OVERRIDE
// spell range
/*targets*/) OVERRIDE
/*targets*/) OVERRIDE {
///// - Sha Touched Weapons - /////
// Heart of Fear
// Shek'zeer
// Kri'tak, Imperial Scepter of the Swarm - Raid Finder
// Kri'tak, Imperial Scepter of the Swarm - Normal
// Kri'tak, Imperial Scepter of the Swarm - Heroic
// Shek'zeer
// Claws of Shek'zeer - Raid Finder
// Claws of Shek'zeer - Normal
// Claws of Shek'zeer - Heroic
// Terrace of Endless Spring
// Tsulong
// Loshan, Terror Incarnate - Raid Finder
// Loshan, Terror Incarnate - Normal
// Loshan, Terror Incarnate - Heroic
// Tsulong
// Gao-Rei, Staff of the Legendary Protector - Raid Finder
// Gao-Rei, Staff of the Legendary Protector - Normal
// Gao-Rei, Staff of the Legendary Protector - Heroic
// Lei Shi
// Taoren, the Soul Burner - Raid Finder
// Taoren, the Soul Burner - Normal
// Taoren, the Soul Burner - Heroic
// Lei Shi
// Spiritsever - Raid Finder
// Spiritsever - Normal
// Spiritsever - Heroic
// Lei Shi
// Jin'ya, Orb of the Waterspeaker - Raid Finder
// Jin'ya, Orb of the Waterspeaker - Normal
// Jin'ya, Orb of the Waterspeaker - Heroic
// Sha of Fear
// Kilrak, Jaws of Terror - Raid Finder
// Kilrak, Jaws of Terror - Normal
// Kilrak, Jaws of Terror - Heroic
// Sha of Fear
// Shin'ka, Execution of Dominion - Raid Finder
// Shin'ka, Execution of Dominion - Normal
// Shin'ka, Execution of Dominion - Heroic
///// - Throne of Thunder - /////
// Last Stand of the Zandalari
// Jin'Rokh
// Soulblade of the Breaking Storm - Raid Finder
// Soulblade of the Breaking Storm - Normal
// Soulblade of the Breaking Storm - Thunderforged
// Soulblade of the Breaking Storm - Heroic
// Soulblade of the Breaking Storm - Heroic Thunderforged
// Jin'Rokh
// Worldbreaker's Stormscythe - Raid Finder
// Worldbreaker's Stormscythe - Normal
// Worldbreaker's Stormscythe - Thunderforged
// Worldbreaker's Stormscythe - Heroic
// Worldbreaker's Stormscythe - Heroic Thunderforged
// Horridon
// Dinomancer's Spiritbinding Spire - Raid Finder
// Dinomancer's Spiritbinding Spire - Normal
// Dinomancer's Spiritbinding Spire - Thunderforged
// Dinomancer's Spiritbinding Spire - Heroic
// Dinomancer's Spiritbinding Spire - Heroic Thunderforged
// Horridon
// Jalak's Maelstrom Staff - Raid Finder
// Jalak's Maelstrom Staff - Normal
// Jalak's Maelstrom Staff - Thunderforged
// Jalak's Maelstrom Staff - Heroic
// Jalak's Maelstrom Staff - Heroic Thunderforged
// Horridon
// Venomlord's Totemic Wand - Raid Finder
// Venomlord's Totemic Wand - Normal
// Venomlord's Totemic Wand - Thunderforged
// Venomlord's Totemic Wand - Heroic
// Venomlord's Totemic Wand - Heroic Thunderforged
// Council of Elders
// Kura-Kura, Kazra'jin's Skullcleaver - Raid Finder
// Kura-Kura, Kazra'jin's Skullcleaver - Normal
// Kura-Kura, Kazra'jin's Skullcleaver - Thunderforged
// Kura-Kura, Kazra'jin's Skullcleaver - Heroic
// Kura-Kura, Kazra'jin's Skullcleaver - Heroic Thunderforged
// Council of Elders
// Amun-Thoth, Sul's Spiritrending Talons - Raid Finder
// Amun-Thoth, Sul's Spiritrending Talons - Normal
// Amun-Thoth, Sul's Spiritrending Talons - Thunderforged
// Amun-Thoth, Sul's Spiritrending Talons - Heroic
// Amun-Thoth, Sul's Spiritrending Talons - Heroic Thunderforged
// Council of Elders
// Zerat, Malakk's Soulburning Greatsword - Raid Finder
// Zerat, Malakk's Soulburning Greatsword - Normal
// Zerat, Malakk's Soulburning Greatsword - Thunderforged
// Zerat, Malakk's Soulburning Greatsword - Heroic
// Zerat, Malakk's Soulburning Greatsword - Heroic Thunderforged
// Forgotten Depths
// Tortos
// Shellsplitter Greataxe - Raid Finder
// Shellsplitter Greataxe - Normal
// Shellsplitter Greataxe - Thunderforged
// Shellsplitter Greataxe - Heroic
// Shellsplitter Greataxe - Heroic Thunderforged
// Tortos
// Shattered Tortoiseshell Longbow - Raid Finder
// Shattered Tortoiseshell Longbow - Normal
// Shattered Tortoiseshell Longbow - Thunderforged
// Shattered Tortoiseshell Longbow - Heroic
// Shattered Tortoiseshell Longbow - Heroic Thunderforged
// Megaera
// Megaera's Poisoned Fang - Raid Finder
// Megaera's Poisoned Fang - Normal
// Megaera's Poisoned Fang - Thunderforged
// Megaera's Poisoned Fang - Heroic
// Megaera's Poisoned Fang - Heroic Thunderforged
// Ji'kun
// Giorgio's Caduceus of Pure Moods - Raid Finder
// Giorgio's Caduceus of Pure Moods - Normal
// Giorgio's Caduceus of Pure Moods - Thunderforged
// Giorgio's Caduceus of Pure Moods - Heroic
// Giorgio's Caduceus of Pure Moods - Heroic Thunderforged
// Halls of Flesh-Shapping
// Durumu
// Ritual Dagger of the Mind's Eye - Raid Finder
// Ritual Dagger of the Mind's Eye - Normal
// Ritual Dagger of the Mind's Eye - Thunderforged
// Ritual Dagger of the Mind's Eye - Heroic
// Ritual Dagger of the Mind's Eye - Heroic Thunderforged
// Durumu
// Durumu's Baleful Gaze - Raid Finder
// Durumu's Baleful Gaze - Normal
// Durumu's Baleful Gaze - Thunderforged
// Durumu's Baleful Gaze - Heroic
// Durumu's Baleful Gaze - Heroic Thunderforged
// Primordius
// Acid-Spine Bonemace - Raid Finder
// Acid-Spine Bonemace - Normal
// Acid-Spine Bonemace - Thunderforged
// Acid-Spine Bonemace - Heroic
// Acid-Spine Bonemace - Heroic Thunderforged
// Dark Animus
// Athame of the Sanguine Ritual - Raid Finder
// Athame of the Sanguine Ritual - Normal
// Athame of the Sanguine Ritual - Thunderforged
// Athame of the Sanguine Ritual - Heroic
// Athame of the Sanguine Ritual - Heroic Thunderforged
// Dark Animus
// Hand of the Dark Animus - Raid Finder
// Hand of the Dark Animus - Normal
// Hand of the Dark Animus - Thunderforged
// Hand of the Dark Animus - Heroic
// Hand of the Dark Animus - Heroic Thunderforged
// Pinnacle of Storms
// Iron Qon
// Iron Qon's Boot Knife - Raid Finder
// Iron Qon's Boot Knife - Normal
// Iron Qon's Boot Knife - Thunderforged
// Iron Qon's Boot Knife - Heroic
// Iron Qon's Boot Knife - Heroic Thunderforged
// Iron Qon
// Qon's Flaming Scimitar - Raid Finder
// Qon's Flaming Scimitar - Normal
// Qon's Flaming Scimitar - Thunderforged
// Qon's Flaming Scimitar - Heroic
// Qon's Flaming Scimitar - Heroic Thunderforged
// Iron Qon
// Voice of the Quilen - Raid Finder
// Voice of the Quilen - Normal
// Voice of the Quilen - Thunderforged
// Voice of the Quilen - Heroic
// Voice of the Quilen - Heroic Thunderforged
// Twin Consorts
// Wu-Lai, Bladed Fan of the Consorts - Raid Finder
// Wu-Lai, Bladed Fan of the Consorts - Normal
// Wu-Lai, Bladed Fan of the Consorts - Thunderforged
// Wu-Lai, Bladed Fan of the Consorts - Heroic
// Wu-Lai, Bladed Fan of the Consorts - Heroic Thunderforged
// Twin Consorts
// Suen-Wo, Spire of the Falling Sun - Raid Finder
// Suen-Wo, Spire of the Falling Sun - Normal
// Suen-Wo, Spire of the Falling Sun - Thunderforged
// Suen-Wo, Spire of the Falling Sun - Heroic
// Suen-Wo, Spire of the Falling Sun - Heroic Thunderforged
// Lei Shen
// Shan-Dun, Breaker of Hope - Raid Finder
// Shan-Dun, Breaker of Hope - Normal
// Shan-Dun, Breaker of Hope - Thunderforged
// Shan-Dun, Breaker of Hope - Heroic
// Shan-Dun, Breaker of Hope - Heroic Thunderforged
// Lei Shen
// Uroe, Harbinger of Terror - Raid Finder
// Uroe, Harbinger of Terror - Normal
// Uroe, Harbinger of Terror - Thunderforged
// Uroe, Harbinger of Terror - Heroic
// Uroe, Harbinger of Terror - Heroic Thunderforged
// Lei Shen
// Torall, Rod of the Shattered Throne - Raid Finder
// Torall, Rod of the Shattered Throne - Normal
// Torall, Rod of the Shattered Throne - Thunderforged
// Torall, Rod of the Shattered Throne - Heroic
// Torall, Rod of the Shattered Throne - Heroic Thunderforged
// Shared Boss Loot
// Bo-Ris, Horror in the Night - Raid Finder
// Bo-Ris, Horror in the Night - Normal
// Bo-Ris, Horror in the Night - Thunderforged
// Bo-Ris, Horror in the Night - Heroic
// Bo-Ris, Horror in the Night - Heroic Thunderforged
// Shared Boss Loot
// Darkwood Spiritstaff - Raid Finder
// Darkwood Spiritstaff - Normal
// Darkwood Spiritstaff - Thunderforged
// Darkwood Spiritstaff - Heroic
// Darkwood Spiritstaff - Heroic Thunderforged
// Shared Boss Loot
// Do-tharak, the Swordbreaker - Raid Finder
// Do-tharak, the Swordbreaker - Normal
// Do-tharak, the Swordbreaker - Thunderforged
// Do-tharak, the Swordbreaker - Heroic
// Do-tharak, the Swordbreaker - Heroic Thunderforged
// Shared Boss Loot
// Fyn's Flickering Dagger - Raid Finder
// Fyn's Flickering Dagger - Normal
// Fyn's Flickering Dagger - Thunderforged
// Fyn's Flickering Dagger - Heroic
// Fyn's Flickering Dagger - Heroic Thunderforged
// Shared Boss Loot
// Greatsword of Frozen Hells - Raid Finder
// Greatsword of Frozen Hells - Normal
// Greatsword of Frozen Hells - Thunderforged
// Greatsword of Frozen Hells - Heroic
// Greatsword of Frozen Hells - Heroic Thunderforged
// Shared Boss Loot
// Invocation of the Dawn - Raid Finder
// Invocation of the Dawn - Normal
// Invocation of the Dawn - Thunderforged
// Invocation of the Dawn - Heroic
// Invocation of the Dawn - Heroic Thunderforged
// Shared Boss Loot
// Jerthud, Graceful Hand of the Savior - Raid Finder
// Jerthud, Graceful Hand of the Savior - Normal
// Jerthud, Graceful Hand of the Savior - Thunderforged
// Jerthud, Graceful Hand of the Savior - Heroic
// Jerthud, Graceful Hand of the Savior - Heroic Thunderforged
// Shared Boss Loot
// Miracoran, the Vehement Chord - Raid Finder
// Miracoran, the Vehement Chord - Normal
// Miracoran, the Vehement Chord - Thunderforged
// Miracoran, the Vehement Chord - Heroic
// Miracoran, the Vehement Chord - Heroic Thunderforged
// Shared Boss Loot
// Nadagast's Exsanguinator - Raid Finder
// Nadagast's Exsanguinator - Normal
// Nadagast's Exsanguinator - Thunderforged
// Nadagast's Exsanguinator - Heroic
// Nadagast's Exsanguinator - Heroic Thunderforged
// Shared Boss Loot
// Tia-Tia, the Scything Star - Raid Finder
// Tia-Tia, the Scything Star - Normal
// Tia-Tia, the Scything Star - Thunderforged
// Tia-Tia, the Scything Star - Heroic
// Tia-Tia, the Scything Star - Heroic Thunderforged
// Shared Boss Loot
// Zeeg's Ancient Kegsmasher - Raid Finder
// Zeeg's Ancient Kegsmasher - Normal
// Zeeg's Ancient Kegsmasher - Thunderforged
// Zeeg's Ancient Kegsmasher - Heroic
// Zeeg's Ancient Kegsmasher - Heroic Thunderforged
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
//This variable acts like the global cooldown that players have (1.5 seconds)
//This variable keeps track of buffs
//Rebuff as soon as we can
//Always decrease our global cooldown first
//Buff timer (only buff when we are alive and not in combat
//Find a spell that targets friendly and applies an aura (these are generally buffs)
//Cast the buff spell
//Set our global cooldown
//Set our timer to 10 minutes before rebuff
//Try agian in 30 seconds
//Return since we have no target
//If we are within range melee the target
//Make sure our attack is ready and we arn't currently casting
//Select a healing spell if less than 30% hp
//No healing spell available, select a hostile spell
//50% chance if elite or higher, 20% chance if not, to replace our white hit with a spell
//Cast the spell
//Set our global cooldown
//Only run this code if we arn't already casting
//Select a healing spell if less than 30% hp ONLY 33% of the time
//No healing spell available, See if we can cast a ranged spell (Range must be greater than ATTACK_DISTANCE)
//Found a spell, check if we arn't on cooldown
//If we are currently moving stop us and set the movement generator
//Cast spell
//Set our global cooldown
//If no spells available and we arn't moving run to target
//Cancel our current spell and then allow movement agian
//new generic_creature;
//new trigger_death;
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/* ContentData
/*########
// no warning, summon Creature at smaller range
// cast guards mark and summon npc - if player shows up with that buff duration < 5 seconds attack
//Air Force Alarm Bot (Alliance)
//Air Force Alarm Bot (Horde)
//Air Force Alarm Bot (Area 52)
//Air Force Guard Post (Horde - Bat Rider)
//Air Force Guard Post (Alliance - Gryphon)
//Air Force Guard Post (Goblin - Area 52 - Zeppelin)
//Air Force Trip Wire - Rooftop (Alliance)
//Air Force Trip Wire - Rooftop (Horde)
//Air Force Trip Wire - Ground (Horde)
//Air Force Trip Wire - Ground (Alliance)
//Air Force Trip Wire - Rooftop (Goblin - Area 52)
//Air Force Guard Post (Ethereal - Stormspire)
//Air Force Guard Post (Scryer - Dragonhawk)
//Air Force Trip Wire - Rooftop (Ethereal - Stormspire)
//Air Force Alarm Bot (Stormspire)
//Air Force Trip Wire - Rooftop (Scryer)
//Air Force Alarm Bot (Scryer)
//Air Force Alarm Bot (Aldor)
//Air Force Guard Post (Aldor - Gryphon)
//Air Force Trip Wire - Rooftop (Aldor)
//Air Force Alarm Bot (Sporeggar)
//Air Force Guard Post (Sporeggar - Spore Bat)
//Air Force Trip Wire - Rooftop (Sporeggar)
//Air Force Guard Post (Toshley's Station - Flying Machine)
//Air Force Alarm Bot (Cenarion)
//Air Force Guard Post (Cenarion - Stormcrow)
//Air Force Trip Wire - Rooftop (Cenarion Expedition)
// find the correct spawnhandling
// airforce guards only spawn for players
// prevent calling Unit::GetUnit at next MoveInLineOfSight call - speedup
// the target wasn't able to move out of our range within 25 seconds
// ROOFTOP only triggers if the player is on the ground
/*######
/*sender*/, uint32 action) OVERRIDE
/*########
/*who*/) OVERRIDE { }
// Reset flags after a certain time has passed so that the next player has to start the 'event' again
/*player*/, Creature* creature, Quest const* quest) OVERRIDE
/*player*/, Creature* creature, Quest const* quest) OVERRIDE
/*######
/*who*/)OVERRIDE { }
/*######
// Top-far-right bunk as seen from entrance
// Top-far-left bunk
// Far-right bunk
// Right bunk near entrance
// Far-left bunk
// Mid-left bunk
// Left bunk near entrance
//alliance run to where
// Left, Behind
// Right, Behind
// Left, Mid
// Right, Mid
// Left, front
// Right, Front
//horde run to where
// 12938 Injured Alliance Soldier
// 12936 Badly injured Alliance Soldier
// 12937 Critically injured Alliance Soldier
//12923 Injured Soldier
//12924 Badly injured Soldier
//12925 Critically injured Soldier
/*######
// If no player or player abandon quest in progress
/*soldier*/, Player* player, Location* point)
/*who*/) OVERRIDE { }
/*#####
//no select
//no regen health
//to make them lay with face down
//lower max health
//Injured Soldier
//Badly injured Soldier
//Critically injured Soldier
/*who*/)OVERRIDE { }
//make not selectable
//regen health
//stand up
/*diff*/) OVERRIDE
//lower HP on every world tick makes it a useful counter, not officlone though
//303, this flag appear to be required for client side item->spell to work (TARGET_SINGLE_FRIEND)
/*######
/// @todo get text for each NPC
// used by 12429, 12423, 12427, 12430, 12428, but signed for 12429
// expect database to have RegenHealth=0
/*who*/) OVERRIDE { }
//not while in combat
//nothing to be done now
// give quest credit, not expect any special quest objectives
/*waypointId*/) OVERRIDE
//something went wrong
/*######
/*who*/) OVERRIDE
/*diff*/) OVERRIDE
/*######
//Katie Hunter
//Unger Statforth
//Merideth Carlson
//Gregor MacVince
//Veron Amberstill
//Ogunaro Wolfrunner
//Harb Clawhoof
//Lelanai
//Zachariah Post
//Zjolnir
//Milli Featherwhistle
//Winaestra
//Torallius the Pack Handler
/*sender*/, uint32 action) OVERRIDE
/*######
/*sender*/, uint32 action) OVERRIDE
// Cast spells that teach dual spec
// Both are also ImplicitTarget self and must be cast by player
// Should show another Gossip text with "Congratulations..."
/*######
// dmg
// res
// arm
// spi
// int
// stm
// str
// agi
// faire fortune
/*who*/) OVERRIDE { }
// Initialize the action bar without the melee attack command
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
/*who*/) OVERRIDE { }
// unsummon it
/*####
//disable rotate
//imune to knock aways like blast wave
/*doneBy*/, uint32& damage) OVERRIDE
//disable rotate
/*who*/) OVERRIDE { }
/*######
// Guessed value, it is really rare though
/*sender*/, uint32 action) OVERRIDE
// Borean Tundra
// Howling Fjord
// Sholazar Basin
// Icecrown
// Storm peaks
// Underground
/*######
/*sender*/, uint32 action) OVERRIDE
/*######
// Arcatraz Key
// Shadowforge Key
// Skeleton Key
// Shatered Halls Key
// Master's Key
// Violet Hold Key
// Essence-Infused Moonstone
// Key to the Focusing Iris
// Heroic Key to the Focusing Iris
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
/*######
//10 00 00 copper (10golds)
/*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE
//PLAYER_FIELD_FLAGS_NO_XP_GAIN
//xp off
//does gain xp
//switch to don't gain xp
//xp on
//doesn't gain xp
//switch to gain xp
// Check if we are near Elune'ara lake south, if so try to summon Omen or a minion
//me->CastSpell(me, GetFireworkSpell(me->GetEntry()), true);
/*#####
/*who*/) OVERRIDE { }
/*param*/) OVERRIDE
/*creature*/, uint32 /*sender*/, uint32 action)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*sender*/, uint32 action) OVERRIDE
// cannot cast, random 30sec
// lepper gnome costume
// male ghost costume
// female ghostcostume
// male ninja costume
// female ninja costume
// male pirate costume
// female pirate costume
// skeleton costume
// Trick
// Hallow's End Candy
// Hallow's End Candy
// Hallow's End Candy
// Hallow's End Candy
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
/*
/*###
/*###
/*###
/*###
/*###
//tailor, alchemy
/*player*/)                      //tailor, alchemy
//tailor, alchemy
/*player*/)                //tailor, alchemy
//blacksmith, leatherwork
//blacksmith
/*###
//player has item equipped that require specialty. Not allow to unlearn, player has to unequip first
// S_UNLEARN_WEAPON
// Light Earthforged Blade
// Light Emberforged Hammer
// Light Skyforged Axe
// S_UNLEARN_ARMOR
// Earthforged Leggings
// Heavy Earthforged Breastplate
// Stormforged Hauberk
// Breastplate of Kings
// Nether Chain Shirt
// Bulwark of Kings
// Bulwark of the Ancient Kings
// Embrace of the Twisting Nether
// Twisting Nether Chain Shirt
// Windforged Leggings
// S_UNLEARN_HAMMER
// Dragonstrike
// Dragonmaw
// Drakefist Hammer
// Lavaforged Warhammer
// Thunder
// Deep Thunder
// Stormherald
// Great Earthforged Hammer
// S_UNLEARN_AXE
// Wicked Edge of the Planes
// Black Planar Edge
// The Planar Edge
// Stormforged Axe
// Skyforged Great Axe
// Bloodmoon
// Lunar Crescent
// Mooncleaver
// S_UNLEARN_SWORD
// Blazefury
// Blazeguard
// Fireguard
// Windforged Rapier
// Stoneforged Claymore
// Lionheart Blade
// Lionheart Champion
// Lionheart Executioner
// S_UNLEARN_DRAGON
// Dragonstrike Leggings
// Golden Dragonstrike Breastplate
// Ebon Netherscale Belt
// Ebon Netherscale Bracers
// Ebon Netherscale Breastplate
// Netherstrike Belt
// Netherstrike Bracers
// Netherstrike Breastplate
// S_UNLEARN_ELEMENTAL
// Blackstorm Leggings
// Primalstorm Breastplate
// Primalstrike Belt
// Primalstrike Bracers
// Primalstrike Vest
// S_UNLEARN_TRIBAL
// Windhawk Hauberk
// Windhawk Belt
// Windhawk Bracers
// Wildfeather Leggings
// Living Crystal Breastplate
// S_UNLEARN_SPELLFIRE
// Spellfire Belt
// Spellfire Gloves
// Spellfire Robe
// S_UNLEARN_MOONCLOTH
// Primal Mooncloth Belt
// Primal Mooncloth Shoulders
// Primal Mooncloth Robe
// S_UNLEARN_SHADOWEAVE
// Frozen Shadoweave Shoulders
// Frozen Shadoweave Boots
// Frozen Shadoweave Robe
/*###
//Zarevhi
//Lorokeem
//Lauranna Thar'well
//Learn Alchemy
//Unlearn Alchemy
//unknown textID ()
//unknown textID ()
//unknown textID ()
//Zarevhi
//unknown textID ()
//Lorokeem
//unknown textID ()
//Lauranna Thar'well
//unknown textID ()
/*###
//WEAPONSMITH & ARMORSMITH
//Myolor Sunderfury
//Krathok Moltenfist
//Ironus Coldsteel
//Borgosh Corebender
//Grumnus Steelshaper
//Okothos Ironrager
//WEAPONSMITH SPEC
//Lilith the Lithe
//Kilram
//Seril Scourgebane
//Learn Armor/Weapon
//_Creature->CastSpell(player, S_REP_ARMOR, true);
//_Creature->CastSpell(player, S_REP_WEAPON, true);
//Unlearn Armor/Weapon
//unknown textID (TALK_MUST_UNLEARN_WEAPON)
//Learn Hammer/Axe/Sword
//Unlearn Hammer/Axe/Sword
//unknown textID (TALK_HAMMER_LEARN)
//unknown textID (TALK_AXE_LEARN)
//unknown textID (TALK_SWORD_LEARN)
//Ironus Coldsteel
//Borgosh Corebender
//Grumnus Steelshaper
//Okothos Ironrager
//unknown textID (TALK_UNLEARN_AXEORWEAPON)
//unknown textID (TALK_HAMMER_UNLEARN)
//unknown textID (TALK_AXE_UNLEARN)
//unknown textID (TALK_SWORD_UNLEARN)
/*###
/*###
//Peter Galen
//Thorkaf Dragoneye
//Sarah Tanner
//Brumn Winterhoof
//Caryssia Moonhunter
//Se'Jib
//Unlearn Leather
//Peter Galen
//Thorkaf Dragoneye
//unknown textID ()
//Sarah Tanner
//Brumn Winterhoof
//unknown textID ()
//Caryssia Moonhunter
//Se'Jib
//unknown textID ()
/*###
//TAILORING SPEC
//Gidge Spellweaver
//Nasmara Moonsong
//Andrion Darkspinner
//Learn Tailor
//Unlearn Tailor
//unknown textID ()
//unknown textID ()
//unknown textID ()
//Gidge Spellweaver
//unknown textID ()
//Nasmara Moonsong
//unknown textID ()
//Andrion Darkspinner
//unknown textID ()
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* ScriptData
// Azuremyst Isle - Susurrus
// Netherstorm - Protectorate Nether Drake
// Old Hillsbrad Foothills - Brazen
// Stormwind City - Thargold Ironwing
// Hellfire Peninsula - Wing Commander Dabir'ee
//Mission: The Murketh and Shaadraz Gateways
//Shatter Point
// Hellfire Peninsula - Gryphoneer Windbellow
//Mission: The Abyssal Shelf || Return to the Abyssal Shelf
//Go to the Front
// Hellfire Peninsula - Wing Commander Brack
//Mission: The Murketh and Shaadraz Gateways
//Mission: The Abyssal Shelf || Return to the Abyssal Shelf
//Spinebreaker Post
// Blade's Edge Mountains - Skyguard Handler Irena
// Isle of Quel'Danas - Ayren Cloudbreaker
// Isle of Quel'Danas - Unrestrained Dragonhawk
// Netherstorm - Veronia
//Behind Enemy Lines
// Terokkar Forest - Skyguard Handler Deesak
// Dragonblight - Lord Afrasastrasz
// middle -> ground
// middle -> top
// Dragonblight - Tariolstrasz //need to check if quests are required before gossip available (12123, 12124)
// ground -> top
// ground -> middle
// Dragonblight - Torastrasza
// top -> middle
// top -> ground
// Dustwallow Marsh - Cassa Crimsonwing
/*sender*/, uint32 action) OVERRIDE
//spellId is correct, however it gives flight a somewhat funny effect //TaxiPath 506.
//TaxiPath 627 (possibly 627+628(152->153->154->155))
//TaxiPath 534
//TaxiPath 1041 (Stormwind Harbor)
//TaxiPath 585 (Gateways Murket and Shaadraz)
//TaxiPath 612 (Taxi - Hellfire Peninsula - Expedition Point to Shatter Point)
//TaxiPath 589 (Aerial Assault Flight (Alliance))
//TaxiPath 607 (Taxi - Hellfire Peninsula - Shatter Point to Beach Head)
//TaxiPath 584 (Gateways Murket and Shaadraz)
//TaxiPath 587 (Aerial Assault Flight (Horde))
//TaxiPath 604 (Taxi - Reaver's Fall to Spinebreaker Ridge)
//TaxiPath 706
//TaxiPath 779
//TaxiPath 784
//TaxiPath 788
//TaxiPath 606
//TaxiPath 705 (Taxi - Skettis to Skyguard Outpost)
//TaxiPath 736
//player->ActivateTaxiPathTo(738);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// including enGB case
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Defined here as it must not be exposed to end-users.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// If we need more bytes than length of BigNumber set the rest to 0
// openssl's BN stores data internally in big endian format, reverse if little endian desired
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*file*/, int /*line*/)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//ARC4 _serverDecrypt(encryptHash);
//ARC4 _clientEncrypt(decryptHash);
// Drop first 1024 bytes, as WoW uses ARC4-drop1024.
//_clientEncrypt.UpdateData(1024, syncBuf);
//_serverDecrypt.UpdateData(1024, syncBuf);
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*! Basic, ad-hoc queries. */
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// Assign thread to task
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// This value stores raw bytes that have to be explicitly casted later
// This value stores somewhat structured data that needs function style casting
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// MySQL context must be present at this point
/// Only close us if we're not operating
//unsigned int timeout = 10;
//mysql_options(mysqlInit, MYSQL_OPT_READ_TIMEOUT, (char const*)&timeout);
// named pipe use option (Windows)
// generic case
// socket use option (Unix/Linux)
// generic case
// MySQL version above 5.1 IS required in both client and server and there is no known issue with different versions above 5.1
// if (mysql_get_server_version(m_Mysql) != mysql_get_client_version())
//     SF_LOG_INFO("sql.sql", "[WARNING] MySQL client/server version mismatch; may conflict with behaviour of prepared statements.");
// set connection properties to UTF8 to properly handle locales for different
// server configs - core sends data in UTF8, so MySQL must expect UTF8 too
// If it returns true, an error was handled successfully (i.e. reconnection)
// Try again
// Can only be null if preparation failed, server side error or bad query
// Cross reference them for debug output
/// @todo Cleaner way
// If it returns true, an error was handled successfully (i.e. reconnection)
// Try again
// If it returns true, an error was handled successfully (i.e. reconnection)
// Try again
// Can only be null if preparation failed, server side error or bad query
// Cross reference them for debug output
/// @todo Cleaner way
// If it returns true, an error was handled successfully (i.e. reconnection)
// Try again
// If it returns true, an error was handled successfully (i.e. reconnection)
// Try again
// If it returns true, an error was handled successfully (i.e. reconnection)
// We try again
// we might encounter errors during certain queries, and depending on the kind of error
// we might want to restart the transaction. So to prevent data loss, we only clean up when it's all done.
// This is done in calling functions DatabaseWorkerPool<T>::DirectCommitTransaction and TransactionTask::Execute,
// and not while iterating over every element.
// For reconnection case
// Check if specified query should be prepared on this connection
// i.e. don't prepare async statements on synchronous connections
// to save memory that will not be used.
// Don't remove 'this' pointer unless you want to skip loading all prepared statements....
// It's possible this attempted reconnect throws 2006 at us. To prevent crazy recursive calls, sleep here.
// Sleep 3 seconds
// Call self (recursive)
// Implemented in TransactionTask::Execute and DatabaseWorkerPool<T>::DirectCommitTransaction
// Query related errors - skip query
// Outdated table or database structure - terminate core
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//- Bind to buffer
/// Initialize variable parameters
/// "If set to 1, causes mysql_stmt_store_result() to update the metadata MYSQL_FIELD->max_length value."
//- Bind on mysql level
// Only != NULL for strings
// stringstream will append a character with that code instead of numeric representation
// stringstream will append a character with that code instead of numeric representation
//- Execution
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// not executed yet, just stored (it's not called a holder for nothing)
/// not executed yet, just stored (it's not called a holder for nothing)
// Don't call to this function if the index is of an ad-hoc statement
// Don't call to this function if the index is of a prepared statement
/// store the result in the holder
/// store the result in the holder
/// if the result was never used, free the resources
/// results used already (getresult called) are expected to be deleted
/// to optimize push_back, reserve the number of queries about to be executed
//the result can't be ready as we are processing it right now
/// we can do this, we are friends
/// execute all queries in the holder and pass the results
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//- This is where we store the (entire) resultset
//- This is where we prepare the buffer based on metadata
//- This is where we bind the bind the buffer to the statement
/// All data is buffered, let go of mysql c api structures
/// Only updates the m_rowPosition so upper level code knows in which element
/// of the rows vector to look
/// Only called in low-level code, namely the constructor
/// Will iterate over every row of data and buffer it
/// More of the in our code allocated sources are deallocated by the poorly documented mysql c api
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//- Append a raw ad-hoc query to the transaction
//- Append a prepared statement to the transaction
// This might be called by explicit calls to Cleanup or by the auto-destructor
// Handle MySQL Errno 1213 without extending deadlock to the core itself
// Clean up now.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Start LoginQueryHolder content
// End LoginQueryHolder content
// Guild handling
// 0: uint32, 1: string, 2: uint32, 3: string, 4: string, 5: uint64, 6-10: uint32, 11: uint64
// 0: uint32
// 0: string, 1: uint32
// 0: uint32, 1: uint32, 2: uint8, 4: string, 5: string
// 0: uint32
// 0: uint32
// 0: uint32, 1: uint8, 3: string, 4: uint32
// 0: uint32
// 0: uint32, 1: uint8
// 0: uint32, 1: uint8
// 0: uint32, 1: uint8
// 0: uint32
// 0: uint32, 1: uint8, 2: uint8, 3: uint32, 4: uint32
// 0: uint32, 1: uint8, 2: uint8
// 0: uint32
// 0: uint32, 1: uint8, 2: uint8, 3: uint8, 4: uint32
// 0: uint32
// 0: uint32, 1: uint8
// 0-1: uint32, 2-3: uint8, 4-5: uint32, 6: uint16, 7: uint8, 8: uint64
// 0: uint32, 1: uint32, 2: uint8
// 0: uint32
// 0-1: uint32, 2: uint8, 3-4: uint32, 5: uint8, 6: uint64
// 0: uint32, 1: uint32
// 0: uint32
// 0: string, 1: uint32
// 0: string, 1: uint32
// 0: uint8, 1: uint32
// 0: string, 1: uint32
// 0: string, 1: uint32
// 0: uint32, 1: uint32
// 0: string, 1: uint8, 2: uint32
// 0: uint32, 1: uint8, 2: uint32
// 0-5: uint32
// 0: string, 1: string, 2: uint32, 3: uint8
// 0: uint64, 1: uint32
// 0: uint8, 1: uint32, 2: uint8, 3: uint32
// 0: uint32, 1: uint8, 2: uint32
// 0: string, 1: uint32, 2: uint8
// 0: uint32, 1: uint32, 2: uint32
// Chat channel handling
// Equipmentsets
// Auras
// Currency
// Account data
// Tutorials
// Instance saves
// Game event saves
// Game event condition saves
// Petitions
// Character battleground data
// Character homebind
// Corpse
// Creature respawn
// Gameobject respawn
// GM Tickets
// GM Bug Tickets
// GM suggest Tickets
// lag report
//  For loading and deleting expired auctions at startup
// LFG Data
// Player saving
//0: lowGUID
//0: lowGUID
// Void Storage
// CompactUnitFrame profiles
// Guild Finder
// Items that hold loot or money
// Calendar
// Pet
// Archaeology
//PrepareStatement(CHAR_SEL_CHAR_RESEARCH_DIGSITES, "SELECT digsiteId, currentFindGUID, remainingFindCount FROM character_research_digsites WHERE guid = ?", CONNECTION_ASYNC);
//PrepareStatement(CHAR_INS_CHAR_RESEARCH_DIGSITE, "INSERT INTO character_research_digsites (guid, digsiteId, currentFindGUID, remainingFindCount) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
//PrepareStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE, "DELETE FROM character_research_digsites WHERE guid = ? AND digsiteId = ?", CONNECTION_ASYNC);
//PrepareStatement(CHAR_SEL_CHAR_RESEARCH_HISTORY, "SELECT projectId, researchCount, firstResearchTimestamp FROM character_research_history WHERE guid = ?", CONNECTION_ASYNC);
//PrepareStatement(CHAR_INS_CHAR_RESEARCH_HISTORY, "INSERT INTO character_research_history (guid, projectId, researchCount, firstResearchTimestamp) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
//PrepareStatement(CHAR_DEL_CHAR_RESEARCH_HISTORY, "DELETE FROM character_research_history WHERE guid = ?", CONNECTION_ASYNC);
//PrepareStatement(CHAR_SEL_CHAR_RESEARCH_PROJECTS, "SELECT projectId FROM character_research_projects WHERE guid = ?", CONNECTION_ASYNC);
//PrepareStatement(CHAR_INS_CHAR_RESEARCH_PROJECT, "INSERT INTO character_research_projects (guid, projectId) VALUES (?, ?)", CONNECTION_ASYNC);
//PrepareStatement(CHAR_DEL_CHAR_RESEARCH_PROJECTS, "DELETE FROM character_research_projects WHERE guid = ?", CONNECTION_ASYNC);
// battle Pet
// blackmarket
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// 0: uint8
// blackmarket
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Signature
//'WDB2'
// Number of records
// Number of fields
// Size of a record
// String size
/* NEW WDB2 FIELDS*/
// Table hash
// Build
// Unknown WDB2
// MinIndex WDB2
// MaxIndex WDB2
// Locales
// Unknown WDB2
// diff * 4: an index for rows, diff * 2: a memory allocation bank
//get struct size and index pos
//find max index
// will be replaces non-empty or "" strings in AutoProduceStrings
// we store flat holders pool as single memory block
// each string field at load have array of string for each locale
// DB2 strings expected to have at least empty string
// assign string holders to string field slots
// init db2 string field slots by pointers to string holders
//send as char* for store in char* pool list for free at unload
// fill only not filled entries
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Number of records
//'WDBC'
// Number of records
// Number of fields
// Size of a record
// String size
// byte fields
// 4 byte fields (int32/float/strings)
/*
//get struct size and index pos
//find max index
// If higher index avalible from sql - use it instead of dbcs
// will replace non-empty or "" strings in AutoProduceStrings
// fill only not filled entries
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// namespace Skyfire
//==========================================
// Matt Pietrek
// MSDN Magazine, 2002
// FILE: WheatyExceptionReport.CPP
//==========================================
//============================== Global Variables =============================
//
// Declare the static variables of the WheatyExceptionReport class
//
// Declare global instance of class
//============================== Class Methods =============================
// Constructor
// Install the unhandled exception filter function
//============
// Destructor
//============
//===========================================================
// Entry point where control comes on an unhandled exception
//===========================================================
/*EXCEPTION_CONTINUE_SEARCH*/
// Skip spaces
// Try calling GetVersionEx using the OSVERSIONINFOEX structure.
// If that fails, try using the OSVERSIONINFO structure.
// Windows NT product family.
// WINVER < 0x0500
// Test for the specific product family.
// Test for specific product on Windows NT 4.0 SP6 and later.
// Test for the workstation type.
// Test for the server type.
// Windows NT 4.0
// Display service pack (if any) and build number.
// Test for SP6 versus SP6a.
// Windows NT 4.0 prior to SP6a
// Windows NT 3.51 and earlier or Windows 2000 and later
//=====================================================\r\n"));
//===========================================================================
// Take a snapshot of all running threads
// Fill in the size of the structure before using it.
// Retrieve information about the first thread,
// and exit if unsuccessful
// Must clean up the
//   snapshot object!
// Now walk the thread list of the system,
// and display information about each thread
// associated with the specified process
//  Don't forget to clean up the snapshot object.
//===========================================================================
// Open the report file, and write the desired information to it.  Called by
// WheatyUnhandledExceptionFilter
//===========================================================================
// Start out with a banner
// First print information about the type of fault
//=====================================================\r\n"));
// Now print information about where the fault occured
// Show the registers
// X86 Only!
// Initialize DbgHelp
//    #ifdef _M_IX86                                          // X86 Only!
//  #endif                                                  // X86 Only!
//======================================================================
// Given an exception code, returns a pointer to a static string with a
// description of the exception
//======================================================================
// If not one of the "known" exceptions, try to get the string
// from NTDLL.DLL's message table.
//=============================================================================
// Given a linear address, locates the module, section, and offset containing
// that address.
//
// Note: the szModule paramater buffer is an output buffer of length specified
// by the len parameter (in characters!)
//=============================================================================
// Point to the DOS header in memory
// From the DOS header, find the NT (PE) header
// RVA is offset from module load address
// Iterate through the section table, looking for the one that encompasses
// the linear address.
// Is the address in this section???
// Yes, address is in the section.  Calculate section and offset,
// and store in the "section" & "offset" params, which were
// passed by reference.
// Should never get here!
// It contains SYMBOL_INFO structure plus additional
// space for the name of the symbol
//============================================================
// Walks the stack, and writes the results to the report file
//============================================================
// true if local/params should be output
// Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag
// Initialize the STACKFRAME structure for the first call.  This is only
// necessary for Intel CPUs, and isn't mentioned in the documentation.
// Get the next stack frame
// Basic sanity check to make sure
// the frame is OK.  Bail if not.
// Displacement of the input address,
// relative to the start of the symbol
// Get the name of the function for this stack frame entry
// Process handle of the current process
// Symbol address
// Address of the variable that will receive the displacement
// Address of the SYMBOL_INFO structure (inside "sip" object)
// No symbol found.  Print out the logical address instead.
// Get the source line for this stack frame entry
// Write out the variables, if desired
// Use SymSetContext to get just the locals/params for this frame
// Enumerate the locals/parameters
//////////////////////////////////////////////////////////////////////////////
// The function invoked by SymEnumSymbols
//////////////////////////////////////////////////////////////////////////////
/*SymbolSize*/,
//////////////////////////////////////////////////////////////////////////////
// Given a SYMBOL_INFO representing a particular variable, displays its
// contents.  If it's a user defined type, display the members and their
// values.
//////////////////////////////////////////////////////////////////////////////
/*cbBuffer*/)
// Indicate if the variable is a local or parameter
// If it's a function, don't do anything.
// SymTagFunction from CVCONST.H from the DIA SDK
// Will point to the variable's data in memory
// if (pSym->Register == 8)   // EBP is the value 8 (in DBGHELP 5.1)
//  This may change!!!
// else
//  return false;
// Don't try to report register variable
// It must be a global variable
// Determine if the variable is a user defined type (UDT).  IF so, bHandled
// will return true.
// The symbol wasn't a UDT, so do basic, stupid formatting of the
// variable.  Based on the size, we're assuming it's a char, WORD, or
// DWORD.
// Emit the variable name
//////////////////////////////////////////////////////////////////////////////
// If it's a user defined type (UDT), recurse through its members until we're
// at fundamental types.  When he hit fundamental types, return
// bHandled = false, so that FormatSymbolValue() will format them.
//////////////////////////////////////////////////////////////////////////////
/*Name*/)
// Get the name of the symbol.  This will either be a Type name (if a UDT),
// or the structure member name.
// Determine how many children this type has.
// If no children, we're done
// Prepare to get an array of "TypeIds", representing each of the children.
// SymGetTypeInfo(TI_FINDCHILDREN) expects more memory than just a
// TI_FINDCHILDREN_PARAMS struct has.  Use derivation to accomplish this.
// Get the array of TypeIds, one for each child type
// Append a line feed
// Iterate through each of the children
// Add appropriate indentation level (since this routine is recursive)
// Recurse for each of the child types
/*Name */);
// If the child wasn't a UDT, format it appropriately
// Get the offset of the child member, relative to its parent
// Get the real "TypeId" of the child.  We need this for the
// SymGetTypeInfo(TI_GET_TYPEID) call below.
// Get the size of the child member
// Calculate the address of the member
//             BasicType basicType = GetBasicType(children.ChildId[i], modBase);
//
//          pszCurrBuffer += sprintf(pszCurrBuffer, rgBaseType[basicType]);
//
// Emit the variable name
//          pszCurrBuffer += sprintf(pszCurrBuffer, "\'%s\'", Name);
// Format appropriately (assuming it's a 1, 2, or 4 bytes (!!!)
// Get the real "TypeId" of the child.  We need this for the
// SymGetTypeInfo(TI_GET_TYPEID) call below.
//============================================================================
// Helper function that writes to the report file, and allows the user to use
// printf style formating
//============================================================================
// _WIN32
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/* = APPENDER_NONE*/, LogLevel _level /* = LOG_LEVEL_DISABLED */, AppenderFlags _flags /* = APPENDER_FLAGS_NONE */):
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// BLACK
// RED
// GREEN
// BROWN
// BLUE
// MAGENTA
// CYAN
// WHITE
// YELLOW
// RED_BOLD
// GREEN_BOLD
// BLUE_BOLD
// MAGENTA_BOLD
// CYAN_BOLD
// WHITE_BOLD
// BLACK
// RED
// GREEN
// BROWN
// BLUE
// MAGENTA
// CYAN
// WHITE
// YELLOW
// LRED
// LGREEN
// LBLUE
// LMAGENTA
// LCYAN
// LWHITE
// No break on purpose
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Avoid infinite loop, PExecute triggers Logging with "sql.sql" type
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// no error handling... if we couldn't make a backup, just ignore
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// Format=type, level, flags, optional1, optional2
// if type = File. optional1 = file and option2 = mode
// if type = Console. optional1 = Color
//fprintf(stdout, "Log::CreateAppenderFromConfig: Created Appender %s (%u), Type CONSOLE, Mask %u\n", appender->getName().c_str(), appender->getId(), appender->getLogLevel());
//fprintf(stdout, "Log::CreateAppenderFromConfig: Created Appender %s (%u), Type FILE, Mask %u, File %s, Mode %s\n", name.c_str(), id, level, filename.c_str(), mode.c_str());
//fprintf(stdout, "Log::CreateLoggerFromConfig: Created Logger %s, Level %u\n", name.c_str(), level);
//fprintf(stdout, "Log::CreateLoggerFromConfig: Added Appender %s to Logger %s\n", appender->getName().c_str(), name.c_str());
// Bad config configuration, creating default config
// Clean any Logger or Appender created
/* = true */)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
//fprintf(stderr, "Logger::write: Logger %s, Level %u. Msg %s Level %u WRONG LEVEL MASK OR EMPTY MSG\n", getName().c_str(), messge.level, message.text.c_str(), .message.level); // DEBUG - RemoveMe
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// optimize disabled trace output
// optimize disabled trace output
// optimize disabled trace output
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// since we have only 7(seven) values in enum Priority
// and 3 we know already (Idle, Normal, Realtime) so
// we need to split each list [Idle...Normal] and [Normal...Realtime]
// into pieces
// register reference to m_task to prevent it deeltion until destructor
//Wait();
// deleted runnable object (if no other references)
//initialize Thread's class static member
// incRef before spawing the thread, otherwise Thread::ThreadTask() might call decRef and delete m_task
// reference set at ACE_Thread::spawn
// task execution complete, free referecne added at
//remove this ASSERT in case you don't want to know is thread priority change was successful or not
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// update time
// main event loop
// get and remove event from queue
// completely destroy event if it is not re-added
// prevent event insertions
// first, abort all existing events
// need per-element cleanup
// fast clear event list (in force case)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// stupid ACE define
//main
// name of service
// service name to display
// desired access
// service type
// start type
// error control type
// service's binary
// no load ordering group
// no tag identifier
// no dependencies
// LocalSystem account
// no password
// handle to service
// change: description
// new data
// handle to service
// information level
// new data
// user defined control code
// unrecognized control code
// initialise service status
// service is starting
// do initialisation here
// running
////////////////////////
// service main cycle //
////////////////////////
// service was stopped
// do cleanup here
// service is now stopped
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// for ASSERT
// Hack like, but the old code accepted these kind of broken strings,
// so changing it would break other things
// Bad format
//bad format
//       YYYY   year
//       MM     month (2 digits 01-12)
//       DD     day (2 digits 01-31)
//       HH     hour (2 digits 00-23)
//       MM     minutes (2 digits 00-59)
//       SS     seconds (2 digits 00-59)
/// Check if the string is a valid ip address representation
// Let the big boys do it.
// Drawback: all valid ip address formats are recognized e.g.: 12.23, 121234, 0xABCD)
/// create PID file
// remove unused tail
// allocate for most long case
// remove unused tail
// allocate for most long case
// remove unused tail
// supported only Cyrillic cases
// Important: end length must be <= MAX_INTERNAL_PLAYER_NAME-MAX_PLAYER_NAME (3 currently)
// get length from string size field
// not implemented yet
// not implemented yet
// converting to lower case
/* = false */)
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// \addtogroup Trinityd Skyfire Daemon
/// @{
/// \file
/*
///< Accessor to the world database
///< Accessor to the character database
///< Accessor to the realm/login database
///< Id of the realm
/// Print out the usage string for this program on the console.
/// Launch the Skyfire server
///- Command line parsing to get the configuration file name
// Services
///- and run the 'Master'
/// @todo Why do we need this 'Master'? Can't all of this be in the Main as for Realmd?
// at sMaster return function exist with codes
// 0 - normal shutdown
// 1 - shutdown at error
// 2 - restart command used, this code can be used by restarter for restart Trinityd
/// @}
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
// [-20, 19], default is 0
/// Handle worldservers's termination signals
// normal work
// possible freeze
/// Main function
//www.projectskyfire.org/> \n");
///- Check the version of the configuration file
/// worldserver PID file creation
///- Start the databases
// set server offline (not connectable)
///- Initialize the World
///- Initialize the signal handlers
/* _WIN32 */
///- Register worldserver's signal handlers
///- Launch WorldRunnable thread
/* need disable console in service mode*/)
///- Launch CliRunnable thread
///- Handle affinity for multiple processors and process priority
// Windows
// remove non accessible processors
// Linux
//Start soap serving thread
///- Start up freeze catcher thread
///- Launch the world listener socket
// go down and shutdown the server
// set server online (allow connecting now)
// when the main thread closes the singletons get unloaded
// since worldrunnable uses them, it will crash if unloaded after master
// set server offline
///- Clean database before leaving
// this only way to terminate CLI thread exist at Win32 (alt. way exist only in Windows Vista API)
//_exit(1);
// send keyboard input to safely unblock the CLI thread
// for some unknown reason, unloading scripts here and not in worldrunnable
// fixes a memory leak related to detaching threads from the module
//UnloadScriptingModule();
// Exit the process with specified return value
/// Initialize connection to the databases
///- Initialize the world database
///- Get character database info from configuration file
///- Initialize the Character database
///- Get login database info from configuration file
///- Initialise the login database
///- Get the realm Id from the configuration file
// Load realm names into a store
// Store the realm name into the store
///- Clean the database before starting
///- Insert version info into DB
// One-time query
/// Clear 'online' status for all accounts with characters in this realm
// Reset online status for all accounts with characters on the current realm
// Reset online status for all characters
// Battleground instance ids reset at server restart
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/// \addtogroup Skyfired
/// @{
/// \file
//printf("Checking %s \n", cmd[idx].Name);
/*end*/)
/*arg*/, const char* str)
/*success*/)
// Non-blocking keypress detector, when return pressed, return 1, else always return 0
/// %Thread start
///- Display the list of available CLI functions then beep
//SF_LOG_INFO("server.worldserver", "");
// \a = Alert
// print this here the first time
// later it will be printed after command queue updates
///- As long as the World is running (no World::m_stopEvent), get the command line and handle it
// = fgets(commandbuf, sizeof(commandbuf), stdin);
// convert from console encoding to utf8
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/*handle*/, ACE_Reactor_Mask /*mask*/)
// While the above wait() will wait for the ::svc() to finish, it will not wait for the async event
// RASocket::commandfinished to be completed. Calling destroy() before the latter function ends
// will lead to using a freed pointer -> crash.
// MSG_NOSIGNAL
// EOF, connection was closed
/* Ignore CR */
// handle quit, exit and logout commands to terminate connection
// wait for result
// Wait a maximum of 1000ms for negotiation packet - not all telnet clients may send it
// "Interpret as Command" (IAC)
// WILL
// WON'T
// DO
// DON'T
// not allowed
//! Just send back end of subnegotiation packet
// MSG_NOSIGNAL
//! Subnegotiation may differ per client - do not react on it
// send motd
// show prompt
/*success*/)
// the message is 0 size control message to tell that command output is finished
// hence we don't put timeout, because it shouldn't increase queue size and shouldn't block
// getting here is bad, command can't be marked as complete
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
// check every 3 seconds if world ended
//%s:%d", _host.c_str(), _port);
// ran into an accept timeout
// make a safe copy
// dealloc C++ data
// dealloc data and clean up
// detach soap struct
/*
// security check
// commands are executed in the world thread. We have to wait for them to be completed
// CliCommandHolder will be deleted from world, accessing after queueing is NOT save
// wait for callback to complete command
// alright, command finished
////////////////////////////////////////////////////////////////////////////////
//
//  Namespace Definition Table
//
////////////////////////////////////////////////////////////////////////////////
//schemas.xmlsoap.org/soap/envelope/", NULL, NULL }, // must be first
//schemas.xmlsoap.org/soap/encoding/", NULL, NULL }, // must be second
//www.w3.org/1999/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
/*/XMLSchema-instance", NULL },
//www.w3.org/1999/XMLSchema",          "http://www.w3.org/*/XMLSchema", NULL },
/*/XMLSchema", NULL },
// "ns1" namespace prefix
/*
//www.trinitycore.org/>
//www.getmangos.eu/>
//www.gnu.org/licenses/>.
/** \file
/// Heartbeat for the World
// used for balanced full tick time length near WORLD_SLEEP_CONST
///- While we have not World::m_stopEvent, update the world
// diff (D0) include time of previous sleep (d0) + tick time (t0)
// we want that next d1 + t1 == WORLD_SLEEP_CONST
// we can't know next t1 and then can use (t0 + d1) == WORLD_SLEEP_CONST requirement
// d1 = WORLD_SLEEP_CONST - t0 = WORLD_SLEEP_CONST - (D0 - d0) = WORLD_SLEEP_CONST + d0 - D0
// save and kick all players
// real players unload required UpdateSessions call
// unload battleground templates before different singletons destroyed
// unload all grids (including locked in memory)
// unload 'i_player2corpse' storage and remove from world
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// Number of records
// Number of records
// Number of fields
// Size of a record
// String size
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*bytesRead*/, NULL);
// Check version
// move to next chunk
// skip self
// move to next chunk
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// **************************************************
// Extractor options
// **************************************************
// Select data for extract
// This option allow limit minimum height to some value (Allow save some memory)
// This option allow use float to int conversion
// Max accuracy = val/256
// Max accuracy = val/65536
// If max - min less this value - surface is flat
// If max - min less this value - liquid surface is flat
// 5.4.8 18273 -- current build is 18414, but Blizz didnt rename the MPQ files
// List MPQ for extract maps from
//#define LAST_DBC_IN_DATA_BUILD 13623    // after this build mpqs with dbc are back to locale folder
// 0777
// i - input path
// o - output path
// e - extract only MAP(1)/DBC(2) - standard both(3)
// f - use float to int conversion
// h - limit minimum height
// b - target client build
// all ok
// all ok
// all ok
// all ok
// all ok
// include build info file also
//printf("Read %s file... ", filename.c_str());
//
// Adt file convertor function and data
//
// Map file format data
// Temporary grid data store
/*cell_y*/, int /*cell_x*/, uint32 build)
// Prepare map header
// Get area flags data
// Area data
// Height
// Height values for triangles stored in order:
// 1     2     3     4     5     6     7     8     9
//    10    11    12    13    14    15    16    17
// 18    19    20    21    22    23    24    25    26
//    27    28    29    30    31    32    33    34
// . . . . . . . .
// For better get height values merge it to V9 and V8 map
// V9 height map:
// 1     2     3     4     5     6     7     8     9
// 18    19    20    21    22    23    24    25    26
// . . . . . . . .
// V8 height map:
//    10    11    12    13    14    15    16    17
//    27    28    29    30    31    32    33    34
// . . . . . . . .
// Set map height as grid height
// Get custom height
// get V9 height map
// get V8 height map
// Liquid data
// water
// ocean
// magma/slime
// Hole data
// Get liquid map for grid (in WOTLK used MH2O chunk)
// Dark water detect
//============================================
// Try pack area data
//============================================
//============================================
// Try pack height data
//============================================
// Check for allow limit minimum height (not store height in deep ochean - allow save some memory)
// Not need store if flat surface
// Try store as packed in uint16 or uint8 values
// Try Store as uint values
// As uint8 (max accuracy = CONF_float_to_int8_limit/256)
// As uint16 (max accuracy = CONF_float_to_int16_limit/65536)
// Pack it to int values if need
//============================================
// Pack liquid data
//============================================
// no water data (if all grid have 0 liquid type)
// No liquid data
// Not need store if flat surface
// Ok all data prepared - store it
// Store area data
// Store height data
// Store liquid data if need
// store hole data
// Loadup map grid data
// draw progress bar
// Load cached locales
// 4.3.2 and higher MPQ
//Open MPQs
//Extract DBC files
//Close MPQs
// Open MPQs
// Extract maps
// Close MPQs
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// first, count the number of spans
// write the span count
// write the spans
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*liquidType*/) { return 0; }
/*type*/, uint32 /*entry*/, Unit const* /*unit*/, uint8 /*flags*/ /*= 0*/) { return false; }
// 'MMAP'
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
// Free memory
/**************************************************************************/
// make sure we process maps which don't have tiles
// initialize the static tree, which loads WDT models
// get the coord bounds of the model data
// get the coord bounds of the model data
// convert coord bounds to grid bounds
// get bounds of current tile
// build navmesh tile
/**************************************************************************/
/**************************************************************************/
// make sure we process maps which don't have tiles
// convert coord bounds to grid bounds
// add all tiles within bounds to tile list.
// build navMesh
// now start building mmtiles for each tile
// unpack tile coords
/**************************************************************************/
// get heightmap data
// get model data
// if there is no data, give up now
// remove unused vertices
// gather all mesh data for final data check, and bounds calculation
// get bounds of current tile
// build navmesh tile
/**************************************************************************/
// old code for non-statically assigned bitmask sizes:
///*** calculate number of bits needed to store tiles & polys ***/
/*** calculate number of bits needed to store tiles & polys ***/
//int tileBits = dtIlog2(dtNextPow2(tiles->size()));
//if (tileBits < 1) tileBits = 1;                                     // need at least one bit!
//int polyBits = sizeof(dtPolyRef)*8 - SALT_MIN_BITS - tileBits;
/*** calculate bounds of map ***/
// use Max because '32 - tileX' is negative for values over 32
/*** now create the navmesh ***/
// navmesh creation params
// now that we know navMesh params are valid, we can write them to file
/**************************************************************************/
// console output
// these are WORLD UNIT based metrics
// this are basic unit dimentions
// value have to divide GRID_SIZE(533.3333f) ( aka: 0.5333, 0.2666, 0.3333, 0.1333, etc )
// All are in UNIT metrics!
// must divide VERTEX_PER_MAP
// anything bigger than tileSize
// keep less than walkableHeight
// eliminates most jagged edges (tiny polygons)
// this sets the dimensions of the heightfield - should maybe happen before border padding
// allocate subregions : tiles
// Initialize per tile config.
// merge per tile poly and detail meshes
// build all tiles
// Calculate the per tile bounding box.
// build heightfield
// mark all walkable tiles, both liquids and solids
// compact heightfield spans
// build polymesh intermediates
// build polymesh
// free those up
// we may want to keep them in the future for debug
// but right now, we don't have the code to merge them
// free things up
// set polygons as walkable
// TODO: special flags for DYNAMIC polygons, ie surfaces that can be turned on and off
// setup mesh parameters
// agent height
// agent radius
// keep less that walkableHeight (aka agent height)!
// will hold final navmesh
// these values are checked within dtCreateNavMeshData - handle them here
// so we have a clear error message
// occurs mostly when adjacent tiles have models
// loaded but those models don't span into this tile
// message is an annoyance
//printf("%sNo vertices to build tile!\n", tileString);
// we have flat tiles with no actual geometry - don't build those, its useless
// keep in mind that we do output those into debug info
// drop tiles with only exact count - some tiles may have geometry while having less tiles
// DT_TILE_FREE_DATA tells detour to unallocate memory when the tile
// is removed via removeTile()
// file output
// write header
// write data
// now that tile is written to disk, we can unload it
// restore padding so that the debug visualization is correct
/**************************************************************************/
// this is for elevation
// this is for width and depth
/**************************************************************************/
// Eastern Kingdoms
// Kalimdor
// Outland
// Northrend
// Pandaria
// test.wdt
// ScottTest.wdt
// Test.wdt
// Colin.wdt
// EmeraldDream.wdt (unused, and very large)
// development.wdt
// ExteriorTest.wdt
// CraigTest.wdt
// development_nonweighted.wdt
// QA_DVD.wdt
// unused.wdt
// ElevatorSpawnTest.wdt
// (UNUSED) Scenario: Alcaz Island
// The Depths [UNUSED]
// (UNUSED) Peak of Serenity Scenario
// (UNUSED) Scenario: Mogu Ruins
// (UNUSED) Scenario: Mogu Crypt
// (UNUSED) Scenario: Black Ox Temple
// LevelDesignLand-DevOnly.wdt
// Alterac Valley
// Azshara Crater
// Warsong Gulch
// Arathi Basin
// Eye of the Storm
// Strand of the Ancients
// Isle of Conquest
// Twin Peaks
// Silvershard Mines
// The Battle for Gilneas (Old Map)
// The Battle for Gilneas
// Rated Eye of the Storm
// Temple of Kotmogu
// Mists of Pandaria CTF3
// DefenseOfTheAleHouseBG
// Deepwind Gorge
/**************************************************************************/
// Transport maps
// Transport: Rut'theran to Auberdine
// Transport: Menethil to Theramore
// Transport: Exodar to Auberdine
// Transport: Feathermoon Ferry
// Transport: Menethil to Auberdine
// Transport: Orgrimmar to Grom'Gol
// Transport: Grom'Gol to Undercity
// Transport: Undercity to Orgrimmar
// Transport: Borean Tundra Test
// Transport: Booty Bay to Ratchet
// Transport: Howling Fjord Sister Mercy (Quest)
// Transport: Naglfar
// Transport: Tirisfal to Vengeance Landing
// Transport: Menethil to Valgarde
// Transport: Orgrimmar to Warsong Hold
// Transport: Stormwind to Valiance Keep
// Transport: Moa'ki to Unu'pe
// Transport: Moa'ki to Kamagua
// Transport: Orgrim's Hammer
// Transport: The Skybreaker
// Transport: Alliance Airship BG
// Transport: HordeAirshipBG
// Transport: Orgrimmar to Thunder Bluff
// Transport: Alliance Vashj'ir Ship
// Transport: The Skybreaker (Icecrown Citadel Raid)
// Transport: Orgrim's Hammer (Icecrown Citadel Raid)
// Transport: Ship to Vashj'ir
// Transport: The Skybreaker (IC Dungeon)
// Transport: Orgrim's Hammer (IC Dungeon)
// Transport: The Mighty Wind (Icecrown Citadel Raid)
// Ship to Vashj'ir (Orgrimmar -> Vashj'ir)
// Vashj'ir Sub - Horde
// Vashj'ir Sub - Alliance
// Twilight Highlands Horde Transport
// Vashj'ir Sub - Horde - Circling Abyssal Maw
// Vashj'ir Sub - Alliance circling Abyssal Maw
// Uldum Phase Oasis
// Transport: Deepholm Gunship
// Transport: Onyxia/Nefarian Elevator
// Transport: Gilneas Moving Gunship
// Transport: Gilneas Static Gunship
// Twilight Highlands Zeppelin 1
// Twilight Highlands Zeppelin 2
// Krazzworks Attack Zeppelin
// Transport: Gilneas Moving Gunship 02
// Transport: Gilneas Moving Gunship 03
// Transport: DarkmoonCarousel
// Transport218599 - The Skybag (Brawl'gar Arena)
// Transport218600 - Zandalari Ship (Mogu Island)
// Transport_Siege_of_Orgrimmar_Alliance - Transport: Siege of Orgrimmar (Alliance)
// Transport_Siege_of_Orgrimmar_Horde - Transport: Siege of Orgrimmar (Horde)
/**************************************************************************/
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// ******************************************
// Map file format defines
// ******************************************
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
// no data in this map file
// data used later
// terrain data
// hole data
// liquid data
// generate coordinates
// dummy vert using invalid height
// generate triangles
// now that we have gathered the data, we can figure out which parts to keep:
// liquid above ground, ground above liquid
// make a copy of liquid vertices
// used to pad right-bottom frame due to lost vertex data at extraction
// default is true, will change to false if needed
// FIXME: "warning: the address of ‘liquid_type’ will always evaluate as ‘true’"
// if there is no liquid, don't use liquid
// merge different types of water
// players should not be here, so logically neither should creatures
// if there is no terrain, don't use terrain
// while extracting ADT data we are losing right-bottom vertices
// this code adds fair approximation of lost data
// update vertex height data
// no valid vertexes - don't use this poly at all
// if there is a hole here, don't use the terrain
// we use only one terrain kind per quad - pick higher one
// terrain under the liquid?
//liquid under the terrain?
// store the result
// advance to next set of triangles
/**************************************************************************/
// wow coords: x, y, height
// coord is mirroed about the horizontal axes
/**************************************************************************/
/* = false*/)
//           0-----1 .... 128
//           |\ T /|
//           | \ / |
//           |L 0 R| .. 127
//           | / \ |
//           |/ B \|
//          129---130 ... 386
//           |\   /|
//           | \ / |
//           | 128 | .. 255
//           | / \ |
//           |/   \|
//          258---259 ... 515
//           0-----1 .... 128
//           |\    |
//           | \ T |
//           |  \  |
//           | B \ |
//           |    \|
//          129---130 ... 386
//           |\    |
//           | \   |
//           |  \  |
//           |   \ |
//           |    \|
//          258---259 ... 515
/**************************************************************************/
// wow coords: x, y, height
// coord is mirroed about the horizontal axes
/**************************************************************************/
// 8 squares per cell
/**************************************************************************/
// 8 squares per cell
/**************************************************************************/
// model instances exist in tree even though there are instances of that model in this tile
// now we have a model to add to the meshdata
// all M2s need to have triangle indices reversed
// transform data
// first handle collision mesh
// now handle liquid data
// convert liquid type to NavTerrain
// indexing is weird...
// after a lot of trial and error, this is what works:
// vertex = y*vertsX+x
// tile   = x*tilesY+y
// flag   = y*tilesY+x
// top triangle
// bottom triangle
/**************************************************************************/
// apply tranform, then mirror along the horizontal axes
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
/**************************************************************************/
// collect all the vertex indices from triangle
// update triangles to use new indices
/**************************************************************************/
// no meshfile input given?
// pretty silly thing, as we parse entire file and load only the tile we need
// but we don't expect this file to be too large
// 1 - both direction, 0 - one sided
// agent size equivalent
// can be used same way as polygon flags
// all movement masks can make this path
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// Need direct access to encapsulated VMAP data, so we add functions for MMAP generator
// maybe add MapBuilder as friend to all of the below classes would be better?
// declared in src/shared/vmap/MapTree.h
// declared in src/shared/vmap/VMapManager2.h
// declared in src/shared/vmap/WorldModel.h
// declared in src/shared/vmap/WorldModel.h
// declared in src/shared/vmap/ModelInstance.h
// declared in src/shared/vmap/WorldModel.h
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
//printf("\nusage: %s <raw data dir> <vmap dest dir> [config file name]\n", argv[0]);
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
//extension in lowercase
//string AdtMapNumber = xMap + ' ' + yMap + ' ' + GetPlainName((char*)Adtfilename.c_str());
//printf("Processing map %s...\n", AdtMapNumber.c_str());
//printf("MapNumber = %s\n", TempMapNumber.c_str());
//printf("xMap = %s\n", xMap.c_str());
//printf("yMap = %s\n", yMap.c_str());
//======================
//======================
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// Number of records
// Number of records
// Number of fields
// Size of a record
// String size
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// TODO: extract .mdl files, if needed
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// Do not show this error on console to avoid confusion, the extractor can continue working even if some models fail to load
//printf("Error loading model %s\n", filename.c_str());
//printf("not included %s\n", filename.c_str());
// rootwmoid, flags, groupid
//bbox, only needed for WMO currently
// liquidflags
// scale factor - divide by 1024. blizzard devs must be on crack, why not just use a float?
//printf("ModelInstance::ModelInstance couldn't open %s\n", tempname);
// get the correct no of vertices
// not used for models
//write mapID, tileX, tileY, Flags, ID, Pos, Rot, Scale, name
/* int realx1 = (int) ((float) pos.x / 533.333333f);
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*= true*/) :
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
//#pragma warning(disable : 4505)
//#pragma comment(lib, "Winmm.lib")
//From Extractor
//------------------------------------------------------------------------------
// Defines
//-----------------------------------------------------------------------------
// 5.4.8.18273
// List MPQ for extract maps from
// added in 5.x.x
// added in 5.x.x
// added in 5.x.x
// after this build mpqs with dbc are back to locale folder
// 15211
// Constants
//static const char * szWorkDirMaps = ".\\Maps";
// Do not attempt to read older MPQ patch archives past this build, they were merged with base
// and trying to read them together with new base will not end well
// 4.3.2 and higher MPQ
// Do not attempt to read older MPQ patch archives past this build, they were merged with base
// and trying to read them together with new base will not end well
// Local testing functions
// copied from contrib/extractor/System.cpp
// Use misc.mpq
//const char* ParsArchiveNames[] = {"patch-2.MPQ", "patch.MPQ", "common.MPQ", "expansion.MPQ"};
//printf("Extracting wmo %s\n", str.c_str());
// Copy files from archive
// Select root wmo files
//printf("root has %d groups\n", froot->nGroups);
//printf("Trying to open groupfile %s\n",groupFileName);
// store the correct no of vertices
// Delete the extracted file in the case of an error
//char id_filename[64];
//sprintf(id_filename,"%02u %02u %03u",x,y,map_ids[i].id);//!!!!!!!!!
// all ok
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
// Main
//
// The program must be run with two command line arguments
//
// Arg1 - The source MPQ name (for testing reading and file find)
// Arg2 - Listfile name
//
// Use command line arguments, when some
// some simple check if working dir is dirty
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
// Create the working directory
//Open MPQs
// extract data
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//map.dbc
//nError = ERROR_SUCCESS;
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
/*map_id*/, unsigned int mapID)
//printf("Can't find WDT file.\n");
// global map objects
// global wmo instance data
/*
//www.trinitycore.org/>
//getmangos.com/>
//www.gnu.org/licenses/>.
// header
/*
//printf("Convert RootWmo...\n");
// will be filled later
//Fix sizeoff = Data size.
//header
/* std::ofstream llog("Buildings/liquid.log", ios_base::out | ios_base::app);
// group bound
// no need to exit?
// no need to exit?
//-------INDX------------------------------------
//-------MOPY--------
// "worst case" size...
// Skip no collision triangles
// Use this triangle
// assign new vertex index numbers
// translate triangle indices to new numbers
// write triangle indices
// write vertices
// "VERT"
//------LIQU------------------------
// "LIQU"
// according to WoW.Dev Wiki:
// edx@1
// eax@1
/* std::ofstream llog("Buildings/liquid.log", ios_base::out | ios_base::app);
// only need height values, the other values are unknown anyway
// todo: compress to bit field
//-----------add_in _dir_file----------------
// get the correct no of vertices
//write mapID, tileX, tileY, Flags, ID, Pos, Rot, Scale, Bound_lo, Bound_hi, name
/* fprintf(pDirfile,"%s/%s %f,%f,%f_%f,%f,%f 1.0 %d %d %d,%d %d\n",
// fclose(dirfile);
/* Copyright (C) 2009 Sun Microsystems, Inc
/* Check stack direction (0-down, 1-up) */
/*
//pos++;
// File.Copy(filePath, filePath + ".bkp");
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
/*
/* __sparcv9 */
/* Make compilers stop complaining about an empty translation unit */
/* ACE_INCLUDE_ATOMIC_OP_SPARC */
/*
/* #define RTEMS_USE_BOOTP */
/*
/*
/* name */
/* attach function */
/* link to next interface */
/* IP address */
/* IP net mask */
/*
/* name */
/* attach function */
/* link to next interface */
/* No more interfaces */
/* BOOTP supplies IP address */
/* BOOTP supplies IP net mask */
/* IP address */
/* IP net mask */
/* !RTEMS_USE_BOOTP */
/* Ethernet hardware address */
/* Driver supplies hardware address */
/* Use default driver parameters */
/*
/* Default network task priority */
/* Default mbuf capacity */
/* Default mbuf cluster capacity */
/* Host name */
/* Domain name */
/* Gateway */
/* Log host */
/* Name server(s) */
/* NTP server(s) */
/*
/* Host name */
/* Domain name */
/* Gateway */
/* Log host */
/* Name server(s) */
/* NTP server(s) */
/* !RTEMS_USE_BOOTP */
/*
/* _RTEMS_NETWORKCONFIG_H_ */
/* ACE_LACKS_NETWORKING */
/*
/* ACE_LACKS_NETWORKING */
/* Make compilers stop complaining about an empty translation unit */
/* ACE_HAS_RTEMS */
/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* Random partitioning.  Median of 3 sometimes fails to
/*---------------------------------------------*/
/* Pre:
/*--
/*--
/*-- set sentinel bits for block-end detection --*/
/*-- the log(N) loop --*/
/*-- find the next non-singleton bucket --*/
/*-- now [l, r] bracket current bucket --*/
/*-- scan bucket and generate header bits-- */
/*-- 
/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/*---------------------------------------------*/
/*--
/*-- copy 1 --*/
/*-- copy 2 --*/
/*-- copy 3 --*/
/*---------------------------------------------*/
/*--
/*---------------------------------------------*/
/* Pre:
/*-- set up the 2-byte frequency table --*/
/*-- (emphasises close relationship of block & quadrant) --*/
/*-- Complete the initial radix sort --*/
/*--
/*--
/*--
/*--
/*--
/* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.
/*--
/*---------------------------------------------*/
/* Pre:
/* Calculate the location for quadrant, remembering to get
/* (wfact-1) / 3 puts the default-factor-30
/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-- fast track the common case --*/           \
/*-- general, uncommon cases --*/              \
/*---------------------------------------------------*/
/*-- fast track the common case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- general, uncommon case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- flush/finish end? --*/
/*---------------------------------------------------*/
/*-- no output space? --*/
/*-- block done? --*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--not reached--*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* restore */
/* end restore */
/* try to finish existing run */
/* Only caused by corrupt data stream? */
/* can a new run be started? */
/* save */
/* end save */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/*---------------------------------------------------*/
/*NOTREACHED*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- File I/O stuff                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*not reached*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/* no use when bzdopen */
/* no use when bzdopen */
/* bzopen: 0, bzdopen:1 */
/* binary mode */
/* Guard against total chaos and anarchy -- JRS */
/*---------------------------------------------------*/
/*--
/*bzopen*/0);
/*---------------------------------------------------*/
/*bzdopen*/1);
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* do nothing now... */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* 
/*---------------------------------------------------*/
/*--
/*--- Decide how many coding tables to use ---*/
/*--- Generate an initial set of coding tables ---*/
/*--- 
/*---
/*--- Set group start & end marks. --*/
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*-- 
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*--
/* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See 
/*20*/ );
/*--- Compute MTF values for the selectors. ---*/
/*--- Assign actual codes for the tables. --*/
/*20*/ ), 3004 );
/*--- Transmit the mapping table. ---*/
/*--- Now the selectors. ---*/
/*--- Now the coding tables. ---*/
/* 10 */ };
/* 11 */ };
/*--- And finally, the block data proper ---*/
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*---------------------------------------------------*/
/*-- If this is the first block, create the stream header. --*/
/*-- Now the block's CRC, so it is in a known place. --*/
/*-- 
/*-- If this is the last block, add the stream trailer. --*/
/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Table for doing CRCs                                  ---*/
/*---                                            crctable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*--
/*-- Ugly, innit? --*/
/*-------------------------------------------------------------*/
/*--- end                                        crctable.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* the longest code */)         \
/*---------------------------------------------------*/
/* stuff that needs to be saved/restored */
/*initialise the save area*/
/*restore from the save area*/
/*--- Receive the mapping table ---*/
/*--- Now the selectors ---*/
/*--- Undo the MTF values for the selectors. ---*/
/*--- Now the coding tables ---*/
/*--- Create the Huffman decoding tables ---*/
/*--- Now the MTF values ---*/
/*-- MTF init --*/
/*-- end MTF init --*/
/* Check that N doesn't get too big, so that es doesn't
/*-- uc = MTF ( nextSym-1 ) --*/
/* avoid general-case expense */
/* general case */
/*-- end uc = MTF ( nextSym-1 ) --*/
/* Now we know what nblock is, we can do a better sanity
/*-- Set up cftab to facilitate generation of T^(-1) --*/
/* Check: unzftab entries in range. */
/* Actually generate cftab. */
/* Check: cftab entries in range. */
/* s->cftab[i] can legitimately be == nblock */
/* Check: cftab entries non-descending. */
/*-- Make a copy of cftab, used in generation of T --*/
/*-- compute the T vector --*/
/*-- Compute T^(-1) by pointer reversal on T --*/
/*-- compute the T^(-1) vector --*/
/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* 17 Oct 04: keep-going condition for the following loop used
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Table for randomising repetitive blocks               ---*/
/*---                                           randtable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                       randtable.c ---*/
/*-------------------------------------------------------------*/
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Generate red-black tree functions. */
/*
/* Generate red-black tree functions. */
/*
/*
/*
/* Generate red-black tree functions. */
/*
/*
/* Freeing an interior pointer can cause assertion failure. */
/* Freeing an unallocated pointer can cause assertion failure. */
/*
/* Keep track of trailing unused pages for later use. */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* Insert the run into the runs_avail tree. */
/*
/* Search the arena's chunks for the lowest best fit. */
/*
/*
/* Don't purge if the option is disabled. */
/* Don't purge if all dirty pages are already being purged. */
/*
/*
/*
/*
/* Append to list for later processing. */
/* Skip run. */
/*
/* Deallocate runs. */
/*
/* Get next chunk with dirty pages. */
/*
/*
/*
/*
/*
/* Mark pages as unallocated in the chunk map. */
/* Try to coalesce forward. */
/*
/* Try to coalesce backward. */
/*
/* Insert into runs_avail, now that coalescing is complete. */
/* Deallocate chunk if it is now completely unused. */
/*
/*
/*
/* Look for a usable run. */
/* No existing runs have any space available. */
/* Allocate a new run. */
/******************************/
/* Initialize run internals. */
/********************************/
/*
/* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
/*
/*
/* Insert such that low regions get used first. */
/* Large allocation. */
/* Only handles large allocations that require more than page alignment. */
/* Dissociate run from bin. */
/*
/******************************/
/*
/* Trim clean pages.  Convert to large run beforehand. */
/* npages = past - run_ind; */
/****************************/
/*
/* Switch runcur. */
/* arena_ptr_small_binind_get() does extra sanity checking. */
/*
/* Try to extend the run. */
/*
/*
/*
/* Same size class. */
/* Fill before shrinking in order avoid a race. */
/*
/* Reallocation would require a move. */
/* Try to avoid moving the allocation. */
/*
/* Try again, this time without extra. */
/* Junk/zero-filling were already done by ipalloc()/arena_malloc(). */
/*
/* Initialize chunks. */
/* Initialize bins. */
/*
/*
/*
/* Counter-act try_nregs-- in loop. */
/* Counter-act try_nregs-- in loop. */
/* Pad to a long boundary. */
/* Add space for bitmap. */
/* Pad to a quantum boundary. */
/* Add space for one (prof_ctx_t *) per region. */
/* run_size expansion loop. */
/*
/* Try more aggressive settings. */
/* Counter-act try_nregs-- in loop. */
/* Counter-act try_nregs-- in loop. */
/* Pad to a long boundary. */
/* Add space for bitmap. */
/* Pad to a quantum boundary. */
/*
/* Copy final settings. */
/*
/******************************************************************************/
/* Data. */
/*
/* Addr immediately past base_pages. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Round size up to nearest multiple of the cacheline size. */
/* Make sure there's enough space for the allocation. */
/* Allocate. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/******************************************************************************/
/* Data. */
/*
/* Various chunk-related settings. */
/* (chunksize - 1). */
/* Max size class for arenas. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Beware size_t wrap-around. */
/* Remove node from the tree. */
/* Insert the leading space as a smaller chunk. */
/* Insert the trailing space as a smaller chunk. */
/*
/*
/* "primary" dss. */
/* mmap. */
/* "secondary" dss. */
/* All strategies for allocation failed. */
/*
/* Try to coalesce forward. */
/*
/* Coalescing forward failed, so insert a new node. */
/*
/* Try to coalesce backward. */
/*
/* Set variables according to the value of opt_lg_chunk. */
/******************************************************************************/
/* Data. */
/* Current dss precedence default, used when creating new arenas. */
/*
/* Base address of the DSS. */
/* Current end of the DSS, or ((void *)-1) if the DSS is exhausted. */
/* Current upper limit on DSS addresses. */
/******************************************************************************/
/*
/*
/* Get the current end of the DSS. */
/*
/*
/* Wrap-around. */
/* Success. */
/******************************************************************************/
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/*
/* Beware size_t wrap-around. */
/*
/*
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/* Search primary bucket. */
/* Search secondary bucket. */
/*
/*
/*
/* Swap cell->{key,data} and {key,data} (evict). */
/* Find the alternate bucket for the evicted item. */
/*
/* Check for a cycle. */
/* Try to insert in primary bucket. */
/* Try to insert in secondary bucket. */
/*
/*
/*
/* Swap in new table. */
/* Rebuilding failed, so back out partially rebuilt table. */
/*
/*
/* Swap in new table. */
/* Rebuilding failed, so back out partially rebuilt table. */
/* Value doesn't really matter. */
/*
/* Do nothing. */
/* Not necessary. */
/* Try to halve the table if it is less than 1/4 full. */
/* Ignore error due to OOM. */
/******************************************************************************/
/* Data. */
/*
/******************************************************************************/
/* Helpers for named and indexed nodes. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* mallctl tree. */
/* Maximum tree depth. */
/*
/******************************************************************************/
/* Merge into sum stats as well. */
/* Merge into sum stats as well. */
/* Extend arena stats and arenas arrays. */
/* ctl_stats.arenas and arenas came from base_alloc(). */
/* Initialize the new astats and arenas elements. */
/* Swap merged stats to their new location. */
/*
/*
/*
/* Equivalent to strchrnul(). */
/* Children are named. */
/* Children are indexed. */
/* Terminal node. */
/*
/* Complete lookup successful. */
/* Update elm. */
/* No more elements. */
/* The name refers to a partial path through the ctl tree. */
/* Iterate down the tree. */
/* Children are named. */
/* Indexed element. */
/* Call the ctl function. */
/* Partial MIB. */
/******************************************************************************/
/* *_ctl() functions. */
/*
/*
/* New arena index is out of range. */
/* Initialize arena if necessary. */
/* Set new arena association. */
/******************************************************************************/
/******************************************************************************/
/* Mutable. */
/******************************************************************************/
/* ctl_mutex must be held during execution of this function. */
/******************************************************************************/
/******************************************************************************/
/* Protect opt_prof_active. */
/*
/******************************************************************************/
/******************************************************************************/
/* Generate red-black tree functions. */
/* Generate red-black tree functions. */
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Tree of chunks that are stand-alone huge allocations. */
/* Allocate one or more contiguous chunks for this request. */
/* size is large enough to cause size_t wrap-around. */
/* Allocate an extent node with which to track the chunk. */
/*
/* Insert node into huge. */
/*
/* Reallocation would require a move. */
/* Try to avoid moving the allocation. */
/*
/* Try again, this time without extra. */
/*
/*
/*
/*
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Initialize chunks data. */
/******************************************************************************/
/* Data. */
/* Runtime configuration options. */
/* Set to true once the allocator has been initialized. */
/* Used to let the initializing thread recursively allocate. */
/* Used to avoid initialization races. */
/* Input pointer (as in realloc(p, s)). */
/* Request size. */
/* Result pointer. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Create a new arena and insert it into the arenas array at index ind. */
/* Only reached if there is an OOM error. */
/*
/* Slow path, called only by choose_arena(). */
/*
/*
/*
/* Initialize a new arena. */
/*
/*
/*
/******************************************************************************/
/*
/* Error. */
/*
/*
/*
/* Get runtime configuration. */
/*
/* No configuration specified. */
/*
/* No configuration specified. */
/*
/* No configuration specified. */
/* NOTREACHED */
/*
/*
/* Busy-wait until the initializing thread completes. */
/* Register fork handlers. */
/* Print statistics at exit. */
/*
/*
/* Initialize allocation counters before any allocations can occur. */
/* Get number of CPUs. */
/*
/*
/* Allocate and initialize arenas. */
/*
/* Copy the pointer to the one arena that was already initialized. */
/*
/******************************************************************************/
/*
/*
/* Make sure that alignment is a large enough power of 2. */
/*
/* size_t overflow. */
/* realloc(ptr, 0) is equivalent to free(p). */
/* realloc(NULL, size) is equivalent to malloc(size). */
/*
/******************************************************************************/
/*
/*
/*
//bugzilla.mozilla.org/show_bug.cgi?id=493541).
/*
/******************************************************************************/
/*
/*
/******************************************************************************/
/*
/*
/*
/*
/******************************************************************************/
/*
/*
/* Acquire all mutexes in a safe order. */
/* Release all mutexes, now that fork() has completed. */
/* Release all mutexes, now that fork() has completed. */
/******************************************************************************/
/*
/******************************************************************************/
/******************************************************************************/
/* Data. */
/******************************************************************************/
/*
/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
/* Data. */
/*
/* Atomic counter. */
/*
/*
/* Do not dump any profiles until bootstrapping is complete. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Throw away (nignore+1) stack frames, if that many exist. */
/*
/* Extras to compensate for nignore. */
/*
/* bt has never been seen before.  Insert it. */
/*
/* OOM. */
/*
/* Link a prof_thd_cnt_t into ctx for this thread. */
/*
/* ret can now be re-used. */
/* Allocate and partially initialize a new cnt. */
/* Finish initializing ret. */
/* Move ret to the front of the LRU. */
/* Flush the buffer if it is full. */
/* Finish writing. */
/* Write as much of s as will fit. */
/* Make sure epoch is even. */
/* Terminate if epoch didn't change while reading. */
/* Add to cnt_all. */
/*
/* Remove ctx from bt2ctx. */
/* Destroy ctx. */
/*
/* Merge cnt stats and detach from ctx. */
/*
/*
/* Make space in prof_dump_buf before read(). */
/* Merge per thread profile stats, and sum them in cnt_all. */
/* Dump profile header. */
/* Dump  per ctx profile stats. */
/* Dump /proc/<pid>/maps if possible. */
/* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
/* "<prefix>.<pid>.<seq>.<v>.heap" */
/* No filename specified, so automatically generate one. */
/* Initialize an empty cache for this thread. */
/*
/*
/*
/*
/*
/*
/*
/******************************************************************************/
/*
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* objs ring buffer data are contiguous. */
/* objs ring buffer data wrap around. */
/*
/*
/* Grow the quarantine ring buffer if it's full. */
/* quarantine_grow() must free a slot if it fails to grow. */
/* Append ptr if its size doesn't exceed the quarantine size. */
/*
/*
/* Leak the rtree. */
/*
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Gap of more than one size class. */
/* Gap of one size class. */
/* Gap of more than one size class. */
/* Gap of one size class. */
/*
/* Print chunk stats. */
/* Print huge stats. */
/* Print merged arena stats. */
/* Print stats for each arena. */
/******************************************************************************/
/* Data. */
/* Total stack elms per tcache. */
/******************************************************************************/
/*
/*
/*
/* Lock the arena bin associated with the first object. */
/*
/*
/* Lock the arena associated with the first object. */
/*
/*
/* Link into list of extant tcaches. */
/* Unlink from list of extant tcaches. */
/* Naturally align the pointer stacks. */
/*
/* Do nothing. */
/*
/*
/* Merge and reset tcache stats. */
/*
/* Initialize tcache_bin_info. */
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Avoid choose_arena() in order to dodge bootstrapping issues. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* malloc_message() setup. */
/*
/*
/*
/* Swallow leading whitespace and get sign, if any. */
/* Fall through. */
/* Fall through. */
/* Get prefix, if any. */
/*
/* Convert. */
/* Overflow. */
/* No characters were converted. */
/* Fall through. */
/* Left padding. */						\
/* Value. */							\
/* Right padding. */						\
/* Synthetic; used for %p. */				\
/* %% */
/* Flags. */
/* Width. */
/* Precision. */
/* Length. */
/* Conversion specifier. */
/*
/*
/* Print to stderr in such a way as to avoid memory allocation. */
/*
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/* Assignment avoids useless compiler warning. */
/* Assignment avoids useless compiler warning. */
/* This function should never be called. */
/*
/*
/* Register the custom zone.  At this point it won't be the default. */
/*
/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* Random partitioning.  Median of 3 sometimes fails to
/*---------------------------------------------*/
/* Pre:
/*--
/*--
/*-- set sentinel bits for block-end detection --*/
/*-- the log(N) loop --*/
/*-- find the next non-singleton bucket --*/
/*-- now [l, r] bracket current bucket --*/
/*-- scan bucket and generate header bits-- */
/*-- 
/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/*---------------------------------------------*/
/*--
/*-- copy 1 --*/
/*-- copy 2 --*/
/*-- copy 3 --*/
/*---------------------------------------------*/
/*--
/*---------------------------------------------*/
/* Pre:
/*-- set up the 2-byte frequency table --*/
/*-- (emphasises close relationship of block & quadrant) --*/
/*-- Complete the initial radix sort --*/
/*--
/*--
/*--
/*--
/*--
/* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.
/*--
/*---------------------------------------------*/
/* Pre:
/* Calculate the location for quadrant, remembering to get
/* (wfact-1) / 3 puts the default-factor-30
/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-- fast track the common case --*/           \
/*-- general, uncommon cases --*/              \
/*---------------------------------------------------*/
/*-- fast track the common case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- general, uncommon case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- flush/finish end? --*/
/*---------------------------------------------------*/
/*-- no output space? --*/
/*-- block done? --*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--not reached--*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* restore */
/* end restore */
/* try to finish existing run */
/* Only caused by corrupt data stream? */
/* can a new run be started? */
/* save */
/* end save */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/*---------------------------------------------------*/
/*NOTREACHED*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- File I/O stuff                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*not reached*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/* no use when bzdopen */
/* no use when bzdopen */
/* bzopen: 0, bzdopen:1 */
/* binary mode */
/* Guard against total chaos and anarchy -- JRS */
/*---------------------------------------------------*/
/*--
/*bzopen*/0);
/*---------------------------------------------------*/
/*bzdopen*/1);
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* do nothing now... */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* 
/*---------------------------------------------------*/
/*--
/*--- Decide how many coding tables to use ---*/
/*--- Generate an initial set of coding tables ---*/
/*--- 
/*---
/*--- Set group start & end marks. --*/
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*-- 
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*--
/* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See 
/*20*/ );
/*--- Compute MTF values for the selectors. ---*/
/*--- Assign actual codes for the tables. --*/
/*20*/ ), 3004 );
/*--- Transmit the mapping table. ---*/
/*--- Now the selectors. ---*/
/*--- Now the coding tables. ---*/
/* 10 */ };
/* 11 */ };
/*--- And finally, the block data proper ---*/
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*---------------------------------------------------*/
/*-- If this is the first block, create the stream header. --*/
/*-- Now the block's CRC, so it is in a known place. --*/
/*-- 
/*-- If this is the last block, add the stream trailer. --*/
/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Table for doing CRCs                                  ---*/
/*---                                            crctable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*--
/*-- Ugly, innit? --*/
/*-------------------------------------------------------------*/
/*--- end                                        crctable.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* the longest code */)         \
/*---------------------------------------------------*/
/* stuff that needs to be saved/restored */
/*initialise the save area*/
/*restore from the save area*/
/*--- Receive the mapping table ---*/
/*--- Now the selectors ---*/
/*--- Undo the MTF values for the selectors. ---*/
/*--- Now the coding tables ---*/
/*--- Create the Huffman decoding tables ---*/
/*--- Now the MTF values ---*/
/*-- MTF init --*/
/*-- end MTF init --*/
/*-- uc = MTF ( nextSym-1 ) --*/
/* avoid general-case expense */
/* general case */
/*-- end uc = MTF ( nextSym-1 ) --*/
/* Now we know what nblock is, we can do a better sanity
/*-- Set up cftab to facilitate generation of T^(-1) --*/
/* s->cftab[i] can legitimately be == nblock */
/*-- Make a copy of cftab, used in generation of T --*/
/*-- compute the T vector --*/
/*-- Compute T^(-1) by pointer reversal on T --*/
/*-- compute the T^(-1) vector --*/
/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* 17 Oct 04: keep-going condition for the following loop used
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Table for randomising repetitive blocks               ---*/
/*---                                           randtable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                       randtable.c ---*/
/*-------------------------------------------------------------*/
/*
//#define SELF_TEST 1
/* defines printf for tests */
/* defines time_t for timings in the test */
/* attempt to define endianness */
/* attempt to define endianness */
/*
/*
//burtleburtle.net/bob/hash/avalanche.html to choose 
/*
/*
/* the key, an array of uint32_t values */
/* the length of the key, in uint32_ts */
/* the previous hash, or an arbitrary value */
/* Set up the internal state */
/*------------------------------------------------- handle most of the key */
/*------------------------------------------- handle the last 3 uint32_t's */
/* all the case statements fall through */
/* case 0: nothing left to add */
/*------------------------------------------------------ report the result */
/*
/* the key, an array of uint32_t values */
/* the length of the key, in uint32_ts */
/* IN: seed OUT: primary hash value */
/* IN: more seed OUT: secondary hash value */
/* Set up the internal state */
/*------------------------------------------------- handle most of the key */
/*------------------------------------------- handle the last 3 uint32_t's */
/* all the case statements fall through */
/* case 0: nothing left to add */
/*------------------------------------------------------ report the result */
/*
/* internal state */
/* needed for Mac Powerbook G4 */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* !valgrind */
/* read 16-bit chunks */
/*--------------- all but last block: aligned reads and different mixing */
/*----------------------------- handle the last (probably partial) block */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length requires no mixing */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/*
/* the key to hash */
/* length of the key */
/* IN: primary initval, OUT: primary hash */
/* IN: secondary initval, OUT: secondary hash */
/* internal state */
/* needed for Mac Powerbook G4 */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length strings require no mixing */
/* !valgrind */
/* read 16-bit chunks */
/*--------------- all but last block: aligned reads and different mixing */
/*----------------------------- handle the last (probably partial) block */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length strings require no mixing */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/* zero length strings require no mixing */
/*
/* to cast key to (size_t) happily */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* all the case statements fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* !VALGRIND */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/* used for timings */
/* check that every input bit changes every output bit half the time */
/*----------------------- for each input byte, */
/*------------------------ for each input bit, */
/*------------ for serveral possible initvals, */
/*---- check that every output bit is affected by that input bit */
/* keys have one bit different */
/* have a and b be two keys differing in only one bit */
/* check every bit is 1, 0, set, and not set at least once */
/* Check for reading beyond the end of the buffer and alignment problems */
/* check that hashlittle2 and hashlittle produce the same results */
/* check that hashword2 and hashword produce the same results */
/* check hashlittle doesn't read before or after the ends of the string */
/* these should all be equal */
/* check for problems with nulls */
/* deadbeef deadbeef */
/* bd5b7dde deadbeef */
/* 9c093ccd bd5b7dde */
/* 17770551 ce7226e6 */
/* e3607cae bd371de4 */
/* cd628161 6cbea4b3 */
/* 17770551 */
/* cd628161 */
/* test that the key is hashed: used for timings */
/* test that whole key is hashed thoroughly */
/* test that nothing but the key is hashed */
/* test hashing multiple buffers (all buffers are null) */
/* test the hash against known vectors */
/* SELF_TEST */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/helper/hash_memory.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:23 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* OID */
/* copy the state into 512-bits into W[0..15] */
/* copy state */
/**
/**
/**
/* increase the length of the message */
/* append the '1' bit */
/* if the length is currently above 56 bytes we append zeros
/* pad upto 56 bytes of zeroes */
/* store length */
/* copy output */
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/md5.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:25:28 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* OID */
/* copy the state into 512-bits into W[0..15] */
/* copy state */
/* expand it */
/* compress */
/* round one */
/* round two */
/* round three */
/* round four */
/* store */
/**
/**
/**
/* increase the length of the message */
/* append the '1' bit */
/* if the length is currently above 56 bytes we append zeros
/* pad upto 56 bytes of zeroes */
/* store length */
/* copy output */
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/sha1.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:25:28 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* ---- trivial ---- */
/* ---- conversions ---- */
/* read ascii string */
/* write one */
/* get size as unsigned char string */
/* store */
/* read */
/* add */
/* sub */
/* mul */
/* sqr */
/* div */
/* modi */
/* gcd */
/* lcm */
/* invmod */
/* setup */
/* get normalization value */
/* reduce */
/* clean up */
/* LTC_MECC_FP */
/* LTC_ECC_SHAMIR */
/* LTC_MECC */
/* $Source: /cvs/libtom/libtomcrypt/src/math/ltm_desc.c,v $ */
/* $Revision: 1.31 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* failed */
/* $Source: /cvs/libtom/libtomcrypt/src/math/multi.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:23 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* get type */
/* allow sizes between 2 and 512 bytes for a prime size */
/* valid PRNG? Better be! */
/* allocate buffer to work with */
/* generate value */
/* munge bits */
/* load value */
/* test */
/* $Source: /cvs/libtom/libtomcrypt/src/math/rand_prime.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:23 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* the final = symbols are read and used to trim the remaining bytes */
/* prevent g < 0 which would potentially allow an overflow later */
/* we only allow = to be at the end */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/base64/base64_decode.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_argchk.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_find_hash.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_find_prng.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_hash_descriptor.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/*
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_hash_is_valid.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/*****************************************************************************/
/* crypt_libc.c                           Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* Description:                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 05.05.10  1.00  Lad  The first version of crypt_libc.c                    */
/*****************************************************************************/
// LibTomCrypt header
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_prng_descriptor.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/*
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_prng_is_valid.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* is it already registered? */
/* find a blank spot */
/* no spot */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_register_hash.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* is it already registered? */
/* find a blank spot */
/* no spot */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_register_prng.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/zeromem.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* packet must be at least 4 bytes */
/* check for 0x03 */
/* offset in the data */
/* get the length of the data */
/* long format get number of length bytes */
/* invalid if 0 or > 2 */
/* read the data len */
/* short format */
/* is the data len too long or too short? */
/* get padding count */
/* too many bits? */
/* decode/store the bits */
/* we done */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/bit/der_decode_bit_string.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/boolean/der_decode_boolean.c,v $ */
/* $Revision: 1.2 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get blk size */
/* set all of the "used" flags to zero */
/* now scan until we have a winner */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/choice/der_decode_choice.c,v $ */
/* $Revision: 1.9 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x16 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/ia5/der_decode_ia5_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* min DER INTEGER is 0x02 01 00 == 0 */
/* ok expect 0x02 when we AND with 0001 1111 [1F] */
/* now decode the len stuff */
/* short form */
/* will it overflow? */
/* no so read it */
/* long form */
/* will number of length bytes overflow? (or > 4) */
/* now read it in */
/* now will reading y bytes overrun? */
/* no so read it */
/* see if it's negative */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/integer/der_decode_integer.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* header is at least 3 bytes */
/* must be room for at least two words */
/* decode the packet header */
/* get the length */
/* decode words */
/* store t */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/object_identifier/der_decode_object_identifier.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x04 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/octet/der_decode_octet_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x13 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/printable_string/der_decode_printable_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get blk size */
/* sequence type? We allow 0x30 SEQUENCE and 0x31 SET since fundamentally they're the same structure */
/* would reading the len bytes overrun? */
/* read len */
/* would this blksize overflow? */
/* mark all as unused */
/* ok read data */
/* detect if we have the right type */
/* restart the decoder */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_ex.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* skip type and read len */
/* read len */
/* <128 means literal */
/* the lower 7 bits are the length of the length */
/* len means len of len! */
/** 
/* scan the input and and get lengths and what not */
/* read the type byte */
/* fetch length */
/* alloc new link */
/* now switch on type */
/* BOOLEAN */
/* INTEGER */
/* init field */
/* decode field */
/* calc length of object */
/* BIT */
/* init field */
/* *8 because we store decoded bits one per char and they are encoded 8 per char.  */
/* OCTET */
/* init field */
/* NULL */
/* valid NULL is 0x05 0x00 */
/* simple to store ;-) */
/* OID */
/* init field */
/* resize it to save a bunch of mem */
/* out of heap but this is not an error */
/* UTF8 */
/* init field */
/* PRINTABLE */
/* init field */
/* IA5 */
/* init field */
/* UTC TIME */
/* init field */
/* SEQUENCE */
/* SET */
/* init field */
/* we have to decode the SEQUENCE header and get it's length */
/* move past type */
/* read length byte */
/* smallest SEQUENCE/SET header */
/* now if it's > 127 the next bytes are the length of the length */
/* update sequence header len */
/* Sequence elements go as child */
/* len update */
/* link them up y0 */
/* invalid byte ... this is a soft error */
/* remove link */
/* advance pointers */
/* rewind l please */
/* return */
/* free list */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_flexi.c,v $ */
/* $Revision: 1.26 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get size of output that will be required */
/* allocate structure for x elements */
/* fill in the structure */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_multi.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* check length */
/* check header */
/* get the packet len */
/* read number */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/short_integer/der_decode_short_integer.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* check header */
/* decode the string */
/* possible encodings are 
/* clear timezone and seconds info */
/* now is it Z, +, - or 0-9 */
/* decode seconds */
/* now is it Z, +, - */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utctime/der_decode_utctime.c,v $ */
/* $Revision: 1.9 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x0C */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* proceed to decode */
/* get first byte */
/* count number of bytes */
/* decode, grab upper bits */
/* grab remaining bytes */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utf8/der_decode_utf8_string.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get the number of the bytes */
/* 03 LL PP DD DD DD ... */
/* 03 81 LL PP DD DD DD ... */
/* 03 82 LL LL PP DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/bit/der_length_bit_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/boolean/der_length_boolean.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* scan string for validity */
/* 16 LL DD DD DD ... */
/* 16 81 LL DD DD DD ... */
/* 16 82 LL LL DD DD DD ... */
/* 16 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/ia5/der_length_ia5_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* positive */
/* we only need a leading zero if the msb of the first byte is one */
/* size for bignum */
/* it's negative */
/* find power of 2 that is a multiple of eight and greater than count bits */
/* now we need a length */
/* short form */
/* long form (relies on z != 0), assumes length bytes < 128 */
/* we need a 0x02 to indicate it's INTEGER */
/* return length */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/integer/der_length_integer.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must be >= 2 words */
/* word1 = 0,1,2,3 and word2 0..39 */
/* leading word is the first two */
/* grab next word */
/* now depending on the length our length encoding changes */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/object_identifier/der_length_object_identifier.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* 04 LL DD DD DD ... */
/* 04 81 LL DD DD DD ... */
/* 04 82 LL LL DD DD DD ... */
/* 04 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/octet/der_length_octet_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* scan string for validity */
/* 16 LL DD DD DD ... */
/* 16 81 LL DD DD DD ... */
/* 16 82 LL LL DD DD DD ... */
/* 16 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/printable_string/der_length_printable_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get size of output that will be required */
/* calc header size */
/* 0x30 0x81 LL */
/* 0x30 0x82 LL LL */
/* 0x30 0x83 LL LL LL */
/* store size */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_length_sequence.c,v $ */
/* $Revision: 1.14 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* force to 32 bits */
/* get the number of bytes */
/* handle zero */
/* we need a 0x02 to indicate it's INTEGER */
/* length byte */
/* bytes in value */
/* see if msb is set */
/* return length */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/short_integer/der_length_short_integer.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* we encode as YYMMDDhhmmssZ */
/* we encode as YYMMDDhhmmss{+|-}hh'mm' */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utctime/der_length_utctime.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** Return the size in bytes of a UTF-8 character
/**
/* 0C LL DD DD DD ... */
/* 0C 81 LL DD DD DD ... */
/* 0C 82 LL LL DD DD DD ... */
/* 0C 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utf8/der_length_utf8_string.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* walk to the start of the chain */
/* now walk the list and free stuff */
/* is there a child? */
/* disconnect */
/* move to next and free current */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_sequence_free.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* first map z back to normal */
/* get 1/z */
/* get 1/z^2 and 1/z^3 */
/* multiply against x/y */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_map.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/** Computes kA*A + kB*B = C using Shamir's Trick
/* argchks */
/* allocate memory */
/* get sizes */
/* sanity check */
/* extract and justify kA */
/* extract and justify kB */
/* allocate the table */
/* init montgomery reduction */
/* copy ones ... */
/* precomp [i,0](A + B) table */
/* precomp [0,i](A + B) table */
/* precomp [i,j](A + B) table (i != 0, j != 0) */
/* for every byte of the multiplicands */
/* grab a nibble */
/* extract two bits from both, shift/update */
/* if both zero, if first, continue */
/* double twice, only if this isn't the first */
/* double twice */
/* if not both zero */
/* if first, copy from table */
/* if not first, add from table */
/* reduce to affine */
/* clean up */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_mul2add.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/* size of sliding window, don't change this! */
/**
/* init montgomery reduction */
/* alloc ram for window temps */
/* make a copy of G incase R==G */
/* tG = G  and convert to montgomery */
/* calc the M tab, which holds kG for k==8..15 */
/* M[0] == 8G */
/* now find (8+k)G for k=1..7 */
/* setup sliding window */
/* perform ops */
/* grab next digit as required */
/* grab the next msb from the ltiplicand */
/* skip leading zero bits */
/* if the bit is zero and mode == 1 then we double */
/* else we add it to the window */
/* if this is the first window we do a simple copy */
/* R = kG [k = first window] */
/* normal window */
/* ok window is filled so double as required and add  */
/* double first */
/* then add, bitbuf will be 8..15 [8..2^WINSIZE] guaranteed */
/* empty window and reset */
/* if bits remain then double/add */
/* double then add */
/* only double if we have had at least one add first */
/* first add, so copy */
/* then add */
/* map R back from projective space */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_mulmod.c,v $ */
/* $Revision: 1.26 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/** Free an ECC point from memory
/* prevents free'ing null arguments */
/* note: p->z may be NULL but that's ok with this function anyways */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_points.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* should we dbl instead? */
/* if Z is one then these are no-operations */
/* T1 = Z' * Z' */
/* X = X * T1 */
/* T1 = Z' * T1 */
/* Y = Y * T1 */
/* T1 = Z*Z */
/* T2 = X' * T1 */
/* T1 = Z * T1 */
/* T1 = Y' * T1 */
/* Y = Y - T1 */
/* T1 = 2T1 */
/* T1 = Y + T1 */
/* X = X - T2 */
/* T2 = 2T2 */
/* T2 = X + T2 */
/* if Z' != 1 */
/* Z = Z * Z' */
/* Z = Z * X */
/* T1 = T1 * X  */
/* X = X * X */
/* T2 = T2 * x */
/* T1 = T1 * X  */
/* X = Y*Y */
/* X = X - T2 */
/* T2 = T2 - X */
/* T2 = T2 - X */
/* T2 = T2 * Y */
/* Y = T2 - T1 */
/* Y = Y/2 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_projective_add_point.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* t1 = Z * Z */
/* Z = Y * Z */
/* Z = 2Z */
/* T2 = X - T1 */
/* T1 = X + T1 */
/* T2 = T1 * T2 */
/* T1 = 2T2 */
/* T1 = T1 + T2 */
/* Y = 2Y */
/* Y = Y * Y */
/* T2 = Y * Y */
/* T2 = T2/2 */
/* Y = Y * X */
/* X  = T1 * T1 */
/* X = X - Y */
/* X = X - Y */
/* Y = Y - X */     
/* Y = Y * T1 */
/* Y = Y - T2 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_projective_dbl_point.c,v $ */
/* $Revision: 1.11 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* ensure valid hash */
/* get hash output size */
/* allocate memory */
/* start counter */
/* handle counter */
/* get hash of seed || counter */
/* store it */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_mgf1.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* default to invalid packet */
/* test valid hash */
/* test hash/message size */
/* allocate ram for DB/mask/salt of size modulus_len */
/* ok so it's now in the form
/* must have leading 0x00 byte */
/* now read the masked seed */
/* now read the masked DB */
/* compute MGF1 of maskedDB (hLen) */ 
/* XOR against seed */
/* compute MGF1 of seed (k - hlen - 1) */
/* xor against DB */
/* now DB == lhash || PS || 0x01 || M, PS == k - mlen - 2hlen - 2 zeroes */
/* compute lhash and store it in seed [reuse temps!] */
/* can't pass hash_memory a NULL so use DB with zero length */
/* compare the lhash'es */
/* now zeroes before a 0x01 */
/* step... */
/* error out if wasn't 0x01 */
/* rest is the message (and skip 0x01) */
/* copy message */
/* valid packet */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_oaep_decode.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* default to invalid */
/* ensure hash is valid */
/* check sizes */
/* allocate ram for DB/mask/salt/hash of size modulus_len */
/* ensure the 0xBC byte */
/* copy out the DB */
/* copy out the hash */
/* check the MSB */
/* generate mask of length modulus_len - hLen - 1 from hash */
/* xor against DB */
/* now clear the first byte [make sure smaller than modulus] */
/* DB = PS || 0x01 || salt, PS == modulus_len - saltlen - hLen - 2 zero bytes */
/* check for zeroes and 0x01 */
/* check for the 0x01 */
/* M = (eight) 0x00 || msghash || salt, mask = H(M) */
/* mask == hash means valid signature */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_pss_decode.c,v $ */
/* $Revision: 1.11 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** @file pkcs_1_v1_5_decode.c
/** @brief LTC_PKCS #1 v1.5 decode.
/* default to invalid packet */
/* test message size */
/* separate encoded message */
/* separator */
/* There was no octet with hexadecimal value 0x00 to separate ps from m,
/* separator check */
/* There was no octet with hexadecimal value 0x00 to separate ps from m. */
/* valid packet */
/* pkcs_1_v1_5_decode */
/* #ifdef LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_v1_5_decode.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** 
/* is the key of the right type for the operation? */
/* must be a private or public operation */
/* init and copy into tmp */
/* sanity check on the input */
/* are we using the private exponent and is the key optimized? */
/* tmpa = tmp^dP mod p */
/* tmpb = tmp^dQ mod q */
/* tmp = (tmpa - tmpb) * qInv (mod p) */
/* tmp = tmpb + q * tmp */
/* exptmod it */
/* read it back */
/* this should never happen ... */
/* convert it */
/* clean up and return */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_exptmod.c,v $ */
/* $Revision: 1.18 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_free.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* init key */
/* see if the OpenSSL DER format RSA public key will work */
/* this includes the internal hash ID and optional params (NULL in this case) */
/* the actual format of the SSL DER key is odd, it stores a RSAPublicKey in a **BIT** string ... so we have to extract it
/* ok now we have to reassemble the BIT STRING to an OCTET STRING.  Thanks OpenSSL... */
/* now it should be SEQUENCE { INTEGER, INTEGER } */
/* not SSL public key, try to match against LTC_PKCS #1 standards */
/* it's a private key */
/* we don't support multi-prime RSA */
/* it's a public key and we lack e */
/* LTC_MRSA */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_import.c,v $ */
/* $Revision: 1.23 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** 
/* make primes p and q (optimization provided by Wayne Scott) */
/* tmp3 = e */
/* make prime "p" */
/* tmp1 = p-1 */
/* tmp2 = gcd(p-1, e) */
/* while e divides p-1 */
/* make prime "q" */
/* tmp1 = q-1 */
/* tmp2 = gcd(q-1, e) */
/* while e divides q-1 */
/* tmp1 = lcm(p-1, q-1) */
/* tmp2 = p-1 */
/* tmp1 = q-1 (previous do/while loop) */
/* tmp1 = lcm(p-1, q-1) */
/* make key */
/* key->e =  e */
/* key->d = 1/e mod lcm(p-1,q-1) */
/* key->N = pq */
/* optimize for CRT now */
/* find d mod q-1 and d mod p-1 */
/* tmp1 = q-1 */
/* tmp2 = p-1 */
/* dP = d mod p-1 */
/* dQ = d mod q-1 */
/* qP = 1/q mod p */
/* set key type (in this case it's CRT optimized) */
/* return ok and free temps */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_make_key.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* default to invalid */
/* valid padding? */
/* valid hash ? */
/* get modulus len in bits */
/* outlen must be at least the size of the modulus */
/* allocate temp buffer for decoded sig */
/* RSA decode it  */
/* make sure the output is the right size */
/* PSS decode and verify it */
/* LTC_PKCS #1 v1.5 decode it */
/* not all hashes have OIDs... so sad */
/* allocate temp buffer for decoded hash */
/* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */
/* construct the SEQUENCE 
/* test OID */
/* LTC_MRSA */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_verify_hash.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2007/05/12 14:32:35 $ */
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* default to invalid */
/* get modulus len in bits */
/* outlen must be at least the size of the modulus */
/* allocate temp buffer for decoded sig */
/* RSA decode it  */
/* make sure the output is the right size */
/* compare the decrypted signature with the given hash */
/* LTC_MRSA */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Known optimal configurations
/* Min. number of digits before Karatsuba multiplication is used. */
/* Min. number of digits before Karatsuba squaring is used. */
/* no optimal values of these are known yet so set em high */
/* $Source: /cvs/libtom/libtommath/bncore.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes the modular inverse via binary extended euclidean algorithm, 
/* 2. [modified] b must be odd   */
/* init all our temps */
/* x == modulus, y == value to invert */
/* we need y = |a| */
/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
/* 4.  while u is even do */
/* 4.1 u = u/2 */
/* 4.2 if B is odd then */
/* B = B/2 */
/* 5.  while v is even do */
/* 5.1 v = v/2 */
/* 5.2 if D is odd then */
/* D = (D-x)/2 */
/* D = D/2 */
/* 6.  if u >= v then */
/* u = u - v, B = B - D */
/* v - v - u, D = D - B */
/* if not zero goto step 4 */
/* now a = C, b = D, gcd == g*v */
/* if v != 1 then there is no inverse */
/* b is now the inverse */
/* $Source: /cvs/libtom/libtommath/bn_fast_mp_invmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes xR**-1 == x (mod N) via Montgomery Reduction
/* get old used count */
/* grow a as required */
/* first we have to get the digits of the input into
/* alias for the W[] array */
/* alias for the digits of  x*/
/* copy the digits of a into W[0..a->used-1] */
/* zero the high words of W[a->used..m->used*2] */
/* now we proceed to zero successive digits
/* mu = ai * m' mod b
/* a = a + mu * m * b**i
/* alias for the digits of the modulus */
/* Alias for the columns set by an offset of ix */
/* inner loop */
/* now fix carry for next digit, W[ix+1] */
/* now we have to propagate the carries and
/* nox fix rest of carries */
/* alias for current word */
/* alias for next word, where the carry goes */
/* copy out, A = A/b**n
/* alias for destination word */
/* alias for shifted double precision result */
/* zero oldused digits, if the input a was larger than
/* set the max used and clamp */
/* if A >= m then A = A - m */
/* $Source: /cvs/libtom/libtommath/bn_fast_mp_montgomery_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Fast (comba) multiplier
/* grow the destination as required */
/* number of output digits to produce */
/* clear the carry */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially 
/* execute loop */
/* store term */
/* make next carry */
/* setup dest */
/* now extract the previous digit [below the carry] */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_mul_digs.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this is a modified version of fast_s_mul_digs that only produces
/* grow the destination as required */
/* number of output digits to produce */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially its 
/* execute loop */
/* store term */
/* make next carry */
/* setup dest */
/* now extract the previous digit [below the carry] */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_mul_high_digs.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* the jist of squaring...
/* grow the destination as required */
/* number of output digits to produce */
/* clear counter */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially
/* now for squaring tx can never equal ty 
/* execute loop */
/* double the inner product and add carry */
/* even columns have the square term in them */
/* store it */
/* make next carry */
/* setup dest */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes a = 2**b 
/* zero a as per default */
/* grow a to accomodate the single bit */
/* set the used count of where the bit will go */
/* put the single bit in its place */
/* $Source: /cvs/libtom/libtommath/bn_mp_2expt.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = |a| 
/* copy a to b */
/* force the sign of b to positive */
/* $Source: /cvs/libtom/libtommath/bn_mp_abs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level addition (handles signs) */
/* get sign of both inputs */
/* handle two cases, not four */
/* both positive or both negative */
/* add their magnitudes, copy the sign */
/* one positive, the other negative */
/* subtract the one with the greater magnitude from */
/* the one of the lesser magnitude.  The result gets */
/* the sign of the one with the greater magnitude. */
/* $Source: /cvs/libtom/libtommath/bn_mp_add.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a + b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_addmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* single digit addition */
/* grow c as required */
/* if a is negative and |a| >= b, call c = |a| - b */
/* temporarily fix sign of a */
/* c = |a| - b */
/* fix sign  */
/* clamp */
/* old number of used digits in c */
/* sign always positive */
/* source alias */
/* destination alias */
/* if a is positive */
/* add digit, after this we're propagating
/* now handle rest of the digits */
/* set final carry */
/* setup size */
/* a was negative and |a| < b */
/* the result is a single digit */
/* setup count so the clearing of oldused
/* now zero to oldused */
/* $Source: /cvs/libtom/libtommath/bn_mp_add_d.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* AND two ints together */
/* zero digits above the last from the smallest mp_int */
/* $Source: /cvs/libtom/libtommath/bn_mp_and.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* trim unused digits 
/* decrease used while the most significant digit is
/* reset the sign flag if used == 0 */
/* $Source: /cvs/libtom/libtommath/bn_mp_clamp.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* clear one (frees)  */
/* only do anything if a hasn't been freed previously */
/* first zero the digits */
/* free ram */
/* reset members to make debugging easier */
/* $Source: /cvs/libtom/libtommath/bn_mp_clear.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_clear_multi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare two ints (signed)*/
/* compare based on sign */
/* compare digits */
/* if negative compare opposite direction */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare a digit */
/* compare based on sign */
/* compare based on magnitude */
/* compare the only digit of a to b */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare maginitude of two ints (unsigned) */
/* compare based on # of non-zero digits */
/* alias for a */
/* alias for b */
/* compare based on digits  */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp_mag.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Counts the number of lsbs which are zero before the first zero bit */
/* easy out */
/* scan lower digits until non-zero */
/* now scan this digit until a 1 is found */
/* $Source: /cvs/libtom/libtommath/bn_mp_cnt_lsb.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* copy, b = a */
/* if dst == src do nothing */
/* grow dest */
/* zero b and copy the parameters over */
/* pointer aliases */
/* source */
/* destination */
/* copy all the digits */
/* clear high digits */
/* copy used count and sign */
/* $Source: /cvs/libtom/libtommath/bn_mp_copy.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns the number of bits in an int */
/* shortcut */
/* get number of digits and add that */
/* take the last digit and count the bits in it */
/* $Source: /cvs/libtom/libtommath/bn_mp_count_bits.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* slower bit-bang division... also smaller */
/* is divisor zero ? */
/* if a < b then q=0, r = a */
/* init our temps */
/* now q == quotient and ta == remainder */
/* integer signed division. 
/* is divisor zero ? */
/* if a < b then q=0, r = a */
/* fix the sign */
/* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
/* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
/* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
/* y = y*b**{n-t} */
/* reset y by shifting it back down */
/* step 3. for i from n down to (t + 1) */
/* step 3.1 if xi == yt then set q{i-t-1} to b-1, 
/* while (q{i-t-1} * (yt * b + y{t-1})) > 
/* find left hand */
/* find right hand */
/* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
/* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
/* now q is the quotient and x is the remainder 
/* get sign before writing to c */
/* $Source: /cvs/libtom/libtommath/bn_mp_div.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = a/2 */
/* copy */
/* source alias */
/* dest alias */
/* carry */
/* get the carry for the next iteration */
/* shift the current digit, add in carry and store */
/* forward carry to next iteration */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_2.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift right by a certain bit count (store quotient in c, optional remainder in d) */
/* if the shift count is <= 0 then we do no work */
/* get the remainder */
/* copy */
/* shift by as many digits in the bit count */
/* shift any bit count < DIGIT_BIT */
/* mask */
/* shift for lsb */
/* alias */
/* carry */
/* get the lower  bits of this word in a temp */
/* shift the current word and mix in the carry bits from the previous word */
/* set the carry to the carry bits of the current word found above */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* divide by three (based on routine from MPI and the GMP manual) */
/* b = 2**DIGIT_BIT / 3 */
/* multiply w by [1/3] */
/* now subtract 3 * [w/3] from w, to get the remainder */
/* fixup the remainder as required since
/* [optional] store the remainder */
/* [optional] store the quotient */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_3.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* fast return if no power of two */
/* single digit division (based on routine from MPI) */
/* cannot divide by zero */
/* quick outs */
/* power of two ? */
/* three? */
/* no easy answer [c'est la vie].  Just division */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_d.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2007/01/09 04:44:32 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if a number is a valid DR modulus */
/* must be at least two digits */
/* must be of the form b**k - a [a <= b] so all
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_is_modulus.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduce "x" in place modulo "n" using the Diminished Radix algorithm.
/* m = digits in modulus */
/* ensure that "x" has at least 2m digits */
/* top of loop, this is where the code resumes if
/* aliases for digits */
/* alias for lower half of x */
/* alias for upper half of x, or x/B**m */
/* set carry to zero */
/* compute (x mod B**m) + k * [x/B**m] inline and inplace */
/* set final carry */
/* zero words above m */
/* clamp, sub and return */
/* if x >= n then subtract and reduce again
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* the casts are required if DIGIT_BIT is one less than
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* swap the elements of two integers, for cases where you can't simply swap the 
/* $Source: /cvs/libtom/libtommath/bn_mp_exch.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this is a shell function that calls either the normal or Montgomery
/* modulus P must be positive */
/* if exponent X is negative we have to recurse */
/* first compute 1/G mod P */
/* now get |X| */
/* and now compute (1/G)**|X| instead of G**X [X < 0] */
/* no invmod */
/* modified diminished radix reduction */
/* is it a DR modulus? */
/* default to no */
/* if not, is it a unrestricted DR modulus? */
/* if the modulus is odd or dr != 0 use the montgomery method */
/* otherwise use the generic Barrett reduction technique */
/* no exptmod for evens */
/* $Source: /cvs/libtom/libtommath/bn_mp_exptmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes Y == G**X mod P, HAC pp.616, Algorithm 14.85
/* use a pointer to the reduction algorithm.  This allows us to use
/* find window size */
/* init M array */
/* init first cell */
/* now init the second half of the array */
/* determine and setup reduction code */
/* now setup montgomery  */
/* automatically pick the comba one if available (saves quite a few calls/ifs) */
/* use slower baseline Montgomery method */
/* setup DR reduction for moduli of the form B**k - b */
/* setup DR reduction for moduli of the form 2**k - b */
/* setup result */
/* create M table
/* now we need R mod m */
/* now set M[1] to G * R mod m */
/* compute the value at M[1<<(winsize-1)] by squaring M[1] (winsize-1) times */
/* create upper table */
/* set initial mode and bit cnt */
/* grab next digit as required */
/* if digidx == -1 we are out of digits so break */
/* read next digit and reset bitcnt */
/* grab the next msb from the exponent */
/* if the bit is zero and mode == 0 then we ignore it
/* if the bit is zero and mode == 1 then we square */
/* else we add it to the window */
/* ok window is filled so square as required and multiply  */
/* square first */
/* then multiply */
/* empty window and reset */
/* if bits remain then square/multiply */
/* square then multiply if the bit is set */
/* get next bit of the window */
/* then multiply */
/* fixup result if Montgomery reduction is used
/* swap res with Y */
/* $Source: /cvs/libtom/libtommath/bn_mp_exptmod_fast.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* calculate c = a**b  using a square-multiply algorithm */
/* set initial result */
/* square */
/* if the bit is set multiply */
/* shift to next bit */
/* $Source: /cvs/libtom/libtommath/bn_mp_expt_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Extended euclidean algorithm of (a, b) produces 
/* initialize, (u1,u2,u3) = (1,0,a) */
/* initialize, (v1,v2,v3) = (0,1,b) */
/* loop while v3 != 0 */
/* q = u3/v3 */
/* (t1,t2,t3) = (u1,u2,u3) - (v1,v2,v3)q */
/* (u1,u2,u3) = (v1,v2,v3) */
/* (v1,v2,v3) = (t1,t2,t3) */
/* make sure U3 >= 0 */
/* copy result out */
/* $Source: /cvs/libtom/libtommath/bn_mp_exteuclid.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read a bigint from a file stream in ASCII */
/* clear a */
/* if first digit is - then set negative */
/* find y in the radix map */
/* shift up and add */
/* $Source: /cvs/libtom/libtommath/bn_mp_fread.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_fwrite.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Greatest Common Divisor using the binary method */
/* either zero than gcd is the largest */
/* get copies of a and b we can modify */
/* must be positive for the remainder of the algorithm */
/* B1.  Find the common power of two for u and v */
/* divide the power of two out */
/* divide any remaining factors of two out */
/* make sure v is the largest */
/* swap u and v to make sure v is >= u */
/* subtract smallest from largest */
/* Divide out all factors of two */
/* multiply by 2**k which we divided out at the beginning */
/* $Source: /cvs/libtom/libtommath/bn_mp_gcd.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the lower 32-bits of an mp_int */
/* get number of digits of the lsb we have to read */
/* get most significant digit of result */
/* force result to 32-bits always so it is consistent on non 32-bit platforms */
/* $Source: /cvs/libtom/libtommath/bn_mp_get_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* grow as required */
/* if the alloc size is smaller alloc more ram */
/* ensure there are always at least MP_PREC digits extra on top */
/* reallocate the array a->dp
/* reallocation failed but "a" is still valid [can be freed] */
/* reallocation succeeded so set a->dp */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_grow.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* init a new mp_int */
/* allocate memory required and clear it */
/* set the digits to zero */
/* set the used to zero, allocated digits to the default precision
/* $Source: /cvs/libtom/libtommath/bn_mp_init.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* creates "a" then copies b into it */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_copy.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Assume ok until proven otherwise */
/* Number of ok inits */
/* init args to next argument from caller */
/* Oops - error! Back-track and mp_clear what we already
/* end the current list */
/* now start cleaning up */            
/* Assumed ok, if error flagged above. */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_multi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* initialize and set a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_set.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* initialize and set a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_set_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* init an mp_init for a given size */
/* pad size so there are always extra digits */
/* alloc mem */
/* set the members */
/* zero the digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* hac 14.61, pp608 */
/* b cannot be negative */
/* if the modulus is odd we can use a faster routine instead */
/* $Source: /cvs/libtom/libtommath/bn_mp_invmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* hac 14.61, pp608 */
/* b cannot be negative */
/* init temps */
/* x = a, y = b */
/* 2. [modified] if x,y are both even then return an error! */
/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
/* 4.  while u is even do */
/* 4.1 u = u/2 */
/* 4.2 if A or B is odd then */
/* A = (A+y)/2, B = (B-x)/2 */
/* A = A/2, B = B/2 */
/* 5.  while v is even do */
/* 5.1 v = v/2 */
/* 5.2 if C or D is odd then */
/* C = (C+y)/2, D = (D-x)/2 */
/* C = C/2, D = D/2 */
/* 6.  if u >= v then */
/* u = u - v, A = A - C, B = B - D */
/* v - v - u, C = C - A, D = D - B */
/* if not zero goto step 4 */
/* now a = C, b = D, gcd == g*v */
/* if v != 1 then there is no inverse */
/* if its too low */
/* too big */
/* C is now the inverse */
/* $Source: /cvs/libtom/libtommath/bn_mp_invmod_slow.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Check if remainders are possible squares - fast exclude non-squares */
/* Store non-zero to ret if arg is square, and zero if not */
/* Default to Non-square :) */
/* digits used?  (TSD) */
/* First check mod 128 (suppose that DIGIT_BIT is at least 7) */
/* Next check mod 105 (3*5*7) */
/* Check for other prime modules, note it's not an ERROR but we must
/* Final check - is sqr(sqrt(arg)) == arg ? */
/* $Source: /cvs/libtom/libtommath/bn_mp_is_square.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes the jacobi c = (a | n) (or Legendre if n is prime)
/* if p <= 0 return MP_VAL */
/* step 1.  if a == 0, return 0 */
/* step 2.  if a == 1, return 1 */
/* default */
/* step 3.  write a = a1 * 2**k  */
/* divide out larger power of two */
/* step 4.  if e is even set s=1 */
/* else set s=1 if p = 1/7 (mod 8) or s=-1 if p = 3/5 (mod 8) */
/* step 5.  if p == 3 (mod 4) *and* a1 == 3 (mod 4) then s = -s */
/* if a1 == 1 we're done */
/* n1 = n mod a1 */
/* done */
/* $Source: /cvs/libtom/libtommath/bn_mp_jacobi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = |a| * |b| using Karatsuba Multiplication using 
/* default the return code to an error */
/* min # of digits */
/* now divide in two */
/* init copy all the temps */
/* init temps */
/* now shift the digits */
/* we copy the digits directly instead of using higher level functions
/* only need to clamp the lower words since by definition the 
/* now calc the products x0y0 and x1y1 */
/* after this x0 is no longer required, free temp [x0==t2]! */
/* x0y0 = x0*y0 */
/* x1y1 = x1*y1 */
/* now calc x1+x0 and y1+y0 */
/* t1 = x1 - x0 */
/* t2 = y1 - y0 */
/* t1 = (x1 + x0) * (y1 + y0) */
/* add x0y0 */
/* t2 = x0y0 + x1y1 */
/* t1 = (x1+x0)*(y1+y0) - (x1y1 + x0y0) */
/* shift by B */
/* t1 = (x0y0 + x1y1 - (x1-x0)*(y1-y0))<<B */
/* x1y1 = x1y1 << 2*B */
/* t1 = x0y0 + t1 */
/* t1 = x0y0 + t1 + x1y1 */
/* Algorithm succeeded set the return code to MP_OKAY */
/* $Source: /cvs/libtom/libtommath/bn_mp_karatsuba_mul.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Karatsuba squaring, computes b = a*a using three 
/* min # of digits */
/* now divide in two */
/* init copy all the temps */
/* init temps */
/* now shift the digits */
/* now calc the products x0*x0 and x1*x1 */
/* x0x0 = x0*x0 */
/* x1x1 = x1*x1 */
/* now calc (x1+x0)**2 */
/* t1 = x1 - x0 */
/* t1 = (x1 - x0) * (x1 - x0) */
/* add x0y0 */
/* t2 = x0x0 + x1x1 */
/* t1 = (x1+x0)**2 - (x0x0 + x1x1) */
/* shift by B */
/* t1 = (x0x0 + x1x1 - (x1-x0)*(x1-x0))<<B */
/* x1x1 = x1x1 << 2*B */
/* t1 = x0x0 + t1 */
/* t1 = x0x0 + t1 + x1x1 */
/* $Source: /cvs/libtom/libtommath/bn_mp_karatsuba_sqr.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes least common multiple as |a*b|/(a, b) */
/* t1 = get the GCD of the two inputs */
/* divide the smallest by the GCD */
/* store quotient in t2 such that t2 * b is the LCM */
/* store quotient in t2 such that t2 * a is the LCM */
/* fix the sign to positive */
/* $Source: /cvs/libtom/libtommath/bn_mp_lcm.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift left a certain amount of digits */
/* if its less than zero return */
/* grow to fit the new digits */
/* increment the used by the shift amount then copy upwards */
/* top */
/* base */
/* much like mp_rshd this is implemented using a sliding window
/* zero the lower digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_lshd.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = a mod b, 0 <= c < b */
/* $Source: /cvs/libtom/libtommath/bn_mp_mod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* calc a value mod 2**b */
/* if b is <= 0 then zero the int */
/* if the modulus is larger than the value than return */
/* copy */
/* zero digits above the last digit of the modulus */
/* clear the digit that is not completely outside/inside the modulus */
/* $Source: /cvs/libtom/libtommath/bn_mp_mod_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_mod_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/*
/* how many bits of last digit does b use */
/* now compute C = A * B mod b */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_calc_normalization.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes xR**-1 == x (mod N) via Montgomery Reduction */
/* can the fast reduction [comba] method be used?
/* grow the input as required */
/* mu = ai * rho mod b
/* a = a + mu * m * b**i */
/* alias for digits of the modulus */
/* alias for the digits of x [the input] */
/* set the carry to zero */
/* Multiply and add in place */
/* compute product and sum */
/* get carry */
/* fix digit */
/* At this point the ix'th digit of x should be zero */
/* propagate carries upwards as required*/
/* at this point the n.used'th least
/* x = x/b**n.used */
/* if x >= n then x = x - n */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* setups the montgomery reduction stuff */
/* fast inversion mod 2**k
/* here x*a==1 mod 2**4 */
/* here x*a==1 mod 2**8 */
/* here x*a==1 mod 2**16 */
/* here x*a==1 mod 2**32 */
/* here x*a==1 mod 2**64 */
/* rho = -1/m mod b */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_setup.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level multiplication (handles sign) */
/* use Toom-Cook? */
/* use Karatsuba? */
/* can we use the fast multiplier?
/* uses s_mp_mul_digs */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a * b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_mulmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = a*2 */
/* grow to accomodate result */
/* alias for source */
/* alias for dest */
/* carry */
/* get what will be the *next* carry bit from the 
/* now shift up this digit, add in the carry [from the previous] */
/* copy the carry that would be from the source 
/* new leading digit? */
/* add a MSB which is always 1 at this point */
/* now zero any excess digits on the destination 
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_2.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift left by a certain bit count */
/* copy */
/* shift by as many digits in the bit count */
/* shift any bit count < DIGIT_BIT */
/* bitmask for carries */
/* shift for msbs */
/* alias */
/* carry */
/* get the higher bits of the current word */
/* shift the current word and OR in the carry */
/* set the carry to the carry bits of the current word */
/* set final carry */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiply by a digit */
/* make sure c is big enough to hold a*b */
/* get the original destinations used count */
/* set the sign */
/* alias for a->dp [source] */
/* alias for c->dp [dest] */
/* zero carry */
/* compute columns */
/* compute product and carry sum for this term */
/* mask off higher bits to get a single digit */
/* send carry into next iteration */
/* store final carry [if any] and increment ix offset  */
/* now zero digits above the top */
/* set used count */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = -a */
/* $Source: /cvs/libtom/libtommath/bn_mp_neg.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* find the n'th root of an integer 
/* input must be positive if b is even */
/* if a is negative fudge the sign but keep track */
/* t2 = 2 */
/* t1 = t2 */
/* t2 = t1 - ((t1**b - a) / (b * t1**(b-1))) */
/* t3 = t1**(b-1) */
/* numerator */
/* t2 = t1**b */
/* t2 = t1**b - a */
/* denominator */
/* t3 = t1**(b-1) * b  */
/* t3 = (t1**b - a)/(b * t1**(b-1)) */
/* result can be off by a few so check */
/* reset the sign of a first */
/* set the result */
/* set the sign of the result */
/* $Source: /cvs/libtom/libtommath/bn_mp_n_root.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* OR two ints together */
/* $Source: /cvs/libtom/libtommath/bn_mp_or.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* performs one Fermat test.
/* default to composite  */
/* ensure b > 1 */
/* init t */
/* compute t = b**a mod a */
/* is it equal to b? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_fermat.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if an integers is divisible by one 
/* default to not */
/* what is a mod LBL_prime_tab[ix] */
/* is the residue zero? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_is_divisible.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* performs a variable number of rounds of Miller-Rabin
/* default to no */
/* valid value of t? */
/* is the input equal to one of the primes in the table? */
/* first perform trial division */
/* return if it was trivially divisible */
/* now perform the miller-rabin rounds */
/* set the prime */
/* passed the test */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_is_prime.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Miller-Rabin test of "a" to the base of "b" as described in 
/* default */
/* ensure b > 1 */
/* get n1 = a - 1 */
/* set 2**s * r = n1 */
/* count the number of least significant bits
/* now divide n - 1 by 2**s */
/* compute y = b**r mod a */
/* if y != 1 and y != n1 do */
/* while j <= s-1 and y != n1 */
/* if y == 1 then composite */
/* if y != n1 then composite */
/* probably prime now */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_miller_rabin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* finds the next prime after the number "a" using "t" trials
/* ensure t is valid */
/* force positive */
/* simple algo if a is less than the largest prime in the table */
/* find which prime it is bigger than */
/* ok we found a prime smaller or
/* scan upwards for a prime congruent to 3 mod 4 */
/* at this point a maybe 1 */
/* fall through to the sieve */
/* generate a prime congruent to 3 mod 4 or 1/3 mod 4? */
/* at this point we will use a combination of a sieve and Miller-Rabin */
/* if a mod 4 != 3 subtract the correct value to make it so */
/* force odd */
/* generate the restable */
/* init temp used for Miller-Rabin Testing */
/* skip to the next non-trivially divisible candidate */
/* y == 1 if any residue was zero [e.g. cannot be prime] */
/* increase step to next candidate */
/* compute the new residue without using division */
/* add the step to each residue */
/* subtract the modulus [instead of using division] */
/* set flag if zero */
/* add the step */
/* if didn't pass sieve and step == MAX then skip test */
/* is this prime? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_next_prime.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns # of RM trials required for a given bit size */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_rabin_miller_trials.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* makes a truly random prime of a given size (bits),
/* This is possibly the mother of all prime generation functions, muahahahahaha! */
/* sanity check the input */
/* LTM_PRIME_SAFE implies LTM_PRIME_BBS */
/* calc the byte size */
/* we need a buffer of bsize bytes */
/* calc the maskAND value for the MSbyte*/
/* calc the maskOR_msb */
/* get the maskOR_lsb */
/* read the bytes */
/* work over the MSbyte */
/* mix in the maskORs */
/* read it in */
/* is it prime? */
/* see if (a-1)/2 is prime */
/* is it prime? */
/* restore a to the original value */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_random_ex.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns size of ASCII reprensentation */
/* special case for binary */
/* make sure the radix is in range */
/* digs is the digit count */
/* if it's negative add one for the sign */
/* init a copy of the input */
/* force temp to positive */
/* fetch out all of the digits */
/* return digs + 1, the 1 is for the NULL byte that would be required. */
/* $Source: /cvs/libtom/libtommath/bn_mp_radix_size.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* chars used in radix conversions */
/* $Source: /cvs/libtom/libtommath/bn_mp_radix_smap.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* makes a pseudo-random int of a given size */
/* first place a random non-zero digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_rand.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read a string [ASCII] in a given radix */
/* zero the digit bignum */
/* make sure the radix is ok */
/* if the leading digit is a 
/* set the integer to the default of zero */
/* process each digit of the string */
/* if the radix < 36 the conversion is case insensitive
/* if the char was found in the map 
/* set the sign only if a != 0 */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_radix.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read signed bin, big endian, first byte is 0==positive or 1==negative */
/* read magnitude */
/* first byte is 0 for positive, non-zero for negative */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_signed_bin.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reads a unsigned char array, assumes the msb is stored first [big endian] */
/* make sure there are at least two digits */
/* zero the int */
/* read the bytes in */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_unsigned_bin.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces x mod m, assumes 0 < x < m**2, mu is 
/* q = x */
/* q1 = x / b**(k-1)  */
/* according to HAC this optimization is ok */
/* q3 = q2 / b**(k+1) */
/* x = x mod b**(k+1), quick (no division) */
/* q = q * m mod b**(k+1), quick (no division) */
/* x = x - q */
/* If x < 0, add b**(k+1) to it */
/* Back off if it's too big */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces a modulo n where n is of the form 2**p - d */
/* q = a/2**p, a = a mod 2**p */
/* q = q * d */
/* a = a + q */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces a modulo n where n is of the form 2**p - d 
/* q = a/2**p, a = a mod 2**p */
/* q = q * d */
/* a = a + q */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_setup_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if mp_reduce_2k can be used */
/* Test every bit from the second digit up, must be 1 */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_is_2k.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if reduce_2k_l can be used */
/* if more than half of the digits are -1 we're sold */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_is_2k_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* pre-calculate the value required for Barrett reduction
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift right a certain amount of digits */
/* if b <= 0 then ignore it */
/* if b > used then simply zero it and return */
/* shift the digits down */
/* bottom */
/* top [offset into digits] */
/* this is implemented as a sliding window where 
/* zero the top digits */
/* remove excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_rshd.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set to a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_set.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set a 32-bit const */
/* set four bits at a time */
/* shift the number up four bits */
/* OR in the top four bits of the source */
/* shift the source up to the next four bits */
/* ensure that digits are not clamped off */
/* $Source: /cvs/libtom/libtommath/bn_mp_set_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shrink a bignum */
/* $Source: /cvs/libtom/libtommath/bn_mp_shrink.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the size for an signed equivalent */
/* $Source: /cvs/libtom/libtommath/bn_mp_signed_bin_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes b = a*a */
/* use Toom-Cook? */
/* Karatsuba? */
/* can we use the fast comba multiplier? */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = a * a (mod b) */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqrmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this function is less generic than mp_n_root, simpler and faster */
/* must be positive */
/* easy out */
/* First approx. (not very bad for large arg) */
/* t1 > 0  */ 
/* And now t1 > sqrt(arg) */
/* t1 >= sqrt(arg) >= t2 at this point */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqrt.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level subtraction (handles signs) */
/* subtract a negative from a positive, OR */
/* subtract a positive from a negative. */
/* In either case, ADD their magnitudes, */
/* and use the sign of the first number. */
/* subtract a positive from a positive, OR */
/* subtract a negative from a negative. */
/* First, take the difference between their */
/* magnitudes, then... */
/* Copy the sign from the first */
/* The first has a larger or equal magnitude */
/* The result has the *opposite* sign from */
/* the first number. */
/* The second has a larger magnitude */
/* $Source: /cvs/libtom/libtommath/bn_mp_sub.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a - b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_submod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* single digit subtraction */
/* grow c as required */
/* if a is negative just do an unsigned
/* clamp */
/* setup regs */
/* if a <= b simply fix the single digit */
/* negative/1digit */
/* positive/size */
/* subtract first digit */
/* handle rest of the digits */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_sub_d.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplication using the Toom-Cook 3-way algorithm 
/* init temps */
/* B */
/* a = a2 * B**2 + a1 * B + a0 */
/* b = b2 * B**2 + b1 * B + b0 */
/* w0 = a0*b0 */
/* w4 = a2 * b2 */
/* w1 = (a2 + 2(a1 + 2a0))(b2 + 2(b1 + 2b0)) */
/* w3 = (a0 + 2(a1 + 2a2))(b0 + 2(b1 + 2b2)) */
/* w2 = (a2 + a1 + a0)(b2 + b1 + b0) */
/* now solve the matrix 
/* r1 - r4 */
/* r3 - r0 */
/* r1/2 */
/* r3/2 */
/* r2 - r0 - r4 */
/* r1 - r2 */
/* r3 - r2 */
/* r1 - 8r0 */
/* r3 - 8r4 */
/* 3r2 - r1 - r3 */
/* r1 - r2 */
/* r3 - r2 */
/* r1/3 */
/* r3/3 */
/* at this point shift W[n] by B*n */
/* $Source: /cvs/libtom/libtommath/bn_mp_toom_mul.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* squaring using Toom-Cook 3-way algorithm */
/* init temps */
/* B */
/* a = a2 * B**2 + a1 * B + a0 */
/* w0 = a0*a0 */
/* w4 = a2 * a2 */
/* w1 = (a2 + 2(a1 + 2a0))**2 */
/* w3 = (a0 + 2(a1 + 2a2))**2 */
/* w2 = (a2 + a1 + a0)**2 */
/* now solve the matrix
/* r1 - r4 */
/* r3 - r0 */
/* r1/2 */
/* r3/2 */
/* r2 - r0 - r4 */
/* r1 - r2 */
/* r3 - r2 */
/* r1 - 8r0 */
/* r3 - 8r4 */
/* 3r2 - r1 - r3 */
/* r1 - r2 */
/* r3 - r2 */
/* r1/3 */
/* r3/3 */
/* at this point shift W[n] by B*n */
/* $Source: /cvs/libtom/libtommath/bn_mp_toom_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* stores a bignum as a ASCII string in a given radix (2..64) */
/* check range of the radix */
/* quick out if its zero */
/* if it is negative output a - */
/* reverse the digits of the string.  In this case _s points
/* append a NULL so the string is properly terminated */
/* $Source: /cvs/libtom/libtommath/bn_mp_toradix.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* stores a bignum as a ASCII string in a given radix (2..64) 
/* check range of the maxlen, radix */
/* quick out if its zero */
/* if it is negative output a - */
/* we have to reverse our digits later... but not the - sign!! */
/* store the flag and mark the number as positive */
/* subtract a char */
/* no more room */
/* reverse the digits of the string.  In this case _s points
/* append a NULL so the string is properly terminated */
/* $Source: /cvs/libtom/libtommath/bn_mp_toradix_n.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in signed [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_signed_bin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in signed [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_signed_bin_n.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in unsigned [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_unsigned_bin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in unsigned [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_unsigned_bin_n.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the size for an unsigned equivalent */
/* $Source: /cvs/libtom/libtommath/bn_mp_unsigned_bin_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* XOR two ints together */
/* $Source: /cvs/libtom/libtommath/bn_mp_xor.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set to zero */
/* $Source: /cvs/libtom/libtommath/bn_mp_zero.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_prime_tab.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reverse an array, used for radix code */
/* $Source: /cvs/libtom/libtommath/bn_reverse.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level addition, based on HAC pp.594, Algorithm 14.7 */
/* find sizes, we let |a| <= |b| which means we have to sort
/* init result */
/* get old used digit count and set new one */
/* alias for digit pointers */
/* first input */
/* second input */
/* destination */
/* zero the carry */
/* Compute the sum at one digit, T[i] = A[i] + B[i] + U */
/* U = carry bit of T[i] */
/* take away carry bit from T[i] */
/* now copy higher words if any, that is in A+B 
/* T[i] = X[i] + U */
/* U = carry bit of T[i] */
/* take away carry bit from T[i] */
/* add carry */
/* clear digits above oldused */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_add.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* find window size */
/* init M array */
/* init first cell */
/* now init the second half of the array */
/* create mu, used for Barrett reduction */
/* create M table
/* compute the value at M[1<<(winsize-1)] by squaring 
/* square it */
/* reduce modulo P */
/* create upper table, that is M[x] = M[x-1] * M[1] (mod P)
/* setup result */
/* set initial mode and bit cnt */
/* grab next digit as required */
/* if digidx == -1 we are out of digits */
/* read next digit and reset the bitcnt */
/* grab the next msb from the exponent */
/* if the bit is zero and mode == 0 then we ignore it
/* if the bit is zero and mode == 1 then we square */
/* else we add it to the window */
/* ok window is filled so square as required and multiply  */
/* square first */
/* then multiply */
/* empty window and reset */
/* if bits remain then square/multiply */
/* square then multiply if the bit is set */
/* then multiply */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_exptmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplies |a| * |b| and only computes upto digs digits of result
/* can we use the fast multiplier? */
/* compute the digits of the product directly */
/* set the carry to zero */
/* limit ourselves to making digs digits of output */
/* setup some aliases */
/* copy of the digit from a used within the nested loop */
/* an alias for the destination shifted ix places */
/* an alias for the digits of b */
/* compute the columns of the output and propagate the carry */
/* compute the column as a mp_word */
/* the new column is the lower part of the result */
/* get the carry word from the result */
/* set carry if it is placed below digs */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_mul_digs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplies |a| * |b| and does not compute the lower digs digits
/* can we use the fast multiplier? */
/* clear the carry */
/* left hand side of A[ix] * B[iy] */
/* alias to the address of where the digits will be stored */
/* alias for where to read the right hand side from */
/* calculate the double precision result */
/* get the lower part */
/* carry the carry */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_mul_high_digs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level squaring, b = a*a, HAC pp.596-597, Algorithm 14.16 */
/* default used is maximum possible size */
/* first calculate the digit at 2*ix */
/* calculate double precision result */
/* store lower part in result */
/* get the carry */
/* left hand side of A[ix] * A[iy] */
/* alias for where to store the results */
/* first calculate the product */
/* now calculate the double precision result, note we use
/* store lower part */
/* get carry */
/* propagate upwards */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level subtraction (assumes |a| > |b|), HAC pp.595 Algorithm 14.9 */
/* find sizes */
/* init result */
/* alias for digit pointers */
/* set carry to zero */
/* T[i] = A[i] - B[i] - U */
/* U = carry bit of T[i]
/* Clear carry from T[i] */
/* now copy higher words if any, e.g. if A has more digits than B  */
/* T[i] = A[i] - U */
/* U = carry bit of T[i] */
/* Clear carry from T[i] */
/* clear digits above used (since we may not have grown result above) */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_sub.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
/* LzFind.c -- Match finder for LZ algorithms
/* it must be power of 2 */
/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
/* if (p->streamEndWasReached) return 0; */
/* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
/* don't change it! It's required for Deflate */
/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
/* MtSync_StopWriting must be called if Writing was started */
/* DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5) ^ (crc[p[4]] << 3)) & hashMask) */
/* #define MFMT_GM_INLINE */
/* Call it after ReleaseStream / SetStream */
/* ReleaseStream is required to finish multithreading */
/* p->MatchFinder->ReleaseStream(); */
/*
/* Condition: there are matches in btBuf with length < p->numHashBytes */
/*
/* case 4: */
/* p->GetHeadsFunc = GetHeads4; */
/*
/* LzmaDec.c -- LZMA Decoder
/* #define _LZMA_SIZE_OPT */
/* First LZMA-symbol is always decoded.
/* (UInt32)((Int32)code >> 31) */
/*
/* unexpected end of input stream */
/* if (bufLimit - buf >= 7) return DUMMY_LIT; */
/* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
/* if (code >= range) code -= range; */
/* LzmaEnc.c -- LZMA Encoder
/* #define SHOW_STAT */
/* #define SHOW_STAT2 */
/* #define LZMA_LOG_BSR */
/* Define it for Intel's CPU */
/*
/*
/* Stream.Init(); */
/* speed optimization */
/* try Literal + rep0 */
/* for (; lenTest2 >= 2; lenTest2--) */
/* speed optimization */
/* if (_maxMode) */
/* for (; lenTest2 >= 2; lenTest2--) */
/* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
/*2*/ startLen; ; lenTest++)
/*_maxMode && */lenTest == matches[offs])
/* Try Match + Literal + Rep0 */
/* for (; lenTest2 >= 2; lenTest2--) */
/* for GCC */
/* ReleaseMFStream(); */
/* Threads.c -- multithreading library
/* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
/* maybe we must use errno here, but probably GetLastError() is also OK. */
/* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
/* InitializeCriticalSectionAndSpinCount(p, 0); */
/*****************************************************************************/
/* crc32.c                                Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Pkware Data Compression Library Version 1.11                              */
/* Dissassembled method crc32 - cdecl version                                */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 09.04.03  1.00  Lad  The first version of crc32.c                         */
/* 02.05.03  1.00  Lad  Stress test done                                     */
/*****************************************************************************/
/*****************************************************************************/
/* explode.c                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Implode function of PKWARE Data Compression library                       */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.03.03  1.00  Lad  Splitted from Pkware.cpp                             */
/* 08.04.03  1.01  Lad  Renamed to explode.c to be compatible with pklib     */
/* 02.05.03  1.01  Lad  Stress test done                                     */
/* 22.04.10  1.01  Lad  Documented                                           */
/*****************************************************************************/
// All data from the input stream is read
// Need more data (dictionary)
// Internal flag, not returned to user
// Internal flag, not returned to user
//-----------------------------------------------------------------------------
// Tables
//-----------------------------------------------------------------------------
// Local functions
// [out] Table of positions
// [in] Table of start indexes
// [in] Table of lengths. Each length is stored as number of bits
// [in] Number of elements in start_indexes and length_bits
// Get the length in bytes
//-----------------------------------------------------------------------------
// Removes given number of bits in the bit buffer. New bits are reloaded from
// the input buffer, if needed.
// Returns: PKDCL_OK:         Operation was successful
//          PKDCL_STREAM_END: There are no more bits in the input buffer
// If number of bits required is less than number of (bits in the buffer) ?
// Load input buffer if necessary
// Update bit buffer
//-----------------------------------------------------------------------------
// Decodes next literal from the input (compressed) data.
// Returns : 0x000: One byte 0x00
//           0x001: One byte 0x01
//           ...
//           0x0FF: One byte 0xFF
//           0x100: Repetition, length of 0x02 bytes
//           0x101: Repetition, length of 0x03 bytes
//           ...
//           0x304: Repetition, length of 0x206 bytes
//           0x305: End of stream
//           0x306: Error
// Number of bits of extra literal length
// Length code
// Test the current bit in byte buffer. If is not set, simply return the next 8 bits.
// Remove one bit from the input data
// The next 8 bits hold the index to the length code table
// Remove the apropriate number of bits
// Are there some extra bits for the obtained length code ?
// In order to distinguish uncompressed byte from repetition length,
// we have to add 0x100 to the length.
// Remove one bit from the input data
// If the binary compression type, read 8 bits and return them as one byte.
// When ASCII compression ...
//-----------------------------------------------------------------------------
// Decodes the distance of the repetition, backwards relative to the
// current output buffer position
// Distance position code
// Number of bits of distance position
// Distance position
// Next 2-8 bits in the input buffer is the distance position code
// If the repetition is only 2 bytes length,
// then take 2 bits from the stream in order to get the distance
// If the repetition is more than 2 bytes length,
// then take "dsize_bits" bits in order to get the distance
// Literal decoded from the compressed data
// Value to be returned
// Number of bytes to copy to the output buffer
// Initialize output buffer position
// Decode the next literal from the input data.
// The returned literal can either be an uncompressed byte (next_literal < 0x100)
// or an encoded length of the repeating byte sequence that
// is to be copied to the current buffer position
// If the literal is greater than 0x100, it holds length
// of repeating byte sequence
// literal of 0x100 means repeating sequence of 0x2 bytes
// literal of 0x101 means repeating sequence of 0x3 bytes
// ...
// literal of 0x305 means repeating sequence of 0x207 bytes
// Length of the repetition, in bytes
// Backward distance to the repetition, relative to the current buffer position
// Get the length of the repeating sequence.
// Note that the repeating block may overlap the current output position,
// for example if there was a sequence of equal bytes
// Get backward distance to the repetition
// Target and source pointer
// Update buffer output position
// Copy the repeating sequence
// Flush the output buffer, if number of extracted bytes has reached the end
// Copy decompressed data into user buffer
// Now copy the decompressed data to the first half of the buffer.
// This is needed because the decompression might reuse them as repetitions.
// Note that if the output buffer overflowed previously, the extra decompressed bytes
// are stored in "out_buff_overflow", and they will now be
// within decompressed part of the output buffer.
// Flush any remaining decompressed bytes
//-----------------------------------------------------------------------------
// Main exploding function.
// Initialize work struct and load compressed data
// Note: The caller must zero the "work_buff" before passing it to explode
// Get the compression type (CMP_BINARY or CMP_ASCII)
// Get the dictionary size
// Initialize 16-bit bit buffer
// Extra (over 8) bits
// Position in input buffer
// Test for the valid dictionary size
// Shifted by 'sar' instruction
/*****************************************************************************/
/* implode.c                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Implode function of PKWARE Data Compression library                       */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.04.03  1.00  Lad  First version of implode.c                           */
/* 02.05.03  1.00  Lad  Stress test done                                     */
/* 22.04.10  1.01  Lad  Documented                                           */
/*****************************************************************************/
// Fucking Microsoft VS.NET 2003 compiler !!! (_MSC_VER=1310)
//-----------------------------------------------------------------------------
// Defines
// The longest allowed repetition
//-----------------------------------------------------------------------------
// Tables
//-----------------------------------------------------------------------------
// Macros
// Macro for calculating hash of the current byte pair.
// Note that most exact byte pair hash would be buffer[0] + buffer[1] << 0x08,
// but even this way gives nice indication of equal byte pairs, with significantly
// smaller size of the array that holds numbers of those hashes
//-----------------------------------------------------------------------------
// Local functions
// Builds the "hash_to_index" table and "pair_hash_offsets" table.
// Every element of "hash_to_index" will contain lowest index to the
// "pair_hash_offsets" table, effectively giving offset of the first
// occurence of the given PAIR_HASH in the input data.
// Hash value of the byte pair
// Offset of the byte pair, relative to "work_buff"
// Zero the entire "phash_to_index" table
// Step 1: Count amount of each PAIR_HASH in the input buffer
// The table will look like this:
//  offs 0x000: Number of occurences of PAIR_HASH 0
//  offs 0x001: Number of occurences of PAIR_HASH 1
//  ...
//  offs 0x8F7: Number of occurences of PAIR_HASH 0x8F7 (the highest hash value)
// Step 2: Convert the table to the array of PAIR_HASH amounts. 
// Each element contains count of PAIR_HASHes that is less or equal
// to element index
// The table will look like this:
//  offs 0x000: Number of occurences of PAIR_HASH 0 or lower
//  offs 0x001: Number of occurences of PAIR_HASH 1 or lower
//  ...
//  offs 0x8F7: Number of occurences of PAIR_HASH 0x8F7 or lower
// Step 3: Convert the table to the array of indexes.
// Now, each element contains index to the first occurence of given PAIR_HASH
// If more than 8 bits to output, do recursion
// Add bits to the last out byte in out_buff;
// If 8 or more bits, increment number of bytes
// If there is enough compressed bytes, flush them
// This function searches for a repetition
// (a previous occurence of the current byte sequence)
// Returns length of the repetition, and stores the backward distance 
// to pWork structure.
// Pointer into pWork->phash_to_index table
// Pointer to the table containing offsets of each PAIR_HASH
// An eventual repetition must be at position below this pointer
// Pointer to the previous occurence of the current PAIR_HASH
// End of the previous repetition
// Index to the table with PAIR_HASH positions
// The lowest allowed hash offset
// Offset within found repetition
// Number of bytes that are equal to the previous occurence
// Length of the found repetition
// Secondary repetition
// Last but one byte from a repetion
// Calculate the previous position of the PAIR_HASH
// If the PAIR_HASH offset is below the limit, find a next one
// Get the first location of the PAIR_HASH,
// and thus the first eventual location of byte repetition
// If the current PAIR_HASH was not encountered before,
// we haven't found a repetition.
// We have found a match of a PAIR_HASH. Now we have to make sure
// that it is also a byte match, because PAIR_HASH is not unique.
// We compare the bytes and count the length of the repetition
// If the first byte of the repetition and the so-far-last byte
// of the repetition are equal, we will compare the blocks.
// Skip the current byte
// Now count how many more bytes are equal
// Are the bytes different ?
// If we found a repetition of at least the same length, take it.
// If there are multiple repetitions in the input buffer, this will
// make sure that we find the most recent one, which in turn allows
// us to store backward length in less amount of bits
// Calculate the backward distance of the repetition.
// Note that the distance is stored as decremented by 1
// Repetitions longer than 10 bytes will be stored in more bits,
// so they need a bit different handling
// Move forward in the table of PAIR_HASH repetitions.
// There might be a more recent occurence of the same repetition.
// If the next repetition is beyond the minimum allowed repetition, we are done.
// A repetition must have at least 2 bytes, otherwise it's not worth it
// If the repetition has max length of 0x204 bytes, we can't go any fuhrter
// Check for possibility of a repetition that occurs at more recent position
//
// The following part checks if there isn't a longer repetition at
// a latter offset, that would lead to better compression.
//
// Example of data that can trigger this optimization:
//
//   "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEQQQQQQQQQQQQ"
//   "XYZ"
//   "EEEEEEEEEEEEEEEEQQQQQQQQQQQQ";
//
// Description of data in this buffer
//   [0x00] Single byte "E"
//   [0x01] Single byte "E"
//   [0x02] Repeat 0x1E bytes from [0x00]
//   [0x20] Single byte "X"
//   [0x21] Single byte "Y"
//   [0x22] Single byte "Z"
//   [0x23] 17 possible previous repetitions of length at least 0x10 bytes:
//          - Repetition of 0x10 bytes from [0x00] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x10 bytes from [0x01] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x10 bytes from [0x02] "EEEEEEEEEEEEEEEE"
//          ...
//          - Repetition of 0x10 bytes from [0x0F] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x1C bytes from [0x10] "EEEEEEEEEEEEEEEEQQQQQQQQQQQQ"
//          The last repetition is the best one.
//
// Note: I failed to figure out what does the table "offs09BC" mean.
// If anyone has an idea, let me know to zezula_at_volny_dot_cz
// 
// Now go through all the repetitions from the first found one
// to the current input data, and check if any of them migh be
// a start of a greater sequence match.
//
// Get the pointer to the previous repetition
// Skip those repetitions that don't reach the end
// of the first found repetition
// Verify if the last but one byte from the repetition matches
// the last but one byte from the input data.
// If not, find a next repetition
// If the new repetition reaches beyond the end
// of previously found repetition, reset the repetition length to zero.
// Reset the length of the repetition to 2 bytes only
// Find out how many more characters are equal to the first repetition.
// Is the newly found repetion at least as long as the previous one ?
// Calculate the distance of the new repetition
// Update the additional elements in the "offs09BC" table
// to reflect new rep length
// Pointer to the end of the input data
// If 1, then all data from the input stream have been already loaded
// Saved length of current repetition
// Saved distance of current repetition
// Length of the found repetition
// 
// Store the compression type and dictionary size
// Reset output buffer to zero
// Load the bytes from the input stream, up to 0x1000 bytes
//
// Warning: The end of the buffer passed to "SortBuffer" is actually 2 bytes beyond
// valid data. It is questionable if this is actually a bug or not,
// but it might cause the compressed data output to be dependent on random bytes
// that are in the buffer. 
// To prevent that, the calling application must always zero the compression
// buffer before passing it to "implode"
//
// Search the PAIR_HASHes of the loaded blocks. Also, include
// previously compressed data, if any.
// Perform the compression of the current block
// Find if the current byte sequence wasn't there before.
// If we found repetition of 2 bytes, that is 0x100 or fuhrter back,
// don't bother. Storing the distance of 0x100 bytes would actually
// take more space than storing the 2 bytes as-is.
// When we are at the end of the input data, we cannot allow
// the repetition to go past the end of the input data.
// Shorten the repetition length so that it only covers valid data
// If we got repetition of 2 bytes, that is 0x100 or more backward, don't bother
// Try to find better repetition 1 byte later.
// Example: "ARROCKFORT" "AROCKFORT"
// When "input_data" points to the second string, FindRep
// returns the occurence of "AR". But there is longer repetition "ROCKFORT",
// beginning 1 byte after.
// Only use the new repetition if it's length is greater than the previous one
// If the new repetition if only 1 byte better
// and the previous distance is less than 0x80 bytes, use the previous repetition
// Flush one byte, so that input_data will point to the secondary repetition
// Revert to the previous repetition
// Move the begin of the input data by the length of the repetition
// If there was no previous repetition for the current position in the input data,
// just output the 9-bit literal for the one character
// Write the termination literal
//-----------------------------------------------------------------------------
// Main imploding function
// Fill the work buffer information
// Note: The caller must zero the "work_buff" before passing it to implode
// Test dictionary size
// 0x1000 bytes
// No break here !!!
// 0x800 bytes
// No break here !!!
// 0x400
// Test the compression type
// We will compress data with binary compression type
// We will compress data with ASCII compression type
// Copy the distance codes and distance bits and perform the compression
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* use NO_DIVIDE if your processor does not do division in hardware */
/* ========================================================================= */
/* split Adler-32 into component sums */
/* in case user likes doing a byte at a time, keep it fast */
/* initial Adler-32 value (deferred check for len == 1 speed) */
/* in case short lengths are provided, keep it somewhat fast */
/* only added so many BASE's */
/* do length NMAX blocks -- requires just one modulo operation */
/* NMAX is divisible by 16 */
/* 16 sums unrolled */
/* do remaining bytes (less than NMAX, still just one modulo) */
/* avoid modulos if none remaining */
/* return recombined sums */
/* ========================================================================= */
/* the derivation of this formula is left as an exercise for the reader */
/* compress.c -- compress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* ===========================================================================
/* ===========================================================================
/* crc32.c -- compute the CRC-32 of a data stream
/* @(#) $Id$ */
/*
/* !DYNAMIC_CRC_TABLE */
/* MAKECRCH */
/* for STDC and FAR definitions */
/* Find a four-byte integer type for crc32_little() and crc32_big(). */
/* need ANSI C limits.h to determine sizes */
/* can't find a four-byte integer type! */
/* STDC */
/* !NOBYFOUR */
/* Definitions for doing the crc four data bytes at a time. */
/* BYFOUR */
/* Local functions for crc concatenation */
/* MAKECRCH */
/*
/* polynomial exclusive-or pattern */
/* terms of polynomial defining this crc (except x^32): */
/* flag to limit concurrent making */
/* See if another task is already doing this (not thread-safe, but better
/* make exclusive-or pattern from polynomial (0xedb88320UL) */
/* generate a crc for every 8-bit value */
/* generate crc for each value followed by one, two, and three zeros,
/* BYFOUR */
/* not first */
/* wait for the other guy to finish (not efficient, but rare) */
/* write out CRC tables to crc32.h */
/* crc32.h -- tables for rapid CRC calculation\n");
/* BYFOUR */
/* MAKECRCH */
/* MAKECRCH */
/* !DYNAMIC_CRC_TABLE */
/* ========================================================================
/* DYNAMIC_CRC_TABLE */
/* =========================================================================
/* DYNAMIC_CRC_TABLE */
/* ========================================================================= */
/* ========================================================================= */
/* DYNAMIC_CRC_TABLE */
/* BYFOUR */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* BYFOUR */
/* dimension of GF(2) vectors (length of CRC) */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* even-power-of-two zeros operator */
/* odd-power-of-two zeros operator */
/* degenerate case */
/* put operator for one zero bit in odd */
/* CRC-32 polynomial */
/* put operator for two zero bits in even */
/* put operator for four zero bits in odd */
/* apply len2 zeros to crc1 (first square will put the operator for one
/* apply zeros operator for this bit of len2 */
/* if no more bits set, then done */
/* another iteration of the loop with odd and even swapped */
/* if no more bits set, then done */
/* return combined crc */
/* deflate.c -- compress data using the deflation algorithm
/*
//www.ietf.org/rfc/rfc1951.txt
/* @(#) $Id$ */
/*
/* ===========================================================================
/* block not completed, need more input or more output */
/* block flush performed */
/* finish started, need only more output at next deflate */
/* finish done, accept no more input or output */
/* Compression function. Returns the block state after the call. */
/* asm code initialization */
/* ===========================================================================
/* Tail of hash chains */
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
/* Minimum amount of lookahead, except at the end of the input file.
/* Values for max_lazy_match, good_match and max_chain_length, depending on
/* reduce lazy search above this match length */
/* do not perform lazy search above this match length */
/* quit search above this match length */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},
/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
/* result of memcmp for equal strings */
/* for buggy compilers */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* ========================================================================= */
/* To do: ignore strm->next_in if we use it as window */
/* ========================================================================= */
/* We overlay pending_buf and d_buf+l_buf. This works since the average
/* suppress zlib wrapper */
/* write gzip wrapper instead */
/* until 256-byte window bug fixed */
/* 16K elements by default */
/* ========================================================================= */
/* use the tail of the dictionary */
/* Insert all strings in the hash table (except for the last two bytes).
/* to make compiler happy */
/* ========================================================================= */
/* use zfree if we ever allocate msg dynamically */
/* was made negative by deflate(..., Z_FINISH); */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* Flush the last buffer: */
/* ========================================================================= */
/* =========================================================================
/* conservative upper bound */
/* if can't get parameters, return conservative bound */
/* if not default parameters, return conservative bound */
/* default settings: return tight bound for that case */
/* =========================================================================
/* =========================================================================
/* ========================================================================= */
/* value of flush param for previous deflate call */
/* just in case */
/* Write the header */
/* Save the adler32 of the preset dictionary: */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* Flush as much pending output as possible */
/* Since avail_out is 0, deflate will be called again with
/* Make sure there is something to do and avoid duplicate consecutive
/* User must not provide more input after the first FINISH: */
/* Start a new block or continue the current one.
/* avoid BUF_ERROR next call, see above */
/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
/* FULL_FLUSH or SYNC_FLUSH */
/* For a full flush, this empty block will be recognized
/* forget history */
/* avoid BUF_ERROR at next call, see above */
/* Write the trailer */
/* If avail_out is zero, the application will call deflate again
/* write the trailer only once! */
/* ========================================================================= */
/* Deallocate in reverse order of allocations: */
/* =========================================================================
/* following zmemcpy do not work for 16-bit MSDOS */
/* MAXSEG_64K */
/* ===========================================================================
/* ===========================================================================
/* Set the default configuration parameters:
/* initialize the asm code */
/* ===========================================================================
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
/* current match */
/* max hash chain length */
/* current string */
/* matched string */
/* length of current match */
/* best match length so far */
/* stop if match long enough */
/* Stop when cur_match becomes <= limit. To simplify the code,
/* Compare two bytes at a time. Note: this is not always beneficial.
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Do not waste too much time if we already have a good match: */
/* Do not look for matches beyond the end of the input. This is necessary
/* Skip to next match if the match length cannot increase
/* This code assumes sizeof(unsigned short) == 2. Do not use
/* It is not necessary to compare scan[2] and match[2] since they are
/* The funny "do {}" generates better code on most compilers */
/* Here, scan <= window+strstart+257 */
/* UNALIGNED_OK */
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* UNALIGNED_OK */
/* ASMV */
/* FASTEST */
/* ---------------------------------------------------------------------------
/* current match */
/* current string */
/* matched string */
/* length of current match */
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Return failure if the match length is less than 2:
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* ===========================================================================
/* check that the match is indeed a match */
/* DEBUG */
/* ===========================================================================
/* Amount of free space at the end of the window. */
/* Deal with !@#$% 64K limit: */
/* Very unlikely, but possible on 16 bit machine if
/* If the window is almost full and there is insufficient lookahead,
/* we now have strstart >= MAX_DIST */
/* Slide the hash table (could be avoided with 32 bit values
/* %%% avoid this when Z_RLE */
/* If n is not on any hash chain, prev[n] is garbage but
/* If there was no sliding:
/* Initialize the hash value now that we have some input: */
/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
/* ===========================================================================
/* Same but force premature exit if necessary. */
/* ===========================================================================
/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
/* Copy as much as possible from input to output: */
/* Fill the window as much as possible: */
/* flush the current block */
/* Emit a stored block if pending_buf will be full: */
/* strstart == 0 is possible when wraparound on 16-bit machine */
/* Flush if we may have to slide, otherwise block_start may become
/* ===========================================================================
/* head of the hash chain */
/* set if current block must be flushed */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() or longest_match_fast() sets match_start */
/* Insert new strings in the hash table only if the match length
/* string at strstart already in table */
/* strstart never exceeds WSIZE-MAX_MATCH, so there are
/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
/* No match, output a literal byte */
/* ===========================================================================
/* head of hash chain */
/* set if current block must be flushed */
/* Process the input block. */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() or longest_match_fast() sets match_start */
/* If prev_match is also MIN_MATCH, match_start is garbage
/* If there was a match at the previous step and the current
/* Do not insert strings in hash table beyond this. */
/* Insert in hash table all strings up to the end of the match.
/* If there was no match at the previous position, output a
/* There is no previous match to compare with, wait for
/* FASTEST */
/* ===========================================================================
/* set if current block must be flushed */
/* length of run */
/* maximum length of run */
/* byte at distance one to match */
/* scan for end of run */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* See how many times the previous byte repeats */
/* if there is a previous byte, that is */
/* Emit match if have run of MIN_MATCH or longer, else emit literal */
/* No match, output a literal byte */
/* inffast.c -- fast decoding
/* Allow machine dependent optimization for post-increment or pre-increment.
/*
/* inflate()'s starting value for strm->avail_out */
/* local strm->next_in */
/* while in < last, enough input available */
/* local strm->next_out */
/* inflate()'s initial strm->next_out */
/* while out < end, enough space available */
/* maximum distance from zlib header */
/* window size or zero if not using window */
/* valid bytes in the window */
/* window write index */
/* allocated sliding window, if wsize != 0 */
/* local strm->hold */
/* local strm->bits */
/* local strm->lencode */
/* local strm->distcode */
/* mask for first level of length codes */
/* mask for first level of distance codes */
/* retrieved table entry */
/* code bits, operation, extra bits, or */
/*  window position, window bytes to copy */
/* match length, unused bytes */
/* match distance */
/* where to copy match from */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* literal */
/* length base */
/* number of extra bits */
/* distance base */
/* number of extra bits */
/* max distance in output */
/* see if copy from window */
/* distance back in window */
/* very common case */
/* some from window */
/* rest from output */
/* wrap around window */
/* some from end of window */
/* some from start of window */
/* rest from output */
/* contiguous in window */
/* some from window */
/* rest from output */
/* copy direct from output */
/* minimum length is three */
/* 2nd level distance code */
/* 2nd level length code */
/* end-of-block */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
/*
/* !ASMINF */
/* inflate.c -- zlib decompression
/*
/* function prototypes */
/* to support ill-conceived Java test suite */
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/*
/* inffixed.h -- table for decoding fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/*
/* if it hasn't been done already, allocate space for the window */
/* if window not in use yet, initialize */
/* copy state->wsize or less output bytes into the circular window */
/* Macros for inflate(): */
/* check function to use adler32() for zlib or crc32() for gzip */
/* check macros for header crc */
/* Load registers with state in inflate() for speed */
/* Restore state from registers in inflate() */
/* Clear the input bit accumulator */
/* Get a byte of input into the bit accumulator, or return from inflate()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Reverse the bytes in a 32-bit value */
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* save starting available input and output */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* buffer for gzip header crc calculation */
/* permutation of code lengths */
/* skip check */
/* gzip header */
/* expect zlib header */
/* check if zlib header allowed */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* go to byte boundary */
/* handle error breaks in while */
/* build code tables */
/* copy from window */
/* copy from output */
/*
/* check state */
/* check for correct dictionary id */
/* copy dictionary to window */
/* check state */
/* save header structure */
/*
/* number of bytes to look at or looked at */
/* temporary to save total_in and total_out */
/* to restore bit buffer to byte string */
/* check parameters */
/* if first time, start search in bit buffer */
/* search available input */
/* return no joy or set up to restart inflate() on a new block */
/*
/* check input */
/* allocate space */
/* copy state */
/* inftrees.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..29 base */
/* Distance codes 0..29 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no symbols to code at all */
/* invalid code marker */
/* make a table to force an error */
/* no symbols, but wait for decoding to report error */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* save offset to next table */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* here min is 1 << curr */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/*
/* invalid code marker */
/* when done with sub-table, drop back to root table */
/* put invalid code marker in table */
/* backwards increment the len-bit code huff */
/* set return parameters */
/* trees.c -- output deflated data using Huffman coding
/*
/* @(#) $Id$ */
/* #define GEN_TREES_H */
/* ===========================================================================
/* Bit length codes must not exceed MAX_BL_BITS bits */
/* end of block literal code */
/* repeat previous bit length 3-6 times (2 bits of repeat count) */
/* repeat a zero length 3-10 times  (3 bits of repeat count) */
/* repeat a zero length 11-138 times  (7 bits of repeat count) */
/* extra bits for each length code */
/* extra bits for each distance code */
/* extra bits for each bit length code */
/* The lengths of the bit length codes are sent in order of decreasing
/* Number of bits used within bi_buf. (bi_buf might be implemented on
/* ===========================================================================
/* see definition of array dist_code below */
/* non ANSI compilers may not accept trees.h */
/* The static literal tree. Since the bit lengths are imposed, there is no
/* The static distance tree. (Actually a trivial tree since all codes use
/* Distance codes. The first 256 values correspond to the distances
/* length code for each normalized match length (0 == MIN_MATCH) */
/* First normalized length for each code (0 = MIN_MATCH) */
/* First normalized distance for each code (0 = distance of 1) */
/* GEN_TREES_H */
/* static tree or NULL */
/* extra bits for each code or NULL */
/* base index for extra_bits */
/* max number of elements in the tree */
/* max bit length for the codes */
/* ===========================================================================
/* Send a code of the given tree. c and tree must not have side effects */
/* DEBUG */
/* ===========================================================================
/* ===========================================================================
/* value to send */
/* number of bits */
/* If not enough room in bi_buf, use (valid) bits from bi_buf and
/* !DEBUG */
/* DEBUG */
/* the arguments must not have side effects */
/* ===========================================================================
/* iterates over tree elements */
/* bit counter */
/* length value */
/* code value */
/* distance index */
/* number of codes at each bit length for an optimal tree */
/* For some embedded targets, global variables are not initialized: */
/* Initialize the mapping length (0..255) -> length code (0..28) */
/* Note that the length 255 (match length 258) can be represented
/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
/* from now on, all distances are divided by 128 */
/* Construct the codes of the static literal tree */
/* Codes 286 and 287 do not exist, but we must include them in the
/* The static distance tree is trivial: */
/* defined(GEN_TREES_H) || !defined(STDC) */
/* ===========================================================================
/* header created automatically with -DGEN_TREES_H */\n\n");
/* GEN_TREES_H */
/* ===========================================================================
/* enough lookahead for inflate */
/* Initialize the first block of the first file: */
/* ===========================================================================
/* iterates over tree elements */
/* Initialize the trees. */
/* Index within the heap array of least frequent node in the Huffman tree */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the tree to restore */
/* node to move down */
/* left son of k */
/* Set j to the smallest of the two sons: */
/* Exit if v is smaller than both sons */
/* Exchange v with the smallest son */
/* And continue down the tree, setting j to the left son of k */
/* ===========================================================================
/* the tree descriptor */
/* heap index */
/* iterate over the tree elements */
/* bit length */
/* extra bits */
/* frequency */
/* number of elements with bit length too large */
/* In a first pass, compute the optimal bit lengths (which may
/* root of the heap */
/* We overwrite tree[n].Dad which is no longer needed */
/* not a leaf node */
/* This happens for example on obj2 and pic of the Calgary corpus */
/* Find the first bit length which could increase: */
/* move one leaf down the tree */
/* move one overflow item as its brother */
/* The brother of the overflow item also moves one step up,
/* Now recompute all bit lengths, scanning in increasing frequency.
/* ===========================================================================
/* the tree to decorate */
/* largest code with non zero frequency */
/* number of codes at each bit length */
/* next code value for each bit length */
/* running code value */
/* bit index */
/* code index */
/* The distribution counts are first used to generate the code values
/* Check that the bit counts in bl_count are consistent. The last code
/* Now reverse the bits */
/* ===========================================================================
/* the tree descriptor */
/* iterate over heap elements */
/* largest code with non zero frequency */
/* new node being created */
/* Construct the initial heap, with least frequent element in
/* The pkzip format requires that at least one distance code exists,
/* node is 0 or 1 so it does not have extra bits */
/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
/* Construct the Huffman tree by repeatedly combining the least two
/* next internal node of the tree */
/* n = node of least frequency */
/* m = node of next least frequency */
/* keep the nodes sorted by frequency */
/* Create a new node father of n and m */
/* and insert the new node in the heap */
/* At this point, the fields freq and dad are set. We can now
/* The field len is now set, we can generate the bit codes */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* guard */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* tree[max_code+1].Len = -1; */  /* guard already set */
/* ===========================================================================
/* index of last bit length code of non zero freq */
/* Determine the bit length frequencies for literal and distance trees */
/* Build the bit length tree: */
/* opt_len now includes the length of the tree representations, except
/* Determine the number of bit length codes to send. The pkzip format
/* Update opt_len to include the bit length tree and counts */
/* ===========================================================================
/* number of codes for each tree */
/* index in bl_order */
/* not +255 as stated in appnote.txt */
/* not -3 as stated in appnote.txt */
/* literal tree */
/* distance tree */
/* ===========================================================================
/* input block */
/* length of input block */
/* true if this is the last block for a file */
/* send block type */
/* with header */
/* ===========================================================================
/* 3 for block type, 7 for EOB */
/* Of the 10 bits for the empty block, we have already sent
/* ===========================================================================
/* input block, or NULL if too old */
/* length of input block */
/* true if this is the last block for a file */
/* opt_len and static_len in bytes */
/* index of last bit length code of non zero freq */
/* Build the Huffman trees unless a stored block is forced */
/* Check if the file is binary or text */
/* Construct the literal and distance trees */
/* At this point, opt_len and static_len are the total bit lengths of
/* Build the bit length tree for the above two trees, and get the index
/* Determine the best encoding. Compute the block lengths in bytes. */
/* force a stored block */
/* force stored block */
/* 4: two words for the lengths */
/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
/* force static trees */
/* The above check is made mod 2^32, for files larger than 512 MB
/* align on byte boundary */
/* ===========================================================================
/* distance of matched string */
/* match length-MIN_MATCH or unmatched char (if dist==0) */
/* lc is the unmatched char */
/* Here, lc is the match length - MIN_MATCH */
/* dist = match distance - 1 */
/* Try to guess if it is profitable to stop the current block here */
/* Compute an upper bound for the compressed length */
/* We avoid equality with lit_bufsize because of wraparound at 64K
/* ===========================================================================
/* literal tree */
/* distance tree */
/* distance of matched string */
/* match length or unmatched char (if dist == 0) */
/* running index in l_buf */
/* the code to send */
/* number of extra bits to send */
/* send a literal byte */
/* Here, lc is the match length - MIN_MATCH */
/* send the length code */
/* send the extra length bits */
/* dist is now the match distance - 1 */
/* send the distance code */
/* send the extra distance bits */
/* literal or match pair ? */
/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
/* ===========================================================================
/* ===========================================================================
/* the value to invert */
/* its bit length */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the input data */
/* its length */
/* true if block header must be written */
/* align on byte boundary */
/* enough lookahead for inflate */
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* for buggy compilers */
/* Z_NEED_DICT       2  */
/* Z_STREAM_END      1  */
/* Z_OK              0  */
/* Z_ERRNO         (-1) */
/* Z_STREAM_ERROR  (-2) */
/* Z_DATA_ERROR    (-3) */
/* Z_MEM_ERROR     (-4) */
/* Z_BUF_ERROR     (-5) */
/* Z_VERSION_ERROR (-6) */
/* exported to allow conversion of error code to string for compress() and
/* The Microsoft C Run-Time Library for Windows CE doesn't have
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Turbo C in 16-bit mode */
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* M_I86 */
/* SYS16BIT */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
/*****************************************************************************/
/* DllMain.c                              Copyright (c) Ladislav Zezula 2006 */
/*---------------------------------------------------------------------------*/
/* Description: DllMain for the StormLib.dll library                         */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 23.11.06  1.00  Lad  The first version of DllMain.c                       */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// DllMain
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* use NO_DIVIDE if your processor does not do division in hardware --
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
/* this assumes a is not negative */ \
/* ========================================================================= */
/* split Adler-32 into component sums */
/* in case user likes doing a byte at a time, keep it fast */
/* initial Adler-32 value (deferred check for len == 1 speed) */
/* in case short lengths are provided, keep it somewhat fast */
/* only added so many BASE's */
/* do length NMAX blocks -- requires just one modulo operation */
/* NMAX is divisible by 16 */
/* 16 sums unrolled */
/* do remaining bytes (less than NMAX, still just one modulo) */
/* avoid modulos if none remaining */
/* return recombined sums */
/* ========================================================================= */
/* for negative len, return invalid adler32 as a clue for debugging */
/* the derivation of this formula is left as an exercise for the reader */
/* assumes len2 >= 0 */
/* ========================================================================= */
/* compress.c -- compress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* ===========================================================================
/* ===========================================================================
/* crc32.c -- compute the CRC-32 of a data stream
/* @(#) $Id$ */
/*
/* !DYNAMIC_CRC_TABLE */
/* MAKECRCH */
/* for STDC and FAR definitions */
/* Definitions for doing the crc four data bytes at a time. */
/* BYFOUR */
/* Local functions for crc concatenation */
/* MAKECRCH */
/*
/* polynomial exclusive-or pattern */
/* terms of polynomial defining this crc (except x^32): */
/* flag to limit concurrent making */
/* See if another task is already doing this (not thread-safe, but better
/* make exclusive-or pattern from polynomial (0xedb88320UL) */
/* generate a crc for every 8-bit value */
/* generate crc for each value followed by one, two, and three zeros,
/* BYFOUR */
/* not first */
/* wait for the other guy to finish (not efficient, but rare) */
/* write out CRC tables to crc32.h */
/* crc32.h -- tables for rapid CRC calculation\n");
/* BYFOUR */
/* MAKECRCH */
/* MAKECRCH */
/* !DYNAMIC_CRC_TABLE */
/* ========================================================================
/* DYNAMIC_CRC_TABLE */
/* =========================================================================
/* DYNAMIC_CRC_TABLE */
/* ========================================================================= */
/* ========================================================================= */
/* DYNAMIC_CRC_TABLE */
/* BYFOUR */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* BYFOUR */
/* dimension of GF(2) vectors (length of CRC) */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* even-power-of-two zeros operator */
/* odd-power-of-two zeros operator */
/* degenerate case (also disallow negative lengths) */
/* put operator for one zero bit in odd */
/* CRC-32 polynomial */
/* put operator for two zero bits in even */
/* put operator for four zero bits in odd */
/* apply len2 zeros to crc1 (first square will put the operator for one
/* apply zeros operator for this bit of len2 */
/* if no more bits set, then done */
/* another iteration of the loop with odd and even swapped */
/* if no more bits set, then done */
/* return combined crc */
/* ========================================================================= */
/* deflate.c -- compress data using the deflation algorithm
/*
//tools.ietf.org/html/rfc1951
/* @(#) $Id$ */
/*
/* ===========================================================================
/* block not completed, need more input or more output */
/* block flush performed */
/* finish started, need only more output at next deflate */
/* finish done, accept no more input or output */
/* Compression function. Returns the block state after the call. */
/* asm code initialization */
/* ===========================================================================
/* Tail of hash chains */
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
/* Values for max_lazy_match, good_match and max_chain_length, depending on
/* reduce lazy search above this match length */
/* do not perform lazy search above this match length */
/* quit search above this match length */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},
/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
/* result of memcmp for equal strings */
/* for buggy compilers */
/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* ========================================================================= */
/* To do: ignore strm->next_in if we use it as window */
/* ========================================================================= */
/* We overlay pending_buf and d_buf+l_buf. This works since the average
/* suppress zlib wrapper */
/* write gzip wrapper instead */
/* until 256-byte window bug fixed */
/* nothing written to s->window yet */
/* 16K elements by default */
/* ========================================================================= */
/* when using zlib wrappers, compute Adler-32 for provided dictionary */
/* avoid computing Adler-32 in read_buf */
/* if dictionary would fill window, just replace the history */
/* already empty otherwise */
/* use the tail */
/* insert dictionary into window and hash */
/* ========================================================================= */
/* use zfree if we ever allocate msg dynamically */
/* was made negative by deflate(..., Z_FINISH); */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* Flush the last buffer: */
/* ========================================================================= */
/* =========================================================================
/* conservative upper bound for compressed data */
/* if can't get parameters, return conservative bound plus zlib wrapper */
/* compute wrapper length */
/* raw deflate */
/* zlib wrapper */
/* gzip wrapper */
/* user-supplied gzip header */
/* for compiler happiness */
/* if not default parameters, return conservative bound */
/* default settings: return tight bound for that case */
/* =========================================================================
/* =========================================================================
/* ========================================================================= */
/* value of flush param for previous deflate call */
/* just in case */
/* Write the header */
/* Save the adler32 of the preset dictionary: */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* Flush as much pending output as possible */
/* Since avail_out is 0, deflate will be called again with
/* Make sure there is something to do and avoid duplicate consecutive
/* User must not provide more input after the first FINISH: */
/* Start a new block or continue the current one.
/* avoid BUF_ERROR next call, see above */
/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
/* FULL_FLUSH or SYNC_FLUSH */
/* For a full flush, this empty block will be recognized
/* forget history */
/* avoid BUF_ERROR at next call, see above */
/* Write the trailer */
/* If avail_out is zero, the application will call deflate again
/* write the trailer only once! */
/* ========================================================================= */
/* Deallocate in reverse order of allocations: */
/* =========================================================================
/* following zmemcpy do not work for 16-bit MSDOS */
/* MAXSEG_64K */
/* ===========================================================================
/* ===========================================================================
/* Set the default configuration parameters:
/* initialize the asm code */
/* ===========================================================================
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
/* current match */
/* max hash chain length */
/* current string */
/* matched string */
/* length of current match */
/* best match length so far */
/* stop if match long enough */
/* Stop when cur_match becomes <= limit. To simplify the code,
/* Compare two bytes at a time. Note: this is not always beneficial.
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Do not waste too much time if we already have a good match: */
/* Do not look for matches beyond the end of the input. This is necessary
/* Skip to next match if the match length cannot increase
/* This code assumes sizeof(unsigned short) == 2. Do not use
/* It is not necessary to compare scan[2] and match[2] since they are
/* The funny "do {}" generates better code on most compilers */
/* Here, scan <= window+strstart+257 */
/* UNALIGNED_OK */
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* UNALIGNED_OK */
/* ASMV */
/* FASTEST */
/* ---------------------------------------------------------------------------
/* current match */
/* current string */
/* matched string */
/* length of current match */
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Return failure if the match length is less than 2:
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* FASTEST */
/* ===========================================================================
/* check that the match is indeed a match */
/* DEBUG */
/* ===========================================================================
/* Amount of free space at the end of the window. */
/* Deal with !@#$% 64K limit: */
/* Very unlikely, but possible on 16 bit machine if
/* If the window is almost full and there is insufficient lookahead,
/* we now have strstart >= MAX_DIST */
/* Slide the hash table (could be avoided with 32 bit values
/* If n is not on any hash chain, prev[n] is garbage but
/* If there was no sliding:
/* Initialize the hash value now that we have some input: */
/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
/* If the WIN_INIT bytes after the end of the current data have never been
/* Previous high water mark below current data -- zero WIN_INIT
/* High water mark at or above current data, but below current data
/* ===========================================================================
/* Same but force premature exit if necessary. */
/* ===========================================================================
/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
/* Copy as much as possible from input to output: */
/* Fill the window as much as possible: */
/* flush the current block */
/* Emit a stored block if pending_buf will be full: */
/* strstart == 0 is possible when wraparound on 16-bit machine */
/* Flush if we may have to slide, otherwise block_start may become
/* ===========================================================================
/* head of the hash chain */
/* set if current block must be flushed */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* Insert new strings in the hash table only if the match length
/* string at strstart already in table */
/* strstart never exceeds WSIZE-MAX_MATCH, so there are
/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
/* No match, output a literal byte */
/* ===========================================================================
/* head of hash chain */
/* set if current block must be flushed */
/* Process the input block. */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* If prev_match is also MIN_MATCH, match_start is garbage
/* If there was a match at the previous step and the current
/* Do not insert strings in hash table beyond this. */
/* Insert in hash table all strings up to the end of the match.
/* If there was no match at the previous position, output a
/* There is no previous match to compare with, wait for
/* FASTEST */
/* ===========================================================================
/* set if current block must be flushed */
/* byte at distance one to match */
/* scan goes up to strend for length of run */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* See how many times the previous byte repeats */
/* Emit match if have run of MIN_MATCH or longer, else emit literal */
/* No match, output a literal byte */
/* ===========================================================================
/* set if current block must be flushed */
/* Make sure that we have a literal to write. */
/* flush the current block */
/* Output a literal byte */
/* gzclose.c -- zlib gzclose() function
/* gzclose() is in a separate file so that it is linked in only if it is used.
/* gzlib.c -- zlib functions common to reading and writing gzip files
/* Local functions */
/* Map the Windows error number in ERROR to a locale-dependent error message
/* Default language */
/* If there is an \r\n appended, zap it.  */
/* UNDER_CE */
/* Reset gzip file state */
/* no output data available */
/* for reading ... */
/* not at end of file */
/* have not read past end yet */
/* look for gzip header */
/* no seek request pending */
/* clear error */
/* no uncompressed data yet */
/* no input data yet */
/* Open a gzip file either by name or file descriptor. */
/* check input */
/* allocate gzFile structure to return */
/* no buffers allocated yet */
/* requested buffer size */
/* no error message yet */
/* interpret mode */
/* can't read and write at the same time */
/* ignore -- will request binary anyway */
/* could consider as an error, but just ignore */
/* must provide an "r", "w", or "a" */
/* can't force transparent read */
/* for empty file */
/* save the path name for error messages */
/* compute the flags for open() */
/* open the file with the appropriate flags (or just use fd) */
/* simplify later checks */
/* save the current position for rewinding (only if reading) */
/* initialize stream */
/* return stream */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* identifier for error messages */
/* for debugging */
/* for debugging */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* make sure we haven't already allocated memory */
/* check and set requested size */
/* need two bytes to check magic header */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no error */
/* back up and start over */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* check that there's no error */
/* can only seek from start or relative to current position */
/* normalize offset to a SEEK_CUR specification */
/* if within raw area while reading, just go there */
/* calculate skip amount, rewinding if needed for back seek when reading */
/* writing -- can't go backwards */
/* before start of file! */
/* rewind, then skip to offset */
/* if reading, skip what's in output buffer (one less gzgetc() check) */
/* request skip (if not zero) */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return position */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* compute and return effective offset in file */
/* reading */
/* don't count buffered input */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return end-of-file state */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return error information */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* clear error and end-of-file */
/* Create an error message in allocated memory and set state->err and
/* free previously allocated message and clear */
/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
/* set error code, and if no message, then done */
/* for an out of memory error, return literal string when requested */
/* construct error message with path */
/* portably return maximum value for an int (when limits.h presumed not
/* gzread.c -- zlib functions for reading gzip files
/* Local functions */
/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
/* Load up input buffer and set eof flag if last data loaded -- return -1 on
/* copy what's there to the start */
/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
/* allocate read buffers and inflate memory */
/* allocate buffers */
/* allocate inflate memory */
/* gunzip */
/* get at least the magic bytes in the input buffer */
/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
/* no gzip header -- if we were decoding gzip before, then this is trailing
/* doing raw i/o, copy any leftover input to output -- this assumes that
/* Decompress from input to the provided next_out and avail_out in the state.
/* fill output buffer up to end of deflate stream */
/* get more input for inflate() */
/* decompress and handle errors */
/* deflate stream invalid */
/* update available output */
/* if the gzip stream completed successfully, look for another */
/* good decompression */
/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
/* -> LOOK, COPY (only if never GZIP), or GZIP */
/* -> COPY */
/* -> GZIP or LOOK (if end of gzip stream) */
/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
/* skip over len bytes or reach end-of-file, whichever comes first */
/* skip over whatever is in output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* need more data to skip -- load up output buffer */
/* get more output, looking for header if required */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* process a skip request */
/* get len bytes to buf, or less than len if at the end */
/* first just try copying data from the output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* tried to read past end */
/* need output data -- for small len or new stream load up our output
/* get more output, looking for header if required */
/* no progress yet -- go back to copy above */
/* the copy above assures that we will leave with space in the
/* large len -- read directly into user buffer */
/* read directly */
/* large len -- decompress directly into user buffer */
/* state->how == GZIP */
/* update progress */
/* return number of bytes read into user buffer (will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* try output buffer (no need to check for skip request) */
/* nothing there -- try gzread() */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* can't push EOF */
/* if output buffer empty, put byte at end (allows more pushing) */
/* if no room, give up (must have already done a gzungetc()) */
/* slide output data if needed and insert byte before existing data */
/* -- see zlib.h -- */
/* check parameters and get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* copy output bytes up to new line or len - 1, whichever comes first --
/* assure that something is in the output buffer */
/* error */
/* end of file */
/* read past end */
/* return what we have */
/* look for end-of-line in current output buffer */
/* copy through end-of-line, or remainder if not found */
/* return terminated string, or if nothing, end of file */
/* -- see zlib.h -- */
/* get internal structure */
/* if the state is not known, but we can find out, then do so (this is
/* return 1 if transparent, 0 if processing a gzip stream */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading */
/* free memory and close file */
/* gzwrite.c -- zlib functions for writing gzip files
/* Local functions */
/* Initialize state for writing a gzip file.  Mark initialization by setting
/* allocate input buffer */
/* only need output buffer and deflate state if compressing */
/* allocate output buffer */
/* allocate deflate memory, set up for gzip compression */
/* mark state as initialized */
/* initialize write buffer if compressing */
/* Compress whatever is at avail_in and next_in and write to the output file.
/* allocate memory if this is the first time through */
/* write directly if requested */
/* run deflate() on provided input until it produces no more output */
/* write out current buffer contents if full, or if flushing, but if
/* compress */
/* if that completed a deflate stream, allow another to start */
/* all done, no errors */
/* Compress len zeros to output.  Return -1 on error, 0 on success. */
/* consume whatever's left in the input buffer */
/* compress len zeros (len guaranteed > 0) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* allocate memory if this is the first time through */
/* check for seek request */
/* for small len, copy to input buffer, otherwise compress directly */
/* copy to input buffer, compress when full */
/* consume whatever's left in the input buffer */
/* directly compress user buffer to file */
/* input was all buffered or compressed (put will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check for seek request */
/* try writing to input buffer for speed (state->size == 0 if buffer not
/* no room in buffer or not initialized, use gz_write() */
/* -- see zlib.h -- */
/* write string */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* !STDC && !Z_HAVE_STDARG_H */
/* -- see zlib.h -- */
/* get internal structure */
/* check that can really pass pointer in ints */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check flush parameter */
/* check for seek request */
/* compress remaining data with requested flush */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* if no change is requested, then do nothing */
/* check for seek request */
/* change compression parameters for subsequent input */
/* flush previous input with previous parameters before changing */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing */
/* check for seek request */
/* flush, free memory, and close file */
/* infback.c -- inflate using a call-back interface
/*
/* function prototypes */
/*
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/* Macros for inflateBack(): */
/* Load returned state from inflate_fast() */
/* Set state from registers for inflate_fast() */
/* Clear the input bit accumulator */
/* Assure that some input is available.  If input is requested, but denied,
/* Get a byte of input into the bit accumulator, or return from inflateBack()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Assure that some output space is available, by writing out the window
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* permutation of code lengths */
/* Check that the strm exists and that the state was initialized */
/* Reset the state */
/* Inflate until end of block marked as last */
/* determine and dispatch block type */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* get and verify stored block length */
/* go to byte boundary */
/* copy stored block from input to output */
/* get dynamic table entries descriptor */
/* get code length code lengths (not a typo) */
/* get length and distance code code lengths */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* use inflate_fast() if we have enough input and output */
/* get a literal, length, or end-of-block code */
/* process literal */
/* process end of block */
/* invalid code */
/* length code -- get extra bits, if any */
/* get distance code */
/* get distance extra bits, if any */
/* copy match from window to output */
/* inflate stream terminated properly -- write leftover output */
/* can't happen, but makes compilers happy */
/* Return unused input */
/* inffast.c -- fast decoding
/* Allow machine dependent optimization for post-increment or pre-increment.
/*
/* inflate()'s starting value for strm->avail_out */
/* local strm->next_in */
/* have enough input while in < last */
/* local strm->next_out */
/* inflate()'s initial strm->next_out */
/* while out < end, enough space available */
/* maximum distance from zlib header */
/* window size or zero if not using window */
/* valid bytes in the window */
/* window write index */
/* allocated sliding window, if wsize != 0 */
/* local strm->hold */
/* local strm->bits */
/* local strm->lencode */
/* local strm->distcode */
/* mask for first level of length codes */
/* mask for first level of distance codes */
/* retrieved table entry */
/* code bits, operation, extra bits, or */
/*  window position, window bytes to copy */
/* match length, unused bytes */
/* match distance */
/* where to copy match from */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* literal */
/* length base */
/* number of extra bits */
/* distance base */
/* number of extra bits */
/* max distance in output */
/* see if copy from window */
/* distance back in window */
/* very common case */
/* some from window */
/* rest from output */
/* wrap around window */
/* some from end of window */
/* some from start of window */
/* rest from output */
/* contiguous in window */
/* some from window */
/* rest from output */
/* copy direct from output */
/* minimum length is three */
/* 2nd level distance code */
/* 2nd level length code */
/* end-of-block */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
/*
/* !ASMINF */
/* inflate.c -- zlib decompression
/*
/* function prototypes */
/* to support ill-conceived Java test suite */
/* get the state */
/* extract wrap request from windowBits parameter */
/* set number of window bits, free window if different */
/* update state and reset the rest of it */
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/*
/* inffixed.h -- table for decoding fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/*
/* if it hasn't been done already, allocate space for the window */
/* if window not in use yet, initialize */
/* copy state->wsize or less output bytes into the circular window */
/* Macros for inflate(): */
/* check function to use adler32() for zlib or crc32() for gzip */
/* check macros for header crc */
/* Load registers with state in inflate() for speed */
/* Restore state from registers in inflate() */
/* Clear the input bit accumulator */
/* Get a byte of input into the bit accumulator, or return from inflate()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* save starting available input and output */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* buffer for gzip header crc calculation */
/* permutation of code lengths */
/* skip check */
/* gzip header */
/* expect zlib header */
/* check if zlib header allowed */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* go to byte boundary */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* copy from window */
/* copy from output */
/*
/* check state */
/* copy dictionary */
/* check state */
/* check for correct dictionary identifier */
/* copy dictionary to window using updatewindow(), which will amend the
/* check state */
/* save header structure */
/*
/* number of bytes to look at or looked at */
/* temporary to save total_in and total_out */
/* to restore bit buffer to byte string */
/* check parameters */
/* if first time, start search in bit buffer */
/* search available input */
/* return no joy or set up to restart inflate() on a new block */
/*
/* check input */
/* allocate space */
/* copy state */
/* inftrees.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..29 base */
/* Distance codes 0..29 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no symbols to code at all */
/* invalid code marker */
/* make a table to force an error */
/* no symbols, but wait for decoding to report error */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* save offset to next table */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* here min is 1 << curr */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/* fill in remaining table entry if code is incomplete (guaranteed to have
/* invalid code marker */
/* set return parameters */
/* trees.c -- output deflated data using Huffman coding
/*
/* @(#) $Id$ */
/* #define GEN_TREES_H */
/* ===========================================================================
/* Bit length codes must not exceed MAX_BL_BITS bits */
/* end of block literal code */
/* repeat previous bit length 3-6 times (2 bits of repeat count) */
/* repeat a zero length 3-10 times  (3 bits of repeat count) */
/* repeat a zero length 11-138 times  (7 bits of repeat count) */
/* extra bits for each length code */
/* extra bits for each distance code */
/* extra bits for each bit length code */
/* The lengths of the bit length codes are sent in order of decreasing
/* ===========================================================================
/* see definition of array dist_code below */
/* non ANSI compilers may not accept trees.h */
/* The static literal tree. Since the bit lengths are imposed, there is no
/* The static distance tree. (Actually a trivial tree since all codes use
/* Distance codes. The first 256 values correspond to the distances
/* length code for each normalized match length (0 == MIN_MATCH) */
/* First normalized length for each code (0 = MIN_MATCH) */
/* First normalized distance for each code (0 = distance of 1) */
/* GEN_TREES_H */
/* static tree or NULL */
/* extra bits for each code or NULL */
/* base index for extra_bits */
/* max number of elements in the tree */
/* max bit length for the codes */
/* ===========================================================================
/* Send a code of the given tree. c and tree must not have side effects */
/* DEBUG */
/* ===========================================================================
/* ===========================================================================
/* value to send */
/* number of bits */
/* If not enough room in bi_buf, use (valid) bits from bi_buf and
/* !DEBUG */
/* DEBUG */
/* the arguments must not have side effects */
/* ===========================================================================
/* iterates over tree elements */
/* bit counter */
/* length value */
/* code value */
/* distance index */
/* number of codes at each bit length for an optimal tree */
/* For some embedded targets, global variables are not initialized: */
/* Initialize the mapping length (0..255) -> length code (0..28) */
/* Note that the length 255 (match length 258) can be represented
/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
/* from now on, all distances are divided by 128 */
/* Construct the codes of the static literal tree */
/* Codes 286 and 287 do not exist, but we must include them in the
/* The static distance tree is trivial: */
/* defined(GEN_TREES_H) || !defined(STDC) */
/* ===========================================================================
/* header created automatically with -DGEN_TREES_H */\n\n");
/* GEN_TREES_H */
/* ===========================================================================
/* Initialize the first block of the first file: */
/* ===========================================================================
/* iterates over tree elements */
/* Initialize the trees. */
/* Index within the heap array of least frequent node in the Huffman tree */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the tree to restore */
/* node to move down */
/* left son of k */
/* Set j to the smallest of the two sons: */
/* Exit if v is smaller than both sons */
/* Exchange v with the smallest son */
/* And continue down the tree, setting j to the left son of k */
/* ===========================================================================
/* the tree descriptor */
/* heap index */
/* iterate over the tree elements */
/* bit length */
/* extra bits */
/* frequency */
/* number of elements with bit length too large */
/* In a first pass, compute the optimal bit lengths (which may
/* root of the heap */
/* We overwrite tree[n].Dad which is no longer needed */
/* not a leaf node */
/* This happens for example on obj2 and pic of the Calgary corpus */
/* Find the first bit length which could increase: */
/* move one leaf down the tree */
/* move one overflow item as its brother */
/* The brother of the overflow item also moves one step up,
/* Now recompute all bit lengths, scanning in increasing frequency.
/* ===========================================================================
/* the tree to decorate */
/* largest code with non zero frequency */
/* number of codes at each bit length */
/* next code value for each bit length */
/* running code value */
/* bit index */
/* code index */
/* The distribution counts are first used to generate the code values
/* Check that the bit counts in bl_count are consistent. The last code
/* Now reverse the bits */
/* ===========================================================================
/* the tree descriptor */
/* iterate over heap elements */
/* largest code with non zero frequency */
/* new node being created */
/* Construct the initial heap, with least frequent element in
/* The pkzip format requires that at least one distance code exists,
/* node is 0 or 1 so it does not have extra bits */
/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
/* Construct the Huffman tree by repeatedly combining the least two
/* next internal node of the tree */
/* n = node of least frequency */
/* m = node of next least frequency */
/* keep the nodes sorted by frequency */
/* Create a new node father of n and m */
/* and insert the new node in the heap */
/* At this point, the fields freq and dad are set. We can now
/* The field len is now set, we can generate the bit codes */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* guard */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* tree[max_code+1].Len = -1; */  /* guard already set */
/* ===========================================================================
/* index of last bit length code of non zero freq */
/* Determine the bit length frequencies for literal and distance trees */
/* Build the bit length tree: */
/* opt_len now includes the length of the tree representations, except
/* Determine the number of bit length codes to send. The pkzip format
/* Update opt_len to include the bit length tree and counts */
/* ===========================================================================
/* number of codes for each tree */
/* index in bl_order */
/* not +255 as stated in appnote.txt */
/* not -3 as stated in appnote.txt */
/* literal tree */
/* distance tree */
/* ===========================================================================
/* input block */
/* length of input block */
/* one if this is the last block for a file */
/* send block type */
/* with header */
/* ===========================================================================
/* ===========================================================================
/* 3 for block type, 7 for EOB */
/* ===========================================================================
/* input block, or NULL if too old */
/* length of input block */
/* one if this is the last block for a file */
/* opt_len and static_len in bytes */
/* index of last bit length code of non zero freq */
/* Build the Huffman trees unless a stored block is forced */
/* Check if the file is binary or text */
/* Construct the literal and distance trees */
/* At this point, opt_len and static_len are the total bit lengths of
/* Build the bit length tree for the above two trees, and get the index
/* Determine the best encoding. Compute the block lengths in bytes. */
/* force a stored block */
/* force stored block */
/* 4: two words for the lengths */
/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
/* force static trees */
/* The above check is made mod 2^32, for files larger than 512 MB
/* align on byte boundary */
/* ===========================================================================
/* distance of matched string */
/* match length-MIN_MATCH or unmatched char (if dist==0) */
/* lc is the unmatched char */
/* Here, lc is the match length - MIN_MATCH */
/* dist = match distance - 1 */
/* Try to guess if it is profitable to stop the current block here */
/* Compute an upper bound for the compressed length */
/* We avoid equality with lit_bufsize because of wraparound at 64K
/* ===========================================================================
/* literal tree */
/* distance tree */
/* distance of matched string */
/* match length or unmatched char (if dist == 0) */
/* running index in l_buf */
/* the code to send */
/* number of extra bits to send */
/* send a literal byte */
/* Here, lc is the match length - MIN_MATCH */
/* send the length code */
/* send the extra length bits */
/* dist is now the match distance - 1 */
/* send the distance code */
/* send the extra distance bits */
/* literal or match pair ? */
/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
/* ===========================================================================
/* black_mask is the bit mask of black-listed bytes
/* Check for non-textual ("black-listed") bytes. */
/* Check for textual ("white-listed") bytes. */
/* There are no "black-listed" or "white-listed" bytes:
/* ===========================================================================
/* the value to invert */
/* its bit length */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the input data */
/* its length */
/* true if block header must be written */
/* align on byte boundary */
/* uncompr.c -- decompress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* for buggy compilers */
/* Z_NEED_DICT       2  */
/* Z_STREAM_END      1  */
/* Z_OK              0  */
/* Z_ERRNO         (-1) */
/* Z_STREAM_ERROR  (-2) */
/* Z_DATA_ERROR    (-3) */
/* Z_MEM_ERROR     (-4) */
/* Z_BUF_ERROR     (-5) */
/* Z_VERSION_ERROR (-6) */
/* exported to allow conversion of error code to string for compress() and
/* The Microsoft C Run-Time Library for Windows CE doesn't have
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Turbo C in 16-bit mode */
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* M_I86 */
/* SYS16BIT */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
/* !Z_SOLO */
