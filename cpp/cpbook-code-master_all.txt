# cpbook-code
CP4 Free Source Code Project (cpp/gnu++17, java/java8, py/python3, and ml/ocaml)

All code in this repo are mostly (reasonably good, hopefully :) implementation of many well-known data structures and algorithms,
so you are free to copy, adapt, use the code.

We will be thankful if you cite us (Steven & Felix Halim) when you use code in this repo.

This license is probably the most suitable: https://opensource.org/licenses/UPL
3
1 2
5 7
6 3
1 2
5 7
6 3
0 0
1 1
1 2
5 7
6 3
1 1
2 3 4
3 8 1 1
4 7 2 9 3
5 1 1 1 1 1
1
3 4
8 1 1
7 2 9 3
1 1 1 1 1
3
0.1227...
0.517611738...
0.7341231223444344389923899277...
6
  0  10   0   0 100   0
 10   0   7   0   8   0
  0   7   0   9   0   0
  0   0   9   0  20   5
100   8   0  20   0   0
  0   0   0   5   0   0
6
2 2 10 5 100
3 1 10 3 7 5 8
2 2 7 4 9
3 3 9 5 20 6 5
3 1 100 2 8 4 20
1 4 5
7
1 2 10
1 5 100
2 3 7
2 5 8
3 4 9
4 5 20
4 6 5
2
10 10
1 1
4
2 3
5 5
9 4
6 5
10 10
1 1
4
2 3
5 5
9 4
6 5
5 9
0 1 2
0 2 1
0 4 3
1 3 4
2 1 1
2 4 1
3 0 1
3 2 3
3 4 5
4 0 1
2 2 70 3 30
2 2 25 3 70
3 0 70 3 5 1 25
3 0 30 2 5 1 70
5 7
0 1 4
0 2 4
0 3 6
0 4 6
1 2 2
2 3 8
3 4 9
5 5 0
0 1 1
0 2 10
1 3 2
2 3 -10
3 4 3
13 16
0 1    1 2    2  3   0  4   1  5   2  6    3  7   5  6
4 8    8 9    5 10   6 11   7 12   9 10   10 11  11 12
5 7 0
0 1 2
0 2 6
0 3 7
1 3 3
1 4 6
2 4 1
3 4 5
6
1 1 0
5 0 0 2 0 3 0 4 0 5 0
1 1 0
1 1 0
2 1 0 5 0
2 1 0 4 0
9
1 1 0
3 0 0 2 0 3 0
2 1 0 3 0
3 1 0 2 0 4 0
1 3 0
0
2 7 0 8 0
1 6 0
1 6 0
8
1 1 0
1 3 0
1 1 0
2 2 0 4 0
1 5 0
1 7 0
1 4 0
1 6 0
8
2 1 0 2 0
2 2 0 3 0
2 3 0 5 0
1 4 0
0
0
0
1 6 0
I love CS3233 Competitive Pro-
gramming and AlGoRiThM. Of
course I love my wife Grace
Suryani very much too. Test
that there are thirty chars
m12345678901234567890123456789
......
hehehe, the line above only
contains six . cannot stop...
.......
after the first input block... there will be one last line can be very long... I am going to type 77777777777777777777777777777777777777777777777777777777777777777777777777777 then a longgggggggggggggggggggggggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg ssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringggggggggggggggggggggggggssssssssssssssssssssssssssstrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrringgggggggggggggggggggggggg
i love cs3232 competitive programming and algorithm. of course i love my wife grace suryani very much too. test that there are thirty chars m12345678901234567890123456789 ...... hehehe the line arose only contains six . cannot stop...
33 58 96
algorithm wife
0
569 3 79
// comment all lines and only uncomment demo code that you are interested with
// number of test cases
// shortcut to repeat until 0
// compute on the fly
// freopen("IO_in2.txt", "r", stdin);
// int a, b;
// // stop when both integers are 0
// while (scanf("%d %d", &a, &b), (a || b))
//   printf("%d\n", a+b);
// freopen("IO_in3.txt", "r", stdin);
// int a, b;
// // scanf returns the number of items read
// while (scanf("%d %d", &a, &b) == 2)
// // or you can check for EOF, i.e.
// // while (scanf("%d %d", &a, &b) != EOF)
//   printf("%d\n", a+b);
// freopen("IO_in3.txt", "r", stdin); // same input file as before
// int a, b, c = 0;
// while (scanf("%d %d", &a, &b) != EOF)
//   // notice the two '\n'
//   printf("Case %d: %d\n\n", ++c, a+b);
// freopen("IO_in3.txt", "r", stdin); // same input file as before
// int a, b, c = 0;
// while (scanf("%d %d", &a, &b) != EOF) {
//   if (c > 0) printf("\n"); // 2nd/more cases
//   printf("Case %d: %d\n", ++c, a+b);
// }
// freopen("IO_in4.txt", "r", stdin);
// int k;
// while (scanf("%d", &k) != EOF) {
//   int ans = 0, v;
//   while (k--) { scanf("%d", &v); ans += v; }
//   printf("%d\n", ans);
// }
// freopen("IO_in5.txt", "r", stdin);
// while (1) { // keep looping
//   int ans = 0, v;
//   char dummy;
//   while (scanf("%d%c", &v, &dummy) != EOF) {
//     ans += v;
//     if (dummy == '\n') break; // test EOLN
//   }
//   if (feof(stdin)) break; // test EOF
//   printf("%d\n", ans);
// }
// include all
// loop from N,N-1,...,0
// set size a bit larger
// `&' is optional here
// note: if you are surprised with the technique above,
// please check scanf details in www.cppreference.com
/*          Forming Quiz Teams, the solution for UVa 10911 above         */
// not C++ standard, but OK in programming contest
// important speedup
// max N = 8
// 1<<16 = 2^16
// DP state = mask
// reference/alias
// this has been computed
// all have been matched
// init with a large value
// speedup
// p1 is first on bit
// turn off bit p1
// then, try to match p1
// with another on bit p2
// turn off bit p2
// memo[mask] == ans
// yes, we can do this :)
// `%*s' skips names
// build distance table
// use `hypot' function
// DP to solve min weighted perfect matching on small general graph
// C++ code for task 2
// adjust field width
// C++ code for task 4
// C++ code for task 5
// use natural order
// reorder DD/MM/YYYY
// to MM, DD, and then
// use NEGATIVE YYYY
// that's all :)
// C++17 style
// C++ code for task 6
// should be index 1
// C++ code for task 7
// C++ code for task 8
// notice the brackets
// this idx is part of set
// can use this primary field to decide sorted order
// ICPC rule: sort by number of problem solved
// a.solved == b.solved, but we can use
// secondary field to decide sorted order
// ICPC rule: sort by descending penalty
// a.solved == b.solved AND a.penalty == b.penalty
// sort based on increasing team ID
// alternative constructor
// sort descending with vector
// reverse iterator
// access the values
// sort descending with integer array
// ascending
// then reverse
// shuffle the content
// partial_sort demo
// sort ascending
// arr is sorted now
// 2, 4, 7, 10, 15
// sort a vector
// 2, 4, 7, 10, 15 too
// multi-field sorting example, suppose we have 4 ICPC teams
// without sorting, they will be ranked like this:
// sort using a comparison function
// after sorting using ICPC rule, they will be ranked like this:
// there is a technique for multi-field sorting if the sort order is "standard"
// use pair (for 2 fields) or tuple (for >= 3 fields) in C++ and put the highest priority in front
// old way
// C++17 way
// use built-in comparator
// sorted ascending based on value, then based on name1,
// then based on name2, in that order!
// binary search using lower bound
// found
// not found
// arr is of size 5 -> 
//    arr[0], arr[1], arr[2], arr[3], arr[4]
// if lower_bound cannot find the required value,
//   it will set return arr index +1 of arr size, i.e.
//   the 'non existent' arr[5]
// thus, testing whether pos - arr == 5 blocks 
//   can detect this "not found" issue
// with vector, lower_bound will do the same:
//   return vector index +1 of vector size
// but this is exactly the position of vector.end()
//   so we can test "not found" this way
// useful if you want to generate permutations of set
// 2, 4, 7, 10, 15 -> 2, 4, 7, 15, 10
// 2, 4, 7, 15, 10 -> 2, 4, 10, 7, 15
// sometimes these two useful simple macros are used
// note: for example usage of bitset, see ch5/primes.cpp
// returns S % N, where N is a power of 2
// in binary representation
// to reverse the print order
// special case for i == 0
// currently s is empty, true (1)
// stack is LIFO, thus the content of s is currently like this:
// c <- top
// b
// a
// output 'c'
// pop topmost
// output 'b'
// output false (0)
// output true (1)
// s has 2 more items
// enqueue 'b' and 'a'
// add one more item
// prints 'b'
// prints 'z'
// output 'b', 'a', then 'z' (until queue is empty), according to the insertion order above
// take the front first
// before popping it
// prints 'a - c'
// only in C++, 'dabc'
// prints 'd - c'
// prints 'd - b'
// prints 'a - b'
// initial size (5) and initial value {7,7,7,0,0}
// initial size (5) and initial value {5,5,5,5,5}
// 7 and 5
// arr = {0,1,2,3,4}
// v = {7,8,9,10,11}
// 2 and 9
// arr[5] = 5;                                 // undefined behavior
// printf("arr[5] = %d\n", arr[5]);            // RTE
// uncomment the line above to see the error (perhaps use -Wall compilation flag)
// vector resizes itself
// 77
// note: there are many clever usages of this set/map
// that you can learn by looking at top coder's codes
// note, we don't have to use .clear() if we have just initialized the set/map
// used_values.clear();
// mapper.clear();
// suppose we enter these 7 name-score pairs below
/*
// then the internal content of mapper MAY be something like this:
// re-read balanced BST concept if you do not understand this diagram
// the keys are names (string)!
//                        (grace,75) 
//           (billy,69)               (martin,81)   
//     (andy,80)   (felix,82)    (john,78)  (steven,77)
// iterating through the content of mapper will give a sorted output
// based on keys (names)
// C++17 style
// map can also be used like this
// interesting usage of lower_bound and upper_bound
// display data between ["f".."m") ('felix' is included, 'martin' is excluded)
// the internal content of used_values MAY be something like this
// the keys are values (integers)!
//                 (78) 
//         (75)            (81)   
//     (69)    (77)    (80)    (82)
// O(log n) search, found
// returns [69, 75] (these two are before 77 in the inorder traversal of this BST)
// returns [77, 78, 80, 81, 82] (these five are equal or after 77 in the inorder traversal of this BST)
// O(log n) search, not found
// suppose we enter these 7 money-name pairs below
/*
// insertion in O(log n)
// alternative way with {}
// priority queue will arrange items in 'heap' based
// on the first key in pair, which is money (integer), largest first
// if first keys tie, use second key, which is name, largest first
// the internal content of pq heap MAY be something like this:
// re-read (max) heap concept if you do not understand this diagram
// the primary keys are money (integer), secondary keys are names (string)!
//                        (2000,grace)
//           (100,steven)               (70,martin)   
//     (100,john)   (10,billy)     (20,andy)  (70,felix)
// let's print out the top 3 person with most money
// O(1) to access the top / max element
// C++17 style
// O(log n) to delete the top and repair the structure
// [score, name] still binded to pq.top() as we use `&' above
// be careful not to overuse & to avoid accidental by reference bug
// note, we don't have to use .clear() if we have just initialized the set/map
// used_values.clear();
// mapper.clear();
// suppose we enter these 7 name-score pairs below
/*
// then the internal content of mapper/used_values are not really known
// (implementation dependent)
// iterating through the content of mapper will give a jumbled output
// as the keys are hashed into various slots
// C++17 style
// map can also be used like this
// there is no lower_bound and upper_bound in an unordered_map
// O(1) search, found
// O(1) search, not found
// the key operation
// for extra flexibility
// index 0 is not used
// internal FT is an array
// create an empty FT
// note f[0] is always 0
// O(n)
// add this value
// i has parent
// add to that parent
// create FT based on f
// create FT based on s
// do the conversion first
// returns RSQ(1, j)
// inc/exclusion
// updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
// O(log^2 n)
// 2^30 > 10^9; usually ok
// BSTA
// See Section 3.3.1
// RUPQ variant
// internally use PURQ FT
// [ui, ui+1, .., n] +v
// [uj+1, uj+2, .., n] -v
// [ui, ui+1, .., uj] +v
// rsq(i) is sufficient
// RURQ variant
// needs two helper FTs
// one RUPQ and
// one PURQ
// initialization
// [ui, ui+1, .., uj] +v
// -(ui-1)*v before ui
// +(uj-ui+1)*v after uj
// optimistic calculation
// cancelation factor
// standard
// index 0 is always 0
// 7 => ft[6]+ft[4] = 5+2 = 7
// index 6, rsq(1, 6) == 7, which is >= 7
// update demo
// now 12
// indices in [2, 3, .., 9] updated by +7
// indices 6&7 are further updated by +3 (10)
// 62
// 20
/*
// idx   0 1 2 3 4 5 6 7  8 9 10, no index 0!
// ft = {-,0,0,0,0,0,0,0, 0,0,0}
// ft = {-,0,1,0,1,0,0,0, 1,0,0}, idx 2,4,8 => +1
// ft = {-,0,1,0,2,0,0,0, 2,0,0}, idx 4,8 => +1
// ft = {-,0,1,0,2,2,2,0, 4,0,0}, idx 5,6,8 => +2
// ft = {-,0,1,0,2,2,5,0, 7,0,0}, idx 6,8 => +3
// ft = {-,0,1,0,2,2,5,2, 9,0,0}, idx 7,8 => +2
// ft = {-,0,1,0,2,2,5,2,10,0,0}, idx 8 => +1
// ft = {-,0,1,0,2,2,5,2,10,1,1}, idx 9,10 => +1
// 0 => ft[1] = 0
// 1 => ft[2] = 1
// 7 => ft[6]+ft[4] = 5+2 = 7
// 11 => ft[10]+ft[8] = 1+10 = 11
// 6 => rsq(1, 6) - rsq(1, 2) = 7-1 = 6
// index 6, rsq(1, 6) == 7, which is >= 7
// index 7, rsq(1, 7) == 9, which is >= 8
// update demo
// now 13
// identical as ft1
// 0 => ft[1] = 0
// 1 => ft[2] = 1
// 7 => ft[6]+ft[4] = 5+2 = 7
// 11 => ft[10]+ft[8] = 1+10 = 11
// 6 => rsq(1, 6) - rsq(1, 2) = 7-1 = 6
// index 6, rsq(1, 6) == 7, which is >= 7
// index 7, rsq(1, 7) == 9, which is >= 8
// update demo
// now 13
// index 0 is always 0 (unused)
// 0 => ft[1] = 0
// 1 => ft[2] = 1
// 7 => ft[6]+ft[4] = 5+2 = 7
// 11 => ft[10]+ft[8] = 1+10 = 11
// 6 => rsq(1, 6) - rsq(1, 2) = 7-1 = 6
// index 6, rsq(1, 6) == 7, which is >= 7
// index 7, rsq(1, 7) == 9, which is >= 8
// update demo
// now 13
// indices in [2, 3, .., 9] updated by +7
// indices 6&7 are further updated by +3 (10)
// 62
// 20
// RUPQ rupq(10) ;                        // empty Fenwick Tree with 10 keys
// rupq.range_update(2, 9, 7);     // indices in [2, 3, .., 9] updated by +7
// rupq.range_update(6, 7, 3); // indices 6&7 are further updated by +3 (10)
// for (int i = 1; i <= 10; i++)
//   printf("%d -> %lld\n", i, rupq.point_query(i));
// printf("=====\n");
// RURQ rurq(10);
// rurq.range_update(2, 2, 1);
// rurq.range_update(4, 9, 1);
// rurq.range_update(5, 7, 1);
// rurq.range_update(6, 6, 1);
// for (int i = 1; i <= 10; i++)
//   printf("%d -> %lld\n", i, rurq.rsq(i));
// printf("RSQ(6, 10) = %lld\n", rurq.rsq(6, 10)); // 3+2+1+1+0 = 7
// printf("RSQ(1, 10) = %lld\n", rurq.rsq(1, 10)); // m = 11
// it is better to declare large (2D) array as global
// Try this input for Adjacency Matrix/Adjacency List/Edge List
// Adjacency Matrix AM
//   for each line: |V| entries, 0 or the weight
// Adjacency List AL
//   for each line: num neighbors, list of neighbors + weight pairs
// Edge List EL
//   for each line: a-b of edge(a,b) and weight
/*
// need to know V first
// if V is > 2000,
// try NOT to use AM
// O(V)
// initialize AL
// to 0-based indexing
// k = |neighbors|
// O(k)
// one way to store EL
// edges sorted by weight (smallest->largest)
// C++17 style
// OOP style
// the underlying array
// n = (int)A.size()
// segment tree array
// lazy propagation array
// go to left child
// go to right child
// corner case
// RMQ
// O(n)
// base case
// has a lazy flag
// [L..R] has same value
// not a leaf
// propagate downwards
// L == R, a single index
// time to update this
// erase lazy flag
// O(log n)
// lazy propagation
// found the segment
// update this
// lazy propagation
// O(log n)
// lazy propagation
// infeasible
// found the segment
// make n a power of 2
// index 2
// index 5
// index 4
// update A[5] to 77
// remains index 2
// now index 4
// remains index 4
// update A[0..3] to 30
// [0,1,2,3] all correct
// remains index 4
// remains index 4
// update A[3] to 7
// now index 3
// remains index 4
// now index 3
// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics
// OOP style
// vi p is the key part
// optional speedup
// optional feature
// optional feature
// optional
// optional
// i and j are in same set
// find both rep items
// keep x 'shorter' than y
// set x under y
// optional speedup
// combine set sizes at y
// a union reduces numSets
// create 5 disjoint sets
// 5
// 4
// 3
// 2
// will return 0 (false)
// will return 1 (true)
// findSet will return 1 for {0, 1} and 3 for {2, 3, 4}
// 1
// findSet will return 3 for {0, 1, 2, 3, 4}
// Lotto
// input: k sorted ints
// six nested loops!
// Division
// this way, abcde and fghij are at most 5 digits
// if digit f=0, then we have to flag it
// if all digits are used, print it
// global variables
// check previous Queens
// infeasible
// a candidate sol
// optional statement
// try all possible row
// early pruning
// can place a Queen here?
// put here and recurse
// to 0-based indexing
// sub 8! operations
// Simple Equations
// 0.150s
// bool sol = false; int x, y, z;
// for (x = -100; x <= 100; ++x)                    // ~201^3 ~= 8M operations
//   for (y = -100; y <= 100; ++y)
//     for (z = -100; z <= 100; ++z)
//       if ((y != x) && (z != x) && (z != y) &&    // all 3 must be different
//           (x+y+z == A) && (x*y*z == B) && (x*x + y*y + z*z == C)) {
//         if (!sol) printf("%d %d %d\n", x, y, z);
//         sol = true;
//       }
// 0.000s, when x is reduced to -22 to 22 due to x*y*z = B and x <= y <= z so x^3 <= B or x <= B^(1/3)
// Social Constraints 
// try all possible O(n!) permutations, the largest nput 8! = 40320
// check the given social constraints based on 'p' in O(m)
// check all constraints, max 20, each check 8 = 160
// positive, at most  c[j]
// negative, at least c[j]
// all constraints are satisfied by this permutation
// the overall time complexity is thus O(m * n!)
// overall complexity = 160 * 40320 = 6M, doable
// Bars
// for each subset, O(2^n)
// for (int j = 0; j < n; j++)             // check membership, O(n)
//   if (i & (1<<j))                       // see if bit 'j' is on?
//     sum += l[j];                        // if yes, process 'j'
// this is now O(k)
// k is the # of on bits
// least significant bit
// 2^j = two_pow_j, get j
// the answer is found
// Through the Desert
// for all events, consume this amount of fuel (0 amount if delta time is 0)
// consumption
// leak
// quick check
// change a parameter, if needed
// Fuel consumption n
// Leak
// Gas station
// Mechanic
// Goal
// update time
// if still have enough fuel by goal, this simulation is a success, otherwise, it is a failure
// first event
// the first four characters are "Fuel"
// Binary Search the Answer (BSTA), then simulate
// // while loop version
// double lo = 0.0, hi = 10000.0;
// while (fabs(hi-lo) > EPS) {                  // answer is not found yet
//   double mid = (lo+hi) / 2.0;                // try the middle value
//   can(mid) ? hi = mid : lo = mid;            // then continue
// }
// for loop version
// log_2(10000/1e-9) ~= 43
// looping 50x is enough
// this is the answer
// Collecting Beepers
// Karel + max 10 beepers
// mask = free coordinates
// close the loop
// computed before
// up to O(n)
// but this is fast
// offset v by +1
// keep the min
// these two values are not used
// include Karel
// Karel is at index 0
// build distance table
// Manhattan distance
// DP-TSP
// printf("The shortest path has length %d\n", dp(0, (1<<(n-1))-1)); // DP-TSP
// predecessor array
// backtracking routine
// base case
// backtrack
// MAX_N up to 10^4
// O(n^2) overall
// was computed before
// O(n) here
// increasing condition
// pick the max
// early 2000 problems usually accept O(n^2) solution
// with O(n^2) DP
// 2020s problems will likely only accept O(n log k) solution
// O(n)
// greedily overwrite this
// remember the index too
// predecessor info
// can extend LIS?
// k = longer LIS by +1
// keep best ending i
// a sample array A
// linear scan, O(n)
// greedily extend this
// keep the cur max RSQ
// reset the running sum
// if it ever dips below 0
// rationale: starting from 0 is better for future
// iterations than starting from -ve running sum
// should be 9
// Maximum Sum
// O(n^3) 1D DP + greedy (Kadane's) solution, 0.000s in UVa
// square matrix size
// pre-processing
// lowest possible val
// Max 1D Range Sum on columns of this row
// Kadane's algorithm on rows
// restart if negative
/*
// square matrix size
// add from top
// add from left
// avoid double count
// inclusion-exclusion
// the lowest possible val
// start coordinate
// end coord
// from (0, 0) to (k, l)
// O(1)
// O(1)
// O(1)
// the answer is here
/*
// square matrix size
// the lowest possible val
// start coordinate
// end coord
// sum this sub-rectangle
// the answer is here
// Coin Change
// N and coinValue are fixed for this problem, max V is 7489
// one way, use nothing
// invalid or done
// was computed before
// ignore this type
// one more of this type
// we only need to initialize this once
// Cutting Sticks
// Top-Down DP
// start with left = 0 and right = n + 1
// SuperSale 
// 0-1 Knapsack DP (Top-Down, faster)
// two base cases
// computed before
// no choice, skip
// has choice, skip
// or take
/*
// 0-1 Knapsack DP (Bottom-Up)
/* How do you add? */
// top-down
/*
// only can use 1 number to add up to N
// the answer is definitely 1, that number itself
// if K > 1, we can choose one number from [0..N] to be one of the number and recursively compute the rest
// we just need the modulo 1M
// memoize them
// some recursion formula + top down DP
// bottom-up
// these are the base cases
// these three nested loops form the correct topological order
// UVa 11450 - Wedding Shopping - Bottom Up (faster than Top Down)
// up to 20 garments at most and 20 models/garment
// maximum budget is 200
// price[g (<= 20)][k (<= 20)]
// bool reachable[MAX_gm][MAX_M]; // reachable table[g (<= 20)][money (<= 200)]
// if using space saving technique
// reachable table[ONLY TWO ROWS][money (<= 200)]
// store k in price[g][0]
// clear everything
// initial values (base cases), using first garment g = 0
// for (int g = 1; g < C; ++g)               // for each garment
//   for (money = 0; money < M; money++) if (reachable[g-1][money])
//     for (int k = 1; k <= price[g][0]; ++k) if (money-price[g][k] >= 0)
//       reachable[g][money-price[g][k]] = true; // also reachable now
// for (money = 0; money <= M && !reachable[C-1][money]; ++money);
// then we modify the main loop in int main a bit
// we start with this row
// for each garment
// reset row
// flip the two rows
// last row has no on bit
// UVa 11450 - Wedding Shopping - Top Down
// this code is similar to recursive backtracking code
// parts of the code specific to top-down DP are commented with: `TOP-DOWN'
// if these lines are commented, this top-down DP will become backtracking!
// up to 20 garments at most and 20 models/garment
// maximum budget is 200
// price[g (<= 20)][k (<= 20)]
// TOP-DOWN: dp table [g (< 20)][money (<= 200)]
// fail, return -ve number
// we are done
// if the line below is commented, top-down DP will become backtracking!!
// TOP-DOWN: memoization
// start with a -ve number
// try each model k
// TOP-DOWN: memoize ans
/*
// must check this first
// money can't be < 0
// remember memory address
// try each model k
// ans == memo[g][money]
// void function
// similar base cases
// which model k is opt?
// this one
// recurse to this only
// easy to code
// store k in price[g][0]
// TOP-DOWN: init memo
// start the top-down DP
// Distributing Ballot Boxes
// (ratio r, num, den)
// max pq
// initially, 1 box/city
// remaining boxes
// extra box->largest city
// current largest city
// reduce its workload
// the final answer
// all other cities in the max pq will have equal or lesser ratio
// Kattis - grass / UVa 10382 - Watering Grass
// sort based on smaller x_l and then larger x_r
// to make this unselected...
// sort the sprinklers
// done
// inside prev interval
// can cover
// go to right to find
// interval with
// the largest coverage
// jump here
// The Dragon of Loowater
// both arrays are sorted
// while not done yet
// find required knight k
// loowater is doomed :S
// pay this amount of gold
// next dragon & knight
// all dragons are chopped
// INF = 1B, not 2^31-1 to avoid overflow
// if |V| > 450, you cannot use Floyd Washall's
// it is better to store a big array in the heap
/*
// directed graph
// loop order is k->u->v
// This code uses new C++17 structured binding
// use this compiler setting "g++ -O2 -std=gnu++17 {cpp17file}"
// Disclaimer: This code is a hybrid between old CP1-2-3 implementation of
// Edmonds Karp's algorithm -- re-written in OOP fashion and the fast
// Dinic's algorithm implementation by
// https://github.com/jaehyunp/stanfordacm/blob/master/code/Dinic.cc
// This code is written in modern C++17 standard
// INF = 1e18, not 2^63-1 to avoid overflow
// BFS to find augmenting path in residual graph
// record BFS sp tree
// stop as sink t reached
// explore neighbors of u
// stored in EL[idx]
// positive residual edge
// 3 lines in one!
// has an augmenting path
// send one flow from s->t
// bottleneck edge f found
// back edge
// back flow
// traverse from s->t
// remember last edge
// in current layer graph
// back edge
// if you are adding a bidirectional edge u<->v with weight w into your
// flow graph, set directed = false (default value is directed = true)
// safeguard: no self loop
// u->v, cap w, flow 0
// remember this index
// back edge
// remember this index
// mf stands for max_flow
// an O(VE^2) EK algorithm
// find and send 1 flow f
// if f == 0, stop
// if f > 0, add to mf
// mf stands for max_flow
// an O(VE^2) EK algorithm
// important speedup
// exhaust blocking flow
/*
// default: directed edge
// printf("%lld\n", mf.edmonds_karp(s, t));
// global variables
// return 1 if there exists an augmenting path from L
// return 0 otherwise
// found 1 matching
// no matching
// inside int main()
// build bipartite graph with directed edge from left to right set
/*
// we know there are 6 vertices in this bipartite graph, left side are numbered 0,1,2, right side 3,4,5
// Graph in Figure 4.41 can be built on the fly
// we know there are 5 vertices in this bipartite graph, left side are numbered 0,1, right side 3,4,5
//int V = 5, Vleft = 2, set1[2] = {1,7}, set2[3] = {4,10,12};
// build the bipartite graph, only directed edge from left to right is needed
// For bipartite graph in Figure 4.44, V = 5, Vleft = 3 (vertex 0 unused)
// AL[0] = {} // dummy vertex, but you can choose to use this vertex
// AL[1] = {3, 4}
// AL[2] = {3}
// AL[3] = {}   // we use directed edges from left to right set only
// AL[4] = {}
// we ignore vertex 0
// build unweighted bipartite graph with directed edge left->right set
// assume all vertices on left set are free initially
// V is the number of vertices in bipartite graph
// Greedy pre-processing for trivial Augmenting Paths
// try commenting versus un-commenting this for-loop
// O(V+E)
// L is matched, no longer a free vertex
// randomize this greedy matching
// for each of the k remaining free vertices
// reset before each recursion
// once f is matched, f remains matched till end
// the answer is 2 for Figure 4.42
// UFDS code from ch2/ownlibrary/ufds.cpp
// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics
// OOP style
// vi p is the key part
// optional speedup
// optional feature
// optional feature
// i and j are in same set
// find both rep items
// keep x 'shorter' than y
// set x under y
// optional speedup
// combine set sizes at y
// a union reduces numSets
/*
// This example shows another form of reading graph input
// Kruskal's algorithm
// read as (u, v, w)
// reorder as (w, u, v)
// sort by w, O(E log E)
// note: std::tuple has built-in comparison function
// no edge has been taken
// all V are disjoint sets
// note: the runtime cost of UFDS is very light
// up to O(E)
// C++17 style
// already in the same CC
// add w of this edge
// link them
// 1 more edge is taken
// optimization
// note: the number of disjoint sets must eventually be 1 for a valid MST
// the graph stored in AL
// to avoid cycle
// to select shorter edges
// C++ STL priority_queue is a max heap, we use -ve sign to reverse order
// set u as taken and enqueue neighbors of u
// sort by non-dec weight
// then by inc id
/*
// This example shows another form of reading graph input
// inside int main() --- assume the graph is stored in AL, pq is empty
// read as (u, v, w)
// no vertex is taken
// take+process vertex 0
// no edge has been taken
// up to O(E)
// C++17 style
// negate to reverse order
// already taken, skipped
// add w of this edge
// take+process vertex u
// 1 more edge is taken
// optimization
// INF = 1B, not 2^31-1 to avoid overflow
/*
// Graph in Figure 4.19, negative cycle exists, Bellman Ford's can detect this
// Bellman Ford's routine, basically = relax all E edges V-1 times
// INF = 1e9 here
// total O(V*E)
// optimization
// these two loops = O(E)
// important check
// C++17 style
// not improving, skip
// relax operation
// optimization
// optimization
// one more pass to check
// C++17 style
// should be false
// if true => -ve cycle
// In this chapter, we will frequently use these
// three data type shortcuts. They may look cryptic
// but shortcuts are useful in competitive programming
// INF = 1B, not 2^31-1 to avoid overflow
// addition:parent vector
// extract info from vi p
// output format: s -> ... -> t
/*
// This example shows another form of reading graph input
// as an example, we start from this source, see Figure 4.3
// BFS routine inside int main() -- we do not use recursion
// INF = 1e9 here
// p is global
// for output printing
// additional feature
// C++17 style, w ignored
// dist[v] != INF now
// parent of v is u
// for next iteration
// same parity
// INF = 1B, not 2^31-1 to avoid overflow
/*
// directed graph
// INF = 1e9 here
// Original Dijkstra's algorithm
/*
// dist[u] = INF
// but dist[s] = 0
// sort the pairs by non-decreasing distance from s
// main loop
// shortest unvisited u
// all edges from u
// not improving, skip
// erase old pair
// relax operation
// enqueue better pair
// (Modified) Dijkstra's algorithm
// sort the pairs by non-decreasing distance from s
// main loop
// shortest unvisited u
// a very important check
// all edges from u
// not improving, skip
// relax operation
// enqueue better pair
// INF = 1B, not 2^31-1 to avoid overflow
/*
// Graph in Figure 4.19, negative cycle exists, SPFA will be trapped in an infinite loop/produces WA (stop only when overflow happens)
// SPFA from source S
// INF = 1e9 here
// like BFS queue
// unique to SPFA
// pop from queue
// C++17 style
// not improving, skip
// relax operation
// add to the queue
// only if v is not
// already in the queue
// basic flag
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// dfs_low[u]<=dfs_num[u]
// a tree edge
// special case, root
// for articulation point
// store this info first
// for bridge
// subtree, always update
// if a non-trivial cycle
// then can update
/*
// Right graph in Figure 4.6/4.7/4.8
// special case
// three flags
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// back vs bidirectional
// check edge properties
// color u as EXPLORED
// C++17 style, w ignored
// EXPLORED->UNVISITED
// a tree edge u->v
// EXPLORED->EXPLORED
// differentiate them
// the most frequent application: check if the graph is cyclic
// EXPLORED->VISITED
// color u as VISITED/DONE
/*
// freopen("dfs_cc_in.txt", "r", stdin);
/*
// basic flags
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// normal usage
// this vertex is visited
// mark u as visited
// C++17 style, w ignored
// to avoid cycle
// recursively visits v
/*
// for each u in [0..V-1]
// if that u is unvisited
// 3 lines here!
// basic flags
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// this is the only change
/*
// make sure that the given graph is DAG
// global variable
// global variable
// same as finding CCs
// reverse ts or
// simply read the content
// of ts backwards
// Wetlands of Florida
// classic DFS flood fill
// the order is:
// S/SE/E/NE/N/NW/W/SW
// returns the size of CC
// outside grid
// does not have color c1
// (r, c) has color c1
// to avoid cycling
// the code is neat as
// we use dr[] and dc[]
// inside int main()
// read the grid as a global 2D array + read (row, col) query coordinates
// remove dummy line
// start of query
// index starts from 0!
// count size of wet area
// restore for next query
// next test case or last test case
// Bicoloring
// notice: vi, not vii
// bidirectional
// add a Boolean flag
// as with original BFS
// don't record distances
// just record two colors
// u & v have same color
// a coloring conflict :(
// optional speedup
// Beverages
// give index i to B1
// directed edge
// enqueue vertices with zero incoming degree into a (priority) queue pq
// min priority queue
// next to be processed
// smaller index first
// Kahn's algorithm
// process u here
// virtually remove u->v
// not a candidate, skip
// enqueue v in pq
// dummy
// Come and Go
// check if the graph is strongly connected, i.e. the SCC of the graph is the graph itself (only 1 SCC)
// global variables
// dfs_low[u] <= dfs_num[u]
// remember the order
// condition for update
// a root/start of an SCC
// when recursion unwinds
// pass = 1 (original), 2 (transpose)
// by ref to avoid copying
// C++17 style, w ignored
// as in finding topological order in Section 4.2.5
// the transposed graph
// to 0-based indexing
// always
// if this is two way, add the reverse direction
// run Tarjan's SCC code here
// // run Kosaraju's SCC code here
// S.clear(); // first pass: record the post-order of original graph
// dfs_num.assign(N, UNVISITED);
// for (int u = 0; u < N; ++u)
//   if (dfs_num[u] == UNVISITED)
//     Kosaraju(u, 1);
// int numSCC = 0; // second pass: explore SCCs using first pass order
// dfs_num.assign(N, UNVISITED);
// for (int i = N-1; i >= 0; --i)
//   if (dfs_num[S[i]] == UNVISITED)
//     numSCC++, Kosaraju(S[i], 2);             // on transposed graph
// if SCC is only 1, print 1, otherwise, print 0
// 10^7 should be enough for most cases
// compact list of primes in form of vector<long long>
// first part
// create list of primes in [0..upperbound]
// add 1 to include upperbound
// set all bits to 1
// except index 0 and 1
// cross out multiples of i <= _sieve_size starting from i*i
// also add this vector containing list of primes
// call this method in main method
// a good enough deterministic prime tester
// now O(1) for small primes
// it takes longer time if N is a large prime!
// note: only work for N <= (last prime in vi "primes")^2
// second part
// remember: vi is vector of integers, ll is long long
// vi `primes' (generated by sieve) is optional
// using PF = 2, 3, 4, ..., is also ok
// stop at sqrt(N), but N can get smaller
// remove this PF
// only consider primes!
// special case if N is actually a prime
// if pf exceeds 32-bit integer, you have to change vi
// third part
// count this pf only once
// start from ans = 1
// count the power
// according to the formula
// (last factor has pow = 1, we add 1 to it)
// start from ans = 1
// formula
// last one
// start from ans = N
// only count unique factor
// last factor
// first part: the Sieve of Eratosthenes
// can go up to 10^7 (need few seconds)
// last prime generated is 9999991
// 2^31-1 = 2147483647, 10-digits prime
// not a prime, 104729*1299709
// second part: prime factors
// slowest, 2^31-1 = 2147483647 is a prime
// slow, 2 large factors 104729 * 1299709
// faster, 2^10 * 3^4 * 5 * 7^4 * 11 * 13
// this is the limit: 9999991^2
// r = primeFactors(100000380000361LL);                 // error, beyond 9999991^2
// for (auto &pf : r) printf("> %d\n", pf);
// printf("\n");
// third part: prime factors variants
// 2^1 * 5^2 => 3
// 2^1 * 5^2 => 2
// 2^1 * 5^2 => 2 + 5 + 5 = 12
// 1, 2, 5, 10, 25, 50, 6 divisors
// 1 + 2 + 5 + 10 + 25 + 50 = 93
// 20 integers < 50 are relatively prime with 50
// special cases when N is a prime number
// 7^1 => 1
// 7^1 = 1
// 7^1 => 7
// 1 and 7, 2 divisors
// 1 + 7 = 8
// 6 integers < 7 are relatively prime with prime number 7
// Pseudo-Random Numbers
// function int f(int x) is defined earlier
// 1st part: finding k*mu, hare's speed is 2x tortoise's
// f(x0) is the node next to x0
// 2nd part: finding mu, hare and tortoise move at the same speed
// 3rd part: finding lambda, hare moves, tortoise stays
// Modular Fibonacci
// increase this if needed
// to let us return a 2D array
// O(n^3), but O(1) as n = 2
// modulo arithmetic is used here
// O(n^3 log p), but O(log p) as n = 2
// prepare identity matrix
// iterative version of Divide & Conquer exponentiation
// check if p is odd (the last bit is on)
// update ans
// square the base
// divide p by 2
// special matrix for Fibonaccci
// set MOD = 2^m
// O(log n) 
// this if fib(n)
// make sure ch is in lowercase
// technique to differentiate first line with the other lines
// to differentiate whether the previous line contains a dash or not
// delete dummy char
// if the last character is '-', delete it by moving the NULL (0) one character forward
// only append " " if this line is the second one onwards
// we can use str[i] as terminating condition as string in C++ is also terminated with NULL (0)
// make each character lower case
// already returns 1 or 0
// casting from C string to C++ string is automatic
// to cast C++ string to C string, we need to use c_str()
// T = text, P = pattern
// b = back table, n = length of T, m = length of P
// try all potential starting indices
// use boolean flag `found'
// if mismatch found
// abort this, shift starting index i by +1
// if P[0..m-1] == T[i..i+m-1]
// call this before calling kmpSearch()
// starting values
// pre-process the pattern string P
// if different, reset j using b
// if same, advance both pointers
// observe i = 8, 9, 10, 11, 12 with j = 0, 1, 2, 3, 4
// in the example of P = "SEVENTY SEVEN" above
// this is similar as kmpPreprocess(), but on string T
// starting values
// search through string T
// if different, reset j using b
// if same, advance both pointers
// a match found when j == m
// prepare j for the next possible match
//if the end of line character is read too, uncomment the line below
//T[n-1] = 0; n--; P[m-1] = 0; m--;
/*
// up to 100K characters
// the input string
// the length of T
// rank array
// suffix array
// for counting/radix sort
// the pattern string
// the length of P
// for computing LCP
// LCP[i] = the LCP between previous suffix T+SA[i-1] and suffix T+SA[i]
// compare
// max ~1000 characters
// this is the initial SA
// sort: O(n log n) * compare: O(n) = O(n^2 log n)
// O(n)
// up to 255 ASCII chars
// clear frequency table
// count the frequency
// of each integer rank
// shuffle SA
// update SA
// can go up to 100K chars
// initial rankings
// initial SA
// repeat log n times
// this is actually radix sort: sort based on the second item
// and then (stable) sort based on the first item
// re-ranking process
// compare adj suffixes
// if same pair => same rank r; otherwise, increase r
// update RA
// nice optimization
// default value
// compute LCP by def
// always reset L to 0
// same L-th char, ++L
// default value
// compute Phi in O(n)
// remember prev suffix
// compute PLCP in O(n)
// special case
// L incr max n times
// L dec max n times
// compute LCP in O(n)
// restore PLCP
// in O(m log n)
// range = [0..n-1]
// find lower bound
// this is round down
// find P in suffix 'mid'
// notice the >= sign
// if not found
// now find upper bound
// notice the > sign
// special case
// return lower/upperbound as first/second item of the pair, respectively
// returns a pair (the LRS length and its index)
// O(n), start from i = 1
// returns a pair (the LCS length and its index)
// O(n), start from i = 1
//printf("Enter a string T below, we will compute its Suffix Array:\n");
// T[n++] = '$';
// if '\n' is read, uncomment the next line
//T[n-1] = '$'; T[n] = 0;
/*
// O(n log n)
// O(n)
// LRS demo
// find the LRS of the first input string
/*
//printf("\nNow, enter a string P below, we will try to find P in T:\n");
// if '\n' is read, uncomment the next line
//P[m-1] = 0; m--;
// LCS demo
//printf("\nRemember, T = '%s'\nNow, enter another string P:\n", T);
// T already has '$' at the back
// if '\n' is read, uncomment the next line
//P[m-1] = 0; m--;
// append P
// add '$' at the back
// update n
// reconstruct SA of the combined strings
// O(n log n)
// O(n)
// find the longest common substring between T and P
// Needleman Wunsnch's algorithm
// insert/delete = -1 point
// match = 2 points, mismatch = -1 point
// cost for match or mismatches
// insert/delete = -1 point
// delete
// insert
// whenever possible, work with point_i
// default constructor
// constructor
// only used if more precision is needed
// default constructor
// constructor
// all integer version
// all integer
//inside/border/outside
// to get the other center, reverse p1 and p2
// circle equation, inside, border, outside
// 0-inside
// 1-at border
// 2-outside
// we simply reverse p1 with p2
// important constant; alternative #define PI (2.0 * acos(0.0))
// struct point_i { int x, y; };    // basic raw form, minimalist mode
// whenever possible, work with point_i
// default constructor
// user-defined
// only used if more precision is needed
// default constructor
// user-defined
// override less than operator
// useful for sorting
// first criteria , by x-coordinate
// second criteria, by y-coordinate
// use EPS (1e-9) when testing equality of two floating points
// Euclidean distance
// hypot(dx, dy) returns sqrt(dx * dx + dy * dy)
// return double
// rotate p by theta degrees CCW w.r.t origin (0, 0)
// multiply theta with PI / 180.0
// a way to represent a line
// the answer is stored in the third parameter (pass by reference)
// vertical line is fine
// default values
// IMPORTANT: we fix the value of b to 1.0
// not needed since we will use the more robust form: ax + by + c = 0
// another way to represent a line
// special case: vertical line
// l contains m = INF and c = x_value
// to denote vertical line x = x_value
// we need this return variable to differentiate result
// l contains m and c of the line equation y = mx + c
// check coefficients a & b
// also check coefficient c
// returns true (+ intersection point) if two lines are intersect
// no intersection
// solve system of 2 linear algebraic equations with 2 unknowns
// special case: test for vertical line to avoid division by zero
// name: `vec' is different from STL vector
// convert 2 points to vector a->b
// nonnegative s = [<1 .. 1 .. >1]
// shorter.same.longer
// translate p according to v
// convert point and gradient/slope to line
// always -m
// always 1
// compute this
// perpendicular to l and pass through p
// special case 1: vertical line
// special case 2: horizontal line
// normal line
// intersect line l with this perpendicular line
// the intersection point is the closest point
// returns the reflection of point on a line
// similar to distToLine
// create a vector
// translate p twice
// returns the dot product of two vectors a and b
// returns the squared value of the normalized vector
// returns the distance from p to the line defined by
// two points a and b (a and b must be different)
// the closest point is stored in the 4th parameter (byref)
// formula: c = a + u*ab
// translate a to c
// Euclidean distance between p and c
// returns the distance from p to the line segment ab defined by
// two points a and b (still OK if a == b)
// the closest point is stored in the 4th parameter (byref)
// closer to a
// Euclidean distance between p and a
// closer to b
// Euclidean distance between p and b
// run distToLine as above
// returns angle aob in rad
// returns the cross product of two vectors a and b
//// another variant
// returns 'twice' the area of this triangle A-B-c
// int area2(point p, point q, point r) {
//   return p.x * q.y - p.y * q.x +
//          q.x * r.y - q.y * r.x +
//          r.x * p.y - r.y * p.x;
// }
// note: to accept collinear points, we have to change the `> 0'
// returns true if point r is on the left side of line pq
// returns true if point r is on the same line as the line pq
// note that both P1 and P2 are (0.00, 0.00)
// true
// false
// sorting points demo
// rearrange the points as shown in the diagram below
/*
// should be 5.000
// line equations
// should be -0.50 * x + 1.00 * y - 1.00 = 0.00
// a vertical line, not a problem in "ax + by + c = 0" representation
// should be 1.00 * x + 0.00 * y - 2.00 = 0.00
// parallel, same, and line intersection tests
// no
// yes, l1 (P[0]-P[1]) and l3 (P[2]-P[3]) are parallel
// no
// yes, l2 (P[0]-P[2]) and l4 (P[2]-P[4]) are the same line (note, they are two different line segments, but same line)
// yes, l1 (P[0]-P[1]) and l2 (P[0]-P[2]) are intersect at (2.0, 2.0)
// other distances
// closer to A (or P[2]) = (2.00, 4.00)
// closer to midway between AB = (3.20, 4.60)
// closer to B (or P[3]) = (6.00, 6.00)
// should be (0.00, 3.00)
// 90 degrees
// 63.43 degrees
// 180 degrees
// no
// yes
// no
// yes
// collinear if r(35, 31)
// right
/*
// translation
// imagine there is an arrow from A to B (see the diagram above)
// D will be located in coordinate (3.0 + 2.0, 2.0 + 1.0) = (5.0, 3.0)
// E will be located in coordinate (3.0 + 1/2 * 2.0, 2.0 + 1/2 * 1.0) = (4.0, 2.5)
// rotation
// B = (4.0, 3.0)
// rotate B by 90 degrees COUNTER clockwise, F = (-3.0, 4.0)
// rotate B by 180 degrees COUNTER clockwise, G = (-4.0, -3.0)
// only used if more precision is needed
// default constructor
// user-defined
// name: `vec' is different from STL vector
// convert 2 points to vector a->b
// Euclidean distance
// return double
// returns the perimeter, which is the sum of Euclidian distances
// of consecutive line segments (polygon edges)
// remember that P[0] = P[n-1]
// returns the area
// Shoelace formula
// if all points are int
// result can be int(eger) until last step
// returns angle aob in rad
// note: to accept collinear points, we have to change the `> 0'
// returns true if point r is on the left side of line pq
// returns true if point r is on the same line as the line pq
// returns true if we always make the same turn while examining
// all the edges of the polygon one by one
// a point/sz=2 or a line/sz=3 is not convex
// remember one result
// then compare with the others
// different sign -> this polygon is concave
// this polygon is convex
// returns true if point p is in either convex/concave polygon P
// avoid point or line
// assume the first vertex is equal to the last vertex
// left turn/ccw
// right turn/cw
// 360d -> in, 0d -> out, we have large margin
// line segment p-q intersect with line A-B.
// cuts polygon Q along the line formed by point a -> point b
// (note: the last point must be the same as the first point)
// Q[i] is on the left of ab
// edge (Q[i], Q[i+1]) crosses line ab
// make P's first point = P's last point
// sort the points lexicographically
// build lower hull
// build upper hull
// copy all points so that Pts is not affected
// corner cases: n=1=point, n=2=line, n=3=triangle
// safeguard from corner case
// the CH is P itself
// first, find P0 = point with lowest Y and if tie: rightmost X
// O(n)
// swap P[P0] with P[0]
// second, sort points by angle w.r.t. pivot P0, O(n log n) for this sort
// use this global variable as reference
// we do not sort P[0]
// special case
// check which one is closer
// compare 2 angles
// third, the ccw tests, although complex, it is just O(n)
// initial S
// then, we check the rest
// note: n must be >= 3 for this method to work, O(n)
// left turn, accept
// or pop the top of S until we have a left turn
// return the result, overall O(n log n) due to angle sorting
// 6 points, entered in counter clockwise order, 0-based indexing
// loop back
// 31.64
// 49.00
// 49.00
// false (P1 is the culprit)
//// the positions of P6 and P7 w.r.t the polygon
//7 P5--------------P4
//6 |                  \
//5 |                    \
//4 |   P7                P3
//3 |   P1___            /
//2 | / P6    \ ___    /
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9 101112
// outside this (concave) polygon
// false
// inside this (concave) polygon
// true
// cutting the original polygon based on line P[2] -> P[4] (get the left side)
//7 P5--------------P4
//6 |               |  \
//5 |               |    \
//4 |               |     P3
//3 |   P1___       |    /
//2 | /       \ ___ |  /
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9 101112
// new polygon (notice the index are different now):
//7 P4--------------P3
//6 |               |
//5 |               |
//4 |               |
//3 |   P1___       |
//2 | /       \ ___ |
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9
// smaller now 29.15
// 40.00
// running convex hull of the resulting polygon (index changes again)
//7 P3--------------P2
//6 |               |
//5 |               |
//4 |   P7          |
//3 |               |
//2 |               |
//1 P0--------------P1
//0 1 2 3 4 5 6 7 8 9
// now this is a rectangle
// precisely 28.00
// precisely 48.00
// true
// true
// true
// whenever possible, work with point_i
// default constructor
// constructor
// only used if more precision is needed
// default constructor
// constructor
// Heron's formula, split sqrt(a * b) into sqrt(a) * sqrt(b); in implementation
//====================================================================
// from ch7_01_points_lines
// a way to represent a line
// the answer is stored in the third parameter (pass by reference)
// vertical line is fine
// default values
// IMPORTANT: we fix the value of b to 1.0
// check coefficient a + b
// returns true (+ intersection point) if two lines are intersect
// no intersection
// solve system of 2 linear algebraic equations with 2 unknowns
// special case: test for vertical line to avoid division by zero
// name: `vec' is different from STL vector
// convert 2 points to vector a->b
// nonnegative s = [<1 .. 1 .. >1]
// shorter.same.longer
// translate p according to v
//====================================================================
// assumption: the required points/lines functions have been written
// returns 1 if there is an inCircle center, returns 0 otherwise
// if this function returns 1, ctr will be the inCircle center
// and r is the same as rInCircle
// no inCircle center
// compute these two angle bisectors
// get their intersection point
// assumption: the required points/lines functions have been written
// returns 1 if there is a circumCenter center, returns 0 otherwise
// if this function returns 1, ctr will be the circumCircle center
// and r is the same as rCircumCircle
// r = distance from center to 1 of the 3 points
// returns true if point d is inside the circumCircle defined by a,b,c
// a right triangle
// must be the same as above
// 1.00
// same, 1.00
// (3.00, 1.00)
// 2.50
// same, 2.50
// (2.00, 1.50)
// inside triangle and circumCircle
// outside the triangle but inside circumCircle
// slightly outside
// Law of Cosines
// Law of Sines
// Phytagorean Theorem
// Triangle Inequality
// yes
// no, actually straight line
// no
// World Finals Stockholm 2009, A - A Careful Approach, UVa 1079, LA 4445
// with certain landing order, and certain L, try
// landing those planes and see what is the gap to b[order[n - 1]]
// greedy, 1st aircraft lands ASAP
// for the other aircrafts
// can land: greedily choose max of a[order[i]] or targetLandingTime
// return +ve value to force binary search to reduce L
// return -ve value to force binary search to increase L
// 2 <= n <= 8
// plane i land safely at interval [ai, bi]
// originally in minutes, convert to seconds
// variable to be searched for
// permute plane landing order, up to 8!
// min 0s, max 1 day = 86400s
// start with an infeasible solution
// binary search L, EPS = 1e-3
// we want the answer rounded to nearest int
// round down first
// must increase L
// infeasible, must decrease L
// get the max over all permutations
// try all permutations
// other way for rounding is to use printf format string: %.0lf:%0.2lf
// round to nearest second
// Sharing Chocolate
// if this bit is on
// if (memo[h][S] != -1) return memo[w][S] = memo[h][S];
// if only one item
// Set one always belong to set #1, can reduce search space by half
// horizontal cut
// vertical cut
// O(32,768*16 = 524,288)
// special case: cannot
// try subproblems
// ACORN, UVa 1231, LA 4106
// there is an acorn here
// initialization
// from this tree, +1 above
// best from tree at height + f
// update this too
// solution will be here
// ignore the last number 0
// Free Parentheses
// Forming Quiz Teams
// if you have problems with this C++ code,
// consult your programming text books first...
/* Forming Quiz Teams, the solution for UVa 10911 above */
// using global variables is a bad software engineering practice,
// but it is OK for competitive programming
// 1 << 16 = 2^16, note that max N = 8
// DP state = bitmask
// we initialize `memo' with -1 in the main function
// this state has been computed before
// simply lookup the memo table
// all students are already matched
// the cost is 0
// initialize with a large value
// find the first bit that is off
// then, try to match p1
// with another bit p2 that is also off
// pick the minimum
// store result in a memo table and return
// freopen("10911.txt", "r", stdin);      // redirect input file to stdin
// yes, we can do this :)
// '%*s' skips names
// build pairwise distance table
// have you used `hypot' before?
// use DP to solve min weighted perfect matching on small general graph
// set -1 to all cells
// return 0;
// Gentlemen Agreement
// all intersections are visited
// one more possible set
// size of the set
// if intersection i is not yet used
// use i and its neighbors
// a more powerful, bit-wise adjacency list (for faster set operations)
// i to itself
// speed up
// just a backtracking with bitmask/subset
// Another n-Queen Problem
// done, 1 way found
// bit = all possible column positions
// list of forbidden column
// after negation, list of allowed columns, but it turns on more bits than necessary
// (1<<n) - 1, turn on n bits only, we want to concentrate on these n bits only
// now recursively count the ways
// try each bit that is turned on
// the first bit that is on
// for future iterations, forbid column t and left_diagonal/right diagonal that has t
// remove that bit t from 'bit'
// mark out the bad squares
// Editing a Book
// turn array into a number for efficiency
// BFS from s until nL depth, store the state distance in "dis",
// "ref" is a state distance from another BFS source.
// If a node exists in "ref" then return the "meet in the middle distance"
//    from source s and from another source (ref's source)
// limit to depth nL only
// we do not use while (!q.empty()) to ensure we only touch nL layers only
// unpack the digits again
// try all possible substring
// cut index [i..j]
// try all possible paste point
// paste at location k (using array a)
// touching the other side, this is the answer: L + 1 (this move) + from v to sorted state
// if revisited, ignore
// relax and push to queue again
// maximum distance (upperbound)
// precalculate bfs from 1, 12, 123, ..., 123456789
// the source
// only need to go 2 level deep, d[0] is blank at this stage
// up to n = 9, 1 digit, can be encoded as integer
// search from s = 123456789, if found, we have an answer
// otherwise, search from target v (2 level deep), if still not found, answer = 5
// maximum size of queue
// n is at most 9. Thus, it can be represented as a single integer.
// Fast shifter for the sequence of numbers.
// initial unmoved elements
// initial unmoved elements 
// move from  l ... r to begin at index k
// move from r ... k to begin at index l
// special case
// the distance and id are compressed as a single integer for speed up
// initially a pair of integer {distance, id}
// id represents whether it comes from src or tgt
// it is set to 1 and 3 for speedup when checking whether a key exists in the map or not
// binary representation :
// - bit-0 : always 1, indicating that a key is present in the map
// - bit-1 : 0 if it comes from src; 1 if it comes from tgt
// - the other bits : represents the distance
// it is faster to use fixed size of queue
// C(N, 3) loop for the edges
// key is present
// if key is not present, the default return value is 0
// it is guaranteed that the answer always exists
// adjust this value as needed
// input: N, Augmented Matrix Aug, output: Column vector X, the answer
// the forward elimination phase
// which row has largest column value
// remember this row l
// swap this pivot row, reason: minimize floating point error
// t is a temporary double variable
// the actual forward elimination phase
// the back substitution phase
// start from back
// the answer is here
// backtrack to current node
// we assume that the root is at index 0
// adjust this value as needed
// 2^14 = 16384 > 10000, adjust this value as needed
// Range Minimum Query
// constructor as well as pre-processing routine
// speed up powers of 2 and logarithmic computations
// initialization
// RMQ of sub array [j..j]
// the two nested loops below have overall time complexity = O(n log n)
// for each i s.t. 2^i <= n, O(log n)
// for each valid j, O(n)
// covers [j..j+2^i-1]
// covers [j+(1<<(i-1))..j+(1<<i)]
// 2^k <= (j-i+1)
// covers [i..i+2^k-1]
// covers [j-2^k+1..j]
// printf("%k = %d, i = %d, modj = %d, x = %d, y = %d\n", k, i, j-P2[k]+1, x, y);
// same example as in chapter 2: segment tree
// for (int i = 0; i < n; i++)
//   for (int j = i; j < n; j++)
//     printf("RMQ(%d, %d) = %d\n", i, j, rmq.query(i, j));
// 15-Puzzle Problem with IDA*
// ROW_SIZE is a matrix of 4 x 4
// E,N,W,S
// R,U,L,D
// heuristic: sum of Manhattan distances (compute all)
// Manhattan distance
// heuristic: sum of manhattan distances (compute delta)
// transform 16 numbers into 64 bits, exactly into ULL
// move left 4 bits
// add this digit (max 15 or 1111)
// not pure backtracking... this is to prevent cycling
// not good
// mark this as visited
// swap first
// if ok, no need to restore, just go ahead
// restore
// next limit
// nlim > lim
// pruning condition in the problem
// change to X (15)
// remember the index
// use 0-based indexing
// Roman Numerals
// from large to small
// check next char first
// by definition
// skip this char
// UVa 11616 will be trivial with AtoR and RtoA methods above
// char str[1000];
// while (gets(str) != NULL) {
//   if (isdigit(str[0])) AtoR(atoi(str));       // Arabic to Roman Numerals
//   else                 RtoA(str);             // Roman to Arabic Numerals
// }
// Tunnelling the Earth
// in meters
// 3D version
// standard Java class name in UVa OJ
// it is in the library!
// comment all lines and only uncomment demo code that you are interested with
// number of test cases
// shortcut to repeat until 0
// compute answer
// on the fly
// Scanner sc = new Scanner(new File("IO_in2.txt"));
// int a, b;
// // stop when both integers are 0
// while (true) {
//   a = sc.nextInt(); b = sc.nextInt();
//   if ((a == 0) && (b == 0)) break;
//   System.out.println(a+b);
// }
// Scanner sc = new Scanner(new File("IO_in3.txt"));
// // Scanner class has hasNext method
// while (sc.hasNext()) {
//   int a = sc.nextInt(), b = sc.nextInt();
//   System.out.println(a+b);
// }
// Scanner sc = new Scanner(new File("IO_in3.txt")); // same input file as before
// int c = 0;
// while (sc.hasNext()) {
//   int a = sc.nextInt(), b = sc.nextInt();
//   // notice the two '\n', Java System.out has printf too
//   System.out.printf("Case %d: %d\n\n", ++c, a+b);
// }
// Scanner sc = new Scanner(new File("IO_in3.txt")); // same input file as before
// int c = 0;
// while (sc.hasNext()) {
//   int a = sc.nextInt(), b = sc.nextInt();
//   if (c > 0) System.out.println(); // 2nd/more cases
//   System.out.printf("Case %d: %d\n", ++c, a+b);
// }
// Scanner sc = new Scanner(new File("IO_in4.txt"));
// while (sc.hasNext()) {
//   int k = sc.nextInt();
//   int ans = 0, v;
//   while (k-- > 0) { v = sc.nextInt(); ans += v; }
//   System.out.println(ans);
// }
// Scanner sc = new Scanner(new File("IO_in5.txt"));
// while (sc.hasNext()) { // keep looping
//   String[] token = sc.nextLine().split(" ");
//   int ans = 0;
//   for (int i = 0; i < token.length; ++i)
//     ans += Integer.parseInt(token[i]);
//   System.out.println(ans);
// }
# comment all lines and only uncomment demo code that you are interested with
# IO_in1.txt
# # IO_in2.txt
# import sys
# for line in sys.stdin.readlines():
#     if line == '0 0\n': break
#     print(sum(map(int, line.split())))
# # IO_in3.txt
# import sys
# for line in sys.stdin.readlines():
#     print(sum(map(int, line.split())))
# # IO_in3.txt, same input file as before
# import sys
# for c, line in enumerate(sys.stdin.readlines(), 1):
#     print("Case %s: %s\n" % (c, sum(map(int, line.split()))))
# # IO_in3.txt, same input file as before
# import sys
# for c, line in enumerate(sys.stdin.readlines(), 1):
#     if c > 1: print()
#     print("Case %s: %s" % (c, sum(map(int, line.split()))))
# # IO_in4.txt
# import sys
# for line in sys.stdin.readlines():
#     print(sum(map(int, line.split()[1:]))) # skip the first integer
# # IO_in5.txt
# import sys
# for line in sys.stdin.readlines():
#     print(sum(map(int, line.split())))
// UVa default class name
// max N = 8
// 1<<16 = 2^16
// DP state = mask
// we initialize `memo' with -1.0 in the main function
// this has been computed
// all have been matched
// init with a large value
// find the first off bit
// then, try to match p1
// with other off bit p2
// pick the minimum
// store result in a table
// build distance table
// use `hypot' function
// DP to solve min weighted perfect matching on small general graph
// Java code for task 1
// Java has printf too!
// Java code for task 3
// 9 August 2010
// note that month starts from 0, so we need to put 7 instead of 8
// "Mon"
// today
// ans grows over time
# Python code for task 3
# CP1 launch date
# 'Mon', %A for 'Monday'
# ans grows over time
# Python code for task 5
// Java code for task 9
// Java code for task 10
// Java code for task 11
// "cheat"
// Java code for task 12
// Big Integer
// This source code is not as complete as array_algorithms.cpp
// can use this primary field to decide sorted order
// ICPC rule: sort by number of problem solved
// solved == o.solved, but we can use
// secondary field to decide sorted order
// ICPC rule: sort by descending penalty
// solved == o.solved AND penalty == o.penalty
// sort based on increasing team ID
// sort descending with vector
// if we want to modify comparison function, use the overloaded method: Collections.sort(List list, Comparator c);
// shuffle the content again
// sort ascending
// without sorting, they will be ranked like this:
// sort using a comparison function
// after sorting using ICPC rule, they will be ranked like this:
// output is -5 (explanation below)
/*
// sometimes these two useful simple macros are used
// note: for example usage of BitSet, see ch5/primes.java
// returns S % N, where N is a power of 2
// in binary representation
// to reverse the print order
// special case for i == 0
# returns S % N, where N is a power of 2
# in binary representation
// s is empty, true
// stack is LIFO, thus the content of s is currently like this:
// c <- top
// b
// a
// output 'c'
// pop topmost
// output 'b'
// s is not empty, false
// Queue is abstract, must be instantiated with LinkedList
// (special case for Java Queue)
// q is empty, true
// s  has 2 more items
// enqueue 'b', and then 'a' (the method name in Java Queue for push/enqueue operation is 'offer')
// add one more item
// prints 'b'
// in Java, it is harder to see the back of the queue...
// output 'b', 'a', then 'z' (until queue is empty), according to the insertion order above
// take the front first
// before popping it
// prints 'a - c'
// prints 'd - c'
// prints 'd - b'
// prints 'a - b'
# s is empty, true (1)
# stack is LIFO, thus the content of s is currently like this:
# c <- top
# b
# a
# output 'c'
# pop topmost
# output 'b'
# s is not empty, false
# q is empty, true (1)
# s has 2 more items
# enqueue 'b' and 'a'
# add one more item
# prints 'b'
# prints 'z'
# output 'b', 'a', then 'z' (until queue is empty), according to the insertion order above
# take the front first
# before popping it
# prints 'a - c'
# prints 'd - c'
# prints 'd - b'
# prints 'a - b'
// initial value {7,7,7,0,0} and thus initial size (5)
// initial size (5) and initial value {5,5,5,5,5}
// 7 and 5, for Java ArrayList, we must use 'get'
// arr = {0,1,2,3,4}
// v = {7,8,9,10,11}, but for Java ArrayList, we must use 'set'
// 2 and 9
// arr[5] = 5; // static array will generate ArrayIndexOutOfBoundsException
// // uncomment the line above to see the error
// ArrayList resizes itself (use method add)
// 77
# Python does not have static array
# Initial size (5) and initial value {5,5,5,5,5}
# 5
# v = {7,8,9,10,11}
# 9
# arr[5] = 5;   # index out of range error generated as index 5 does not exist
# uncomment the line above to see the error
# list will resize itself after appending
# 77
// note: there are many clever usages of this set/map
// that you can learn by looking at top coder's codes
// must use TreeSet as Set is an abstract class
// must use TreeMap as Map is an abstract class
// suppose we enter these 7 name-score pairs below
/*
// then the internal content of mapper MAY be something like this:
// re-read balanced BST concept if you do not understand this diagram
// the keys are names (string)!
//                        (grace,75) 
//           (billy,69)               (martin,81)   
//     (andy,80)   (felix,82)    (john,78)  (steven,77)
// iterating through the content of mapper will give a sorted output
// based on keys (names)
// map can also be used like this
// interesting usage of SubMap
// display data between ["f".."m") ('felix' is included, martin' is excluded)
// the internal content of used_values MAY be something like this
// the keys are values (integers)!
//                 (78) 
//         (75)            (81)   
//     (69)    (77)    (80)    (82)
// O(log n) search, found
// returns true
// returns [69, 75] (these two are before 77 in the inorder traversal of this BST)
// returns [77, 78, 80, 81, 82] (these five are equal or after 77 in the inorder traversal of this BST)
// O(log n) search, not found
// utilizing Java "Generics"
// introducing 'pair'
// overriding the compare method
// currently max heap, reverse these two to try produce min-heap
// suppose we enter these 7 money-name pairs below
/*
// inserting a pair in O(log n)
// this is how we use Java PriorityQueue
// priority queue will arrange items in 'heap' based
// on the first key in pair, which is money (integer), largest first
// if first keys tied, use second key, which is name, largest first
// the internal content of pq heap MAY be something like this:
// re-read (max) heap concept if you do not understand this diagram
// the primary keys are money (integer), secondary keys are names (string)!
//                        (2000,grace)
//           (100,steven)               (70,martin)   
//     (100,john)   (10,billy)     (20,andy)  (70,felix)
// let's print out the top 3 person with most money
// O(1) to access the top / max element + O(log n) removal of the top and repair the structure
# suppose we enter these 7 money-name pairs below
# priority queue will arrange items in 'heap' based
# on the first key in pair, which is money (integer), largest first
# if first keys tie, use second key, which is name, smallest first in python
# the internal content of pq heap MAY be something like this (we negated the weights to make python heap a max heap):
# re-read (max) heap concept if you do not understand this diagram
# the primary keys are money (integer), secondary keys are names (string)!
#                         (2000,grace)
#            (100,steven)               (70,martin)   
#let's print out the top 3 person with most money
# O(1) to access the top / max element and O(log n) to delete the top and repair the structure
// suppose we enter these 7 name-score pairs below
/*
// then the internal content of mapper/used_values are not really known
// (implementation dependent)
// iterating through the content of mapper will give a jumbled output
// as the keys are hashed into various slots
// map can also be used like this
// there is no headSet and tailSet in an unordered_map
// O(1) search, found
// returns true
// O(1) search, not found
// initialization: n + 1 zeroes, ignore index 0
// returns RSQ(1, j)
// returns RSQ(i, j)
// updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
// note: n = ft.size()-1
// idx   0 1 2 3 4 5 6 7  8 9 10, no index 0!
// ft = {-,0,0,0,0,0,0,0, 0,0,0}
// ft = {-,0,1,0,1,0,0,0, 1,0,0}, idx 2,4,8 => +1
// ft = {-,0,1,0,2,0,0,0, 2,0,0}, idx 4,8 => +1
// ft = {-,0,1,0,2,2,2,0, 4,0,0}, idx 5,6,8 => +2
// ft = {-,0,1,0,2,2,5,0, 7,0,0}, idx 6,8 => +3
// ft = {-,0,1,0,2,2,5,2, 9,0,0}, idx 7,8 => +2
// ft = {-,0,1,0,2,2,5,2,10,0,0}, idx 8 => +1
// ft = {-,0,1,0,2,2,5,2,10,1,1}, idx 9,10 => +1
// 0 => ft[1] = 0
// 1 => ft[2] = 1
// 7 => ft[6] + ft[4] = 5 + 2 = 7
// 11 => ft[10] + ft[8] = 1 + 10 = 11
// 6 => rsq(1, 6) - rsq(1, 2) = 7 - 1
// update demo
// now 13
# Example for https://open.kattis.com/problems/fenwick
# from sys import stdin, stdout
#
# def main():
#     n, q = [int(i) for i in stdin.readline().split(' ')]
#     f = FTree([0] * n)
#     for l in stdin.read()[:-1].split('\n'):
#         a = l.split(' ')
#         if a[0] == '?':
#             if a[1] == '0':
#                 stdout.write("0\n")
#             else:
#                 stdout.write("{}\n".format(f.q(1, int(a[1]))))
#         else:
#             f.u(int(a[1]) + 1, int(a[2]))
#
# main()
// Try this input for Adjacency Matrix/Adjacency List/Edge List
// Adjacency Matrix AM
//   for each line: |V| entries, 0 or the weight
// Adjacency List AL
//   for each line: num neighbors, list of neighbors + weight pairs
// Edge List EL
//   for each line: a-b of edge(a,b) and weight
/*
// we must know this size first!
// remember that if V is > 100, try NOT to use AM!
// O(|V|)
// for each vertex
// add this empty neighbor list to Adjacency List
// to 0-based indexing
// edges sorted by weight (smallest->largest)
# Try this input for Adjacency Matrix/Adjacency List/Edge List
# Adjacency Matrix AM
#    for each line: |V| entries, 0 or the weight
#  Adjacency List AL
#    for each line: num neighbors, list of neighbors + weight pairs
#  Edge List EL
#    for each line: a-b of edge(a,b) and weight
# we must know this size first!
# remember that if V is > 2000, try NOT to use AM!
#adjacency matrix
# O(|V|)
#initalize AL
# AL[0] contains the required information 
# build a heap
# edges sorted by weight (smallest->largest)
// the segment tree is stored like a heap array
// same as binary heap operations
// as L == R, either one is fine
// store the index
// recursively compute the values
// O(log n)
// current segment outside query range
// inside query range
// compute the min position in the left and right part of the interval
// if we try to access segment outside query
// same as above
// as as in build routine
// this update code is still preliminary, i == j
// must be able to update range in the future!
// if the current interval does not intersect 
// the update interval, return this st node value!
// if the current interval is included in the update range,
// update that st[node]
// update the underlying array
// this index
// compute the minimum position in the 
// left and right part of the interval
// return the position where the overall minimum is
// copy content for local usage
// create vector with length `len' and fill it with zeroes
// recursive build
// overloading
// the original array
// answer = index 2
// answer = index 5
// answer = index 4
// answer = index 0
// answer = index 1
// answer = index 5
// update A[5] from 11 to 100
// 2
// 4
// 0
// 1
// 5->2
// 5->4
// 5->4
// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics
// OOP style
// rank is used to keep the tree short
// create 5 disjoint sets
// 5
// 4
// 3
// 2
// will return false
// will return true
// findSet will return 1 for {0, 1} and 3 for {2, 3, 4}
// 1
// findSet will return 3 for {0, 1, 2, 3, 4}
# Example for https://open.kattis.com/problems/unionfind
# from sys import stdin, stdout
#
# def main():
#     n, q = [int(i) for i in stdin.readline().split(' ')]
#     u = UFDS(n)
#     for l in stdin.read()[:-1].split('\n'):
#         c, a, b = l.split(' ')
#         if c == '?':
#             stdout.write("yes\n" if u.find(int(a)) == u.find(int(b)) else "no\n")
#         else:
#             u.union(int(a), int(b))
#
# main()
/* 8 Queens Chess Problem */
// it is ok to use global variables in competitive programming
// check previously placed queens
// an infeasible solution if share same row or same diagonal
// try all possible row
// if can place a queen at this col and row...
// put this queen in this col and row
// a candidate solution & (a, b) has 1 queen
// recursively try next column
// generate all possible 8! candidate solutions
#      1 2 3 4 5 6 7 8\n")
# input
# try all possible O(n!) permutations, the largest nput 8! = 40320
# check all constraints, max 20, each check 8 = 160 
# all constraints are satisfied by this permutation
# the overall time complexity is thus O(m * n!)
# overall complexity = 160 * 40320 = 6M, should be doable with pruning...
# input
#iterate through all subsets
#pick Least Sig Bit
#trailing zeroes
// Collecting Beepers
// DP TSP
// Karel + max 10 beepers
// bitmask stores the visited coordinates
// return trip to close the loop
// O(n) here
// if coordinate nxt is not visited yet
// these two values are not used
// karel's position is at index 0
// build distance table
// Manhattan distance
// DP-TSP
// System.out.printf("The shortest path has length %d\n", dp(0, 1)); // DP-TSP
// some adjustments are needed
// a sample array A
// O(n)
// the overall running sum is still +ve
// keep the largest RSQ overall
// the overall running sum is -ve, we greedily restart here
// because starting from 0 is better for future
// iterations than starting from -ve running sum
// should be 9
// Maximum Sum, 0.150s in UVa (C++ version runs in 0.000s)
// UVa default class name
// pre-processing
// the lowest possible val
// Max 1D Range Sum on columns of this row
// Kadane's algorithm on rows
// restart if negative
# input
# How to use:
# 1) copy line 1-25
# 2) declare variable as SamInput()
# Ex: test = SamInput()
# 3) to read one line, use readln
# Ex: newline = test.readln()
# 4) to read one element(splitted by empty line / whitespace), use read
# Ex: newline = test.read()
# 5) remember, all this function will return a string, need to convert to int
# 6) if there is no more element/line, it will return False (boolean object)
#O(n^3) 1D DP + greedy (Kadane's) solution
#setting up the dp table
#the dimension of input square matrix
# only add columns of this row i
# lowest possible value
#max 1D Range Sum on columns in this row
#greedy, restart if running sum < 0
#Kadane's algo in rows
/* Coin Change, 1.492s in Java, 0.038s in C++ */
// O(NV) DP solution
// N and coinValue are fixed for this problem, max V is 7489
// This solution is TLE without using BufferedReader and PrintWriter
// we only need to initialize this once
// do not forget to do this
# input
# How to use:
# 1) copy line 1-25
# 2) declare variable as SamInput()
# Ex: test = SamInput()
# 3) to read one line, use readln
# Ex: newline = test.readln()
# 4) to read one element(splitted by empty line / whitespace), use read
# Ex: newline = test.read()
# 5) remember, all this function will return a string, need to convert to int
# 6) if there is no more element/line, it will return False (boolean object)
#my input will return False when it is arrived at the end of input
/* Cutting Sticks, 1.762s in Java, 0.302s in C++ */
// Top-Down DP
// start with left = 0 and right = n + 1
/* SuperSale */
// 0-1 Knapsack DP (Top-Down) - faster as not all states are visited
/* How do you add? */
// top-down
// only can use 1 number to add up to N
// the answer is definitely 1, that number itself
// if K > 1, we can choose one number from [0..N] to be one of the number
// and recursively compute the rest
// we just need the modulo 1M
// memoize them
// some recursion formula + top down DP
/* UVa 11450 - Wedding Shopping - Bottom Up */
// price[g (<= 20)][model (<= 20)]
// reachable table[money (<= 200)][g (<= 20)]
// to simplify coding, we store K in price[i][0]
// clear everything
// initial values
// if only using first garment g = 0
// for each remaining garment (note: this is written in column major)
// if can reach this state
// flag the rest
// as long as it is feasible
// the answer is in the last column
// nothing in this last column has its bit turned on
# UVa 11450 - Wedding Shopping - Bottom Up (faster than Top Down)
# 20 garments at most and 20 models per garment at most
# maximum budget is 200
# price[g (<= 20)][model (<= 20)]
#reachable = [[False for i in range(MAX_M)] for j in range(MAX_gm)] # reachable table[g (<= 20)][money (<= 200)]
# if using space saving technique
# reachable table[ONLY TWO ROWS][money (<= 200)]
# store number of models in price[g][0]
# initial values (base cases), using first garment g = 0
# for g in range(1, C):                            # for each remaining garment
#   for money in range(0, M):
#       if (reachable[g-1][money]):
#           for k in range(1, price[g][0]+1):
#               if (money-price[g][k] >= 0):
#                   reachable[g][money-price[g][k]] = True  # also reachable now
# money = 0
# while (money <= M and not reachable[C-1][money]):
#   money += 1
# then we modify the main loop in main a bit
# we start with this row
# for each remaining garment
# reset row
# IMPORTANT technique: flip the two rows
/* UVa 11450 - Wedding Shopping - Top Down */
// price[g (<= 20)][model (<= 20)]
// dp table memo[money (<= 200)][g (<= 20)]
// fail, return a large negative number (1B)
// we have bought last garment, done
// this state has been visited before
// try all possible models
// assign ans to dp table + return it!
// easy to code if you are already familiar with it
// to simplify coding, we store K in price[i][0]
// initialize DP memo table
// start the top-down DP
/*
// 1e9 to avoid overflow
// directed graph
// O(v^3) Floyd Warshall's
# if |V| > 450, you cannot use Floyd Washall's
# Graph in Figure 4.30
# 5 9
# 0 1 2
# 0 2 1
# 0 4 3
# 1 3 4
# 2 1 1
# 2 4 1
# 3 0 1
# 3 2 3
# 3 4 5
# directed graph
# loop order is k->u->v
// enough for sample graph in Figure 4.24/4.25/4.26
// we need these global variables
// define MAX_V appropriately
// traverse the BFS spanning tree as in print_path (section 4.3)
// reach the source, record minEdge in a global variable `f'
// recursive call
// alter residual capacities
/*
// Graph in Figure 4.25
// Graph in Figure 4.26.A
// Graph in Figure 4.26.B
// Graph in Figure 4.26.C
// run O(VE^2) Edmonds Karp to solve the Max Flow problem
// run BFS, please examine parts of the BFS code that is different than in Section 4.3
// #define INF 2000000000
// (we have to record the BFS spanning tree)
// (we need the shortest path from s to t!)
// immediately stop BFS if we already reach sink t
// note: enumerating neighbors with AdjMatrix is `slow'
// res[u][v] can change!
// parent of vertex v is vertex u
// find the min edge weight `f' along this path, if any
// if we cannot send any more flow (`f' = 0), terminate the loop
// we can still send a flow, increase the max flow!
// this is the max flow value of this flow graph
// global variables
// either greedy assignment or recurse
// we found one matching
// no matching
/*
// we know there are 6 vertices in this bipartite graph, l side are numbered 0,1,2, right side 3,4,5
//int V = 6, V_l = 3;
//int set1[] = new int[] {1,7,11}, set2[] = new int[] {4,10,12};
// Graph in Figure 4.41 can be built on the fly
// we know there are 5 vertices in this bipartite graph, l side are numbered 0,1, right side 3,4,5
// build the bipartite graph, only directed edge from l to right is needed
// store blank ArrayList first
// For bipartite graph in Figure 4.44, V = 5, Vleft = 3 (vertex 0 unused)
// AL[0] = {} // dummy vertex, but you can choose to use this vertex
// AL[1] = {3, 4}
// AL[2] = {3}
// AL[3] = {}   // we use directed edges from left to right set only
// AL[4] = {}
// store blank ArrayList first
// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics
// OOP style
// rank is used to keep the tree short
/*
// This example shows another form of reading graph input
// Kruskal's algorithm
// reorder as (w, u, v)
// sort by w, O(E log E)
// no edge has been taken
// all V are disjoint sets
// up to O(E)
// check
// add w of this edge
// link them
// 1 more edge is taken
// optimization
// note: the number of disjoint sets must eventually be 1 for a valid MST
# Union-Find Disjoint Sets Library written in OOP manner
# using both path compression and union by rank heuristics
# OOP style
# rank is used to keep the tree short
# set u as taken and enqueue neighbors of u
# sort by (inc) weight
# then by (inc) id
# Graph in Figure 4.10 left, format: list of weighted edges
# This example shows another form of reading graph input
# 5 7
# 0 1 4
# 0 2 4
# 0 3 6
# 0 4 6
# 1 2 2
# 2 3 8
# 3 4 9
# Kruskal's algorithm merged with Prim's algorithm
# the graph stored in AL
# read as (u, v, w)
# reorder as (w, u, v)
# sort by w, O(E log E)
# all V are disjoint sets
# for each edge, O(E)
# check
# 1 more edge is taken
# add w of this edge
# link them
# note: the runtime cost of UFDS is very light
# note: the number of disjoint sets must eventually be 1 for a valid MST
# to avoid cycle, no vertex is taken
# to select shorter edges
# take+process vertex 0
# no edge has been taken
# until we take V-1 edges
# we have not taken u yet
# 1 more edge is taken
# add w of this edge
# take+process vertex u
# each edge is in pq once
// global boolean flag to avoid cycle
// priority queue to help choose shorter edges
//  we do not need to use -ve sign to reverse the sort order
/*
// This example shows another form of reading graph input
// inside int main() --- assume the graph is stored in AL, pq is empty
// a blank ArrayList
// sort by edge weight O(E log E)
// PQ default: sort descending. Trick: use <(negative) weight(i, j), <i, j> >
// no edge has been taken
// no vertex has been taken
// take & process vertex 0
// up to O(E)
// no need to negate id/weight
// already taken, skipped
// add w of this edge
// take+process vertex u
// 1 more edge is taken
// optimization
/*
// Graph in Figure 4.19, negative cycle exists
// Bellman Ford's routine, basically = relax all E edges V-1 times
// INF = 1e9 here
// total O(V*E)
// optimization
// these two loops = O(E)
// important check
// not improving, skip
// relax operation
// optimization
// one more pass to check
// should be false
// if true => -ve cycle
# Graph in Figure 4.18, has negative weight, but no negative cycle
# 5 5 0
# 0 1 1
# 0 2 10
# 1 3 2
# 2 3 -10
# 3 4 3
# Graph in Figure 4.19, negative cycle exists, Bellman Ford's can detect this
# 3 3 0
# 0 1 1000
# 1 2 15
# 2 1 -42
# Bellman Ford's routine, basically = relax all E edges V-1 times
# INF = 1e9 here
# total O(V*E)
# optimization
# these two loops = O(E)
# important check
# not improving, skip
# relax operation
# optimization
# optimization
# one more pass to check
# should be false
# if true => -ve cycle
/*
// This example shows another form of reading graph input
// as an example, we start from this source, see Figure 4.3
// BFS routine inside void main(String[] args) -- we do not use recursion
// INF = 1e9 here
// p is global
// for output printing
// additional feature
// w ignored
// dist[v] != INF now
// parent of v is u
// for next iteration
// same parity
# Graph in Figure 4.3, format: list of unweighted edges
# This example shows another form of reading graph input
# 13 16
# 0 1    1 2    2  3   0  4   1  5   2  6    3  7   5  6
# 4 8    8 9    5 10   6 11   7 12   9 10   10 11  11 12
# as an example, we start from this source, see Figure 4.3
# BFS routine inside main() -- we do not use recursion
# p is global
# for output printing
# additional feature
# w ignored
# dist[v] != INF now
# parent of v is u
# for next iteration
# same parity
/*
// INF = 1e9 here
// Original Dijkstra's algorithm
/*
// dist[u] = INF
// but dist[s] = 0
// sort the pairs by non-decreasing distance from s
// main loop
// shortest unvisited u
// all edges from u
// not improving, skip
// erase old pair
// relax operation
// enqueue better pair
// (Modified) Dijkstra's algorithm
// sort the pairs by non-decreasing distance from s
// main loop
// shortest unvisited u
// a very important check
// all edges from u
// not improving, skip
// relax operation
// enqueue better pair
# Graph in Figure 4.17
# 5 7 0
# 0 1 2
# 0 2 6
# 0 3 7
# 1 3 3
# 1 4 6
# 2 4 1
# 3 4 5
# directed graph
# (Modified) Dijkstra's routine
# sort the pairs by non-decreasing distance from s
# main loop
# shortest unvisited u
# a very important check
# all edges from u
# not improving, skip
# relax operation
/*
// Graph in Figure 4.19, negative cycle exists, SPFA will be trapped in an infinite loop/produces WA (stop only when overflow happens)
// SPFA from source S
// INF = 1e9 here
// like BFS queue
// unique to SPFA
// pop from queue
// not improving, skip
// relax operation
// add to the queue
// only if v is not
// already in the queue
# SPFA from source S
# initially, only source vertex s has dist[s] = 0 and in the queue
# pop from queue
# not improving, skip
# relax operation
# add to the queue
# only if v is not
# already in the queue
// we only need this
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// dfs_low[u] <= dfs_num[u]
// a tree edge
// special case, root
// for articulation point
// store this information first
// for bridge
// update dfs_low[u]
// a back edge and not direct cycle
// update dfs_low[u]
/*
// Right graph in Figure 4.6/4.7/4.8
// store blank vector first
// global variable
// special case
// now we need three flags
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// back vs bidirectional
// check edge properties
// color u as EXPLORED
// EXPLORED->UNVISITED
// a tree edge u->v
// EXPLORED->EXPLORED
// EXPLORED->VISITED
// color u as VISITED/DONE
/*
// Scanner sc = new Scanner(new File("dfs_cc_in.txt"));
/*
// store blank vector first
// we only need these two
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// normal usage
// this vertex is visited
// mark u as visited
// w ignored
// to avoid cycle
// recursively visits v
/*
// store blank vector first
// for each u in [0..V-1]
// if that u is unvisited
// we only need these two
// these variables have to be global to be easily accessible by our recursion (other ways exist)
// this is the only change
/*
// store blank vector first
// make sure that the given graph is DAG
// global variable
// global variable
// reverse ts or simply read the content of ts backwards
// classic DFS flood fill
/* UVa 469 - Wetlands of Florida, 0.659s in Java, 0.162s in C++ */
// S,SE,E,NE,N,NW,W,SW
// neighbors
// outside
// we want only c1
// important step to avoid cycling!
// coloring c1 -> c2, add 1 to answer
// recurse to neighbors
// inside the void main(String[] args) of the solution for UVa 469 - Wetlands of Florida
// read the implicit graph as global 2D array 'grid'/R/C and (row, col) query coordinate
// remove dummy line
// start of query
// index starts from 0!
// change water 'W' to '.'; count size of this lake
// restore for next query
// last test case
// next test case
// Bicoloring
// bidirectional
// add a Boolean flag
// as with original BFS
// don't record distances
// just record two colors
// u & v have same color
// a coloring conflict :(
// optional speedup
# Bicoloring
# bidirectional
# add one more boolean flag, initially true
# but, instead of recording distance,
# we just record two colors {0, 1}
# u & v have the same color
# we have a coloring conflict
// Beverages
// give index i to B1
// directed edge
// enqueue vertices with zero incoming degree into a (priority) queue pq
// min priority queue
// next to be processed
// smaller index first
// Kahn's algorithm
// process u here
// virtually remove u->v
// not a candidate, skip
// enqueue v in pq
// dummy
# Beverages
#{}: Dilbert should drink beverages in this order:".format(caseNo))
# enqueue vertices with zero incoming degree into a (priority) queue pq
# min priority queue
# all vertices with 0 in-degree can be processed
# smaller index goes first
# Kahn's algorithm
# process u
# virtually 'remove' u->v
# v is the next candidate
# smallest id to front
// Come and Go
// check if the graph is strongly connected, i.e. the SCC of the graph is the graph itself (only 1 SCC)
// 0.835s in Java, 0.092s in C++
// global variables
// dfs_low[u] <= dfs_num[u]
// stores u in a vector based on order of visitation
// a tree edge
// condition for update
// a root/start of an SCC
// pass = 1 (original), 2 (transpose)
// as in finding topological order in Section 4.2.5
// the transposed graph
// always
// if this is two way, add the reverse direction
// run Tarjan's SCC code here
// dfs_num = new ArrayList<>(Collections.nCopies(N, UNVISITED));
// dfs_low = new ArrayList<>(Collections.nCopies(N, 0));
// visited = new ArrayList<>(Collections.nCopies(N, 0));
// St = new Stack<>();
// dfsNumberCounter = numSCC = 0;
// for (int u = 0; u < N; ++u)
//   if (dfs_num.get(u) == UNVISITED)
//     tarjanSCC(u);
// run Kosaraju's SCC code here
// first pass: record the post-order of original graph
// second pass: explore SCCs using first pass order
// if SCC is only 1, print 1, otherwise, print 0
// 10^7 should be enough for most cases
// compact list of primes in form of vector<int>
// first part
// create list of primes in [0..upperbound]
// add 1 to include upperbound
// set all bits to 1
// except index 0 and 1
// cross out multiples of i starting from i * i!
// also add this vector containing list of primes
// call this method in main method
// a good enough deterministic prime tester
// O(1) for small primes
// it takes longer time if N is a large prime!
// note: only work for N <= (last prime in vi "primes")^2
// second part
// remember: vi is vector of integers, long is long long
// vi `primes' (generated by sieve) is optional
// using PF = 2, 3, 4, ..., is also ok
// stop at sqrt(N), but N can get smaller
// remove this PF
// only consider primes!
// special case if N is actually a prime
// if pf exceeds 32-bit integer, you have to change vi
// third part
// count this pf only once
// start from ans = 1
// count the power
// according to the formula
// (last factor has pow = 1, we add 1 to it)
// start from ans = 1
// formula
// last one
// start from ans = N
// only count unique factor
// last factor
// first part: the Sieve of Eratosthenes
// can go up to 10^7 (need few seconds)
// 10-digits prime
// not a prime, 104729*1299709
// second part: prime factors
// slowest, 2147483647 is a prime
// slow, 2 large pfactors 104729*1299709
// faster, 2^10*3^4*5*7^4*11*13
//res = primeFactors((long)(1010189899 * 1010189899)); // "error"
//for (vi::iterator i = res.begin(); i != res.end(); i++) System.out.printf("^ %d\n", *i);
// third part: prime factors variants
// 2^1 * 5^2 => 3
// 2^1 * 5^2 => 2
// 2^1 * 5^2 => 2 + 5 + 5 = 12
// 1, 2, 5, 10, 25, 50, 6 divisors
// 1 + 2 + 5 + 10 + 25 + 50 = 93
// 20 integers < 50 are relatively prime with 50
// Pseudo-Random Numbers, 0.288s in Java, 0.022s in C++
// function "int f(int x)" must be defined earlier
// 1st part: finding k*mu, hare's speed is 2x tortoise's
// f(x0) is the node next to x0
// 2nd part: finding mu, hare and tortoise move at the same speed
// 3rd part: finding lambda, hare moves, tortoise stays
# Pseudo-Random Numbers, 0.288s in Java, 0.022s in C++, 0.160s in Python
# 1st part: finding k*mu, hare's speed is 2x tortoise's
# f(x0) is the node next to x0
# 2nd part: finding mu, hare and tortoise move at the same speed
# 3rd part: finding lambda, hare moves, tortoise stays
// 0.189s in Java
// UVa 01230 (LA 4104)
// valueOf converts
// simple integer
// into BigInteger
// it's in the library!
// Modular Fibonacci, 0.282s in Java, 0.019s in C++
// O(n^3 ~> 1) as n=2
// modulo arithmetic is used here
// O(n^3 log p ~> log p)
// prepare identity matrix
// iterative version of Divide & Conquer exponentiation
// check if p is odd (the last bit is on)
// update ans
// square the base
// divide p by 2
// special Fibonaccci matrix
// set MOD = 2^m
// O(log n)
// this if fib(n)
// 2.788s in Java
// UVa 10235
// certainty 10 is enough
/*
// old (and longer) C++ code for comparison
// 0.345s in Java
// Kattis basicremains
// test cases are small
// the second parameter
// is the base
// can output in any base
// 0.212s in Java
// UVa 10814
// we have to use > 0
// ignore this `/' char
// wow :)
# 0.040s in Python
# Python's built in fractions module
// 0.572s in Java using Scanner
// 0.110s in Java using BufferedReader/PrintWriter
// in package java.math
// UVa 10925 - Krakovia
// use BufferedReader
// and PrintWriter
// = fast IO
// N bills
// F friends
// built-in constant
// sum the N large bills
// string constructor
// BigInteger addition
// divide the large sum to F friends
# make Python I/O a bit faster
# N bills, F friends
# native Big Integer support
# sum the N large bills
# native Big Integer, will not overflow
#%d costs %d: each friend should pay %d\n"
# integer divide the large sum to F friends
// make sure ch is in lowercase
// technique to differentiate first line with the other lines
// to differentiate whether the previous line contains a dash or not
// if the last character is '-', delete it
// only append " " if this line is the second one onwards
// we can use str[i] as terminating condition as string in C++ is also terminated with NULL (0)
// make each character lower case
// already returns 1 or 0
// T = text, P = pattern
// n = length of T, m = length of P
// b = back table
// try all potential starting indices
// use boolean flag `found'
// if mismatch found
// abort this, shift starting index i by +1
// if P[0 .. m - 1] == T[i .. i + m - 1]
// call this before calling kmpSearch()
// starting values
// pre-process the pattern string P
// if different, reset j using b
// if same, advance both pointers
// observe i = 8, 9, 10, 11, 12 with j = 0, 1, 2, 3, 4
// in the example of P = "SEVENTY SEVEN" above
// this is similar as kmpPreprocess(), but on string T
// starting values
// search through string T
// if different, reset j using b
// if same, advance both pointers
// a match found when j == m
// prepare j for the next possible match
/*
// strncmp-in-java-SA-code-not-needed,java-LRS-minor-bug
// the input string, up to 100K characters
// the length of input string
// rank array and temporary rank array
// suffix array and temporary suffix array
// for counting/radix sort
// the pattern string (for string matching)
// the length of pattern string
// for computing longest common prefix
// LCP[i] stores the LCP between previous suffix "T + SA[i-1]" and current suffix "T + SA[i]"
// up to 255 ASCII chars or length of n
// clear frequency table
// count the frequency of each rank
// shuffle the suffix array if necessary
// update the suffix array SA
// this version can go up to 100000 characters
// initial rankings
// initial SA: {0, 1, 2, ..., n-1}
// repeat sorting process log n times
// actually radix sort: sort based on the second item
// then (stable) sort based on the first item
// re-ranking; start from rank r = 0
// compare adjacent suffices
// if same pair => same rank r; otherwise, increase r
// update the rank array RA
// default value
// compute Phi in O(n)
// remember which suffix is behind this suffix
// compute Permuted LCP in O(n)
// special case
// L will be increased max n times
// L will be decreased max n times
// compute LCP in O(n)
// put the permuted LCP back to the correct position
// string matching in O(m log n)
// valid matching = [0 .. n-1]
// find lower bound
// this is round down
// try to find P in suffix 'mid'
// prune upper half (notice the >= sign)
// prune lower half including mid
// observe `=' in "res >= 0" above
// if not found
// if lower bound is found, find upper bound
// prune upper half
// prune lower half including mid
// (notice the selected branch when res == 0)
// special case
// return lower/upper bound as the first/second item of the pair, respectively
// print out the length and the actual LRS
// O(n)
// print out the length and the actual LCS
// not used in Java version
// char ans[MAX_N];
// strcpy(ans, "");
//System.out.printf("\nRemember, T = '%s'\nNow, enter another string P:\n", new String(T));
// T already has '.' at the back
// append P and '#'
// update n
// O(n log n)
// O(n)
// different owner
// not used in Java version
// strncpy(ans, T + SA[i], maxLCP);
// ans[maxLCP] = 0;
//System.out.printf("Enter a string T below, we will compute its Suffix Array:\n");
// O(n log n)
// O(n)
// LRS demo
// find the longest repeated substring of the first input string
// stringMatching demo
//System.out.printf("\nNow, enter a string P below, we will try to find P in T:\n");
// LCS demo
// find the longest common substring between T and P
// note that the LRS and LCS demo are slightly different in Java version
// Needleman Wunsnch's algorithm
// insert/delete = -1 point
// match = 2 points, mismatch = -1 point
// cost for match or mismatches
// insert/delete = -1 point
// delete
// insert
# Needleman Wunsnch's algorithm
# match = 2 points, mismatch = -1 point
# insert/delete = -1 point
# delete
# insert
// whenever possible, work with point_i
// default constructor
// constructor
// only used if more precision is needed
// default constructor
// constructor
// all integer version
// all integer
// inside/border/outside
// circle equation, inside, border, outside
// 0-inside
// 1-at border
// 2-outside
// we will use constant Math.PI in Java
//struct point_i { int x, y; };        // basic raw form, minimalist mode
// whenever possible, work with point_i
// default constructor
// user-defined
// only used if more precision is needed
// default constructor
// user-defined
// use EPS (1e-9) when testing equality of two floating points
// override less than operator
// useful for sorting
// first: by x-coordinate
// second: by y-coordinate
// they are equal
// Euclidean distance
// Math.hypot(dx, dy) returns sqrt(dx * dx + dy * dy)
// return double
// rotate p by theta degrees CCW w.r.t origin (0, 0)
// multiply theta with PI / 180.0
// a way to represent a line
// the answer is stored in the third parameter
// vertical line is fine
// IMPORTANT: we fix the value of b to 1.0
// not needed since we will use the more robust form: ax + by + c = 0 (see above)
// another way to represent a line
// special case: vertical line
// l contains m = INF and c = x_value
// to denote vertical line x = x_value
// we need this return variable to differentiate result
// l contains m and c of the line equation y = mx + c
// check coefficients a & b
// also check coefficient c
// returns true (+ intersection point) if two lines are intersect
// no intersection
// solve system of 2 linear algebraic equations with 2 unknowns
// special case: test for vertical line to avoid division by zero
// name: `vec' is different from Java Vector
// convert 2 points to vector
// nonnegative s = [<1 .. 1 .. >1]
// shorter.same.longer
// translate p according to v
// convert point and gradient/slope to line
// always -m
// always 1
// compute this
// perpendicular to l and pass through p
// special case 1: vertical line
// special case 2: horizontal line
// normal line
// intersect line l with this perpendicular line
// the intersection point is the closest point
// returns the reflection of point on a line
// similar to distToLine
// create a vector
// translate p twice
// returns the distance from p to the line defined by
// two points a and b (a and b must be different)
// the closest point is stored in the 4th parameter
// formula: c = a + u * ab
// translate a to c
// Euclidean distance between p and c
// returns the distance from p to the line segment ab defined by
// two points a and b (still OK if a == b)
// the closest point is stored in the 4th parameter
// closer to a
// Euclidean distance between p and a
// closer to b
// Euclidean distance between p and b
// run distToLine as above
// returns angle aob in rad
//// another variant
//int area2(point p, point q, point r) { // returns 'twice' the area of this triangle A-B-c
//  return p.x * q.y - p.y * q.x +
//         q.x * r.y - q.y * r.x +
//         r.x * p.y - r.y * p.x;
//}
// note: to accept collinear points, we have to change the `> 0'
// returns true if point r is on the left side of line pq
// returns true if point r is on the same line as the line pq
// note that both P1 and P2 are (0.00, 0.00)
// true
// false
// sorting points demo
// rearrange the points as shown in the diagram below
/*
// should be 5.000
// line equations
// should be -0.50 * x + 1.00 * y - 1.00 = 0.00
// a vertical line, not a problem in "ax + by + c = 0" representation
// should be 1.00 * x + 0.00 * y - 2.00 = 0.00
// parallel, same, and line intersection tests
// no
// yes, l1 (P[0]-P[1]) and l3 (P[2]-P[3]) are parallel
// no
// yes, l2 (P[0]-P[2]) and l4 (P[2]-P[4]) are the same line (note, they are two different line segments, but same line)
// yes, l1 (P[0]-P[1]) and l2 (P[0]-P[2]) are intersect at (2.0, 2.0)
// other distances
// closer to A (or P[2]) = (2.00, 4.00)
// closer to midway between AB = (3.20, 4.60)
// closer to B (or P[3]) = (6.00, 6.00)
// should be (0.00, 3.00)
// 90 degrees
// 63.43 degrees
// 180 degrees
// no
// yes
// no
// yes
// collinear if r(35, 31)
// right
/*
// translation
// imagine there is an arrow from A to B (see the diagram above)
// D will be located in coordinate (3.0 + 2.0, 2.0 + 1.0) = (5.0, 3.0)
// E will be located in coordinate (3.0 + 1/2 * 2.0, 2.0 + 1/2 * 1.0) = (4.0, 2.5)
// rotation
// B = (4.0, 3.0)
// rotate B by 90 degrees COUNTER clockwise, F = (-3.0, 4.0)
// rotate B by 180 degrees COUNTER clockwise, G = (-4.0, -3.0)
// In Java, we can use Math.PI instead of using Math.acos(-1.0)
// only used if more precision is needed
// default constructor
// user-defined
// use EPS (1e-9) when testing equality of two floating points
// override less than operator
// useful for sorting
// first: by x-coordinate
// second: by y-coordinate
// they are equal
// name: `vec' is different from Java Vector
// convert 2 points to vector
// Euclidean distance
// return double
// returns the perimeter, which is the sum of Euclidian distances
// of consecutive line segments (polygon edges)
// remember that P[0] = P[n-1]
// returns the area, which is half the determinant
// works for both convex and concave polygons
// returns angle aob in rad
// note: to accept collinear points, we have to change the `> 0'
// returns true if point r is on the left side of line pq
// returns true if point r is on the same line as the line pq
// returns true if we always make the same turn while examining
// all the edges of the polygon one by one
// a point/sz=2 or a line/sz=3 is not convex
// remember one result
// then compare with the others
// different sign -> this polygon is concave
// this polygon is convex
// returns true if point p is in either convex/concave polygon P
// assume first vertex = last vertex
// left turn/ccw
// right turn/cw
// line segment p-q intersect with line A-B.
// cuts polygon Q along the line formed by point a -> point b
// (note: the last point must be the same as the first point)
// Q[i] is on the left of ab
// edge (Q[i], Q[i+1]) crosses line ab
// make P's first point = P's last point
// safeguard from corner case
// special case, the CH is P itself
// first, find P0 = point with lowest Y and if tie: rightmost X
// swap P[P0] with P[0]
// second, sort points by angle w.r.t. P0
// use this global variable as reference
// angle-sorting function
// which one is closer?
// third, the ccw tests
// initial S
// then, we check the rest
// note: n must be >= 3 for this method to work
// left turn, accept
// or pop the top of S until we have a left turn
// return the result
// 6 points, entered in counter clockwise order, 0-based indexing
// loop back
// 31.64
// 49.00
// false (P1 is the culprit)
//// the positions of P6 and P7 w.r.t the polygon
//7 P5--------------P4
//6 |                  \
//5 |                    \
//4 |   P7                P3
//3 |   P1___            /
//2 | / P6    \ ___    /
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9 101112
// outside this (concave) polygon
// false
// inside this (concave) polygon
// true
// cutting the original polygon based on line P[2] -> P[4] (get the left side)
//7 P5--------------P4
//6 |               |  \
//5 |               |    \
//4 |               |     P3
//3 |   P1___       |    /
//2 | /       \ ___ |  /
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9 101112
// new polygon (notice the index are different now):
//7 P4--------------P3
//6 |               |
//5 |               |
//4 |               |
//3 |   P1___       |
//2 | /       \ ___ |
//1 P0              P2
//0 1 2 3 4 5 6 7 8 9
// smaller now 29.15
// 40.00
// running convex hull of the resulting polygon (index changes again)
//7 P3--------------P2
//6 |               |
//5 |               |
//4 |   P7          |
//3 |               |
//2 |               |
//1 P0--------------P1
//0 1 2 3 4 5 6 7 8 9
// now this is a rectangle
// precisely 28.00
// precisely 48.00
// true
// true
// true
// whenever possible, work with point_i
// default constructor
// constructor
// only used if more precision is needed
// default constructor
// constructor
// Heron's formula, split sqrt(a * b) into sqrt(a) * sqrt(b); in implementation
//====================================================================
// from ch7_01_points_lines
// a way to represent a line
// the answer is stored in the third parameter
// vertical line is fine
// IMPORTANT: we fix the value of b to 1.0
// check coefficients a & b
// returns true (+ intersection point) if two lines are intersect
// no intersection
// solve system of 2 linear algebraic equations with 2 unknowns
// special case: test for vertical line to avoid division by zero
// name: `vec' is different from Java Vector
// convert 2 points to vector
// nonnegative s = [<1 .. 1 .. >1]
// shorter.same.longer
// translate p according to v
//====================================================================
// assumption: the required points/lines functions have been written
// returns 1 if there is an inCircle center, returns 0 otherwise
// if this function returns 1, ctr will be the inCircle center
// and r is the same as rInCircle
// no inCircle center
// compute these two angle bisectors
// get their intersection point
// assumption: the required points/lines functions have been written
// returns r, the radius of the circumCircle if there is a circumCenter center,
// and set ctr to be the circumCircle center
// returns 0 otherwise
// distance from center to 1 of the 3 points
// returns true if point d is inside the circumCircle defined by a,b,c
// a right triangle
// must be the same as above
// 1.00
// same, 1.00
// (3.00, 1.00)
// 2.50
// same, 2.50
// (2.00, 1.50)
// inside triangle and circumCircle
// outside the triangle but inside circumCircle
// slightly outside
// Law of Cosines
// Law of Sines
// Phytagorean Theorem
// Triangle Inequality
// yes
// no, actually straight line
// no
// World Finals Stockholm 2009, A - A Careful Approach, UVa 1079, LA 4445, 0.???s in Java, 0.578s in C++
// with certain landing order, and certain L, try
// landing those planes and see what is the gap to b[order[n - 1]]
// greedy, 1st aircraft lands ASAP
// for the other aircrafts
// can land: greedily choose max of a[order[i]] or targetLandingTime
// return +ve value to force binary search to reduce L
// return -ve value to force binary search to increase L
// Java does not have next_permutation like C++ <algorithm>
// do things to curPermute
// min 0s, max 1 day = 86400s
// start with an infeasible solution
// binary search L, EPS = 1e-3
// we want the answer rounded to nearest int
// round down first
// must increase L
// infeasible, must decrease L
// get the max over all permutations
// 2 <= n <= 8
// plane i land safely at interval [ai, bi]
// originally in minutes, convert to seconds
// variable to be searched for
// permute plane landing order, up to 8!
// other way for rounding is to use printf format string: %.0lf:%0.2lf
// round to nearest second
// one digit?
// ACORN, UVa 1231, LA 4106, 0.???s in Java (submission error?), 0.344s in C++
// there is an acorn here
// initialization
// from this tree, +1 above
// best from tree at height + f
// update this too
// solution will be here
// ignore the last number 0
/* UVa 10911 - Forming Quiz Teams, 0.462s in Java, 0.032s in C++ */
// this is 2^16, max N = 8
// DP state = bitmask
// we initialize `memo' with -1 in the main function
// this state has been computed before
// simply lookup the memo table
// all students are already matched
// the cost is 0
// initialize with a large value
// find the first bit that is off
// then, try to match p1
// with another bit p2 that is also off
// pick the minimum
// store result in a memo table and return
// dummy
// use DP to solve min weighted perfect matching on small general graph
// adjust this value as needed
// adjust this value as needed
// input: N, Augmented Matrix Aug, output: Column vector X, the answer
// the forward elimination phase
// which row has largest column value
// remember this row l
// swap this pivot row, reason: minimize floating point error
// t is a temporary double variable
// the actual forward elimination phase
// the back substitution phase
// start from back
// the answer is here
// backtrack to current node
// we assume that the root is at index 0
// x = (x^2 % n + b) % n
// special
// rand for luck
// initially y = x
// x = f(x)
// y = f(f(y))
// d = (x-y) % n
// if d != 1
// d is one of the divisor of composite number n
// special case, n = 1
// n is a prime, the only factor is n
// n is a composite number, can be split
// recursive check to divisor
// and n/divisor
// Big
// factorize n to 7 x 124418296927 x 143054969437
// Range Minimum Query
// adjust this value as needed
// constructor as well as pre-processing routine
// RMQ of sub array starting at index i + length 2^0=1
// the two nested loops below have overall time complexity = O(n log n)
// for each j s.t. 2^j <= n, O(log n)
// for each valid i, O(n)
// RMQ
// start at index i of length 2^(j-1)
// start at index i+2^(j-1) of length 2^(j-1)
// 2^k <= (j-i+1)
// same example as in chapter 2: segment tree
// 15-Puzzle Problem with IDA*, 2.975s in Java, 1.758s in C++
// ROW_SIZE is a matrix of 4 x 4
// E,N,W,S
// R,U,L,D
// heuristic: sum of Manhattan distances (compute all)
// Manhattan distance
// heuristic: sum of manhattan distances (compute delta)
// transform 16 numbers into 64 bits, exactly into ULL
// move left 4 bits
// add this digit (max 15 or 1111)
// not pure backtracking... this is to prevent cycling
// not good
// mark this as visited
// swap first
// if ok, no need to restore, just go ahead
// restore
// next limit
// nlim > lim
// pruning condition in the problem
// change to X (15)
// remember the index
// use 0-based indexing
// Roman Numerals, 0.986s in Java (almost TLE), only 0.032s in C++
// process from larger values to smaller values
// check next char first
// by definition
// skip this char
// Arabic to Roman Numerals
// Roman to Arabic Numerals
// Tunnelling the Earth
// Great Circle distance + Euclidean distance
// 0.852s in Java, 0.019s in C++
// in meters
// 3D version
