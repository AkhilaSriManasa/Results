________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\AndroidPlayer\jni\engine.cpp
//----------------------------------------------------------------------------------
// File:        native_basic/jni/engine.cpp
// SDK Version: v10.14 
// Email:       tegradev@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2007-2012, NVIDIA CORPORATION.  All rights reserved.
//
// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA OR ITS SUPPLIERS
// BE  LIABLE  FOR  ANY  SPECIAL,  INCIDENTAL,  INDIRECT,  OR  CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//
//----------------------------------------------------------------------------------
//To work around http://code.google.com/p/android/issues/detail?id=23203
//we don't link with the crt objects. In some configurations, this means
//a lack of the __dso_handle symbol because it is defined there, and
//depending on the android platform and ndk versions used, it may or may
//not be defined in libc.so. In the latter case, we fail to link. Defining
//it here as weak makes us provide the symbol when it's not provided by
//the crt objects, making the change transparent for future NDKs that
//would fix the original problem. On older NDKs, it is not a problem
//either because the way __dso_handle was used was already broken (and
//the custom linker works around it).
//__attribute__((weak)) void *__dso_handle;
// _SAMPLE
//jclass activityClass = (app->activity->env)->GetObjectClass(app->activity->clazz);
// _ENGINE
//DestroyRenderWindow(mainWnd);
// _ENGINE
// _SAMPLE
/* all are split */
// should look up by font file name.
// should look up by font file name.
// should look up by font file name.
//// ----- Core initialization -----
//BE1::Engine::InitParms initParms;
//BE1::Str appDir = BE1::PlatformFile::ExecutablePath();
//initParms.baseDir = appDir;
//BE1::Str dataDir = appDir + "/Data";
//initParms.searchPath = dataDir;
//BE1::Engine::Init(&initParms);
//// -------------------------------
//BE1::resourceGuidMapper.Read("Data/guidmap");
//// mainWindow(UIWindow) - rootViewController.view(UIView) - eaglView(EAGLView)
//CGRect screenBounds = [[UIScreen mainScreen] bounds];
//mainWindow = [[UIWindow alloc] initWithFrame:screenBounds];
//mainWindow.backgroundColor = [UIColor blackColor];
//rootViewController = [[RootViewController alloc] init];
//mainWindow.rootViewController = rootViewController;
//[mainWindow makeKeyAndVisible];
//BE1::gameClient.Init((__bridge BE1::Renderer::WindowHandle)mainWindow, true);
/*&mEgl*/, true);
//float retinaScale = [[UIScreen mainScreen] scale];
//BE1::Vec2 screenScaleFactor(0.75f, 0.75f);
//int renderWidth = screenBounds.size.width * retinaScale * screenScaleFactor.x;
//int renderHeight = screenBounds.size.height * retinaScale* screenScaleFactor.y;
//app.mainRenderContext = BE1::renderSystem.AllocRenderContext(true);
//app.mainRenderContext->Init((__bridge BE1::Renderer::WindowHandle)[rootViewController view],
//	renderWidth, renderHeight, DisplayContext, NULL);
//app.Init();
////BE1::cmdSystem.BufferCommandText(BE1::CmdSystem::Append, L"exec \"autoexec.cfg\"\n");
// _SAMPLE
// set up viewport
// clear buffers as necessary
// do some game rendering here
// ...
// start rendering bitfont text overlaid here.
// we update the clock text >after< drawing so it will change on pause.
// done rendering overlaid text.
// _SAMPLE
// Each frame, we check to see if the window has resized.  While the
// various events we get _should_ cover this, in practice, it appears
// that the safest move across all platforms and OSes is to check at 
// the top of each frame
// Time stands still when we're auto-paused, and we don't
// automatically render
// This will try to set up EGL if it isn't set up
// When we first set up EGL completely, we also load our GLES resources
// If these are already set up or we succeed at setting them all up now, then
// we go ahead and render.
// forced rendering when needed for UI, etc
// Even if we are not interactible, we may be visible, so we
// HAVE to do any forced renderings if we can.  We must also
// check for resize, since that may have been the point of the
// forced render request in the first place!
//We only handle motion events (touchscreen) and key (button/key) events
// A tap on the screen takes us out of autopause into gameplay mode if
// we were paused.  No other touch processing is done.
// if we are in gameplay mode, we eat the back button and move into
// pause mode.  If we are already in pause mode, we allow the back
// button to be handled by the OS, which means we'll be shut down
// _SAMPLE
// A tap on the screen takes us out of autopause into gameplay mode if
// we were paused.  No other touch processing is done.
// The window is being shown, get it ready.
// Note that on ICS, the EGL size will often be correct for the new size here
// But on HC it will not be.  We need to defer checking the new res until the
// first render with the new surface!
// The window is being hidden or closed, clean it up.
// Move out of gameplay mode if we are in it.  But if we are
// in another dialog mode, leave it as-is
// ICS does not appear to require this, but on GB phones,
// not having this causes rotation changes to be delayed or
// ignored when we're in a non-rendering mode like autopause.
// The forced renders appear to allow GB to process the rotation
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\AndroidPlayer\jni\main.cpp
//----------------------------------------------------------------------------------
// File:        native_basic/jni/main.cpp
// SDK Version: v10.14 
// Email:       tegradev@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2007-2012, NVIDIA CORPORATION.  All rights reserved.
//
// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA OR ITS SUPPLIERS
// BE  LIABLE  FOR  ANY  SPECIAL,  INCIDENTAL,  INDIRECT,  OR  CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//
//----------------------------------------------------------------------------------
/**
//			LOGD("Config[%d] is the new best config", i, configs[i]);
// Make sure glue isn't stripped.
// if we have a basic EGL failure, we need to exit immediately; nothing else we can do
// loop waiting for stuff to do.
// Read all pending events.
// If not rendering, we will block 250ms waiting for events.
// If animating, we loop until all events are read, then continue
// to draw the next frame of animation.
// Process this event. 
// Check if we are exiting.  If so, dump out
// clamp time - it must not go backwards, and we don't
// want it to be more than a half second to avoid huge
// delays causing issues.  Note that we do not clamp to above
// zero because some tools will give us zero delta
// Update the frame, which optionally updates time and animations
// and renders
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\Etc2CompLib\Etc2CompLib.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\etcpack_lib\etcpack_lib.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\libogg\libogg.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\libvorbis\libvorbis.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\lua\lua.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\LuaCpp\LuaCpp.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\nvidia\nvidia.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\NvTriStrip\NvTriStrip.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\tynyxml2\tynyxml2.cpp
/**********************************
/** This is the C++ implementation of the Java native method.
// Enter code here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\AndroidAdmob.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//GADRequest *request = [GADRequest request];
//BE1::StrArray testDeviceList;
//BE1::SplitStringIntoList(testDeviceList, testDevices, " ");
//if (testDeviceList.Count() > 0) {
//	NSString *nsTestDevices[256];
//	for (int i = 0; i < testDeviceList.Count(); i++) {
//		nsTestDevices[i] = [[NSString alloc] initWithBytes:testDeviceList[i].c_str() length : testDeviceList[i].Length() encoding : NSUTF8StringEncoding];
//	}
//	request.testDevices = [NSArray arrayWithObjects : nsTestDevices count : testDeviceList.Count()];
//}
//if (!unitID || !unitID[0]) {
//	unitID = "ca-app-pub-3940256099942544/1712485313";
//}
//NSString *nsUnitID = [[NSString alloc] initWithBytes:unitID length : strlen(unitID) encoding : NSUTF8StringEncoding];
//// Set up event notification
//// Required to set the delegate prior to loading an ad.
//[GADRewardBasedVideoAd sharedInstance].delegate = viewController;
//[[GADRewardBasedVideoAd sharedInstance] loadRequest:request
//	withAdUnitID : nsUnitID];
//	return[[GADRewardBasedVideoAd sharedInstance] isReady];
//	[[GADRewardBasedVideoAd sharedInstance] presentFromRootViewController:viewController];
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\AndroidPlayerLibrary.cpp
/* This trivial function returns the platform ABI for which this dynamic native library is compiled.*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\gles3jni.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// Square with diagonal < 2 so that it fits in a [-1 .. 1]^2 square
// regardless of rotation.
// ----------------------------------------------------------------------------
// Auto gives a signed int :-(
// number of cells along the larger screen dimension
// cell size in scene space
// Calculations are done in "landscape", i.e. assuming dim[0] >= dim[1].
// Only at the end are values put in the opposite order if h > w.
// -1.0 for d=0
// outer product of centers[0] and centers[1]
// ----------------------------------------------------------------------------
//// ----- Core initialization -----
//BE1::Engine::InitParms initParms;
//BE1::Str appDir = BE1::PlatformFile::ExecutablePath();
//initParms.baseDir = appDir;
//BE1::Str dataDir = appDir + "/Data";
//initParms.searchPath = dataDir;
//BE1::Engine::Init(&initParms);
//// -------------------------------
//BE1::resourceGuidMapper.Read("Data/guidmap");
//// mainWindow(UIWindow) - rootViewController.view(UIView) - eaglView(EAGLView)
//CGRect screenBounds = [[UIScreen mainScreen] bounds];
//mainWindow = [[UIWindow alloc] initWithFrame:screenBounds];
//mainWindow.backgroundColor = [UIColor blackColor];
//rootViewController = [[RootViewController alloc] init];
//mainWindow.rootViewController = rootViewController;
//[mainWindow makeKeyAndVisible];
//BE1::gameClient.Init((__bridge BE1::Renderer::WindowHandle)mainWindow, true);
/*&mEgl*/, true);
//float retinaScale = [[UIScreen mainScreen] scale];
//BE1::Vec2 screenScaleFactor(0.75f, 0.75f);
//int renderWidth = screenBounds.size.width * retinaScale * screenScaleFactor.x;
//int renderHeight = screenBounds.size.height * retinaScale* screenScaleFactor.y;
//app.mainRenderContext = BE1::renderSystem.AllocRenderContext(true);
//app.mainRenderContext->Init((__bridge BE1::Renderer::WindowHandle)[rootViewController view],
//	renderWidth, renderHeight, DisplayContext, NULL);
//app.Init();
////BE1::cmdSystem.BufferCommandText(BE1::CmdSystem::Append, L"exec \"autoexec.cfg\"\n");
//DestroyRenderWindow(mainWnd);
//Java String to C Style string
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\RendererES2.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// array of 2x2 column-major matrices
/* The destructor may be called after the context has already been
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\RendererES3.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/* The destructor may be called after the context has already been
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\Bullet\Bullet.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\DummyLibrary\DummyLibrary.cpp
/* This trivial function returns the platform ABI for which this dynamic native library is compiled.*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\Etc2CompLib\Etc2CompLib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\etcpack_lib\etcpack_lib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\freetype\freetype.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\HACD\HACD.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\jsoncpp\jsoncpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\libjpeg\libjpeg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\libogg\libogg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\libpng\libpng.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\libvorbis\libvorbis.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\lua\lua.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\LuaCpp\LuaCpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\minizip\minizip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\NvTriStrip\NvTriStrip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\rg_etc1\rg_etc1.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\tynyxml2\tynyxml2.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\AndroidPlayer.NativeActivity\nv_main\engine.cpp
//----------------------------------------------------------------------------------
// File:        native_basic/jni/engine.cpp
// SDK Version: v10.14 
// Email:       tegradev@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2007-2012, NVIDIA CORPORATION.  All rights reserved.
//
// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA OR ITS SUPPLIERS
// BE  LIABLE  FOR  ANY  SPECIAL,  INCIDENTAL,  INDIRECT,  OR  CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//
//----------------------------------------------------------------------------------
//To work around http://code.google.com/p/android/issues/detail?id=23203
//we don't link with the crt objects. In some configurations, this means
//a lack of the __dso_handle symbol because it is defined there, and
//depending on the android platform and ndk versions used, it may or may
//not be defined in libc.so. In the latter case, we fail to link. Defining
//it here as weak makes us provide the symbol when it's not provided by
//the crt objects, making the change transparent for future NDKs that
//would fix the original problem. On older NDKs, it is not a problem
//either because the way __dso_handle was used was already broken (and
//the custom linker works around it).
// _SAMPLE
// _ENGINE
//DestroyRenderWindow(mainWnd);
// _ENGINE
// _SAMPLE
/* all are split */
// should look up by font file name.
// should look up by font file name.
// should look up by font file name.
//// ----- Core initialization -----
//BE1::Engine::InitParms initParms;
//BE1::Str appDir = BE1::PlatformFile::ExecutablePath();
//initParms.baseDir = appDir;
//BE1::Str dataDir = appDir + "/Data";
//initParms.searchPath = dataDir;
//BE1::Engine::Init(&initParms);
//// -------------------------------
//BE1::resourceGuidMapper.Read("Data/guidmap");
//// mainWindow(UIWindow) - rootViewController.view(UIView) - eaglView(EAGLView)
//CGRect screenBounds = [[UIScreen mainScreen] bounds];
//mainWindow = [[UIWindow alloc] initWithFrame:screenBounds];
//mainWindow.backgroundColor = [UIColor blackColor];
//rootViewController = [[RootViewController alloc] init];
//mainWindow.rootViewController = rootViewController;
//[mainWindow makeKeyAndVisible];
//BE1::gameClient.Init((__bridge BE1::Renderer::WindowHandle)mainWindow, true);
/*&mEgl*/, true);
//float retinaScale = [[UIScreen mainScreen] scale];
//BE1::Vec2 screenScaleFactor(0.75f, 0.75f);
//int renderWidth = screenBounds.size.width * retinaScale * screenScaleFactor.x;
//int renderHeight = screenBounds.size.height * retinaScale* screenScaleFactor.y;
//app.mainRenderContext = BE1::renderSystem.AllocRenderContext(true);
//app.mainRenderContext->Init((__bridge BE1::Renderer::WindowHandle)[rootViewController view],
//	renderWidth, renderHeight, DisplayContext, NULL);
// _SAMPLE
// set up viewport
// clear buffers as necessary
// do some game rendering here
// ...
// start rendering bitfont text overlaid here.
// we update the clock text >after< drawing so it will change on pause.
// done rendering overlaid text.
// _SAMPLE
// Each frame, we check to see if the window has resized.  While the
// various events we get _should_ cover this, in practice, it appears
// that the safest move across all platforms and OSes is to check at 
// the top of each frame
// Time stands still when we're auto-paused, and we don't
// automatically render
// This will try to set up EGL if it isn't set up
// When we first set up EGL completely, we also load our GLES resources
// If these are already set up or we succeed at setting them all up now, then
// we go ahead and render.
// forced rendering when needed for UI, etc
// Even if we are not interactible, we may be visible, so we
// HAVE to do any forced renderings if we can.  We must also
// check for resize, since that may have been the point of the
// forced render request in the first place!
//We only handle motion events (touchscreen) and key (button/key) events
// A tap on the screen takes us out of autopause into gameplay mode if
// we were paused.  No other touch processing is done.
// if we are in gameplay mode, we eat the back button and move into
// pause mode.  If we are already in pause mode, we allow the back
// button to be handled by the OS, which means we'll be shut down
// _SAMPLE
// A tap on the screen takes us out of autopause into gameplay mode if
// we were paused.  No other touch processing is done.
// The window is being shown, get it ready.
// Note that on ICS, the EGL size will often be correct for the new size here
// But on HC it will not be.  We need to defer checking the new res until the
// first render with the new surface!
// The window is being hidden or closed, clean it up.
// Move out of gameplay mode if we are in it.  But if we are
// in another dialog mode, leave it as-is
// ICS does not appear to require this, but on GB phones,
// not having this causes rotation changes to be delayed or
// ignored when we're in a non-rendering mode like autopause.
// The forced renders appear to allow GB to process the rotation
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\AndroidPlayer.NativeActivity\nv_main\main.cpp
//----------------------------------------------------------------------------------
// File:        native_basic/jni/main.cpp
// SDK Version: v10.14 
// Email:       tegradev@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2007-2012, NVIDIA CORPORATION.  All rights reserved.
//
// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA OR ITS SUPPLIERS
// BE  LIABLE  FOR  ANY  SPECIAL,  INCIDENTAL,  INDIRECT,  OR  CONSEQUENTIAL DAMAGES
// WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS OF BUSINESS PROFITS,
// BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
// ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
//
//----------------------------------------------------------------------------------
/**
//			LOGD("Config[%d] is the new best config", i, configs[i]);
// Make sure glue isn't stripped.
// if we have a basic EGL failure, we need to exit immediately; nothing else we can do
// loop waiting for stuff to do.
// Read all pending events.
// If not rendering, we will block 250ms waiting for events.
// If animating, we loop until all events are read, then continue
// to draw the next frame of animation.
// Process this event. 
// Check if we are exiting.  If so, dump out
// clamp time - it must not go backwards, and we don't
// want it to be more than a half second to avoid huge
// delays causing issues.  Note that we do not clamp to above
// zero because some tools will give us zero delta
// Update the frame, which optionally updates time and animations
// and renders
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\Bullet\Bullet.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\Etc2CompLib\Etc2CompLib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\etcpack_lib\etcpack_lib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\freetype\freetype.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\HACD\HACD.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\jsoncpp\jsoncpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\libjpeg\libjpeg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\libogg\libogg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\libpng\libpng.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\libpvrt\libpvrt.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\libvorbis\libvorbis.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\lua\lua.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\LuaCpp\LuaCpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\minizip\minizip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\NvTriStrip\NvTriStrip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\Renderer\Renderer.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\rg_etc1\rg_etc1.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\tynyxml2\tynyxml2.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\zlib\zlib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\Bullet\Bullet.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\DummyLibrary\DummyLibrary.cpp
/* This trivial function returns the platform ABI for which this dynamic native library is compiled.*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\Etc2CompLib\Etc2CompLib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\etcpack_lib\etcpack_lib.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\freetype\freetype.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\HACD\HACD.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\jsoncpp\jsoncpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\libjpeg\libjpeg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\libogg\libogg.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\libpng\libpng.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\libvorbis\libvorbis.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\lua\lua.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\LuaCpp\LuaCpp.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\minizip\minizip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\NvTriStrip\NvTriStrip.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\rg_etc1\rg_etc1.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\tynyxml2\tynyxml2.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\XamarinPlayerLibrary.cpp
/* This trivial function returns the platform ABI for which this dynamic native library is compiled.*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\jni\app-android.cpp
/* San Angeles Observation OpenGL ES version example
/*
/* Call to initialize the graphics state */
//#if _SAMPLE
//	importGLInit();
//#endif
//	appInit();
/* Call to finalize the graphics state */
/* This is called to indicate to the render loop that it should
/* we paused the animation, so store the current
/* we resumed the animation, so adjust the time offset
/* Call to render the next GL frame */
/* NOTE: if sDemoStopped is TRUE, then we re-render the same frame
//__android_log_print(ANDROID_LOG_INFO, "XamarinPlayer", "curTime=%ld", curTime);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\jni\demo.cpp
/* San Angeles Observation OpenGL ES version example
//iki.fi/jetro/
// _SAMPLE
// Total run length is 20 * camera track base unit length (see cams.h).
// Capped conversion from float to fixed.
// Definition of one GL object in this demo.
/* Vertex array and color array are enabled for all objects, so their
// Already done in initialization:
//glEnableClientState(GL_VERTEX_ARRAY);
//glEnableClientState(GL_COLOR_ARRAY);
// sphere-mapping of supershape parameters
// Creates and returns a supershape object.
// Based on Paul Bourke's POV-Ray implementation.
// http://astronomy.swin.edu.au/~pbourke/povray/supershape/
// latitude 0 to pi/2 for no mirrored bottom
// (latitudeBegin==0 for -pi/2 to pi/2 originally)
// non-inclusive
// longitude -pi to pi
// latitude 0 to pi/2
//float lenSq, invLenSq;
// kludge to set lower edge of the object to fixed level
// Calculate normal with cross product.
/*   i    j    k      i    j
/* Pre-normalization of the normals is disabled here because
/*
// r0 && r1 && r2 && r3
// latitude
// longitude
// Set number of vertices in object to the actual amount created.
// ends are non-inclusive
// 101 1111
// Axis bits for quad triangles:
// x: 011100 (0x1c), y: 110001 (0x31)  (clockwise)
// x: 001110 (0x0e), y: 100011 (0x23)  (counter-clockwise)
// Called from the app framework.
//// ----- Core initialization -----
//BE1::Engine::InitParms initParms;
//BE1::Str appDir = BE1::PlatformFile::ExecutablePath();
//initParms.baseDir = appDir;
//BE1::Str dataDir = appDir + "/Data";
//initParms.searchPath = dataDir;
//BE1::Engine::Init(&initParms);
//// -------------------------------
//BE1::resourceGuidMapper.Read("Data/guidmap");
//// mainWindow(UIWindow) - rootViewController.view(UIView) - eaglView(EAGLView)
//CGRect screenBounds = [[UIScreen mainScreen] bounds];
//mainWindow = [[UIWindow alloc] initWithFrame:screenBounds];
//mainWindow.backgroundColor = [UIColor blackColor];
//rootViewController = [[RootViewController alloc] init];
//mainWindow.rootViewController = rootViewController;
//[mainWindow makeKeyAndVisible];
//BE1::gameClient.Init((__bridge BE1::Renderer::WindowHandle)mainWindow, true);
/*&mEgl*/, true);
//float retinaScale = [[UIScreen mainScreen] scale];
//BE1::Vec2 screenScaleFactor(0.75f, 0.75f);
//int renderWidth = screenBounds.size.width * retinaScale * screenScaleFactor.x;
//int renderHeight = screenBounds.size.height * retinaScale* screenScaleFactor.y;
//app.mainRenderContext = BE1::renderSystem.AllocRenderContext(true);
//app.mainRenderContext->Init((__bridge BE1::Renderer::WindowHandle)[rootViewController view],
//	renderWidth, renderHeight, DisplayContext, NULL);
//app.Init();
////BE1::cmdSystem.BufferCommandText(BE1::CmdSystem::Append, L"exec \"autoexec.cfg\"\n");
// Called from the app framework.
//DestroyRenderWindow(mainWnd);
// _ENGINE
// _ENGINE
/* Following gluLookAt implementation is adapted from the
/* Make rotation matrix */
/* Z vector */
/* mpichler, 19950515 */
/* Y vector */
/* X vector = Y cross Z */
/* Recompute Y = Z cross X */
/* mpichler, 19950515 */
/* cross product gives area of parallelogram, which is < 1.0 for
/* Translate Eye to Origin */
// Called from the app framework.
/* The tick is current time in milliseconds, width and height
// Actual tick value is "blurred" a little bit.
// Terminate application after running through the demonstration once.
// Prepare OpenGL ES for rendering of the frame.
// Update the camera position and set the lookat.
// Configure environment.
// Draw the reflection by drawing models with negated Z-axis.
// Blend the ground plane to the window.
// Draw all the models normally.
// Draw fade quad over whole window (when changing cameras).
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\jni\importgl.cpp
/* San Angeles Observation OpenGL ES version example
//iki.fi/jetro/
// Desktop or mobile Win32 environment:
// Linux environment:
// WIN32
// LINUX
/* DISABLE_IMPORTGL */
/* Imports function pointers to selected function calls in OpenGL ES Common
// Cannot find OpenGL ES Common or Common Lite DLL.
/* The following fetches address to each egl & gl function call
// WIN32
/* !ANDROID_NDK */
/* !ANDROID_NDK */
// Cannot find OpenGL ES Common or Common Lite SO.
// LINUX
/* !ANDROID_NDK */
/* DISABLE_IMPORTGL */
/* DISABLE_IMPORTGL */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinWin\libControl\dllmain.cpp
// dllmain.cpp : Defines the entry point for the DLL application.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\libControl\Client.cpp
//#include "asio.hpp"
//	BE_LOG(L"Read Calling %d\n", PACKET_LENGTH - m_nLength);
//BE_LOG(L"OnRead Called %d %d\n", ec.value(), length);
// MULTI_THREAD
// MULTI_THREAD
// MULTI_THREAD
//	decode
//			Read();
// asio::io_service::run_one is not working
//		IoService.poll(ec);
//		BE1::Engine::Init(&initParms);
//asio::ip::tcp::endpoint endpoint(asio::ip::address::from_string("192.168.111.10"), SERVER_PORT);
//tcp::resolver resolver(IOService);
//asio::connect(s, resolver.resolve({ "127.0.0.1", "4000" }));
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\libControl\Control.cpp
// ConsoleDll.cpp : Defines the exported functions for the DLL application.
//
//#include <mono/jit/jit.h>
//#include <mono/metadata/object.h>
//#include <mono/metadata/environment.h>
//#include <mono/metadata/assembly.h>
//#include <mono/metadata/debug-helpers.h>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\libControl\Precompiled.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\AndroidAdMob.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------------------------
// ad unit of interstitial provided by Google for testing purposes.
//-------------------------------------------------------------------------------------------------
// ad unit of interstitial provided by Google for testing purposes.
//-------------------------------------------------------------------------------------------------
// ad unit of rewarded video provided by Google for testing purposes.
//
// Internal functions to call script functions
//
// Called when an ad request has successfully loaded.
// Called when an ad request failed to load.
// Called when an ad is shown.
// Called when the ad is closed.
// Create new banner object and request again
// Called when the ad click caused the user to leave the application.
// Called when an ad request has successfully loaded.
// Called when an ad request failed to load.
// Called when an ad is shown.
// Called when the ad is closed.
// Create new interstitial object and request again
// Called when the ad click caused the user to leave the application.
// Called when an ad request has successfully loaded.
// Called when an ad request failed to load.
// Called when an ad is shown.
// Called when the ad starts to play.
// Called when the user should be rewarded for watching a video.
// Called when the ad is closed.
// Called when the ad click caused the user to leave the application.
//
// JNI callbacks invoked from the GameAdMobActivity class
//
// native void GameAdMobActivity::bannerAdLoaded()
// native void GameAdMobActivity::bannerAdFailedToLoad(String errorMessage)
// native void GameAdMobActivity::bannerAdOpened()
// native void GameAdMobActivity::bannerAdClosed()
// native void GameAdMobActivity::bannerAdLeftApplication()
// native void GameAdMobActivity::interstitialAdLoaded()
// native void GameAdMobActivity::interstitialAdFailedToLoad(String errorMessage)
// native void GameAdMobActivity::interstitialAdOpened()
// native void GameAdMobActivity::interstitialAdClosed()
// native void GameAdMobActivity::interstitialAdLeftApplication()
// native void GameAdMobActivity::rewardBasedVideoAdLoaded()
// native void GameAdMobActivity::rewardBasedVideoAdFailedToLoad(String errorMessage)
// native void GameAdMobActivity::rewardBasedVideoAdOpened()
// native void GameAdMobActivity::rewardBasedVideoAdStarted()
// native void GameAdMobActivity::rewardBasedVideoAdRewarded(String type, int amount)
// native void GameAdMobActivity::rewardBasedVideoAdClosed()
// native void GameAdMobActivity::rewardBasedVideoAdLeftApplication()
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\AndroidAnalytics.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\AndroidMain.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// landscape mode
/*
// by all means at this point, ASensorManager_getInstance should be available
// If a sensor has data, process it now.
/*float maginitude = event.acceleration.x * event.acceleration.x + event.acceleration.y * event.acceleration.y;
// When our app gains focus, we start monitoring the accelerometer.
// We'd like to get 60 events per second (in us).
// We'd like to get 60 events per second (in microseconds).
// When our app loses focus, we stop monitoring the accelerometer.
// This is to avoid consuming battery while not being used.
// Process the next main command.
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Process the next input event.
// TODO: Implement this
// ACTION_MOVE events are batched, unlike the other events.
// ----- Core initialization -----
// -------------------------------
// Set window format to 8888
// app command callback
// input event callback
// Prepare to monitor accelerometer
// extern "C"
/**
// loop waiting for stuff to do.
// Read all pending events.
// If not animating, we will block forever waiting for events.
// If animating, we loop until all events are read, then continue
// to draw the next frame of animation.
// Process this event.
// Check if we are exiting.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\Application.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\Precompiled.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\WinMain.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// The title bar text
//BE1::Str cmdLine = Str::UTF8StrFromWCharString(lpCmdLine);
//initParms.args.TokenizeString(cmdLine, false);
// Disable automatic DPI scaling.
//::SetProcessDPIAware();
// Initialize global strings
/*case WM_PAINT: {
// Parse the menu selections:
// higher 16 bit of lParam represent scancode
// use lower 8 bit and set extended bit to it's MSB
// WM_CHAR message uses Unicode Transformation Format UCS-2
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Precompiled.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Animator\Animator.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Sets blended duration for each blending states
// Calls events for each blending states
//BE_LOG("%s: %.3f\n", stateBlenders[0].animState->GetName().c_str(), animTime);
// Gets the transitions which have src state currently blended in
// Atomic transition cannot be interrupted by other transition until it finish
// Check all of the conditions to transit to
// Skip transition unless all of the conditions are satisfied
// Defer transition if it has exit time
// Initialize jointMats from bindposes
// Clear all animation state blenders for each layers 
// Set all the parameter values to 0
// TODO: 
// bindpose AABB
// Clear all animation state blenders for each layers 
// Set to the default animation state for each layers
// 0'th element of the animation state array represents current animation state
// If current state animation is still blending in
// 새로운 animation state 를 0 번째 element 에 넣기 위해 이전 state blenders 들을 뒤쪽 element 로 이동시킨다.
// ready to blend in new animation state
// blend out for previous animation state
// Temporary buffer for the joint poses of base layer
// Copy bindposes for all joints
// Masked joints will be calculated against a layer so unmasked joints still have bindposes
// Blending animation state only for base layer 
// Temporary buffer for the joint poses of the other layers
// Blending animation state for other layers
// layer 의 blended weight 가 있다면 layer 끼리 블렌딩한다
// other layers have the mask joints
// NOTE: anim layer weight -- is it really necessary ?
// Convert the joint quaternions to rotation matrices
// Add in the animController offset
// Transform the rest of the hierarchy
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Animator\AnimStateBlender.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// set current blended weight to blend start weight
// Actual elapsed time from start time
// Get the normalized animation time
// blendEndWeight 를 0 으로 설정하고, blendDuration 동안 서서히 value 를 줄여간다
// FIXME: time wrap for only loop state
//BE_LOG("%s %f %i %i %f %f\n", event->string.c_str(), event->time, fromTime, toTime, t1, t2);
// Get the current weight of this animation state
// we don't need a temporary buffer, so just store it directly in the blendedFrame
// allocate a temporary buffer to copy the joints from
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\AnimController\AnimBlendTree.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// TODO: remove
// TODO: remove
// Check the maximum children
// Check the maximum children
// Sum of all the weights are equal to 1.0
// TODO: Cache results if parameters are not changed
// Clears weights
// Gets a current parametric point
// Gets blending sample points
// Sort by nearest distance with currentPoint
//BE_LOG("(%f %f) %f (%f %f) %f (%f %f) %f\n", a.x, a.y, barycentricCoord.x, b.x, b.y, barycentricCoord.y, c.x, c.y, barycentricCoord.z);
//BE_LOG("(%f) %f (%f) %f\n", a, barycentricCoord.x, b, barycentricCoord.y);
// Clears weights
// Gets a current parametric point
// Gets blending sample points
// Sort by largest dot product with currentPoint
// If the sample point (0, 0) exist..
//BE_LOG("%f %f %f\n", barycentricCoord.x, barycentricCoord.y, barycentricCoord.z);
// If current point is inside of a triangle, we'll use triangular interpolation
// Clears weights
// Gets a current parametric angle
// Gets blending sample angles
// Sort by nearest angle with currentAngle
// only blend after the first animation is mixed in
//const AnimClip *        childClip;
//childClip = animLayer->GetNodeAnimClip(nodeNum);
//int index = animator->GetAnimController()->FindAnimClipIndex(childClip);
//childClip->GetAABB(normalizedTime * childClip->Length(), animator->GetAnimAABB(index)->frameAABBs, aabb);
// children 의 time 은 child->duration * (time / nodeDuration) 에 맞춰서 흐른다
//childClip = animLayer->GetNodeAnimClip(nodeNum);
//int index = animator->GetAnimController()->FindAnimClipIndex(childClip);
//childClip->GetAABB(normalizedTime * childClip->Length(), animator->GetAnimAABB(index)->frameAABBs, childAABB);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\AnimController\AnimClip.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//const_cast<Anim *>(anim->AddRefCount());
// TODO: 구간 (startTime, endTime) 을 정해서 구할 것
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\AnimController\AnimController.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------------------------------------
// jointNames: ex) Bone01 Bone02 -Bone03 *Bone04
//                 add    add    sub     addChildren
// scan through list of joints and add each to the joint list
// copy joint name
// include all joint's children
// FIXME: hash search
// Set up initial pose for skeleton
// Convert the joint quaternions to joint matrices (quaternions -> local joint matrices)
// Check if we offset the skeleton by the root joint
// Transform the joint hierarchy (local matrices -> world matrices)
// shrink animClips & animLayers down to save space
// jointParents 는 SIMD 연산을 위해 따로 배열 형태로 저장한다.
// first layer should be a base layer
// Write skeleton
// Write parameters
// Write layers
// Write base layer
// Write additional anim layers
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\AnimController\AnimLayer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// return node num
// return leaf num which is negative number
/*for (int i = 0; i < stateHashMap.Count(); i++) {
// parse name
// parse type
//blendTree = GetNodeAnimBlendTree(state->nodeNum);
// blendTree 가 참조하는 parameter
// blendTree 내부의 animClip 은 blend space point 를 갖는다
// blendTree 내부의 blendTree 역시 blend space point 를 갖는다.
// Parse blend tree name
// Parse parameter name
// Parse compare func
// Parse compare value
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\AnimController\AnimState.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//int index = animator->GetAnimController()->FindAnimClipIndex(animClip);
//animClip->GetAABB(normalizedTime * animClip->Length(), animator->GetAnimAABB(index)->frameAABBs, outAabb);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\AnimAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\AnimControllerAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\Asset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\AssetImporter.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\FBXAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\FolderAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\FontAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\GuidMapper.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// predefined texture GUID
// predefined shader GUID
// predefined material GUID
// predefined font GUID
// predefined mesh GUID
// predefined particle system GUID
// predefined skeleton GUID
// predefined anim controller GUID
// predefined sound GUID
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\JointMaskAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*JointMask *existingJointMask = jointMaskManager.FindJointMask(GetResourceFilename());
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\MapAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\MaterialAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\MeshAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\ParticleSystemAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\PrefabAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//prefabManager.ReleasePrefab(prefab);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\ScriptAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\ShaderAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\SkeletonAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\SoundAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Asset\TextureAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComAnimation.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Convert joint matrices from local space to world space
// Disconnect with previously connected skeleton asset
// Set up joints to T-pose
// Convert joint matrices from local space to world space
//anim->ComputeFrameAABBs(skeleton, referenceMesh, frameAABBs);
// Need to connect skeleton asset to be reloaded in Editor
// Disconnect with previously connected anim asset
// Release the previously used anim
// Set up joints to T-pose
// Convert joint matrices from local space to world space
// FIXME: Slow!!
//anim->ComputeFrameAABBs(skeleton, referenceMesh, frameAABBs);
// Need to connect anim asset to be reloaded in Editor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComAnimator.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
/*if (!animator.FrameHasChanged(GetGameWorld()->GetTime())) {
// Modify jointMats for IK here !
// Get AABB from animator
/*animator.ComputeAABB(currentTime);
// Disconnect with previously connected animation controller asset
// Set new animation controller
// Reset animator state
// Need to connect animation controller asset to be reloaded in Editor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComAudioListener.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComAudioSource.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComBoxCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCamera.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 3d sprite for editor
// Mark as initialized
/*if (ctx) {
// Fade icon alpha in near distance
// Compute right/down normalized screen coordinates [-1.0, +1.0]
// Compute right/down normalized screen coordinates [-1.0, +1.0]
// Compute screen coordinates
// right/down normalized screen coordinates [-1.0, +1.0]
// Get current render context which is unique for each OS-level window in general.
// Get the actual screen rendering resolution.
// Offset and scale with the normalized [0, 1] screen fraction values.
// Get the aspect ratio from device screen size.
// Compute viewport rectangle size in orthogonal projection.
// Compute fovX, fovY with the given fov and aspect ratio.
// Update render camera with the given parameters.
// Render scene with the given camera.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCapsuleCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCharacterController.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
//body->SetCollisionListener(this);
// 땅에 닿아있는지 체크하기위해 z 축으로 6cm 만큼 내려서 이동시켜 본다
// FIXME: speration normal 이 아닌 표면의 normal 과 비교해야 한다
// 최대 4 번까지 iteration
// 한번에 밀어내지 않고, 가장 깊이 penetration 된 contact 부터 조금씩 밀어낸다.
//BE_LOG("%s (%f) -> %s\n", contact.normal.ToString(), contact.dist, origin.ToString());
// 다 밀어냈다면 종료
// bump normal 리스트를 작성한다. 
// 땅 바닥과 슬라이드
// 땅 바닥 normal 을 bump normal 리스트에 추가
// 시작 move 방향을 bump normal 리스트에 추가
// origin 에서 targetPos 로 capsule cast 
// 이동 가능한 fraction 만큼 origin 이동
// cast 결과 충돌이 없다면 종료
// 이동한 만큼 이동거리를 빼준다.
//BE_LOG("%i %f\n", bumpCount, trace.normal.z);
//GetGameWorld()->GetRenderWorld()->SetDebugColor(Vec4Color::cyan, Vec4(0, 0, 0, 0));
//GetGameWorld()->GetRenderWorld()->DebugLine(trace.point, trace.point + trace.normal * 10, 1, false, 10000);
// 누적된 bump normals 의 최대 개수를 초과했다면..
// 여기로 오면 안된다. 혹시나 만약 오게되면 여기서 종료.
// 같은 평면에 부딛혔다면 moveVec 을 normal 방향으로 약간 nudge 시킨다.
// 부딪힌 normal 을 추가
// moveVec 방향으로 부딪힐 수 없는 normal 은 제외
// 부딪힌 normal 로 slide
// 또 다시 다른 평면으로 slide 
// 두번째 slide vector 가 첫번째 부딛힌 normal 과 또 부딛힌다면, cross 방향으로 slide
// 다른 normal 과 또 부딛힌다면 slide 를 멈춘다.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCharacterJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Fill up a constraint description 
// Create a constraint with the given description
// Apply limit angles
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComConeCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComConstantForce.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComCylinderCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComEnvironmentProbe.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// The origin must be included in the box range.
// So if it doesn't we need to adjust box offset.
// The origin must be included in the box range.
// So if it doesn't we need to adjust box size.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComFixedJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Fill up a constraint description 
// Create a constraint with the given description
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComHingeJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Create a constraint with the given description
// Apply limit angles
// Apply motor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Wake up both rigid bodies in case they have been constrained by the joint.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComLight.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 3d sprite for editor
// Mark as initialized
// Fade icon alpha in near distance
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComLogic.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComMeshCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//collider;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Release instantiated mesh
// Release reference mesh
// Mark as initialized
// Disconnect with previously connected mesh asset
// Release the previously used instantiated mesh
// Release the previously used reference mesh
// Release previously used materials
// Get the new reference mesh
// Get number of materials
// Get previously used number of materials
// Resize material slots
// Set default materials to material slots
// Need mesh asset to be reloaded in editor
// Set default materials to appended material slots
// Release the previously used material
// Get the new material
// FIXME: release ?
// Ignore backface vertices 
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComParticleSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 3d spriteDef
// Mark as initialized
// Disconnect with previously connected particleSystem asset
// Release the previously used particleSystem
// Get the new particleSystem
// Need to particleSystem asset to be reloaded in editor
// Free memory used for particles
// Get the particle pointer with the given particle index
// Standard module
// Is in delay time ?
// Wrap elapsed time of this particle if it is needed
// Get the particle pointer with the given particle index
// Check this particle is alive now 
// Generate if this particle is not generated yet. 
//
// Compute size
// Compute aspect ratio
// Compute rotation angle
// Compute color
// fade in
// fade out
// Compute position
// Apply force
// Apply gravity
// Add trail bounds to the entity bounds
// Fade icon alpha in near distance
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\Component.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComReflectionProbe.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// The origin must be included in the box range.
// So if it doesn't we need to adjust box offset.
// The origin must be included in the box range.
// So if it doesn't we need to adjust box size.
// Convert format to RGB_11F_11F_10F if texture format is HDR
// Convert format to RGB_11F_11F_10F if texture format is HDR
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComRenderable.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//localRay.dir.Normalize();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComRigidBody.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//BE_LOG("Collide with %s, n = (%.2f %.2f %.2f), impulse = %.2f\n", collision.entity->GetName(), normal.x, normal.y, normal.z, impulse);
// Mark as initialized
// Collect collider shadpes in this entity
// Collect collider shadpes in children recursively
// static rigid body can't have collision listener
// Create a rigid body
// Collect vehicle wheels in children recursively
// If a vehicle wheel component exists in any of its children, create a physics vehicle
//ComTransform *wheelTransform = vehicleWheels[wheelIndex]->GetEntity()->GetTransform();
//wheelTransform->Connect(&ComTransform::SIG_TransformUpdated, this, (SignalCallback)&ComVehicleWheel::TransformUpdated, SignalObject::Unique);
// Block SIG_TransformUpdated during chainging transform in below
// Check if old collision entity is removed
// Cancel transform update due to physics simulation
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComScript.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Get the script GUID in JSON value
// Disconnect with previously connected script asset
//state->ForceGC();
// Sandbox name is same as component GUID in string
// Load a script with sandboxed on current Lua state
// Get the state of current loaded script
// Run this script
// Check execute modes
// Get the script property informations with this sandboxed script
// Need to script asset to be reloaded in editor
// Set zero values of object script properties
// Create all the property info
// FIXME: when to delete ?
// Update editor UI
// Update editor UI
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSensor.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Collect collider shadpes in this entity
// Collect collider shadpes in children recursively
// Get the collided entity
// Get the collided entity in past
// TODO: draw blend mesh
/*ComponentPtrArray colliderComponents = GetEntity()->GetComponents(ComCollider::metaObject);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSkinnedMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Root object should have ComAnimation or ComAnimator component
// FIXME
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSliderJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Fill up a constraint description 
// Create a constraint with the given description
// Apply limit distances
// Apply limit angles
// Apply linear motor
// Apply angular motor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSocketJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Fill up a constraint description 
// Create a constraint with the given description
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSphereCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSpline.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Disconnect with previously connected points
// incremental time just used for key ordering
// duplicate a start point
// duplicate a end point
//originCurve->SetCloseTime(100);
//anglesCurve->SetCloseTime(100);
// Draw originCurve
// Draw transform points
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComSpringJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Fill up a constraint description
// Create a constraint with the given description
// Apply limit distances
// Apply spring stiffness & damping
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComStaticMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComTextRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComTransform.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Precondition:
// a) whenever a transform is marked worldMatrixInvalidated, all its children are marked worldMatrixInvalidated as well.
// b) whenever a transform is cleared from being worldMatrixInvalidated, all its parents must have been cleared as well.
// World matrix should be updated so we emit this signal
// Don't update children that has rigid body. they will be updated by own.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComVehicleWheel.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mark as initialized
// Draw wheel circle
// Draw forward direction
// Draw axle axis
// Draw suspension direction
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Components\ComWheelJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// .SetRange(0, 1, 0.01f);
// Mark as initialized
// Fill up a constraint description 
// Create a constraint with the given description
// Apply limit suspension distances
// Apply limit steering angles
// Apply suspension stiffness & damping
// Apply motor
// Draw wheel circle
// Draw axle axis
// Draw forward direction
// Draw suspension direction
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Containers\HashIndex.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 초기화된 상태이므로 indexSize 만 변경하고 나온다.
// allocate new index chain data
// copy old index chain data
// fill -1 for redundant values
// delete old index chain data
// update new index size
// if no items in hash
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\ByteOrder.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// runtime byte order test.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Checksum_CRC32.cpp
/*
/*
/* terms of polynomial defining this crc (except x^32): */
/* make exclusive-or pattern from polynomial (0xedb88320L) */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Checksum_MD5.cpp
/*
/*
/* The four core functions - F1 is optimized somewhat */
/* #define F1(x, y, z) (x & y | ~x & z) */
/* This is the central step in the MD5 algorithm. */
/*
/*
/*
/* Update bitcount */
/* Carry from low to high */
/* Bytes already in shsInfo->data */
/* Handle any leading odd-sized chunks */
/* Process data in 64-byte chunks */
/* Handle any remaining bytes of data. */
/*
/* Compute number of bytes mod 64 */
/* Set the first char of padding to 0x80.  This is safe since there is
/* Bytes of padding needed to make 64 bytes */
/* Pad out to 56 mod 64 */
/* Two lots of padding:  Pad the first block to 64 bytes */
/* Now fill the next block with 56 bytes */
/* Pad block to 56 bytes */
/* Append length in bits and transform */
/* In case it's sensitive */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\CmdArgs.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// escape string
// this is usually something malicious
// check for negative numbers
// check for cvar expansion
// this is usually something malicious
// regular token
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Cmds.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 동일한 것이 있나 먼저 검사
// 없다면 부분 매치검색
// cvar 와 이름이 중복됐다
// copy off any commands still remaining in the exec buffer
// shut up compiler
// add the entire text of the file
// add the copied off data
// HACK!
// Execute a command
// Process a cvar command
// '\n' or ';' 인 라인 구분자를 찾는다 
// don't break if inside a quoted string
// 커맨드 라인 실행
// commandBufferWait 명령이 켜져 있다면 나머지 커맨드들을 다음프레임으로 미룬다
//--------------------------------------------------------------------------------------------------
//
//	cmd command
//
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\CVars.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
//
//	CVar
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
//	CVarSystem
//
//--------------------------------------------------------------------------------------------------
// Check full name 
// Check partial name
// Print cvar information if no parameters are specified
//--------------------------------------------------------------------------------------------------
//
//  CVar command
//
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\DateTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Holds the days per month in a non-leap year.
// Holds the cumulative days per month in a non-leap year.
// the current year is not a full year yet
// the current month is not a full month yet
// leap year day every four years...
// ...except every 100 years...
// ...but also every 400 years
// days in this year up to last month
// days in this month minus today
// Based on FORTRAN code in:
// Fliegel, H. F. and van Flandern, T. C.,
// Communications of the ACM, Vol. 11, No. 10 (October 1968).
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Dict.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// check for assignment to self
// check for assignment to self
// first set the new value and then free the old value to allow proper self copying
// 같은 key/value pool 을 사용하고 있으므로 주소만 복사한다.
// other 는 clear
// first set the new value and then free the old value to allow proper self copying
// make sure all keys can still be found in the hash index
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\DynamicAABBTree.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Build a linked list for the free list
// Allocated a node from the pool. Grow the pool if necessary.
// Expand the node pool as needed.
// The free list is empty. Rebuild a bigger pool.
// Build a linked list for the free list. The parent
// pointer becomes the "next" pointer.
// Peel a node off the free list
// Return a node to the pool
// Create a proxy in the tree as a leaf node. We return the index
// of the node instead of a pointer so that we can grow the node pool.
// Fatten the aabb.
// Expand AABB.
// Predict AABB displacement.
// Find the best sibling for this node
// Cost of creating a new parent for this node and the new leaf
// Minimum cost of pushing the leaf further down the tree
// Cost of descending into child1
// Cost of descending into child2
// Descend according to the minimum cost.
// Descend
// Create a new parent.
// The sibling was not the root.
// The sibling was the root.
// Walk back up the tree fixing heights and AABBs
//Validate();
// Destroy parent and connect sibling to grandParent.
// Adjust ancestor bounds.
//Validate();
// Perform a left or right rotation if node A is imbalanced.
// Returns the new root index.
// Rotate C up
// Swap A and C
// A's old parent should point to C
// Rotate
// Rotate B up
// Swap A and B
// A's old parent should point to B
// Rotate
// Free node in pool
// Compute the height of a sub-tree.
// Build array of leaves. Free the rest.
// free node in pool
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Event.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Allow NULL to indicate no args, but always store it as ""
// so we don't have to check for it.
// Calculate the offsets for each argument
// Check if same name event def already exist
// Same name but different formatSpec
// Same name but different returnType
//-----------------------------------------------------------------------------------------
// Copy arguments to event data
// event queue 는 시간 순으로 정렬되어 있다.
// evdef->IsGuiEvent() ? guiEventQueue : eventQueue;
// copy the data into the local argPtrs array and set up pointers
// the event is removed from its list so that if then object
// is deleted, the event won't be freed twice
// return the event to the free list
// Don't allow ourselves to stay in here too long.  An abnormally high number
// of events being processed is evidence of an infinite loop of events.
// Don't allow ourselves to stay in here too long.  An abnormally high number
// of events being processed is evidence of an infinite loop of events.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Expr.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 연산자 우선순위
// NOTE: 배열 순서는 헤더파일의 OpCode enum 값과 맞춰져있음
// (
// (
// [
// !
// +
// -
// abs
// floor
// ceil
// fract
// sqrt
// inverse sqrt
// min
// max
// power
// exponent
// log
// sine
// cosine
// tangent
// arc sine
// arc cosine
// arc tangent
// *
// /
// %
// +
// -
// >
// >=
// <
// <=
// ==
// !=
// &&
// ||
// NOTE: 선증감
// NOTE: 선증감
// punctuation type -> op code
// !
// +
// -
// *
// /
// %
// >
// >=
// <
// <=
// ==
// !=
// &&
// ||
// unary operator
//g_constantRegisters[a] = +g_constantRegisters[a]; // 생략
// + (unary) 는 연산안함
// binary operator
// 두 오퍼랜드 모두 상수냐? 그렇다면.. 상수끼리 연산은 미리 계산한다
// '(' 는 무조건 push
// '[' 도 무조건 push
// ')'
// '('
// ']'
// table 연산 evaluate
// 이전 opCode 과 precedence 비교
// HACK
// built-in 연산자 리스트에서 찾는다
// built-in 연산자가 아니라면 identifier (레지스터 or 파라미터 or 테이블) 다.
// 레지스터 이름에서 찾는다
// 로컬 파라미터에서 찾는다
// 로컬 파라미터에서 찾는다
// 파라미터 리스트에서 찾는다.
// 테이블 리스트에서 찾는다.
/*	for (i = 0; i < numConstantRegisters; i++) {
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Guid.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// RawValues
// DigitsWithHyphens
// DigitsWithHyphensInBraces
// DigitsWithHyphensInParentheses
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Heap.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define SJPARK
// DEBUG_MEMORY
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Lexer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: longer punctuations first
// binary operators
//
// define merge operator
// pre-compiler
// logic operators
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// arithmatic operators
// binary operators
// pre-compiler
// pre-compiler
// reference operators
// C++
// arithmatic operators
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// binary operators
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
// logic operators
// pre-compiler
// pre-compiler
// pre-compiler
// reference operator
// seperators
// pre-compiler
// label indication
// pre-compiler
// if statement
// pre-compiler
// embracements
// pre-compiler
// pre-compiler
// pre-compiler
// pre-compiler
//
// precompiler operator
// pre-compiler
// leading quote
// if trailing quote
// check for hexadecimal number
// check for octal number
// it's decimal zero case
// decimal integer or float point number
// if a floating point number
// check for floating point exponent
// check for floating point exception infinite 1.#INF or indefinite 1.#IND or NaN
// single-precision: float
// extended-precision: long double
// default is double-precision: double
// default: signed long
// long integer
// unsigned integer
// if there is a token available (from UnreadToken)
// skip whitespace
// skip double slash comments
// skip /* */ comments
/* */ comments
// handle quoted strings
// if there is a number
// if there is a identifier
// check for punctuation
// if the given string is available
// unread token
// The next token should be an open brace.
// Parses until a matching close brace is found.
// Maintains exact characters between braces.
//
// FIXME: this should use ReadToken and replace the token white space with correct indents and newlines
// The next token should be an open brace.
// Parses until a matching close brace is found.
// Internal brace depths are properly skipped.
// if the token is on a new line
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\MinMaxCurve.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Object.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 자식 class 의 MetaObject 가 먼저 생성되었다면 자식 클래스를 찾아서 super 를 지정해준다
// classname 을 알파벳 순서로 링크드리스트에 소팅하면서 insert
// classname conflicts
// MetaObject 초기화 함수. Object::Init 에서 불린다.
// 부모 클래스 먼저 Init
// hierarchy node 세팅
// 각 클래스별로 child 노드 개수를 lastChildIndex 에 담는다
// 따로 event callback 이 없다면 부모것으로 세팅 후 리턴
// 여기까지 왔다면 event map 을 새로 할당 할거니까, 나중에 삭제할거라고 표시해둔다
// 전체 event 개수만큼 event callback 함수 메모리 할당
// allocate temporary memory for flags so that the subclass's event callbacks
// override the superclass's event callback
// go through the inheritence order and copies the event callback function into
// a list indexed by the event number.  This allows fast lookups of event functions.
// free up the memory used for event lookups
//-----------------------------------------------------------------------------------------------
// alphabetical order
// number the types according to the class hierarchy so we can quickly determine if a class is a subclass of another
// Object::Init hasn't been called yet, so do a slow lookup
// do a binary search through the list of types
// we don't respond to this event, so ignore it
// we don't respond to this event, so ignore it
// Copy arguments to array of intptr_t
// we don't respond to this event, so ignore it
// formatSpecBits = 0bNNNFFFFFF
// N means number of arguments
// F means float bit mask
//----------------------------------------------------------------------------------------------
// 0 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 1 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 2 args
//----------------------------------------------------------------------------------------------
// 3 args
//----------------------------------------------------------------------------------------------
// 4 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 5 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 6 args
//----------------------------------------------------------------------------------------------
// Forces the remove to be done at a safe time
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Serializable.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// You can force to write a value even though a property has read only flag.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Signal.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Allow NULL to indicate no args, but always store it as ""
// so we don't have to check for it.
// Calculate the offsets for each argument
// Same name but different formatSpec
// Same name but different returnType
//-----------------------------------------------------------------------------------------
// Copy arguments to signal data
// copy the data into the local argPtrs array and set up pointers
// the signal is removed from its list so that if then object
// is deleted, the signal won't be freed twice
// return the signal to the free list
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\SignalObject.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// connection pointer is shared among sender's publications and receiver's subscriptions.
// remove receiver's subscription
// remove sender's publication
// remove receiver's subscription
// stack sender's publication for remove
// remove receiver's subscription
// stack sender's publication for remove
// formatSpecBits = 0bNNNFFFFFF
// N means number of arguments
// F means float bit mask
//----------------------------------------------------------------------------------------------
// 0 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 1 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 2 args
//----------------------------------------------------------------------------------------------
// 3 args
//----------------------------------------------------------------------------------------------
// 4 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 5 args
//----------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
// 6 args
//----------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Str.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// safe behaviour if nullptr
// copying same thing
// check if we're aliasing
// skip whitespaces
// big, but small enough to fit in PPC stack
// 11 bits
// 16 bits
// 21 bits
// 26 bits
// 31 bits
/*
// don't include extension
// already a path is relative path.
// 확장자가 있다면 그냥 리턴
// absolute path location
//
// back up until a \ or the start
//
//
// back up until a \ or the start
//
//
// back up until a \ or the start
//
//
// back up until a . or the start
//
// no extension
/*
// strings are equal
// strings are equal until end point
// strings are equal
// strings are equal
// strings are equal until end point
// strings are equal
// make sure folders come first
// same folder depth so use the regular compare
// strings are equal until end point
// make sure folders come first
// same folder depth so use the regular compare
// natsort (zlib license) - http://sourcefrog.net/projects/natsort/
/* CUSTOMIZATION SECTION
/* These are defined as macros to make it easier to adapt this code to
/* The longest run of digits wins.  That aside, the greatest
/* Compare two left-aligned numbers: the first to have a
/* skip over leading spaces or zeros */
/* process run of digits */
/* The strings compare the same.  Perhaps the caller
/* Compare, recognizing numeric string and ignoring case. */
// If the original string is equal to the abbreviation, perfect match.
// If the comparison string is empty, perfectly bad match.
// Create a copy of original string, so that we can manipulate it. */
// Walk through abbreviation and add up scores.
// Find the first case-insensitive match of a character.
// Set base score for any matching char.
// Same-case bonus.
// Consecutive letter & start-of-string bonus.
// Increase the score when matching first character of the remainder of the string.
// If match is the first char of the string & the first char
// of abbreviation, add a start-of-string match bonus.
// Acronym Bonus
// Weighing Logic: Typing the first character of an acronym is as
// if you preceded it with two perfect character matches.
// Left trim the already matched part of the string. 
// (Forces sequential matching.)
// Reduce penalty for longer strings.
// Safe strncpy that ensures a trailing zero
// never goes past bounds or leaves without a terminating 0
// returns -1 if not found otherwise the index of the char
// returns -1 if not found otherwise the index of the char
// returns -1 if not found otherwise the index of the text
// returns -1 if not found otherwise the index of the text
// in case called by nested functions
// use an array of string so that multiple calls won't collide
// in case called by nested functions
// use an array of string so that multiple calls won't collide
// big, but small enough to fit in PPC stack
// vsnprintf portability:
// 
// C99 standard: vsnprintf returns the number of characters (excluding the trailing '\0') 
// which would have been written to the final string if enough space had been available
// snprintf and vsnprintf do not write more than size bytes (including the trailing '\0')
// 
// win32: _vsnprintf returns the number of characters written, not including the terminating null character,
// or a negative value if an output error occurs. If the number of characters to write exceeds count, then count 
// characters are written and -1 is returned and no trailing '\0' is added.
// 
// Str::vsnPrintf: always appends a trailing '\0', returns number of characters written (not including terminal \0)
// or returns -1 on failure or if the buffer would be overflowed.
// Sets the value of the string using a printf interface.
// Sets the value of the string using a vprintf interface.
// does a varargs printf into a temp buffer
// NOTE: not thread safe
// 재귀 호출이 4번까지는 가능하다.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Task.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create synchronization objects.
// Get thread count as number of logical processors
// Create task threads.
// Destroy all the synchronization objects.
// Destroy all the task threads.
// Lock for task addition
// Unlock for task addition
// Set the stopping and wake all the task threads.
// Wait until finishing all the task threads.
// Wait for task condition variable.
// Get the task from the ring buffer.
// Do the task.
// Decrease active task count after finishing a task function.
// Wake finish condition variable when there is no active tasks.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Timespan.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\UTF16.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Check if we are at a low surrogate
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\UTF8.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 0xxxxxxx
// 110xxxxx
// 2 byte encoding - the next byte must begin with
// 1110xxxx
// 3 byte encoding
// 11110xxx
// 4 byte encoding
// this isnt' a valid UTF-8 precursor character
// check for byte-order-marker
// just low ASCII
// 2 byte encoding - the next byte must begin with bit pattern 10
// skip over UTF-8 character
// 3 byte encoding - the next 2 bytes must begin with bit pattern 10
// skip over UTF-8 character
// 4 byte encoding - the next 3 bytes must begin with bit pattern 10
// skip over UTF-8 character
// this isnt' a valid UTF-8 character
// 11 bits
// 16 bits
// 21 bits
// 26 bits
// 31 bits
// Check if we are in the middle of a UTF8 character
// return a null terminator if out of range
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Variant.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Type::MinMaxCurve can not support here
// Type::MinMaxCurve can not support here
// Type::MinMaxCurve can not support here
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Core\Vec4Color.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// LIGHT GRAY
// RED
// GREEN
// YELLOW
// BLUE
// CYAN
// MAGENTA
// WHITE
// GRAY
// BLACK
// ORANGE
// PINK
// LAWN
// MINT
// VIOLET
// TEAL
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Engine\Common.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//common.Shutdown();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Engine\Console.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ignore CR
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Engine\Engine.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Set user-default ANSI code page obtained from the operating system
//_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
//_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
// NOTE: can be replaced by setting '{,,ucrtbased}_crtBreakAlloc' (msvc2015) in debug watch window
//_CrtSetBreakAlloc(123456);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Engine\GameClient.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// set default resource GUID mapper
// materialManager.GetMaterial("Data/EngineMaterials/console.material");    
//materialManager.ReleaseMaterial(consoleMaterial);
// FIXME: use thread
// Save current line length
// Save next line offset
// Save current line length
// Save next line offset
// Abandon remaining text
// Calculate the y-coordinate
// Calculate the x-coordinate
// Draw outline of text with black color
// Draw text shadow with black color
//DrawConsoleNotify();
// Draw console background.
// Draw version string.
// Draw back scroll marks.
// Calculate number of lines to show.
// Draw content of console text.
// Exclude color escape characters when drawing.
// Draw console command line text.
// Determine caret shape.
// Draw caret.
/*
// Enter
// skip the CMDLINE_PROMPT_MARK
// Auto completion
// Backspace
// Scroll up
// Scroll down
// Move to the begining of a lineText
// Move to the end of a lineText
// History up
// History down
// Replace a character.
// Insert a character.
// Append a character.
// Replace a character.
// Insert a character.
// Append a character.
// Toggle console without key binding
/*netadr_t *adr, sizebuf_t *buf*/) {
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\File\File.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------------------
// File
//---------------------------------------------------------------
//---------------------------------------------------------------
// FileReal
//---------------------------------------------------------------
//---------------------------------------------------------------
// FileInZip
//---------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\File\FileSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
//
// ZIP archive
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
// FileArray
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
// FileSystem
//
//--------------------------------------------------------------------------------------------------
// path 의 zip 파일들을 searchpath 에 추가
// Set the current file of the zipfile to the first file.
/*
/*|| srcFileSize < 1 */) {
//-------------------------------------------------------------------------------
//
// File system I/O
//
//-------------------------------------------------------------------------------
//PlatformFile::FileSize(filename);
// PlatformFile::FileSize(filename);
//-------------------------------------------------------------------------------
//
//  Memory file I/O
//
//-------------------------------------------------------------------------------
// check directory
// check extension
//fileInfo.size = entry->size;
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\File\ZipArchiver.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\CastResult.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\Entity.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Purge all the components in opposite order
// Initialize components
// Copy entity JSON value
// Replace entity GUID to the new one
// Mark in the GUID hash table
// Replace component GUID to the new one
// Mark in the GUID hash table
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\GameSettings.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\GameWorld.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create render world
// Create physics world
// Create render settings
// Free render world
// Free physics world
// List up all of the entities to remove in depth first order
// Remove entities in reverse depth first order
// If entityIndex is not given, find a blank space in entities[]
// Serialize source entity and it's children
// Clone entities value which is replaced by new GUIDs
// Create cloned entity
// Remap all GUID references to newly created
// If source entity is prefab source, mark cloned entity originated from prefab entity
//meshManager.EndLevelLoad();
// Read map version
// Read map render settings
// Read and spawn entities
// Write map version
// Write map render settings
// Write entities
// FixedUpdate() is called in StepSimulation() internally
// Wake up waiting coroutine in Lua scripts
// Update tweeners in Lua scripts
// Call fixed update function for each entities in depth-first order
// Call fixed post-update function for each entities in depth-first order
// Call update function for each entities in depth-first order
// Call post-update function for each entities in depth-first order
// Process pointer input in reverse order
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\MapRenderSettings.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\PhysicsSettings.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\PlayerSettings.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\Prefab.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// GUID 0 means a root entity
// Serialize root entity and it's children
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\PrefabManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Serialize source entity and it's children
// Clone entities value which is replaced by new GUIDs
// Clear parent of this prefab root entity
// Remap all GUID references to newly created
//prefabEntity->InitComponents();
// Serialize prefab entity
// Set the original entity's prefab source
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Game\TagLayerSettings.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// default tags
// default layers
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\DxtDecoder.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Decode 64 bits color block to RGBA8888
// 4-color or 3-color & 1-transparent color block ?
// Four-color block: derive the other two colors
// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
// Three-color block: derive the other colors
// 00 = color_0, 01 = color_1, 10 = color_2, 11 = transparent
// random color to indicate alphas
// Decode 64 bits alpha block to 8-bit alphas
// 8-alpha or 6-alpha block?
// 8-alpha block: derive the other 6 alphas.
// 000 = alpha_0, 001 = alpha_1, others are interpolated
// 010
// 011
// 100
// 101
// 110
// 111
// 6-alpha block: derive the other alphas.
// 000 = alpha_0, 001 = alpha_1, others are interpolated
// 010
// 011
// 100
// 101
// 110
// 111
// Decode 64 bits alpha block (4 bits per pixel) to 8-bit alphas
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\DxtEncoder.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// inset the bounding box with ( range >> shift )
// inset alpha channel
// 0xFF minus last three bits
// 0xFF minus last two bits
// get alpha min / max
// compute A - e*I
// compute cofactor matrix
// find the largest component
// pick the column with this component
// compute A - e*I
// find the largest component
// pick the first eigenvector based on this index
// Symmetric 3x3 matrix
// m[0] m[1] m[2]
//      m[3] m[4]
//           m[5]
// Compute the cubic coefficients
// x^3 - c2 * x^2 + c1 * x + c0 = 0
// Compute the quadratic coefficients
// x = t + c2 / 3
// t^3 + p * t + q = 0
// Compute the root count check
// Test the multiplicity
// Only one root, which implies we have a multiple of the identity
// Three distinct roots
// Pick the larger
// Get the eigenvector
// if (d >= -FLT_EPSILON && d <= FLT_EPSILON) {
// Two roots
// repeated
// Get the eigenvector
// Normalize colors and compute mean vector
// Compute symmetric covariance matrix
// Compute principal axis from covariance matrix
// TODO: compare to https://en.wikipedia.org/wiki/Eigenvalue_algorithm
// Compute bounds relative to principle axis
// Compute min/max points
// uses sum of absolute differences instead of squared distance to find the best match
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\Image.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Environment equirectangluar image has reversed phi
// Convert range [-1/4 pi, 7/4 pi] to [0.0, 1.0]
// Convert range [0, pi] to [0.0, 1.0]
// Convert range [0.0, 1.0] to [0, pi]
// Convert range [0.0, 1.0] to [-1/4 pi, 7/4 pi]
// [0] [1]
// [2] [3]
// [0] [1]
// [2] [3]
// [0] [1]
// [2] [3]
// [0] [1]
// [2] [3]
// +Y direction in z-up axis
// -Y direction in z-up axis
// +Z direction in z-up axis
// -Z direction in z-up axis
// +X direction in z-up axis
// -X direction in z-up axis
// Convert cubemap coordinates from GL axis to z-up axis
// Convert cubemap coordinates from z-up axis to GL axis
// Scale up to [-1, 1] range (inclusive), offset by 0.5 to point to texel center.
// CHECK: is half pixel correct ?
// s and t are the -1..1 texture coordinate on the current face.
// Get projected area for this texel
//--------------------------------------------------------------------------------------------------
//
// static helper functions for image information
//
//--------------------------------------------------------------------------------------------------
// TODO: check 1-bit-alpha is used
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageColorSpace.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// Alpha
// Alpha
// Alpha
// Alpha
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// writes out one 8*8 block of the 16*16 tile per iteration
// writes out 2 rows of an 8*8 block per iteration
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// Red
// Green
// Blue
// writes out one 8*8 block of the 16*16 tile per iteration
// writes out 2 rows of an 8*8 block per iteration
// Red
// Green
// Blue
// Alpha
// Red
// Green
// Blue
// Alpha
// Red
// Green
// Blue
// Alpha
// Red
// Green
// Blue
// Alpha
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageCommand.cpp
// image command function type
// heightmap ( image, bumpiness )
// addnormals ( image, image )
// grayscale ( image )
// image command argument type
// image command parse state
// image command function
// image command argument
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageCompressDXT.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageCompressETC.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Convert byte RGBA_8_8_8_8 to float RGBA
// Encode 
// Write to destination memory
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageConvert.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//uint64_t startClocks = rdtsc();
//uint64_t endClocks = rdtsc();
//BE_LOG("%DXT compression in %" PRIu64 " clocks\n", endClocks - startClocks);
// Create output image based on src (this) image
// If source format is compressed, then decompress to RGBA_8_8_8_8
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageDecompressDXT.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageDecompressETC.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*****************************************************************************
/*****************************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*nMode*/)
// check flipbit
// differential mode 5 colour bits + 3 difference bits
// get base colour for subblock 1
// get differential colour for subblock 2
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// individual mode 4 + 4 colour bits
// get base colour for subblock 1
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// get base colour for subblock 2
// copy bits to lower sig
// copy bits to lower sig
// copy bits to lower sig
// get the modtables for each subblock
// 2 2x4 blocks side by side
// vertical
// horizontal
// 2 4x2 blocks on top of each other
/*!***********************************************************************
// decompress into a buffer big enough to take the minimum size
// copy from larger temp buffer to output data
// decompress larger MIP levels straight into the output data
// swap r and b channels
// read color block from data stream
// Fill alpha channel first
// ETC2 RGB block
// ETC2 RGB/punchthrough alpha block 
// EAC block
// ETC2 RGB block
// FIXME: a bug !
// EAC block
// EAC block
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageDecompressPVRTC.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*****************************************************************************
/********************************************************************************/
/*!***********************************************************************
// Opaque Colour Mode - RGB 554
// 5->5 bits
// 5->5 bits
// 4->5 bits
// 0->4 bits
// Transparent Colour Mode - ARGB 3443
// 4->5 bits
// 4->5 bits
// 3->5 bits
// 3->4 bits - note 0 at right
/*!***********************************************************************
// Opaque Colour Mode - RGB 555
// 5->5 bits 
// 5->5 bits
// 5->5 bits
// 0 bits
// Transparent Colour Mode - ARGB 3444
// 4->5 bits
// 4->5 bits
// 4->5 bits
// 3->4 bits - note 0 at right
/*!***********************************************************************
//Convert to int 32.
//Get vectors.
//Multiply colours.
//Loop through pixels to achieve results.
//Loop through pixels to achieve results.
/*!***********************************************************************
// Unpack differently depending on 2bpp or 4bpp modes.
// determine which of the three modes are in use:
// If this is the either the H-only or V-only interpolation mode...
// look at the "LSB" for the "centre" (V=2,H=4) texel. Its LSB is now
// actually used to indicate whether it's the H-only mode or the V-only...
// The centre texel data is the at (y==2, x==4) and so its LSB is at bit 20.
// This is the V-only mode
// This is the H-only mode
// Create an extra bit for the centre pixel so that it looks like
// we have 2 actual bits for this texel. It makes later coding much easier.
// set it to produce code for 1.0
// clear it to produce 0.0 code
// end if H-Only or V-Only interpolation mode was chosen
/*set it*/
/*clear it*/
// run through all the pixels in the block. Note we can now treat all the
// "stored" values as if they have 2bits (even when they didn't!)
// if this is a stored value...
// end for y
// else if direct encoded 2bit mode - i.e. 1 mode bit per pixel
/*
// end for y
//Much simpler than the 2bpp decompression, only two modes, so the n/8 values are set directly.
// run through all the pixels in the word.
//if (i32ModulationValues==0) {}; don't need to check 0, 0 = 0/8.
//+10 tells the decompressor to punch through alpha.
// end for x
// end for y
// end for x
// end for y
/*!***********************************************************************
// extract the modulation value. If a simple encoding
// if this is a stored value
// else average from the neighbours
// if H&V interpolation...
// else if H-Only
// else it's V-Only
/*!***********************************************************************
//4bpp only needs 8*8 values, but 2bpp needs 16*8, so rather than wasting processor time we just statically allocate 16*8.
//Only 2bpp needs this.
//4bpp only needs 16 values, but 2bpp needs 32, so rather than wasting processor time we just statically allocate 32.
//Get the modulations from each word.
// Bilinear upscale image data from 2x2 -> 4x4
//Convert the 32bit precision result to 8 bit per channel colour.
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
//Initially assume X is the larger size.
//Check the sizes are valid.
//If Y is the larger dimension - switch the min/max values.
// Step through all the bits in the "minimum" dimension
// Prepend any unused bits
/*!***********************************************************************
// map P
// map Q
// map R
// map S
/*!***********************************************************************
// Calculate number of words
// Structs used for decompression
// For each row of words
// for each column of words
//Work out the offsets into the twiddle structs, multiply by two as there are two members per word.
//Access individual elements to fill out PVRTCWord
// assemble 4 words into struct to get decompressed pixels from
// for each word
// for each row of words
//Return the data size
/*!***********************************************************************
//Check the X and Y values are at least the minimum size.
//Decompress the surface.
//Loop through all the required pixels.
//Free the temporary buffer.
/*****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFile.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 확장자에 맞춰서 로딩함수 call
//LoadBTexFromMemory(name, data, size);
// 못 읽었다면 확장자를 붙여가면서 읽어본다.
//std::string s = filename;
//std::string ext = s.substr(s.find_last_of("."));
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFileBMP.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 'BM'
// 8 bits paletted color
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFileDDS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// surface description flags
// pixel format flags
// our extended flags
// caps1
// caps2
// DDS legacy formats
// !D3D_DISABLE_9EX
// !D3D_DISABLE_9EX
// DX10
// DX10 formats
//case DX10_FORMAT_R16_UNORM: format = Format::R_16; break;
//case DX10_FORMAT_R16G16_UNORM: format = Format::RG_16_16; break;
//case DX10_FORMAT_R16G16B16A16_UNORM: format = Format::RGBA_16_16_16_16; break;
//case DX10_FORMAT_R10G10B10A2_UNORM: format = Format::RGBA_10_10_10_2; break;
//this->format = Format::L_16;
// doom3 RXGB
// ATI 3DTc
// ATI 3DTc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFileHDR.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Reference: http ://paulbourke.net/dataformats/pic/
// #?RADIANCE
// standard conversion from float pixels to rgbe pixels
// standard conversion from rgbe to float pixels 
// note: Ward uses ldexp(col + 0.5, exp - (128 + 8)).  However we wanted pixels
//       in the range [0,1] to map back into the range [0, 1].
// nonzero pixel
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFileJPG.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
/* "public" fields */
/* for return to caller */
/*
/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
/* Always display the message. */
/* We could postpone this until after returning, if we chose. */
/* Return control to the setjmp point */
/*
/* This struct contains the JPEG decompression parameters and pointers to
/* We use our private extension JPEG error handler.
/* More stuff */
//FILE * infile;		/* source file */
/* source file */
/* Output row buffer */
/* physical row width in output buffer */
/* In this example we want to open the input file before doing anything else,
/* Step 1: allocate and initialize JPEG decompression object */
/* We set up the normal JPEG error routines, then override error_exit. */
/* Establish the setjmp return context for my_error_exit to use. */
/* If we get here, the JPEG code has signaled an error.
/* Now we can initialize the JPEG decompression object. */
/* Step 2: specify data source (eg, a file) */
/* Step 3: read file parameters with jpeg_read_header() */
/* We can ignore the return value from jpeg_read_header since
/* Step 5: Start decompressor */
/* We can ignore the return value since suspension is not possible
/* Step 4: set parameters for decompression */
/* We may need to do some setup of our own at this point before reading
/* JSAMPLEs per row in output buffer */
/* Make a one-row-high sample array that will go away when done with image */
/* Step 6: while (scan lines remain to be read) */
/*           jpeg_read_scanlines(...); */
/* Here we use the library's state variable cinfo.output_scanline as the
/* jpeg_read_scanlines expects an array of pointers to scanlines.
/* Assume put_scanline_someplace wants a pointer and sample count. */
/* Step 7: Finish decompression */
/* We can ignore the return value since suspension is not possible
/* Step 8: Release JPEG decompression object */
/* This is an important step since it will release a good deal of memory. */
/* After finish_decompress, we can close the input file.
/* At this point you may want to check to see whether any corrupt-data
/* And we're done! */
/*
/*
/* This struct contains the JPEG compression parameters and pointers to
/* This struct represents a JPEG error handler.  It is declared separately
/* More stuff */
/* target file */
/* pointer to JSAMPLE row[s] */
/* physical row width in image buffer */
/* Step 1: allocate and initialize JPEG compression object */
/* We have to set up the error handler first, in case the initialization
/* Now we can initialize the JPEG compression object. */
/* Step 2: specify data destination (eg, a file) */
/* Note: steps 2 and 3 can be done in either order. */
/* Here we use the library-supplied code to send compressed data to a
/* Step 3: set parameters for compression */
/* First we supply a description of the input image.
/* image width and height, in pixels */
/* # of color components per pixel */
/* colorspace of input image */
/* Now use the library's routine to set default compression parameters.
/* Now you can set any non-default parameters you wish to.
/* limit to baseline-JPEG values */);
/* Step 4: Start compressor */
/* TRUE ensures that we will write a complete interchange-JPEG file.
/* Step 5: while (scan lines remain to be written) */
/*           jpeg_write_scanlines(...); */
/* Here we use the library's state variable cinfo.next_scanline as the
/* JSAMPLEs per row in image_buffer */
/* jpeg_write_scanlines expects an array of pointers to scanlines.
//row_pointer[0] = & src[(cinfo.image_height - 1 - cinfo.next_scanline) * row_stride];    
/* Step 6: Finish compression */
/* After finish_compress, we can close the output file. */
/* Step 7: release JPEG compression object */
/* This is an important step since it will release a good deal of memory. */
/* And we're done! */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFilePCX.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 0x0a
// version 5
// when 1, it's RLE encoding
// bits per pixel
// 16-color palette
// number of color planes
// number of bytes per line
// 1 = color, 2 = grayscale
// 8 bits paletted color
// 24 bits color
// FIXME: fwrite 를 한번에 하자
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFilePNG.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// get picture info
// tell libpng to strip 16 bit/color files down to 8 bits/color
// expand paletted images to RGB triplets
// expand gray-scaled images to RGB triplets
// if there is no alpha information, fill with 255
//	if (!(color_type & PNG_COLOR_MASK_ALPHA)) {
//		png_set_filler(png, 255, PNG_FILLER_AFTER);
//}
// expand pictures with less than 8bpp to 8bpp
// update structure with the above settings
// allocate the memory to hold the image
// set a new exception handler
// read image data
// read rest of file, and get additional chunks in info
// clean up after the read, and free any memory allocated
//simdProcessor->Memcpy(png->io_ptr, data, length);
// Allocate/initialize the image information data.
// Set error handling.
// Write the file header information.
// clean up after the write, and free any memory allocated
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFilePVR.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//Max(1, (int)header->u32NumSurfaces);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFileTGA.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// image types
// interleave flag
// 칼라맵 정보가 있다면 읽어들인다
// read appropriate number of bytes, break into rgb & put in map
// grey scale, read and triplicate
// 5 bits each of red green and blue
// watch for byte order
// 8 bits each of blue green and red
// read alpha byte
// RLE check
// have to restart run
// stream of unencoded pixels
// single pixel replicated
// decrement count & get pixel
// have already read count & (at least) first pixel
// replicated pixels
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageFormat.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
//
// XXXToRGBA8888 (unpacking function from custom format to rgba8888)
//
//--------------------------------------------------------------------------------------------------
//simdProcessor->Memcpy(dst, src, 4 * numPixels);
//--------------------------------------------------------------------------------------------------
//
// RGBA8888ToXXX (packing function from rgba8888 to custom format)
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
// XXXToRGBA32F (unpacking function from custom format to rgba32f)
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
// RGBA32FToXXX (packing function from rgba32f to custom format)
//
//--------------------------------------------------------------------------------------------------
// 컬러 채널 표기(RGBALX)는 바이트 주소체계와 선형이다 (D3D식 표기와 반대)
// +----------------------------------------------------------------------------------- name
// |                        +---------------------------------------------------------- size (bytes per pixel or bytes per block)
// |                        |   +------------------------------------------------------ number of components
// |                        |   |   +-------------------------------------------------- r bits
// |                        |   |   |   +---------------------------------------------- g bits
// |                        |   |   |   |   +------------------------------------------ b bits
// |                        |   |   |   |   |   +-------------------------------------- a bits
// |                        |   |   |   |   |   |   +---------------------------------- type
// |                        |   |   |   |   |   |   |  +------------------------------- unpackRGBA8888
// |                        |   |   |   |   |   |   |  |        +---------------------- packRGBA8888
// |                        |   |   |   |   |   |   |  |        |        +------------- unpackRGBA32F
// |                        |   |   |   |   |   |   |  |        |        |        +---- packRGBA32F
// |                        |   |   |   |   |   |   |  |        |        |        |
/*R8ToRGBA8888*/, nullptr/*RGBA8888ToR8*/, nullptr, nullptr },
/*RG88ToRGBA8888*/, nullptr/*RGBA8888ToRG88*/, nullptr, nullptr },
/*RGB888ToRGBA8888*/, nullptr/*RGBA8888ToRGB888*/, nullptr, nullptr },
/*RGB888ToRGBA8888*/, nullptr /*RGBA8888ToRGB888*/, nullptr, nullptr },
// packed format ------------------------------------------------------------------------------
// float format -------------------------------------------------------------------------------
// DXT (BTC) ----------------------------------------------------------------------------------
// PVRTC --------------------------------------------------------------------------------------
// ETC ----------------------------------------------------------------------------------------
// ATC ----------------------------------------------------------------------------------------
// depth --------------------------------------------------------------------------------------
// Explicit alpha
// Interpolated alpha
// Explicit alpha
// Interpolated alpha
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// gammaToLinearTable[i] = (i/255)^2.2
//pic[3] = 0;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Image\ImageResize.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: Should we need to lerp in linear color space ?
// NOTE: Should we need to lerp in linear color space ?
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Input\InputSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Input\KeyCmd.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//------------------------
// Aliases to make it easier to bind or to support old configs
//------------------------
// Remove binding for this keynum
// 키를 누르는 동안 오는 자동 반복 신호 무시
// K_JOY1 이상은 키보드외 입력장치의 키 이벤트 신호
//BE_LOG("%s is unbound.\n", KeyCmdSystem::KeynumToString(keynum));
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\AABB.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: Math::Infinity is big number not real float INFINITY.
// d1 = center 와 평면의 거리
// d2 = extent 벡터를 분리축(평면의 normal) 에 투영한 거리
// X 축 투영 거리 비교
// Y 축 투영 거리 비교
// Z 축 투영 거리 비교
// 선분의 방향과 AABB 의 축들과의 외적한 축들에 대해서 검사
//       +Z
//
//       4------7
//      /|     /|
//     / |    / |
//    5------6  |       
//    |  0---|--3  +Y
//    | /    | /
//    |/     |/  
//    1------2
//
// +X 
//
// REF: RTCD p.179 - Testing AABB Against Triangle
// AABB center
// AABB extent
// AABB center 를 원점으로 설정
// triangle edge vectors
// a00 축 비교 
// a00 = cross(x, f0) = (0, -f0.z, f0.y)
// r = e.x * abs(dot(x, a00)) + e.y * abs(dot(y, a00)) + e.z * abs(dot(z, a00))
// dot(a00, v0) = dot(a00, v1)
// dot(a00, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a01 축 비교
// a01 = cross(x, f1) = (0, -f1.z, f1.y)
// r = e.x * abs(dot(x, a01)) + e.y * abs(dot(y, a01)) + e.z * abs(dot(z, a01))
// dot(a01, v0)
// dot(a01, v1) = dot(a01, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a02 축 비교
// a02 = cross(x, f2) = (0, -f2.z, f2.y)
// r = e.x * abs(dot(x, a02)) + e.y * abs(dot(y, a02)) + e.z * abs(dot(z, a02))
// dot(a02, v0) = dot(a02, v2)
// dot(a02, v1)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a10 축 비교
// a10 = cross(y, f0) = (f0.z, 0, -f0.x)
// r = e.x * abs(dot(x, a10)) + e.y * abs(dot(y, a10)) + e.z * abs(dot(z, a10))
// dot(a10, v0) = dot(v10, v1)
// dot(a10, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a11 축 비교
// a11 = cross(y, f1) = (f1.z, 0, -f1.x)
// r = e.x * abs(dot(x, a11)) + e.y * abs(dot(y, a11)) + e.z * abs(dot(z, a11))
// dot(a11, v0)
// dot(a11, v1) = dot(a11, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a12 축 비교
// a12 = cross(y, f2) = (f2.z, 0, -f2.x)
// r = e.x * abs(dot(x, a12)) + e.y * abs(dot(y, a12)) + e.z * abs(dot(z, a12))
// dot(a12, v0) = dot(a12, v2)
// dot(a12, v1)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a20 축 비교
// a20 = cross(z, f0) = (-f0.y, f0.x, 0)
// r = e.x * abs(dot(x, a20)) + e.y * abs(dot(y, a20)) + e.z * abs(dot(z, a20))
// dot(a20, v0) = dot(v20, v1)
// dot(a20, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a21 축 비교
// a21 = cross(z, f1) = (-f1.y, f1.x, 0)
// r = e.x * abs(dot(x, a21)) + e.y * abs(dot(y, a21)) + e.z * abs(dot(z, a21))
// dot(a21, v0)
// dot(a21, v1) = dot(a21, v2)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// a22 축 비교
// a22 = cross(z, f2) = (-f2.y, f2.x, 0)
// r = e.x * abs(dot(x, a22)) + e.y * abs(dot(y, a22)) + e.z * abs(dot(z, a22))
// dot(a22, v0) = dot(a22, v2)
// dot(a22, v1)
// projection intervals are disjoint if Min(p0, p1, p2) > r or -Max(p0, p1, p2) > r
// AABB.x 축 비교
// AABB.y 축 비교
// AABB.z 축 비교
// Triangle.normal 축 비교
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Angles.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------------------------------------
//
// * Euler 회전행렬을 만들어 x, y, z 기저축 벡터들을 구한다
//
// V = R(yaw) * R(pitch) * R(roll)
//    
//     | cosy*cosp  -siny*cosr + sinr*sinp*cosy   sinr*siny + sinp*cosy*cosr |
// V = | siny*cosp   cosr*cosy + sinr*sinp*siny  -cosy*sinr + cosr*sinp*siny |
//     |     -sinp                    sinr*cosp                    cosr*cosp |
//
//---------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------
//
// * Euler Angles to Quaternion
//
// X축 회전 사원수 = qr( -sin(r/2), 0, 0, cos(r/2) )
// Y축 회전 사원수 = qp( 0, -sin(p/2), 0, cos(p/2) )
// Z축 회전 사원수 = qy( 0, 0, -sin(y/2), cos(y/2) )
//  
// qr * qp * qy = { cos(r/2) * sin(p/2) * sin(y/2) - sin(r/2) * cos(p/2) * cos(y/2) } * i +
//                {-cos(r/2) * sin(p/2) * cos(y/2) - sin(r/2) * cos(p/2) * sin(y/2) } * j + 
//                { sin(r/2) * sin(p/2) * cos(y/2) - cos(r/2) * cos(p/2) * sin(y/2) } * k + 
//                { cos(r/2) * cos(p/2) * cos(y/2) + sin(r/2) * sin(p/2) * sin(y/2) }
//      
//-------------------------------------------------------------------------------------------
//vec *= (1.0f / sin(angle));
// get sines and cosines of half angles
//---------------------------------------------------------------------------------
//
// V = Rz * Ry * Rx
//   = R(yaw) * R(pitch) * R(roll)
//
//     | 1     0      0 |   |  cosp  0  sinp |   | cosy  -siny  0 |
//   = | 0  cosr  -sinr | * |     0  1     0 | * | siny   cosy  0 |
//     | 0  sinr   cosr |   | -sinp  0  cosp |   |    0      0  1 |
//
//     | cosy*cosp  -siny*cosr + sinr*sinp*cosy   sinr*siny + sinp*cosy*cosr |
//   = | siny*cosp   cosr*cosy + sinr*sinp*siny  -cosy*sinr + cosr*sinp*siny |
//     |     -sinp                    sinr*cosp                    cosr*cosp |
//
//---------------------------------------------------------------------------------
// This is an "unrolled" contatenation of rotation matrices Rx Ry and Rz
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Color3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// RGB 를 HSL 로 변환
// HSL 을 RGB 로 변환
// http://chilliant.blogspot.kr/2012/08/srgb-approximations-for-hlsl.html
// Approximate Planckian locus in CIE 1960 UCS
// XYZ to RGB with BT.709 primaries
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Color4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Complex.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\CQuaternion.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Cylinder.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Test if ray fully outside either endcap of cylinder
// ray outside p[0] side of cylinder
// ray outside p[1] side of cylinder
// Test if ray runs parallel to cylinder axis
// 'a' and thus the ray lie outside cylinder
// Now known that ray intersects cylinder; figure out how it intersects
// Intersect ray against p[0] endcap
// Intersect ray against p[1] endcap
// 'a' lies inside cylinder
// No real roots; no intersection
// Test if intersection outside cylinder on p[0] side	
// Keep intersection if Dot(L(t) - p[0], L(t) - p[0]) <= r^2
// Test if intersection outside cylinder on p[1] side	
// Keep intersection if Dot(L(t) - p[1], L(t) - p[1]) <= r^2
// Ray intersects cylinder between the endcaps
// Test if segment fully outside either endcap of cylinder
// Segment outside p[0] side of cylinder
// Segment outside p[1] side of cylinder
// Test if segment runs parallel to cylinder axis
// 'a' and thus the segment lie outside cylinder
// No real roots; no intersection
// Test if intersection outside cylinder on p[0] side	
// Keep intersection if Dot(L(t) - p[0], L(t) - p[0]) <= r^2
// Test if intersection outside cylinder on p[1] side
// Keep intersection if Dot(L(t) - p[1], L(t) - p[1]) <= r^2
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Frustum.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
// transform point to frustum space
// test whether or not the point is within the frustum
// Tests if any of the planes of the frustum can be used as a separating plane.
//
//   3 muls best case
//  25 muls worst case
// near plane
// far plane
// test left/right planes
// test up/down planes
// Tests if any of the planes of the frustum can be used as a separating plane.
//
//  24 muls best case
//  37 muls worst case
// transform the bounds into the space of this frustum
// Tests if any of the planes of the frustum can be used as a separating plane.
//
//  39 muls best case
//  61 muls worst case
// transform the box into the space of this frustum
// Tests if any of the planes of the frustum can be used as a separating plane.
//
//   9 muls best case
//  21 muls worst case
// test near plane
// test far plane
// test left/right planes
// test up/down planes
// Tests if any of the planes of this frustum can be used as a separating plane.
//
//   0 muls best case
//  30 muls worst case
// test near plane
// test far plane
// test left plane
// test right plane
// test up plane
// test down plane
// Tests if any of the planes of this frustum can be used as a separating plane.
//
//  58 muls best case
//  88 muls worst case
// transform the given frustum into the space of this frustum
// Tests if any of the bounding box planes can be used as a separating plane.
//  7 divs
//  30 muls
// test near plane
// test far plane
// test left plane
// test right plane
// test up plane
// test down plane
// Returns true if the ray starts inside the frustum.
// If there was an intersection scale1 <= scale2
// test near plane
// test far plane
// test left plane
// test right plane
// test up plane
// test down plane
// test if any edges of the other frustum intersect this frustum
// test if any edges of the other frustum intersect this frustum
// FIXME: test this
// Returns true if the line intersects the box between the start and end point.
// Creates a frustum which contains the projection of the AABB.
// Creates a frustum which contains the projection of the OBB.
// Creates a frustum which contains the projection of the sphere.
// Returns false if no part of the bounds extends beyond the near plane.
// Returns false if no part of the box extends beyond the near plane.
// Returns false if no part of the sphere extends beyond the near plane.
// Returns false if no part of the frustum extends beyond the near plane.
// http://www.gamedev.net/topic/604797-minimum-bounding-sphere-of-a-frustum/
// planes point outwards
// 22 muls
// 18 muls
// 40 muls
// 76 muls
// test left plane
// test right plane
// test up plane
// test down plane
// add start point to projection bounds
// add end point to projection bounds
// test left plane
// test right plane
// test up plane
// test down plane
// Returns true if the ray starts inside the bounds.
// If there was an intersection scale1 <= scale2
//#if !defined(__UNIX__)
// if the frustum origin is inside the bounds
// bounds that cover the whole frustum
// transform the bounds into the space of this frustum
// test outer four edges of the bounds
// if the bounds are completely outside this frustum
// if the bounds are completely inside this frustum
// test the remaining edges of the bounds
// if the bounds extend beyond two or more boundaries of this frustum
// test the outer edges of this frustum for intersection with the bounds
//#endif
// test left/right planes
// test up/down planes
// FIXME: implement
// bounds that cover the whole frustum
// if the frustum origin is inside the other frustum
// bounds that cover the whole frustum
// transform the given frustum into the space of this frustum
// test outer four edges of the other frustum
// if the other frustum is completely outside this frustum
// if the other frustum is completely inside this frustum
// test the remaining edges of the other frustum
// if the other frustum extends beyond two or more boundaries of this frustum
// test the outer edges of this frustum for intersection with the other frustum
// Clips the frustum far extents to the box.
// make sure the frustum is not clipped between the frustum origin and the near plane
// Returns true if part of the line is inside the frustum.
// Does not clip to the near and far plane.
// test left plane
// test right plane
// test up plane
// test down plane
// if completely inside
// if the frustum origin is inside the other frustum
// bounds that cover the whole frustum
// clip the outer edges of the given frustum to the clip bounds
// transform the clipped frustum to the space of this frustum
// test outer four edges of the clipped frustum
// get cull bits for the clipped frustum
// if the clipped frustum is not completely inside this frustum
// test the remaining edges of the clipped frustum
// if the clipped frustum far end points are inside this frustum
// if the clipped frustum is not clipped to a single plane of the clip bounds
// transform the clip box into the space of the other frustum
// cull the box corners with the other frustum
// transform the clip box into the space of this frustum
// clip the edges of the clip bounds to the other frustum and add the clipped edges to the projection bounds
// if the clipped frustum extends beyond two or more boundaries of this frustum
// transform this frustum into the space of the other frustum
// transform this frustum into the space of the clip bounds
// test the outer edges of this frustum for intersection with both the other frustum and the clip bounds
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Half.cpp
///////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// Digital Ltd. LLC
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// *       Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// *       Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// *       Neither the name of Industrial Light & Magic nor the names of
// its contributors may be used to endorse or promote products derived
// from this software without specific prior written permission. 
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////
//
// Plus or minus zero
//
//
// Denormalized number -- renormalize it
//
//
// Positive or negative infinity
//
//
// Nan -- preserve sign and significand bits
//
//
// Normalized number
//
//
// Assemble s, e and m.
//
//-----------------------------------------------
// Overflow handler for float-to-half conversion;
// generates a hardware floating-point overflow,
// which may be trapped by the operating system.
//-----------------------------------------------
// this will overflow before
// the forloop terminates
//-----------------------------------------------------
// Float-to-half conversion -- general case, including
// zeroes, denormalized numbers and exponent overflows.
//-----------------------------------------------------
//
// Our floating point number, f, is represented by the bit
// pattern in integer i.  Disassemble that bit pattern into
// the sign, s, the exponent, e, and the significand, m.
// Shift s into the position where it will go in in the
// resulting half number.
// Adjust e, accounting for the different exponent bias
// of float and half (127 versus 15).
//
//
// Now reassemble s, e and m into a half:
//
//
// E is less than -10.  The absolute value of f is
// less than HALF_MIN (f may be a small normalized
// float, a denormalized float or a zero).
//
// We convert f to a half zero.
//
//
// E is between -10 and 0.  F is a normalized float,
// whose magnitude is less than HALF_NRM_MIN.
//
// We convert f to a denormalized half.
// 
//
// Round to nearest, round "0.5" up.
//
// Rounding may cause the significand to overflow and make
// our number normalized.  Because of the way a half's bits
// are laid out, we don't have to treat this case separately;
// the code below will handle it correctly.
// 
//
// Assemble the half from s, e (zero) and m.
//
//
// F is an infinity; convert f to a half
// infinity with the same sign as f.
//
//
// F is a NAN; we produce a half NAN that preserves
// the sign bit and the 10 leftmost bits of the
// significand of f, with one exception: If the 10
// leftmost bits are all zero, the NAN would turn 
// into an infinity, so we have to set at least one
// bit in the significand.
//
//
// E is greater than zero.  F is a normalized float.
// We try to convert f to a normalized half.
//
//
// Round to nearest, round "0.5" up
//
// overflow in significand,
// adjust exponent
//
// Handle exponent overflow
//
// Cause a hardware floating point overflow;
// if this returns, the half becomes an
// infinity with the same sign as f.
//
// Assemble the half from s, e and m.
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Math.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 1.1754944e-038f
// inverse square root lookup table
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Matrix2.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 2+4 = 6 multiplications
//		 1 division
// 2*4 = 8 multiplications
//		 2 division
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Matrix3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 18+3+9 = 30 multiplications
//			 1 division
// 3*10 = 30 multiplications
//		   3 divisions
//	4*2+4*4 = 24 multiplications
//		2*1 =  2 divisions
// r0 = m0.Inverse();	// 2x2
// r1 = r0 * m1;		// 2x1 = 2x2 * 2x1
// r2 = m2 * r1;		// 1x1 = 1x2 * 2x1
// r3 = r2 - m3;		// 1x1 = 1x1 - 1x1
// r3.InverseSelf();
// r2 = m2 * r0;		// 1x2 = 1x2 * 2x2
// m2 = r3 * r2;		// 1x2 = 1x1 * 1x2
// m0 = r0 - r1 * m2;	// 2x2 - 2x1 * 1x2
// m1 = r1 * r3;		// 2x1 = 2x1 * 1x1
// m3 = -r3;
//------------------------------------------------
//  
//        | 1    0     0 | | m00  m10  m20 |
// Rx M = | 0  cos  -sin | | m01  m11  m21 |
//        | 0  sin   cos | | m02  m12  m22 |
//
//------------------------------------------------
//------------------------------------------------
//  
//        |  cos  0  sin | | m00  m10  m20 |
// Ry M = |    0  1    0 | | m01  m11  m21 |
//        | -sin  0  cos | | m02  m12  m22 |
//
//------------------------------------------------
//------------------------------------------------
//
//        | cos  -sin  0 | | m00  m10  m20 |
// Rz M = | sin   cos  0 | | m01  m11  m21 |
//        |   0     0  1 | | m02  m12  m22 |
//
//------------------------------------------------
//------------------------------------------------
//
//        | sx   0   0 | | m00  m10  m20 |
// S M  = |  0  sy   0 | | m01  m11  m21 |
//        |  0   0  sz | | m02  m12  m22 |
//
//------------------------------------------------
//--------------------------------------------------------------------------------------------
//
// * Rotation Matrix to Euler Angles
//
// V = Rz * Ry * Rx
//   = R(yaw) * R(pitch) * R(roll)
//    
//     | cosy*cosp  -siny*cosr + sinr*sinp*cosy   sinr*siny + sinp*cosy*cosr |
// V = | siny*cosp   cosr*cosy + sinr*sinp*siny  -cosy*sinr + cosr*sinp*siny |
//     |     -sinp                    sinr*cosp                    cosr*cosp |
// 
// 1) cosp != 0 인 경우
//
// f02       = -sinp
// f01 / f00 = siny*cosp / cosy*cosp = siny / cosy = tany
// f12 / f22 = sinr*cosp / cosr*cosp = sinr / cosr = tanr	
//
// pitch = -asin( f02 )
// yaw   = atan( f01 / f00 )
// roll  = atan( f12 / f22 )
//
// 2) cosp == 0 인 경우
//
// i) sinp == 1 인 경우
//
//     |  0  -siny*cosr + sinr*cosy   sinr*siny + cosy*cosr |
// V = |  0   cosr*cosy + sinr*siny  -cosy*sinr + cosr*siny |
//     | -1                       0                       0 |
//
//     |  0  -sin(y - r)  cos(y - r) |
// V = |  0   cos(y - r)  sin(y - r) |
//     | -1            0           0 |
//
// f10 / f11 = -sin(y - r) / cos(y - r) = -tan(y - r)
//
// yaw-roll = -atan( f10 / f11 )
// pitch    = -asin( f02 )
//  
// ii) sinp == -1 인경우
//
//     |  0  -siny*cosr - sinr*cosy   sinr*siny - cosy*cosr |
// V = |  0   cosr*cosy - sinr*siny  -cosy*sinr - cosr*siny |
//     |  1                       0                       0 |
//
//     |  0  -sin(y + r)   cos(y + r) |
// V = |  0   cos(y + r)  -sin(y + r) |
//     |  1            0            0 |
//  
// f10 / f11 = -sin(y + r) / cos(y + r) = -tan(y + r)
//
// yaw+roll = -atan( f10 / f11 )
// pitch    = -asin( f02 )
//
// yaw 와 pitch 가 같은 자유도를 갖는다. roll 을 0 으로 고정시키면 i), ii) 모두의 경우에,..
//
// pitch    = -asin( f02 )
// yaw      = -atan( f10 / f11 )
// roll     = 0
//
//--------------------------------------------------------------------------------------------
// asin 의 NAN 값을 피하기위해 clamp
//
// not a unique solution
//-------------------------------------------------------------------------------------------
//
// * Rotation Matrix to Axis-Angle
//
// N = rotation axis
// s = sin( theta )
// c = cos( theta )
//
//     |   0  -Nz   Ny |        | -(Ny^2 + Nz^2)           Nx*Ny           Nx*Nz |
// S = |  Nz    0  -Nx |  S^2 = |           Nx*y  -(Nx^2 + Nz^2)           Ny*Nz |
//     | -Ny   Nx    0 |        |           Nx*z           Ny*Nz  -(Nx^2 + Ny^2) |
//
// R = I + s*S + (1-c)*S^2
//
//     |     c + (1-c)*Nx^2  (1-c)*Nx*Ny - s*Nz  (1-c)*Nx*Nz + s*Ny |
// R = | (1-c)*Nx*Ny + s*Nz      c + (1-c)*Ny^2  (1-c)*Ny*Nz - s*Nx |
//     | (1-c)*Nx*Nz - s*Ny  (1-c)*Ny*Nz + s*Nx      c + (1-c)*Nz^2 | 
//
// trace(R) = R00 + R11 + R22 = 3*c + (1-c) * (Nx^2 + Ny^2 + Nz^2) = 3*c + (1-c) 
//          = 2*c + 1
//
// 1) theta == 0 (trace(R) == 3)
//
// 회전행렬은 단위행렬이므로, 회전축은 아무거나 할수 있다
//
// 2) 0 < theta < pi (3 > trace(R) > -1)
//  
// theta = acos( (trace(R) - 1) / 2 )
//
// Vx = R21 - R12 = 2*s*Nx
// Vy = R02 - R20 = 2*s*Ny
// Vz = R10 - R01 = 2*s*Nz
//  
// Nx = Vx / (2*s) 
// Ny = Vy / (2*s)
// Nz = Vz / (2*s)
//
// (단순히 V 를 normalize 해도 된다)
//
// 3) theta == pi (trace(R) == -1)
//
//     | 2*Nx^2 - 1     2*Nx*Ny     2*Nx*Nz |
// R = |    2*Nx*Ny  2*Ny^2 - 1     2*Ny*Nz |
//     |    2*Nx*Nz     2*Ny*Nz  2*Nz^2 - 1 |
//
// 이때 3가지 방법이 있는데..
//     ___________________
// i) √R00 - R11 - R22 + 1 / 2 = Nx 
//     ___________________
// j) √R11 - R00 - R22 + 1 / 2 = Ny
//     ___________________
// k) √R22 - R00 - R11 + 1 / 2 = Nz
//
// 제곱근 안의 값이 양수가 나오게 하려면 R 의 대각성분중에 가장 큰성분을 찾아야 한다
//
// i, j, k 중 한가지 방법으로 Nx, Ny, Nz 중 하나를 구했으면, 나머지 값들은 쉽게 구할수 있다
//  
//-------------------------------------------------------------------------------------------
// trace == 2c + 1
// 쿼터니언 안 거치고 구현하기
// theta == 0
// 일단 쿼터니언 값을 만든다
// TODO: trace > -1.0f 가 아닌 이유는?? 3D Game Engine Design 참고할것
// angle is zero, axis can be anything
// r.vec *= (1.0f / sin(angle));
// 걍 노멀라이징 한다
//-------------------------------------------------------------------------------------------
//
// * Rotation Matrix to Quaternion
//
// Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
// article "Quaternion Calculus and Fast Animation".
//
//-------------------------------------------------------------------------------------------
// check the diagonal
// diagonal is negative
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Matrix3x4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------
//
//        |  1  0  0  tx | | m00  m01  m02  m03 |
// T M  = |  0  1  0  ty | | m10  m11  m12  m13 |
//        |  0  0  1  tz | | m20  m21  m22  m23 |
//
//---------------------------------------------------
//---------------------------------------------------
//
//       | m00  m01  m02  m03 | |  1  0  0  tx |
// M T = | m10  m11  m12  m13 | |  0  1  0  ty |
//       | m20  m21  m22  m23 | |  0  0  1  tz |
//
//---------------------------------------------------
//---------------------------------------------------
//
//       | sx   0   0 | | m00  m01  m02  m03 |
// S M = |  0  sy   0 | | m10  m11  m12  m13 |
//       |  0   0  sz | | m20  m21  m22  m23 |
//
//---------------------------------------------------
// T * R * S
// Euclidean inverse (TRS)^{-1} = S^{-1} R^T (-T)
// get squared inverse scale factor
// negate inverse rotated translation part
// transpose rotation part
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Matrix4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 2x2 sub-determinants
// 3x3 sub-determinants
// 84+4+16 = 104 multiplications
//             1 division
// 2x2 sub-determinants required to calculate 4x4 determinant
// 3x3 sub-determinants required to calculate 4x4 determinant
// remaining 2x2 sub-determinants
// remaining 3x3 sub-determinants
// 4*18 = 72 multiplications
//         4 divisions
//  6*8+2*6 = 60 multiplications
//      2*1 =  2 divisions
// r0 = m0.Inverse();
// r1 = r0 * m1;
// r2 = m2 * r1;
// r3 = r2 - m3;
// r3.InverseSelf();
// r2 = m2 * r0;
// m2 = r3 * r2;
// m0 = r0 - r1 * m2;
// m1 = r1 * r3;
// m3 = -r3;
// The bottom row vector of the matrix should always be [ 0 0 0 1 ]
// The translation components of the original matrix
// The rotational part of the matrix should be inverted
// -(Rt * T)
// The bottom row vector of the matrix should always be [ 0 0 0 1 ]
// The translation components of the original matrix
// The rotational part of the matrix is simply the transpose of the original matrix
// -(Rt * T)
// Doolittle Algorithm
// Doolittle uses unit diagonals for the lower triangle
// Compute a line of U
// not dividing by diagonals
// Compute a line of L
// Solve Ly = b
// not dividing by diagonals
// Solve Ux = y
//---------------------------------------------------
//
//        |  1  0  0  tx | | m00  m01  m02  m03 |
// T M  = |  0  1  0  ty | | m10  m11  m12  m13 |
//        |  0  0  1  tz | | m20  m21  m22  m23 |
//        |  0  0  0   1 | | m30  m31  m32  m33 |
//
//---------------------------------------------------
//---------------------------------------------------
//
//       | m00  m01  m02  m03 | |  1  0  0  tx |
// M T = | m10  m11  m12  m13 | |  0  1  0  ty |
//       | m20  m21  m22  m23 | |  0  0  1  tz |
//       | m30  m31  m32  m33 | |  0  0  0   1 |
//
//---------------------------------------------------
//---------------------------------------------------
//
//       | sx   0   0  0 | | m00  m01  m02  m03 |
// S M = |  0  sy   0  0 | | m10  m11  m12  m13 |
//       |  0   0  sz  0 | | m20  m21  m22  m23 |
//       |  0   0   0  1 | | m30  m31  m32  m33 |
//
//---------------------------------------------------
// prevent artifacts with infinite far plane
// check for division by 0
// if zFar == -1, use an infinite far plane
// if zFar == -1, use an infinite far plane
//--------------------------------------------------------------------------------------------
//
// * 한점을 주어진 평면으로 반사(reflection)시키는 행렬을 만든다
//
// X = ( 2 * (-D*N) / (N*N) ) * N + D
//
//     | 1-2*Nx*Nx   -2*Nx*Ny   -2*Nx*Nz  2*d*Nx |
// R = |  -2*Nx*Ny  1-2*Ny*Ny   -2*Ny*Nz  2*d*Ny |
//     |  -2*Nx*Nz   -2*Ny*Nz  1-2*Nz*Nz  2*d*Nz |
//     |         0          0          0       1 |
//
//--------------------------------------------------------------------------------------------
// T * R * S
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\OBB.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
// 000000 = 0
// 000001 = 1
// 000010 = 2
// 000011 = 3
// 000100 = 4
// 000101 = 5
// 000110 = 6
// 000111 = 7
// 001000 = 8
// 001001 = 9
// 001010 = 10
// 001011 = 11
// 001100 = 12
// 001101 = 13
// 001110 = 14
// 001111 = 15
// 010000 = 16
// 010001 = 17
// 010010 = 18
// 010011 = 19
// 010100 = 20
// 010101 = 21
// 010110 = 22
// 010111 = 23
// 011000 = 24
// 011001 = 25
// 011010 = 26
// 011011 = 27
// 011100 = 28
// 011101 = 29
// 011110 = 30
// 011111 = 31
// 100000 = 32
// 100001 = 33
// 100010 = 34
// 100011 = 35
// 100100 = 36
// 100101 = 37
// 100110 = 38
// 100111 = 39
// 101000 = 40
// 101001 = 41
// 101010 = 42
// 101011 = 43
// 101100 = 44
// 101101 = 45
// 101110 = 46
// 101111 = 47
// 110000 = 48
// 110001 = 49
// 110010 = 50
// 110011 = 51
// 110100 = 52
// 110101 = 53
// 110110 = 54
// 110111 = 55
// 111000 = 56
// 111001 = 57
// 111010 = 58
// 111011 = 59
// 111100 = 60
// 111101 = 61
// 111110 = 62
// 111111 = 63
// 비어 있을 경우
// local axis 로 변환해서 AABB 로 다룬다.
// p 를 local axis 로 변환해서 AABB 에 추가
// p 가 이미 포함되어 있다.
// center 에서 p 방향으로 oriented 된 OBB 를 상정한다.
// 첫번째 축은 p 방향으로 고른다.
// 두번째 축은 OBB 의 각 축에 투영해보고 가장 independant 한 벡터를 하나 고른다.
// 첫번째 축에 투영해서 orthonormal 하게 만든다.
// 세번째 축은 외적으로 얻는다.
// axis2 에 투영해서 AABB 를 만든다.
// p 를 local axis 로 변환해서 AABB 에 추가
// aabb1 과 aabb2 중 작은 volume 의 aabb 를 기반으로 OBB 를 만든다.
// a 가 비어있을 경우
// this 가 비어있을 경우
// this 의 local axis 로 변환해서 AABB 로 다룬다.
// a 를 this.axis 에 투영해서 local AABB 를 만든다.
// a 는 이미 포함되어 있다.
// a 의 local axis 로 변환해서 AABB 로 다룬다.
// this 를 a.axis 에 투영해서 local AABB 를 만든다.
// this OBB 는 이미 a 에 포함되어 있다.
// center 사이 벡터 방향으로 oriented 된 OBB 를 2개 상정한다.
// 첫번째 축은 OBB 의 center 사이 벡터 방향으로 고른다.
// 두번째 축은 OBB 의 각 축에 투영해보고 가장 independant 한 벡터를 하나 고른다.
// ax[0] 와 ax[1] 은 각각 this.axis, a.axis
// 첫번째 축에 투영해서 orthonormal 하게 만든다.
// 세번째 축은 외적으로 얻는다.
// this 와 a 를 각각 ax[i] 에 투영해서 AABB 를 만들고 합친다.
// 가장 작은 volume 의 aabb 를 구한다.
// 가장 작은 volume 의 aabb 를 기반으로 OBB 를 만든다.
// axis[i] * t
// distance between centers and projected extents
// vector between centers
// Ax 축으로 비교 (axis[0])
// Ay 축으로 비교 (axis[1])
// Az 축으로 비교 (axis[2])
// Bx 축으로 비교 (b.axis[0])
// By 축으로 비교 (b.axis[1])
// Bz 축으로 비교 (b.axis[2])
// cross(Ax, Bx) 축으로 비교
// cross(Ax, By) 축으로 비교
// cross(Ax, Bz) 축으로 비교
// cross(Ay, Bx) 축으로 비교
// cross(Ay, By) 축으로 비교
// cross(Ay, Bz) 축으로 비교
// cross(Az, Bx) 축으로 비교
// cross(Az, By) 축으로 비교
// cross(Az, Bz) 축으로 비교
// X 축 투영 거리 비교
// Y 축 투영 거리 비교
// Z 축 투영 거리 비교
// 선분의 방향과 AABB 의 축들과의 외적한 축들에 대해서 검사
//       +Z.axis
//
//       4------7
//      /|     /|
//     / |    / |
//    5------6  |       
//    |  0---|--3  +Y.axis
//    | /    | /
//    |/     |/  
//    1------2
//
// +X.axis
//
// compute mean of points
// compute covariances of points
// compute eigenvectors for covariance matrix
// refine by calculating the aabb of the points projected onto the axis and adjusting the center and extents
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Plane.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// No collision if the ray hit the plane from behind.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Pluecker.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// pluecker coordinate for the intersection of two planes
// calculates square of shortest distance between the two
// 3D lines represented by their pluecker coordinates
// FIXME: implement for parallel lines
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Point.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Quaternion.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// check if parallel
// check if opposite
// check if we can use cross product of from vec with [1, 0, 0]
// nope! we need cross product of from vec with [0, 1, 0]
// ... else we can just cross two vecs
// Spherical linear interpolation between two quaternions.
// calc cosine
// adjust signs (if necessary)
// calculate coefficients
//Math::FLT_EPSILON
// standard case (slerp)
// "from" and "to" quaternions are very close 
//  ... so we can do a linear interpolation
// calculate final values
// Approximation of spherical linear interpolation between two quaternions.
// The interpolation traces out the exact same curve as Slerp but does not maintain a constant speed across the arc.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Ray.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Rect.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\RGBE9995.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* NaN gets here too since comparisons with NaN always fail! */
/* Ok, FloorLog2 is not correct for the denorm and zero values, but we
/* This pow function could be replaced by a table. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Rotation.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// take half-angle
//------------------------------------------------------------------------------
// ref. Essential Mathematics for Games & Interactive Applications 2nd Edition p.148
//
// N(x, y, z) = 단위 축벡터
//
//     |  0  -z   y |          | -(y^2 + z^2)           x*y           x*z |
// S = |  z   0  -x |    S^2 = |          x*y  -(x^2 + z^2)           y*z |
//     | -y   x   0 |          |          x*z           y*z  -(x^2 + y^2) |
//
// R = I + sin(theta)*S + (1-cos(theta))*S^2
//
//     |   c + (1-c)*x^2  (1-c)*x*y - s*z  (1-c)*x*z + s*y |
// R = | (1-c)*x*y + s*z    c + (1-c)*y^2  (1-c)*y*z - s*x |
//     | (1-c)*x*z - s*y  (1-c)*y*z + s*x    c + (1-c)*z^2 |
//  
//------------------------------------------------------------------------------
// 12 multiplications
// 13 multiplications
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Sphere.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * 2 생략
// determinant = (b^2 - 4ac) / 4
// No intersection occured if determinant is less than 0.
// If there is definitely at least one real root, there must be an intersection	
// Exit if line's origin outside sphere (c > 0) and line pointing away from sphere (b > 0)	
// A negative discriminant corresponds to ray missing sphere
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\SphericalHarmonics.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// number of terms = n^2
// l = [0, n - 1]
// m = [-(n - 1), +(n - 1)]
// l = 0, m = 0
// l = 1, m = -1
// l = 1, m = 0
// l = 1, m = 1
// l = 2, m = -2
// l = 2, m = -1
// l = 2, m = 0
// l = 2, m = 1
// l = 2, m = 2
// l = 3, m = -3
// l = 3, m = -2
// l = 3, m = -1
// l = 3, m = 0
// l = 3, m = 1
// l = 3, m = 2
// l = 3, m = 3
// To produce result of this function
// convert spherical function cos(theta) / PI to ZH coefficients
// and then convert it to SH coefficients
// bogus case
// odd case
// even case
// -1^(l/2 - 1) = -1 when l is a multiple of 4, 1 for other multiples of 2
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Vector2.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Mapping unit square to the point on unit disk (filled circle)
// Mapping unit square to the point on unit disk (filled circle) 
// Peter Shirley (1997): Concentric mapping gives less distortion than above function
// Map uniform random numbers to [-1, 1]
// Handle degeneracy at the origin
// Apply concentric mapping to point
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Vector3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Spherical linear interpolation from v1 to v2.
// Vectors are expected to be normalized.
// Mapping unit square to the point on unit sphere 
//
// Spherical uniform PDF = pdf(w) = 1/4pi
// pdf(theta, phi) = sin(theta) / 4pi
//
// pdf(theta) = Int_0^2pi pdf(theta, phi) dphi = sin(theta) / 2
// pdf(phi|theta) = pdf(theta, phi) / pdf(theta) = 1/2pi
//
// cdf(theta) = Int_0^theta pdf(theta') dtheta' = 1/2 - cos(theta)/2
// cdf(phi|theta) = Int_0^phi pdf(phi'|theta) dphi' = phi/2pi
//
// theta = cos^{-1}(1 - 2*u1)
// phi = 2pi * u2
//
// x = sin(theta) * cos(phi) = sqrt(1 - (1 - 2*u1)^2) * cos(2pi * u2)
// y = sin(theta) * sin(phi) = sqrt(1 - (1 - 2*u1)^2) * sin(2pi * u2)
// z = cos(theta) = 1 - 2*u1
// Mapping unit square to the point on unit hemisphere
//
// Hemishpere uniform PDF = pdf(w) = 1/2pi
// pdf(theta, phi) = sin(theta) / 2pi
//
// pdf(theta) = Int_0^2pi pdf(theta, phi) dphi = sin(theta)
// pdf(phi|theta) = pdf(theta, phi) / pdf(theta) = 1/2pi
//
// cdf(theta) = Int_0^theta pdf(theta') dtheta' = 1 - cos(theta)
// cdf(phi|theta) = Int_0^phi pdf(phi'|theta) dphi' = phi/2pi
//
// theta = cos^{-1}(u1)
// phi = 2pi * u2
//
// x = sin(theta) * cos(phi) = sqrt(1 - u1*u1) * cos(2pi * u2)
// y = sin(theta) * sin(phi) = sqrt(1 - u1*u1) * sin(2pi * u2)
// z = cos(theta) = u1
// Mapping unit square to the point on unit hemisphere that has cosine weighted distribution
// Malley's method: projecting points up to the hemishpere from uniformly distributed disk
// result in distribution of directions a cosine distribution
// Mapping unit square to the point on unit hemisphere that has powered cosine weighted distribution
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Math\Vector4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Network\Packet.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Network\Socket.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define BUFFER_POOL_SIZE 16
//BE_ASSERT(((intptr_t) newBuffer & (alignof(BUffer) - 1)) == 0);
// aligned_malloc
//	newBuffer->m_nRef = 1;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\Collider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// No need to set margin, because entire shape can be represented by margin
// No need to set margin, because entire shape can be represented by margin
// convex hull have no indexes
// reference: http://kmamou.blogspot.kr/2011/11/hacd-parameters.html
// FIXME
// minimum number of clusters
// max of 100 vertices per convex-hull
// maximum allowed concavity
/*
//localTransform.setOrigin(btVector3(-centroid.x, -centroid.y, -centroid.z));
//btTriangleInfoMap *triangleInfoMap = new btTriangleInfoMap();
//btGenerateInternalEdgeInfo(static_cast<btBvhTriangleMeshShape *>(shape), triangleInfoMap);
// TODO: vertex hash 로 중복 vertex position 제거할 것
// assume TRIANGLES primitive type
//shape->setMargin(0.01f);
// TODO: vertex hash 로 중복 vertex position 제거할 것
// TODO
// assume TRIANGLES primitive type
//shape->setMargin(0.001f);
//CreateConvexDecomp(mesh, scale);
// remove mangled name <CH>
// TODO: Implement this !
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\ColliderManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// TODO
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsCollidable.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// bullet world transform origin stands for the center of mass
// not working ?
/*void PhysCollidable::SetCollisionFilterMask(short mask) {
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsCollisionListener.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//constraint->buildJacobian();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsCVars.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsDebugDraw.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//Vec3 p = btVector3ToVec3(location);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsGenericConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsGenericSpringConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsHingeConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsP2PConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// pivotInB stands for local anchor in B or world anchor if body B is not defined
// pivotInB stands for local anchor in B or world anchor if body B is not defined
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsRigidBody.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// HACK
// HACK
// TODO:
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsSensor.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//btBroadphasePair *collisionPair = dynamicsWorld->getPairCache()->findPair(pair->m_pProxy0, pair->m_pProxy1);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsSliderConstraint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//btAdjustInternalEdgeContacts(cp, colObj1, colObj0, partId1, index1);
//btAdjustInternalEdgeContacts(cp, colObj1, colObj0, partId1, index1, BT_TRIANGLE_CONVEX_BACKFACE_MODE);
//btAdjustInternalEdgeContacts(cp, colObj1, colObj0, partId1, index1, BT_TRIANGLE_CONVEX_DOUBLE_SIDED + BT_TRIANGLE_CONCAVE_DOUBLE_SIDED);
// this return value is currently ignored, but to be on the safe side: return false if you don't calculate friction
// Construct initial world transform 
// Compute total centroid & volume
// Construct local transform for each child shapes
// Construct initial world transform 
// NOTE: bullet 에서는 shape 이 center of mass 에 정렬되어 있다고 가정하고,
// 대부분의 경우에 AABB approximation 으로 inertia tensor 를 계산한다.
// the constraint solver can discard solving contacts, if the distance is above this threshold. 
//rigidBody->setContactProcessingThreshold(BT_LARGE_FLOAT);
// NOTE: compound shape 일 경우 CCD 적용 안됨
// Remove attached constraints of rigid body
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsVehicle.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// wheel tunning options
// connection point in chassis local space
// ray cast direction in chassis local space
// vehicle right direction in chassis local space
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Physics\PhysicsWorld.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define DETERMINISTIC
/*class CollisionFilterCallback : public btOverlapFilterCallback {
// return true when pairs need collision
// collision configuration contains default setup for memory, collision setup
//collisionConfiguration = new btSoftBodyRigidBodyCollisionConfiguration();
//collisionConfiguration->setConvexConvexMultipointIterations();
// use the default collision dispatcher. For parallel processing you can use a different dispatcher (see Extras/BulletMultiThreaded)
// register GImpact collision algorithm
//btGImpactCollisionAlgorithm::registerAlgorithm(collisionDispatcher);
// broadphase dynamic bounding volume tree
// the default constraint solver. For parallel processing you can use a different solver (see Extras/BulletMultiThreaded)
//softBodySolver = new btDefaultSoftBodySolver;
//dynamicsWorld = new btSoftRigidDynamicsWorld(collisionDispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
// for direct solver it is better to have a small A matrix 
//dynamicsWorld ->getSolverInfo().m_minimumSolverBatchSize = 1; 
// the polyhedral contact clipping can use either GJK or SAT test to find the separating axis
//dynamicsWorld->getDispatchInfo().m_enableSatConvex = false;
// NOTE: Bullet will clear all forces after the post-tick call
//filterCallback = new CollisionFilterCallback();
//dynamicsWorld->getPairCache()->setOverlapFilterCallback(filterCallback);
//dynamicsWorld->setSynchronizeAllMotionStates(true);
//SAFE_DELETE(filterCallback);
// Clean up in the reverse order of creation/initialization
// Removed cached contact points (this is not necessary if all objects have been removed from the dynamics world)
//dynamicsWorld->getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(colObj->getBroadphaseHandle(), dynamicsWorld->getDispatcher());
// Reset some internal cached data in the broadphase
// Direct MLCP solvers are useful when higher quality simulation is needed, for example in robotics. 
// The performance is less than the SI solver,
// NOTE: rolling friction is not working with MLCP solver ! (bullet bug)
// for direct solver it is better to have a small A matrix 
//dynamicsWorld ->getSolverInfo().m_minimumSolverBatchSize = 128;
// The btDiscreteDynamicsWorld is guaranteed to call setWorldTransform() once per substep 
// for every btRigidBody that : has a MotionState AND is active AND is not KINEMATIC or STATIC.
// maxSubSteps > 0 이면 motion state 의 getWorldTransform() 은 interpolation 된 결과를 반환한다.
// & BIT(TagLayerSettings::DefaultLayer)
// & BIT(TagLayerSettings::DefaultLayer)
// & BIT(TagLayerSettings::DefaultLayer)
/*if (shape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE) {
//const short colMaskA = a->GetCollisionFilterMask();
//const short colMaskB = b->GetCollisionFilterMask();
/*if (!(GetCollisionFilterMask(a->customFilterIndex) & BIT(b->customFilterIndex))) {
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\cpuid.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Reference: http://msdn.microsoft.com/en-us/library/hskdteyh(v=vs.100).aspx
//unsigned int nIds = info[0];
// If Visual Studio 2010 SP1 or later
// Checking for AVX requires 3 things:
// 1) CPUID indicates that the OS uses XSAVE and XRSTORE
//     instructions (allowing saving YMM registers on context
//     switch)
// 2) CPUID indicates support for AVX
// 3) XGETBV indicates the AVX registers will be saved and
//     restored on context switch
//
// Note that XGETBV is only available on 686 or later CPUs, so
// the instruction needs to be conditionally run.
// Check if the OS will save the YMM registers
// unsupported 386/486 processor
// unsupported 386/486 processor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Platform.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformAndroid.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseFile.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformBaseTLS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformGeneric.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
// TODO
// 받아올 event 가 없는 경우 NULL event
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\PlatformWin.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//SystemParametersInfo(SPI_GETMOUSE, 0, originalmouseparms, 0);
//newmouseparms[0] = 0;
//newmouseparms[1] = 0;
//newmouseparms[2] = 1;
// 커서를 화면에 가둔다
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Android\PlatformAndroidFile.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Can't write to asset.
// FIXME: Read newest file
// Read from external data directory
// Read by asset manager
// file doesn't exist
// NOTE: AAsset_openFileDescriptor will work only with files that are not compressed.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Android\PlatformAndroidProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Android\PlatformAndroidSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Android\PlatformAndroidThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//pthread_cancel(*androidThread->thread);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Apple\PlatformAppleThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Apple\PlatformAppleTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Time base is in nano seconds.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Linux\PlatformLinuxProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// get the full path to the running executable
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Linux\PlatformLinuxSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Linux\PlatformLinuxThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: the POSIX standard no longer requires pthread_t to be an arithmetic type
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Linux\PlatformLinuxTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixFile.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------------------
//normalizedFilename.BackSlashesToSlashes();
//normalizedDirname.BackSlashesToSlashes();
// make sure to return -1 for directories
// file doesn't exist
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// try the $HOME environment variable
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// get current system time and add millisecs
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// we use gettimeofday() instead of rdtsc, so it's 1000000 "cycles" per second on this faked CPU.
// query for calendar time
// convert it to local time
// pull out data/time
// query for calendar time
// convert it to UTC
// pull out data/time
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Posix\PlatformPosixTLS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// allocate a per-thread mem slot
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinFile.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------------------
// some error occured, close the handle and return FALSE
// directory couldn't be deleted
// remove the empty directory
// change read-only file mode
// remove the empty directory
// Remove executable filename
//fileInfo.size = finddata.size;
//fileInfo.size = finddata.size;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// get the full path to the running executable
// So you can see what the error is in the debugger...
// Quote module filename string
// NOTE: The new process won't be started with lpCurrentDirectory as the current directory during the start.
// Instead, the current directory is set once the process has started.
// thread handle is no longer needed so we close
// The read operation will block until there is data to read
// remove '\r' from the buffer
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Get the My Documents directory
// Get only physical cores
// Get the size of the buffer to hold processor information.
// Allocate the buffer to hold the processor infoBuffer.
// Get the actual information.
// Count physical cores
// Get the number of logical processors, including hyperthreaded ones.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinThread.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Set the affinity of a given thread
// Creates a hardware thread running on specific core
/**
//msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
// Must be 0x1000.
// Pointer to name (in user addr space).
// Thread ID (-1=caller thread).
// Reserved for future use, must be zero.
// Spin first before entering critical section, causing ring-0 transition and context switch.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinTime.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// converting file time to unix epoch
// convert into microseconds
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinTLS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Platform\Windows\PlatformWinUtils.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\PlatformUtils\Android\AndroidGPUInfo.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/* Vivante GC4000 in early HiSilicon chipsets */
/* Vivante GC5000 in PXA1928 chipset */
/* ARM Mali-T720 in some MT8163 chipsets */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\PlatformUtils\Android\AndroidJNI.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Unregister this thread from the VM
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Profiler\Profiler.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// readFrameDataIndex is valid only if frameData[readFrameDataIndex].time != InvalidTime
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Anim.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define CYCLIC_DELTA_MOVEMENT
// Checks if both have the same number of joints.
// Checks if both have the same joint names.
// Checks if both have the same parent-child relationships.
// only one frame exists
// time is less than or equal to zero
//if (rootTranslationXY && rootTranslationZ) {
//    outTranslation = baseFrame[0].t;
//    return;
//}
// just use the baseframe
/*if (rootTranslationXY) {
// just use the baseframe
// just use the baseframe
// Copy the base frame
// Just use the base frame
// Copy the base frame
// Just use the base frame
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\AnimManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Anim_banim.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --- frame times ---
// --- joint info ---
// --- base frame ---
// --- frames ---
// --- total delta ---
// --- frame times ---
// --- joint info ---
// --- base frames ---
// --- frames ---
// --- total delta ---
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Anim_optimize.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: w 값을 양수로 유지하기 위해 -1 을 곱한 xyz 를 고려해야 한다. 오차값이 실제보다 더 작게 나올 수도 있지만, 일단은 이렇게..
// FIXME: compare method
// Set up whole joint indexes
// Set up the reference joints of all frames.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\BufferCache.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// size of float RGBA
// Create dynamic buffer to use for dynamic batching
// Create texture buffer to write directly
// Create unpack buffer to translate data from PBO to VTF texture
// See below link if you want to know what PBO is 
// http://www.songho.ca/opengl/gl_pbo.html
// Create stream buffer for use in debug drawing
// Wait until the gpu is no longer using the buffer
// Place a fence which will be removed when the draw command has finished
// Unmap the current frame so the GPU can read it
// Update buffered texture
// The update to the data is not guaranteed to affect the texture until next time it is bound to a texture image unit
// Unmapped PBO -> texture
// Prepare the next frame for writing to by the CPU
// Clear current frame data
//assert_16_byte_aligned(dst);
// Check just write offset (don't write)
// Check just write offset (don't write)
// Check just write offset (don't write)
// Check just write offset (don't write)
//rhi.BindBuffer(RHI::BufferType::Vertex, currentBufferSet->vertexBuffer);
//rhi.FlushMappedBufferRange(currentBufferSet->vertexBuffer, bc->offset, bc->bytes);
//rhi.BindBuffer(RHI::BufferType::Index, currentBufferSet->indexBuffer);
//rhi.FlushMappedBufferRange(currentBufferSet->indexBuffer, bc->offset, bc->bytes);
//rhi.BindBuffer(RHI::BufferType::Uniform, currentBufferSet->uniformBuffer);
//rhi.FlushMappedBufferRange(currentBufferSet->uniformBuffer, bc->offset, bc->bytes);
//rhi.BindBuffer(currentBufferSet->texelBufferType, currentBufferSet->texelBuffer);
//rhi.FlushMappedBufferRange(currentBufferSet->texelBuffer, bc->offset, bc->bytes);
// static buffer
// Transfer PBO -> texture using DMA
// If asynchronous DMA transfer is supported, glTexSubImage2D() should return immediately.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\EnvProbe.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Replace diffuse probe texture to new baked one.
// Use baked diffuse probe cubemap.
// Create default diffuse probe cubemap.
// Replace specular probe texture to new baked one.
// Use baked specular probe cubemap.
// Create default specular probe cubemap.
// Resolution value same order with EnvProbe::Resolution.
// fixed size (16) for irradiance cubemap
// Recreate diffuse probe texture if it need to.
// Diffuse probe texture is recreated so we must recreate render target too.
// Create diffuse probe render target if it is not created yet.
// Recreate specular probe texture if it need to.
// Specular probe texture is re-created so we must re-create render target too.
// Create specular probe render target if it is not created yet.
// Recreate env probe texture to use when refreshing specular probe texture
// FIXME: use EnvProbeStatic instead of -1
// We can skip complex calculation of specular convolution cubemap for mipLevel 0.
// It is same as perfect specular mirror. so we just render environment cubmap.
// Generate mipmaps of environment cubemap to generate specular convolution cube map using pre-filtered environment cubemap.
// Generate specular convolution cube map from mipLevel 1 to specularProbeCubemapMaxLevel using environment cubemap.
// Generate diffuse convolution cube map using environment cubemap.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Font.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*fontSize*/)) {
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\FontFaceBitmap.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// byte offset of bitmaps
// a number of bitmaps
// byte offset of glyphs
// a number of glyphs
// .font 파일 로딩
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\FontFaceFreeType.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// FreeType2 reference:
// http://freetype.sourceforge.net/freetype2/docs/reference/ft2-base_interface.html
// NOTE: LCD 모드로 렌더링이 안되는 font 도 존재하기 때문에,
// 나중에 RGBA 텍스쳐로 통합해서, 되는 폰트만 LCD 로 하는 편이 나을 수도 있겠다
//#define LCD_MODE_RENDERING
// glyph atlas texture 의 사용중인 공간을 덩어리 단위로 표현
// initialize FreeType library
// 대략 8x8 조각의 glyph 들을 하나의 텍스쳐에 packing 했을 경우 개수 만큼 할당..
// FT_Done_Face 이후에 font file data 를 해제 해야 한다
// 트루 타입 폰트 파일 로딩
// Certain font formats allow several font faces to be embedded in a single file.
// faceIndex tells which face you want to load.
// FIXME
// face 개수 몇개인지 출력
// unicode charmap 만 사용한다
// NOTE: fontSize 는 EM 을 의미한다. 실제 font 의 bitmap size 가 아님
// glyph 을 그리기 위한 임시 버퍼
// FT_Set_Pixel_Sizes 와는 다르게 fontHeight * fontHeight 를 넘어가는 비트맵이 나올수도 있어서 넉넉하게 가로 세로 두배씩 더 할당
// glyph bitmap 을 얻기 위해 glyph slot 에 glyph 을 로드
// charCode 에 맞는 glyph image 가 존재하지 않는다.
// glyph slot 에 glyph 을 로드
// FT_Bitmap 으로 부터 glyphBuffer 에 비트맵 데이터를 그린다.
// 0 으로 채운다
// 여기서 부터 FreeType bitmap 그리기
// 가로로 남는 덩어리가 있는지..
// 세로 크기가 같은 덩어리를 발견하면 바로 거기다 끼워놓고 리턴
// 남는 공간이 있다면 새로운 청크 생성
// 문자코드에 따른 glyph 을 texture 에 캐싱
// FT_RENDER_MODE_NORMAL: LCD sub-pixel RGB anti-aliasing mode
// FT_RENDER_MODE_NORMAL: normal 8bit anti-aliasing mode
// NOTE: ascender 의 의미가 폰트 포맷마다 해석이 좀 다양하다
// (base line 에서부터 위쪽으로 top bearing 을 포함해서 그 위쪽까지의 거리가 필요함)
// The ascender is the vertical distance from the horizontal baseline to 
// the highest ‘character’ coordinate in a font face. 
// Unfortunately, font formats define the ascender differently. For some, 
// it represents the ascent of all capital latin characters (without accents), 
// for others it is the ascent of the highest accented character, and finally, 
// other formats define it as being equal to global_bbox.yMax.
// glyph 캐시에 있다면 미리 구한 advance 를 리턴
// glyph 캐시에 없다면 advance 를 계산하기 위해 glyph 을 로드
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\FontManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//"Data/EngineFonts/Lucida Console12.font"
// 레퍼런스 카운터가 0 인 font 만 제거한다
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\FrameData.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// reset the mem allocation to the first block
// clear all the blocks
// advance to the next mem block if available
// create a new block if we are at the end of the chain
//memset(r, 0, bytes);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\GuiMesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Cache 4 vertices in the dynamic vertex buffer
// Set/Modify vertex cache info for the current surface
// Cache all indices in the dynamic index buffer
// Set index cache info for each surfaces
// TODO: Prebuilt index cache in max batch size and just make use of base vertex index to use calling RHI::DrawElementsBaseVertex
//surf->indexCache.baseVertexIndex = surf->vertexCache.offset / sizeof(VertexGeneric);
// completely clipped away
// 2D frame
//  +-----> +X
//  |   
//  |
// +Y
// 3D frame
//  +-----> +Y
//  |
//  |
// -Z
// Clip away before accessing to the font glyph
// Save current line length
// Save next line offset
// Calculate the coordinate y
// Calculate the coordinate x
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Material.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Parse shader property string values in dictionary
// Shader has property info
// Set shader property values
// Value string
// Get texture path from GUID
// Get texture from path
// Value string
// Get value
// depth write off when blendFunc is valid
/* else if (!token.Icmp("scale")) {
// We don't use DST_ALPHA
// Release textures of old shader property
// Change new reference shader
// Set shader properties with reusing old shader properties
// Instantiate shader with changed define properites 
// List up define list for re-instantiating shader.
// property propInfo with shaderDefine allows only bool/enum type.
// Release previous one
// Instantiate shader with the given define list.
// Reload shader's texture.
/*
// NOTE: sizeof(inMatrix) == 4 로 나옴
//--------------------------------------------------------------------------------------------------
//
//                  | [0] [1]  0  [2] |
// texture matrix = | [3] [4]  0  [5] |
//                  |  0   0   1   0  |
//                  |  0   0   0   1  |
//    
//--------------------------------------------------------------------------------------------------
// [0] [1] [2]
// [0] [1] [2]
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\MaterialManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create default lit surface material
// Create white lit surface material
// Create unlit surface material
// Create blend unlit surface material
// Create white light material
// Create white light (zero clamped) material
// Create default skybox material
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Mesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// override to static mesh
// Free previously allocated skinning joint cache
// Free previously allocated surfaces
//SplitMirroredVerts();
/*for (int i = 0; i < surfaces.Count(); i++) {
// TODO: consider to remove this
// add small epsilon
// Compute volume using AABB
// Compute volume and centroid using AABB
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\MeshManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create default (box shape) mesh
// Create default quad mesh
// Create default plane mesh
// Create default box mesh
// Create default sphere mesh
// Create default geosphere mesh
// Create default cone mesh
//defaultConeMesh = AllocMesh("_defaultConeMesh");
//defaultConeMesh->permanence = true;
//defaultConeMesh->CreateCone(Vec3::origin, Mat3::identity, MeterToUnit(0.5), MeterToUnit(2), 32);
// Create default cylinder mesh
// Create default capsule mesh
// Counts total verts/indices for combined mesh.
// Allocates a combiend mesh.
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Mesh_bmesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --- joints ---
// --- surfaces ---
// --- vertexes ---
// --- vertex weights ---
// --- indexes ---
// guarantee 8 bytes aligned read
// --- joints ---
// --- surfaces ---
// --- vertexes ---
// --- vertex weights ---
// --- indexes ---
// guarantee 8 bytes aligned write
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Mesh_CreateMesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// bottom face
// top face
// front face
// right face
// back face
// left face
// y
// x
// y
// x
// bottom face
// top face
// front face
// right face
// back face
// left face
// TODO: subdivision
// top cap, bottom cap verts
// 0 ~ 2pi
// sides verts
// 0 ~ 2pi
// top cap indexes
// bottom cap indexes
// sides indexes
// hemisphere latitude verts
// hemisphere longitude verts
// 0 ~ pi/2
// 0 ~ 2pi
// pi/2 ~ pi
// 0 ~ 2pi
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Mesh_SortAndMerge.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// m0 의 AABB 와 합쳤을 때 area 가 작은 순으로 sorting
// 합칠 기준 AABB 를 확장
// 합쳐질 AABB 의 면적이 80% 이하일 경우 중단
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\ParticleMesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Cache 4 vertices in the dynamic vertex buffer
// forward, left, up
// = FromCross(-viewAxis[1], unitZ)
//stage.standardModule.material != currentSurf->material) { FIXME
// number of indices for the quad that consist of two triangles
// Cache vertices
// Compute world position of all particle pivots including trails
// Compute cameraDir/tangentDir of all particle pivots including trails
// Cache all indices in the dynamic index buffer
// Set index cache info for each surfaces
// TODO: Prebuilt index cache in max batch size and just make use of base vertex index to use calling RHI::DrawElementsBaseVertex
//surf->indexCache.baseVertexIndex = surf->vertexCache.offset / sizeof(VertexGeneric);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\ParticleSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Stage name
// StandardModule is always included
// ShapeModule
// CustomPathModule
// LTColorModule
// LTSpeedModule
// LTForceModule
// LTRotationModule
// RotationBySpeedModule
// LTSizeModule
// SizeBySpeedModule
// LTAspectRatioModule
// TrailsModule
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\ParticleSystemManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create default particle system
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_Batch.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Check if continuous instance index
//assert(renderGlobal.instancingMethod == Mesh::InstancingMethod::UniformBuffer);
// startIndex 는 Flush 후에 -1 로 세팅된다
// indexCache 가 순차적으로 연결되지 않는다면 한꺼번에 그릴 수 없으므로 Flush
// HACK!!
// TODO: check vertex type of the subMesh instead of this
//vertexBuffer = RHI::NullBuffer;
//indexBuffer = RHI::NullBuffer;
// Converts 24-bit ID to Vec3
// Converts 32-bit ID to Vec4
/*
//	float distanceScale;
//	Vec3 vec;
//	distanceScale = cMath::Tan(m_view.m_fovX * 0.5f) / 100.0f;
//vec = m_entity->GetWorldMatrix() * vptr->xyz;
//drawLength = vec.Distance(m_view.m_vieworg) * distanceScale;
//if (drawLength < 1.0f)
//drawLength = 1.0f;
//	float distanceScale;
//	Vec3 vec;
//	distanceScale = cMath::Tan(m_view.m_fovX * 0.5f) / 100.0f;
//vec = m_entity->GetWorldMatrix() * vptr->xyz;
//drawLength = vec.Distance(m_view.m_vieworg) * distanceScale;
//if (drawLength < 1.0f)
//drawLength = 1.0f;
//g_textureManager.m_whiteTexture->Bind();
/*
// 포그 면이 아닌 블렌딩 쉐이더는 칼라값에서 빼주므로 여기서는 무시한다.
// 포그 평면과 시점자와의 거리 (포그 바깥쪽이 양의 노말)
// 포그 평면과 월드 버텍스와의 거리
// 월드 버텍스가 포그안이라면
// 시점자가 포그 안이라면
// 시점자가 포그 밖이라면
//-dist2 / fogMaterial->m_fogDistance;
// NOTE: 이전 패스가 있다면 버텍스 배열을 지정할 필요는 없다
//bglVertexPointer(3, GL_FLOAT, 0, m_drawBuffer.xyz);
// 포그 평면과 시점자와의 거리 (포그 바깥쪽이 양의 노말)
// 시점자가 포그 안
// 시점자가 포그 밖
// 포그 평면과 월드버텍스와의 거리
// 알파 값을 이용한다면 버텍스 알파에 곱한다
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_BatchRender.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Iterate over all shader property specs
// Skip if it is a shader define
// Skip if not exist in shader properties
// 
// 0-indexed buffer for instance buffer
// .w holds boolean value for box projection 
// .w holds boolean value for box projection 
//shader->SetConstantMatrix4fv("prevModelViewMatrix", 1, true, prevModelViewMatrix);
//shader->SetConstant1f("motionBlurID", (float)surfSpace->id);
/*
// WARNING: for the nvidia's stupid dynamic branching... 
/*bool useLightCube = lightStage->textureStage.texture->GetType() == TextureCubeMap ? true : false;
// light texture transform matrix
// light texture transform matrix
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_DebugTools.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// TEMP
// copy any text that still needs to be drawn
// NOTE: RB_DrawDebugPrims 에서 vertex array 를 sorting 한다면 임시 memory 에 copy 하는 식으로 바꿔야 함 
//qsort(rb_debugPrims, rb_numDebugPrims, sizeof(rb_debugPrims[0]), RB_CompareDebugPrims);
// free up our strings
// copy any text that still needs to be drawn
// returns the length of the given text
// oriented on the viewaxis
// align can be 0-left, 1-center (default), 2-right
// right
// center
//if (text->origin.DistanceSqr(backEnd.camera->def->state.origin) > MeterToUnit(100*100)) {
//  continue;
//}
// Flush previous batch
// Restore depthHack
/*if (r_showTangentSpace.GetBool()) {
//g_textureManager.m_whiteTexture->Bind();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_DrawSimple.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//static const uint16_t indices[24] = { 3, 2, 1, 0, 5, 4, 0, 1, 6, 5, 1, 2, 7, 6, 2, 3, 4, 7, 3, 0, 6, 7, 4, 5 };
//static const uint16_t indices[24] = { 3, 2, 1, 0, 5, 4, 0, 1, 6, 5, 1, 2, 7, 6, 2, 3, 4, 7, 3, 0, 6, 7, 4, 5 };
//static const uint16_t indices[24] = { 3, 2, 1, 0, 5, 4, 0, 1, 6, 5, 1, 2, 7, 6, 2, 3, 4, 7, 3, 0, 6, 7, 4, 5 };
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_ForwardAdditivePass.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Flush previous batch
// Restore depth hack
// Forward lighting renders each surfaces depending on lights that affect the surface.
// FIXME:
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_ForwardBasePass.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//surf->material->HasRefraction()) {
// Flush previous batch
// Restore depth hack
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_GenericPass.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Render sky only
// Flush previous batch
// Flush previous batch
// Restore depth hack
/*if (surf->subMesh->GetAABB().Volume() < MeterToUnit(1) * MeterToUnit(1) * MeterToUnit(1)) {
// Flush previous batch
// Restore depth hack
// Flush previous batch
// Restore depth hack
// Flush previous batch
// Restore depth hack
//!surf->material->HasRefraction()) {
// Flush previous batch
// Restore depth hack
// Flush previous batch
// Restore depth hack
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_Main.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*for (int i = 0; i < MAX_LIGHTS; i++) {
/*for (int i = 0; i < MAX_LIGHTS; i++) {
// TODO: create one for each context
/*float *outputValues = (float *)frameData.Alloc(lightMaterial->GetExprChunk()->NumRegisters() * sizeof(float));
//outputValues;
// Linearize light color
// Build light texture transform matrix
// FIXME: ellipsoid 그리기로 바꾸자
// NOTE: ambient pass 이후에 실행되므로 화면에 깊이값은 채워져있다
/*	bool    insideLightVolume;
// light 가 query 중이었다면..
// 아직 query result 를 사용할 수 없고, query wait frame 한도를 넘지 않았다면..
// 이전 result sample 로 visibility 를 판단한다
//BE_LOG("%i\n", lightQuery->resultSamples);
// query result 를 가져온다. unavailable 일 경우 blocking 상태가 된다.
// visible threshold 값
// 카메라가 light volume 안에 있는지 체크
// alloc ambient occludee buffer in a AABB form
// Query HOM culling for each occludees
// write back for visibility information to each surf
// count ambient occludees for culling
//BE_LOG("%.2f %.2f %.2f %.2f\n", nearPlane.a, nearPlane.b, nearPlane.c, nearPlane.d);
// Render occluder to HiZ occlusion buffer
// Generate depth hierarchy
// Test all the ambient occludee's AABB using HiZ occlusion buffer
// Render pass for HiZ occlusion culling.
// Render opaque/perforated surface to depth buffer fast for early-z culling ([depth] + unlit + [normal])
// Render all solid (non-translucent) geometry ([depth] + base + [primary lit])
// Render all shadow and light interaction.
// Render any stage with blend surfaces.
// Render to velocity map.
// Render no lighting interaction surfaces.
// Render wireframe for option.
// Render wireframes.
// Render debug surfaces.
//shader->SetConstant2f("depthRange", Vec2(backEnd.camera->zNear, backEnd.camera->zFar));
// FIXME: Consider this view is sub camera
// Apply gamma ramp table
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_PostProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//PP_LinearizeDepth(backEnd.ctx->screenRT->DepthStencilTexture(), backEnd.camera->def->zNear, backEnd.camera->def->zFar, backEnd.ctx->ppRTs[PP_RT_LINEAR_DEPTH]);
//backEnd.ctx->screenRT->Begin();
//backEnd.ctx->screenRT->End();
// shafts blur 8x -> 64x -> 512x
//sunColor *= sunLight->intensity;
// 이전 프레임의 방향벡터의 각도 차이가 가장 큰 값의 cos 값을 구한다.
// camera motion blur 를 적용할지 결정
// 카메라의 rotation 에 대해서만 적용, translation 은 적용하지 않는다
// 카메라 rotation 정도에 따라 iterative blur
// Downscale current screen to 1/4 scale
// Compute Geometric average luminance.
// Luminance adaptation using luminance of previous frame.
// Do HDR composition.
//shader->SetTexture("randomDir4x4Sampler", textureManager.randomDir4x4Texture);
//shader->SetConstant2f("frameRand", Vec2(renderConfig.random.RandomFloat(), renderConfig.random.RandomFloat()));
//bc->screenRT->Blit();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RB_ShadowPass.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// litVisAABB 와 viewFrustum 을 이용해서 light OBB 의 near, far 를 구한다
// litVisAABB 와 viewFrustum 을 이용해서 light frustum 의 near 와 far 를 구한다
// [-1, +1] to [0, 1]
//xmax = Min(xmax, 1.0f);
//ymax = Min(ymax, 1.0f);
// [0, 1] to [-1, +1]
// Calculates crop bounds of view frustum in light OBB space
// Calculates crop bounds of shadow caster OBB in light OBB space.
// Intersects crop bounds.
// Returns false if there is no intersection.
// Calculate crop bounds [-1, 1] of view sphere in light OBB space
// crop bounds 를 만든다
// 두개의 crop bounds 의 교집합
//BE_LOG("%f %f, %f %f\n", xmin, xmax, ymin, ymax);
//BE_LOG("%f %f, %f %f\n", xmin, xmax, ymin, ymax);
// Zeye 에서 depth 값을 구하기 위한 projection 행렬의 33, 43 성분을 다시 W(-Zeye) 로 나눈값
// TODO: cascade 별로 컬링해야함
// crop matrix 를 곱해서 effective 'zoomed in' shadow view-projection matrix 를 만든다
/*if (r_optimizedShadowProjection.GetInteger() > 0) {
// crop matrix 를 곱해서 effective 'zoomed in' shadow view-projection matrix 를 만든다
// split 된 viewFrustum 일 수 있기 때문에 컬링 가능
//return false;
// crop matrix 를 곱해서 effective 'zoomed in' shadow view-projection matrix 를 만든다
// z-based selection shader needs shadowSplitFar value
// 각 split 뷰 프러스텀에 대하여 shadow map 생성
// FIXME
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderCamera.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Set bounding volume for orthogonal view
// Calculate orthogonal projection matrix
// Set bounding frustum for perspective view
// Calculate view frustum planes
// Calculate view frustum points
// Calculate perspective projection matrix
// Calculate view matrix
// Calculate view projection matrix
// Set bounding volume for orthogonal view
// Calculate orthogonal projection matrix
// Set bounding frustum for perspective view
// Calculate view frustum planes
// Calculate view frustum points
// Calculate perspective projection matrix
// Re-calculate view projection matrix
// [-1, 1]
// [-1, 1]
// [-1, 1] or [0, 1] in D3D
// [0, 1]
// [0, 1]
// Invert Y axis
// in case camera in in sphere
// sphere 의 중심좌표(L) 를 카메라 로컬좌표계(X, Y, Z = FORWARD, LEFT, UP) 로 변환
// 세로 접평면 T 는 z 축에 평행하고 카메라(C) 를 지나므로,
// T = (Nx, Ny, 0, 0) 이면
//
// 1) T dot L = r 
// 2) Nx^2 + Ny^2 = 1
// 식1 을 식2 에 대입해서 이차방정식으로 풀수 있다.
// 접평면의 Nx 에 대한 판별식
// sphere 가 카메라 뒤에 있다면..
// planeNormal1 = left plane
// planeNormal2 = right plane
// 가로 접평면 T 는 y 축에 평행하고 카메라(C) 를 지나므로,
// T = (Nx, 0, Nz, 0) 이면
//
// 1) T dot L = r 
// 2) Nx^2 + Nz^2 = 1
// 접평면의 Nz 에 대한 판별식
// sphere 가 카메라 뒤에 있다면..
// planeNormal1 = upper plane
// planeNormal2 = bottom plane
// CHECK: is valid AABB ?
// zNear can be negative number in orthogonal view
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderContext.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// This is actual rendering resolution that will be upscaled if it is smaller than device resolution
//--------------------------------------
// Create screenRT
//--------------------------------------
//--------------------------------------
// Create RT for post processing
//--------------------------------------
//ppTextures[PP_TEXTURE_COLOR_TEMP_4X] = textureManager.AllocTexture(va("_%i_screenColorTempD4x", (int)contextHandle));
//ppTextures[PP_TEXTURE_COLOR_TEMP_4X]->CreateEmpty(RHI::TextureType::Texture2D, quarterWidth, quarterHeight, 1, 1, 1, screenImageFormat, screenTextureFlags | Texture::Flag::SRGBColorSpace);
//ppRTs[PP_RT_BLUR] = RenderTarget::Create(ppTextures[PP_TEXTURE_COLOR_TEMP_4X], nullptr, RHI::SRGBWrite);
//--------------------------------------
// Create screen copy texture for refraction
//--------------------------------------
//--------------------------------------
// HDR RT 
//--------------------------------------
//hdrLuminanceRT[i]->Clear(Color4(0.5, 0.5, 0.5, 1.0), 0.0f, 0.0f);
// Cascaded shadow map
// Virtual shadow cube map
// deferred resizing render targets
//rhi.ChangeDisplaySettings(deviceWidth, deviceHeight, rhi.IsFullScreen());
// Window size have changed since last call of BeginFrame()
// Adds system GUI commands
// Adds swap buffer command
//double starttime = PlatformTime::Seconds();
//rhi.GenerateMipmap();
//BE_LOG("%lf\n", PlatformTime::Seconds() - starttime);
// FIXME: is depth format confirmed ?
// FIXME
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderCVars.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderLight.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Saturate light color RGBA in range [0, 1]
// NOTE: shader 에서 이미 한번 square 처리가 되므로 여기서 sqrt 해준다
// Calculate view matrix with the given origin and axis
// Set bounding volume for point light
// Calculate point light orthogonal projection matrix
// Calculate light fall-off matrix
// Bounding volume for box light
// Calculate box light orthogonal projection matrix
// No fall-off for directional light
// Set bounding frustum for spot light
// Calculate spot light perspective projection matrix
// Calculate light fall-off matrix
// Compute caster bounds for light axis
// Compute light bounds for light axis
// light maximum x
//renderSystem.GetRenderWorld()->DebugFrustum(shadowFrustum, false, 1.0f, true, true);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderObject.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Saturates object color components in range [0, 1].
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderPostProcess.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// for camera motion blur
//shader->SetTexture("depthMap", backEnd.ctx->screenDepthTexture);
// luminance 값을 구하면서 4x downscale
// 4x4 이하가 될때까지 downsampling
// 1x1 로 최종 luminance 값을 구함
//shader->SetConstant1f("frameTime", frameTime);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Initialize OpenGL renderer
// Save current gamma ramp table
//skinManager.Init();
//skinManager.Shutdown();
// add an end-of-list command
// clear it out, in case this is a sync and not a buffer flip
/*if (r_usePostProcessing.GetBool() && r_HDR.GetInteger() == 1) {
// Needs any render context to render environment cubemap
// Use any render context
//int t0 = PlatformTime::Milliseconds();
// Use any render context
//int t1 = PlatformTime::Milliseconds();
//BE_LOG("CaptureEnvCubeFaceRT(%i) takes %ims\n", faceIndex, t1 - t0);
//-------------------------------------------------------------------------------
// Create 4-by-4 envmap sized block weight map for each faces
//------------------------------------------------------------------------------- 
// Gets sample direction for each faces 
// 9 terms are required for order 3 SH basis functions
// Evaluates the 9 SH basis functions Ylm with the given direction
// Solid angle of the cubemap texel
// Precalculates 9 terms (basisEval * dw) for each envmap pixel in the 4-by-4 envmap sized block texture for each faces  
//-------------------------------------------------------------------------------
// SH projection of (Li * dw) and create 9 coefficents in a single 4x4 texture
//-------------------------------------------------------------------------------
//rhi.ReadPixels(0, 0, 4, 4, Image::RGB_32F_32F_32F, image.GetPixels());
//-------------------------------------------------------------------------------
// SH convolution
//-------------------------------------------------------------------------------
// Precompute ZH coefficients * sqrt(4PI/(2l + 1)) of Lambert diffuse spherical function cos(theta) / PI
// which function is rotationally symmetric so only 3 terms are needed
// 1
// 2/3
// 1/4
//int t0 = PlatformTime::Milliseconds();
//int t1 = PlatformTime::Milliseconds();
//BE_LOG("GenerateIrradianceEnvCubeRT() takes %ims\n", t1 - t0);
// power drop range [maxSpecularPower, 2]
// We can skip complex calculation for mipLevel 0 for perfect specular mirror.
//int t0 = PlatformTime::Milliseconds();
//int t1 = PlatformTime::Milliseconds();
//BE_LOG("GenerateGGXLDSumRTLevel(%i/%i) takes %ims\n", mipLevel, numMipLevels, t1 - t0);
//envCubeImage.ConvertFormatSelf(Image::RGB_11F_11F_10F, false, Image::HighQuality);
//irradianceEnvCubeImage.ConvertFormatSelf(Image::RGB_11F_11F_10F, false, Image::HighQuality);
//prefilteredCubeImage.ConvertFormatSelf(Image::RGB_11F_11F_10F, false, Image::HighQuality);
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderTarget.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// to suppress a warning
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderUtils.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
/*
//(float)((xmax + xmin) * one_deltax);
//(float)((ymax + ymin) * one_deltay);
//(float)((xmax + xmin) * one_deltax);
//(float)((ymax + ymin) * one_deltay);
/*
/*
//  assert(side0.LengthSqr() > VECTOR_EPSILON);
//  assert(side1.LengthSqr() > VECTOR_EPSILON);
//t1 -= t1.Dot(n) * n + t1.Dot(t0) * t0;
//assert(t0.LengthSqr() > 0.0f);
//assert(t1.LengthSqr() > 0.0f);
// NOTE: Normalized device coordinates 에서 z 값이 -1 로 클리핑(near plane clip)
// 하기 위해서는 xy 를 -w 로 나눈다.
// Practical split scheme:
//
// CLi = n*(f/n)^(i/numsplits)
// CUi = n + (f-n)*(i/numsplits)
// Ci = CLi*(lambda) + CUi*(1-lambda)
//
// lambda scales between logarithmic and uniform
// Calculate Gaussian weights based on kernel size
// Generate weights and offsets for filter, taking advantage of linear texture filtering
// GPU Gems 2, Chapter 20. Fast Third Order Texture Filtering 참고
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderWorld.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Cancel refreshing environment probes
// Add proxy in the DBVT for the renderObjects
// If this object is a static mesh, add proxy for each sub meshes in the DBVT for the static meshes
// If this object is a static mesh
// mesh surface count changed so we recreate static proxies
// Cancel environment probe in refreshing
// Compare importances.
// Compare intersection volumes.
// Adjust probe's AABB for better box projection
//#ifndef _DEBUG
//    int startTime = PlatformTime::Milliseconds();
//
//    objectDbvt.RebuildBottomUp();
//    staticMeshDbvt.RebuildBottomUp();
//    lightDbvt.RebuildBottomUp();
//    probeDbvt.RebuildBottomUp();
//
//    int elapsedTime = PlatformTime::Milliseconds() - startTime;
//    BE_LOG("%i msec to build dynamic AABB tree\n", elapsedTime);
//#endif
// Create current camera in frame data
// Create GUI camera
// GUI object def
// GUI camera
// GUI visible object
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderWorldDebugTools.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// radius1 is the radius at the apex
// radius2 is the radius at the bottom
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\RenderWorldDrawCamera.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Add visObject from renderObject.
// Prevent to add multiple times in same visCamera.
// Already registered for this frame
// Connect visObject to renderObject for use in this frame next time.
// Calling DrawCamera() increase viewCount.
// Add visLight from renderLight.
// Prevent to add multiple times in visCamera.
// already registered for this frame
// Connect visLight to renderLight for use in this frame next time.
// Calling DrawCamera() increase viewCount.
// Add visible lights/objects using bounding view volume.
// Called for each scene lights that intersects with camera frustum.
// Returns true if it want to proceed next query.
// Skip if light layer is not visible with this camera
// Skip if camera uses static lights and light is not static
// Skip if a light is farther than maximum visible distance
// Cull exact light bounding volume
// Calculate light scissor rect
// glScissor 의 x, y 좌표는 lower left corner 이므로 y 좌표를 밑에서 증가되도록 뒤집는다.
// Called for each scene objects that intersects with camera frustum.
// Returns true if it want to proceed next query.
// Skip if object layer is not visible with this camera
// Skip if camera renders static objects and this object is not static
// Skip first person camera only object in sub camera
// Skip 3rd person camera only object in sub camera
// Skip if a object is farther than maximum visible distance
// Register visible object form the render object
//inverse = inverse * Mat3(0, 0, 1, 1, 0, 0, 0, 1, 0);
// Add drawing surfaces of visible static meshes.
// Called for each static mesh surfaces intersecting with camera frustum 
// Returns true if it want to proceed next query
// surf 가 없다면 static mesh 가 아님
/*if (proxy->lodGroup >= 0) {
// More accurate OBB culling
// Add drawing surfaces of visible skinned meshes.
// More accurate OBB culling
// Update skinning joint cache for GPU skinning
// Add drawing surfaces of visible particle meshes.
// Copy this SubMesh to the temporary frame data for use in backend
// Add drawing surfaces of visible text meshes.
// Copy this SubMesh to the temporary frame data for use in back end
// Add drawing surfaces of the skybox mesh.
// Skybox object parameters
// Add skybox object
// Add lit drawing surfaces of visible static meshes for each light.
// Called for static mesh surfaces intersecting with each light volumes.
// Returns true if it want to proceed next query.
// Skip if object layer is not visible with this camera
// Skip if camera renders static objects and this object is not static
// Skip first person camera only object in sub camera.
// Skip 3rd person camera only object in sub camera.
// Skip if the object is farther than maximum visible distance.
// Already visible in this frame.
// Add drawSurf from visible drawSurf.
// This surface is not visible but shadow might be visible as a shadow caster.
// Register a visObject used only for shadow caster.
// Add lit drawing surfaces of visible skinned meshes for each light.
// Called for entities intersecting with each light volume
// Returns true if it want to proceed next query
// Skip if not skinned mesh
// Skip if object layer is not visible with this camera
// Skip if camera renders static objects and this object is not static
// Skip first person camera only object in sub camera 
// Skip 3rd person camera only object in sub camera
// Already visible in this frame
// Add drawSurf from visible drawSurf
// This surface is not visible but shadow might be visible as a shadow caster.
// Register a visObject used only for shadow caster
// Only for mesh type render object
/*if (surf->drawSurf->material->GetPass()->shader->GetPropertyInfoHashMap().Get("_PARALLAX")) {
// Iterate over light linked list in camera
// Compute effective AABB
// Find visible renderLights by querying view frustum in lightDBVT.
// Then register each visible renderLight to the current camera as VisLight.
// Find visible renderObjects by querying view frustum in objectDBVT.
// Then register each visible renderObject to the current camera as VisObject.
// Add drawing surfaces of static meshes by querying view frustum in staticMeshDBVT.
// Add drawing surfaces of skinned meshes by searching in visObjects.
//AddSubCamera(camera);
// Add drawing surfaces of particle meshes by searching in visObjects.
// Add drawing surfaces of text meshes by searching in visObjects.
// Add drawing surface of skybox.
// Add drawing surfaces of static meshes by querying light BV in staticMeshDBVT.
// Added drawing surface might be the shadow caster only surface if it is not the visible in the previous steps.
// Add drawing surfaces of skinned meshes by querying light BV in objectMeshDBVT.
// Added drawing surface might be the shadow caster only surface if it is not the visible in the previous steps.
// Compute scissor rect of each visLights and exclude if it is not visible.
// Cache instance data for instancing.
// Sort drawing surfaces.
//if (visObject->def->state.customSkin) {
//  actualMaterial = (visObject->def->state.customSkin)->RemapMaterialBySkin(material);
//}
/*float *outputValues = (float *)frameData.Alloc(actualMaterial->GetExprChunk()->NumRegisters() * sizeof(float));
//outputValues;
// Rough sorting back-to-front order for translucent surfaces.
//---------------------------------------------------
// SortKey for translucent materials:
// 0xFFF0000000000000 (0~4095)  : visLight index
// 0x000F000000000000 (0~15)    : material sort
// 0x0000FFFF00000000 (0~65535) : depth distance
// 0x00000000FFFF0000 (0~65535) : material index
// 0x000000000000FFFF (0~65535) : visObject index
//---------------------------------------------------
//---------------------------------------------------
// SortKey for opaque materials:
// 0xFFF0000000000000 (0~4095)  : visLight index
// 0x000F000000000000 (0~15)    : material sort
// 0x0000FFFF00000000 (0~65535) : sub mesh index
// 0x00000000FFFF0000 (0~65535) : material index
// 0x000000000000FFFF (0~65535) : visObject index
//---------------------------------------------------
// FIXME: Use radix sort to boost up speed
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Shader.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: must be same order with Shader::BuiltInConstant enum.
// ModelViewMatrix
// ModelViewMatrixTranspose
// ViewMatrix
// ViewMatrixTranspose
// ProjectionMatrix
// ProjectionMatrixTranspose
// ViewProjectionMatrix
// ViewProjectionMatrixTranspose
// ModelViewProjectionMatrix
// ModelViewProjectionMatrixTranspose
// PrevModelViewProjectionMatrix
// InstanceDataBuffer
// InstanceIndexes
// LocalToWorldMatrix
// WorldToLocalMatrix
// TextureMatrixS
// TextureMatrixT
// ConstantColor
// VertexColorScale
// VertexColorAdd
// PerforatedAlpha
// ViewOrigin
// LightVec
// LightTextureMatrix
// LightColor
// LightFallOffMatrix
// LightFallOffExponent
// Joints
// InvJointsMapSize
// SkinningBaseTc
// JointIndexOffset
// ShadowProjMatrix
// ShadowCascadeProjMatrix
// ShadowSplitFar
// Probe0SpecularCubeMapMaxMipLevel
// Probe0Position
// Probe0Mins
// Probe0Maxs
// Probe1SpecularCubeMapMaxMipLevel
// Probe1Position
// Probe1Mins
// Probe1Maxs
// ProbeLerp
// NOTE: must be same order with Shader::BuiltInSampler enum.
// CubicNormalCubeMap
// IndirectionCubeMap
// AlbedoMap
// NormalMap
// JointsMap
// LightProjectionMap
// LightCubeMap
// ShadowMap
// ShadowArrayMap
// PrefilteredDfgMap
// Probe0DiffuseCubeMap
// Probe0SpecularCubeMap
// Probe1DiffuseCubeMap
// Probe1SpecularCubeMap
// '{'
// Skip define value is 0
// instantiated shader name start with '@' character
// return instantiated shader if it already exist
// instantiated shader always has pointer to original shader
// allocate new instantiated shader
// insert local define array
// insert global define array
//BE_WARNLOG("Shader::SetConstant1i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant2i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant3i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant4i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant1f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant2x2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant3x3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant4x4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstant4x3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray1i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray2i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray3i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray4i: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray1f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray2x2f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray3x3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray4x4f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantArray4x3f: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetConstantBuffer: invalid constant name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetTexture: invalid texture name '%s' in shader '%s'\n", name, this->hashName.c_str());
//BE_WARNLOG("Shader::SetTextureArray: invalid texture name '%s' in shader '%s'\n", temp, this->hashName.c_str());
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\ShaderManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//defaultShader = AllocShader("_defaultShader", DefaultShaderGuid);
//defaultShader->Create(va("{ }", DefaultShaderGuid));
//defaultShader->permanence = true;
//shaderManager.AddGlobalHeader("#define ETC2_NORMAL\n");
// Remove '.shader'
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Skeleton.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --- joints ---
// --- bindpose ---
// --- inverted bindpose ---
// --- joints ---
// --- bindposes ---
// --- inverted bindposes ---
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\SkeletonManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Create default skeleton
// 레퍼런스 카운터가 0 인 skeleton 만 제거한다
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Skin.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\SkinManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\SkinningJointCache.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: VTF skinning 일 때만 모션블러 함
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\SubMesh.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Fill in static vertex buffer
// skinning subMesh 라면 vertex weight 값을 vertex buffer 뒤에 write 한다
//surfSpace->def->state.joints && useGpuSkinning) {
// Fill in static index buffer
// Fill in dynamic vertex buffer
// Fill in dynamic index buffer
// handedness 가 다르고 mirrored 버텍스가 없다면, 새 버텍스를 만든다
// mirrored vertex index 심기
// NOTE: should we normalize this ?
//v0->normal += v1->normal;
//v1->normal = v0->normal;
// Compute area weighted average of the normals
// Calculate tangent vectors for each face in isolation
// area sign bit
// determinant
// was = 1.0f / area;
// Clear the tangents
// Sum up the neighbors
// For each vertex on this face
// Project the summed vectors onto the normal plane and normalize.
// The tangent vectors will not necessarily be orthogonal to each
// other, but they will be orthogonal to the surface normal.
// normal
// area sign bit
// determinant
// tangent
// bitangent
// Project the summed vectors onto the normal plane and normalize.
// The tangent vectors will not necessarily be orthogonal to each
// other, but they will be orthogonal to the surface normal.
// compress the normals and tangents
// Derives the normal and orthogonal tangent vectors for the triangle vertices.
// For each vertex the normal and tangent vectors are derived from a single dominant triangle.
//#define DERIVE_UNSMOOTHED_BITANGENT
// Compute the dominant triangles for each vertices
// The dominant triangle should have most larger surface area among the adjacent triangles of a vertex
// Compute the surface area of a triangle
//float area = p0.Cross(p1).Length() * 0.5f; // original version
// low cost version
// Now dominantTri is [i, dominantTriVertex2, dominantTriVertex3]
// We just need determinant sign because tangents vectors should be normalized
// Assumes each edge is shared by at most two triangles.
// Temporary edge buffer to compute real 'edges'
// Maximum edge count is same as index count. but we need one more space for 0'th edge for dummy
// 0'th edge is not possible to have negative index, so we'll ignore it.
// edge's vertex index v0 to the edge table
// vertices might have many edges.
// edge indexes
// Vertex indexes for a current triangle
// 작은 인덱스가 먼저오도록 ordering
// edge vertex index 0
// edge vertex index 1
// edge vertex winding 이 triangle winding (CCW) 과 같다면 0
// edge vertex winding 이 triangle winding (CCW) 과 다르다면 1
// 공유하는 edge 를 찾는다
// 공유하는 edge 를 못 찾았거나 이미 두개의 edge 가 공유되어 있다면 새로운 edge 를 추가
// Add an edge to the temporary edge buffer 
// Update edge chain for later use
// Update a triangle index of an edge
//assert(tempEdges[edgeNum].t[order] == -1);
// Update an edge index
// 2개 이상 공유된 edge 개수를 경고 출력.
// Cleans up temporary memory
// Returns negative edge index if and if only first vertex index is larger than second one.
// All the edges should have two adjacent triangles if the mesh is closed
// ray sidedness for edges
// test triangles
// NOTE: consider if size of the index is greater than 16 bit number or not
// remap indices
// remap vertices
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\Texture.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*if (flags & HighPriority) {
// Indirection cubemap : Converts cubic coords to VCM coords
// VCM layout
// ----------------
// | PX | PY | PZ |
// |----+----+----| vcmHeight
// | NX | NY | NZ |
// ----------------
//     vcmWidth
/*
/*
/*
/*
/*
/*
// Convert cubemap coordinates from z-up to GL axis
/*
/*
/*
/*
/*
/*
// Apply scale down mip level
// Can't upload texels for depth texture
// Invalidates render target which is linked with this texture.
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\TextureManager.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Set texture filtering mode
//"LinearMipmapNearest");
// Set texture anisotropy mode
// Create pre-defined textures
// Create default texture
// Create zeroClamp texture
// Create defaultCube texture
// Create blackCube texture
// Create white texture
// Create black texture
// Create grey texture
// Create flatNormal texture
// Create normalCube texture
/*normalCubeMapTexture = AllocTexture("_normalCubeTexture");
// Create _cubicNormalCube texture
// Create fog texture
// Create fogEnter texture
// Create randomRotMat texture
// Create randomRot4x4 texture
/*for (int i = 0; i < rhi.hwLimits.maxTextureImageUnits; i++) {
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Render\VertexFormat.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Xy
// XySt
// XyStr
// XyzStr
// Xyz
// XyzColor
// GenericXyz
// GenericXyzSkinning1, GenericXyzSkinning4, GenericXyzSkinning8
// GenericXyzSt
// GenericXyzStSkinning1, GenericXyzStSkinning4, GenericXyzStSkinning8
// GenericXyzStColor
// GenericXyzStColorSkinning1, GenericXyzStColorSkinning4, GenericXyzStColorSkinning8
// GenericXyzNormal
// GenericXyzNormalSkinning1, GenericXyzNormalSkinning4, GenericXyzNormalSkinning8
// GenericXyzStNT
// GenericXyzStNTSkinning1, GenericXyzStNTSkinning4, GenericXyzStNTSkinning8
// GenericXyzStColorNT
// GenericXyzStColorNTSkinning1, GenericXyzStColorNTSkinning4, GenericXyzStColorNTSkinning8
// Occludee
// Create instanced array vertex format
// localToWorldMatrix
// entityColor
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLBuffer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Allowed only target UniformBuffer or TransformFeedbackBuffer
// Allowed only target UniformBuffer or TransformFeedbackBuffer
// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml
// GL_MAP_INVALIDATE_RANGE_BIT -- previous contents of the specified range may be discarded
// GL_MAP_UNSYNCHRONIZED_BIT -- GL should not attempt to synchronize pending operations on the buffer prior to returning from glMapBufferRange
// GL_MAP_FLUSH_EXPLICIT_BIT -- modifications to each subrange must be explicitly flushed (DMA) by calling glFlushMappedBufferRange()
// GL_MAP_PERSISTENT_BIT -- keep mapping and that the client intends to hold and use the returned pointer during subsequent GL operation
// GL_MAP_COHERENT_BIT -- persistent mapping is also to be coherent (automatically visible to GPU)
// glUnmapBuffer returns GL_TRUE unless the data store contents have become corrupt during the time the data
// store was mapped. This can occur for system-specific reasons that affect the availability of graphics
// memory, such as screen mode changes. In such situations, GL_FALSE is returned and the data store contents
// are undefined. An application must detect this rare condition and reinitialize the data store.
// glMapBufferRange 함수는 buffer alloc 되어 있지 않다면 GL_INVALID_VALUE error 발생
// buffer respecification using glBufferData
// If date == nullptr, buffer memory is reserved
/*if (gglMapBufferRange) {
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLCommon.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*int red, green, blue, alpha;
// texture limits
// the maximum supported texture image units that can be used to access texture maps from the fragment shader.
// the maximum number of 4 component generic vertex attributes accessible to a vertex shader.
// the maximum number of individual floating point, integer, or boolean values that can be held in uniform variable storage for a vertex shader.
// the maximum number of vector floating point, integer, or boolean values that can be held in uniform variable storage for a vertex shader.
// the maximum supported texture image units that can be used to access texture maps from the vertex shader.
// the maximum number of individual floating point, integer, or boolean values that can be held in uniform variable storage for a fragment shader.
// the maximum number of vector floating point, integer, or boolean values that can be held in uniform variable storage for a fragment shader.
// the maximum number of components of the inputs read by the fragment shader.
// the maximum supported texture image units that can be used to access texture maps from the geometry shader.
// the maximum number of uniform buffer binding points on the context.
// the maximum size in basic machine units of a uniform block.
// the minimum required alignment for uniform buffer sizes and offset.
// GL_ARB_framebuffer_object (3.0)
// GL_ARB_draw_buffers (2.0)
// Checking NVDIA vertex program version
// Checking NVDIA fragment program version
// GL_ARB_fragment_shader
// 1.3
// 1.4 - deprecated in OpenGL3
//gglHint(GL_GENERATE_MIPMAP_HINT_SGIS, GL_NICEST);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLDebug.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLPlatformAndroid.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// EGL_KHR_create_context
//minAttribs[numMinAttribs++] = EGL_COLOR_COMPONENT_TYPE_EXT;
//minAttribs[numMinAttribs++] = EGL_COLOR_COMPONENT_TYPE_FIXED_EXT;
//minAttribs[numMinAttribs++] = EGL_COLOR_COMPONENT_TYPE_FLOAT_EXT;
//if (!eglGetConfigs(eglDisplay, configs, maxConfigs, &maxConfigs)) {
// smaller score is better
// Optional, Tegra-specific non-linear depth buffer, which allows for much better
// effective depth range in relatively limited bit-depths (e.g. 16-bit)
// GL_MAJOR_VERSION, GL_MINOR_VERSION 쿼리는 3.0 core context 부터 지원된다
// 아직 context 가 만들어지기 전이라면 glGetString 을 이용
// Create main context
// main context has no surface
// Create EGL display connection
// Initialize EGL for this display
// Set the current rendering API
// Create a main EGL rendering context
// default FBO 
// Create default VAO for main context
// Delete default VAO for main context
// main context will be reused
// Create a main EGL rendering context
// Create default VAO for shared context
// Delete default VAO for shared context
// EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is
// guaranteed to be accepted by ANativeWindow_setBuffersGeometry().
// As soon as we picked a EGLConfig, we can safely reconfigure the
// ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.
// Change the format and size of the window buffers. 
// 0, 0 -> Buffer dimensions = Screen resolution
// Once we've got a valid configuration we can create a window surface that'll be used for rendering
// NOTE: If the frame buffer color format does not contain alpha, sRGB capable buffer creation will fail !!
// https://android.googlesource.com/platform/frameworks/native/+/63108c34ec181e923b68ee840bb7960f205466a7/opengl/libs/EGL/eglApi.cpp
// Associate the EGL context with the EGL surface
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLPlatformWin.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ES2 profile including ES3
// hide fake window
// Get the number of pixel formats supported by this DC.
// Use positive one-based integer indexes
// Is supported by GDI software implementation ?
// Is color index pixel type ?
// Check color bits
// Check alpha bits
// Check depth bits
// Check stencil bits
// Best PFD choosed !!
// WGL_SUPPORT_OPENGL_ARB
// WGL_ACCELERATION_ARB
// WGL_DOUBLE_BUFFER_ARB
// WGL_DRAW_TO_WINDOW_ARB
// WGL_PIXEL_TYPE_ARB
// WGL_ALPHA_BITS_ARB
// WGL_DEPTH_BITS_ARB
// WGL_STENCIL_BITS_ARB
// WGL_SAMPLE_BUFFERS_ARB
// WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB
// check color bits
// check alpha bits
// check depth bits
// check stencil bits
// check multi samples
// GL_MAJOR_VERSION, GL_MINOR_VERSION 쿼리는 3.0 core context 부터 지원된다
// 아직 context 가 만들어지기 전이라면 glGetString 을 이용
//majorVersion = 3;
//minorVersion = 2;
// NOTE: WGL extension string 을 얻기 위해서는 RC 와 연결된 valid DC 가 필요하다
// gwglXXX function bindings & check WGL extensions
// gglXXX function bindings & check GL extensions
// Create main context
// Create fake window for global RC
// Set PF for the main DC
// Create rendering context
// Enable debug callback
// default FBO 
// Create default VAO for main context
// Delete default VAO for main context
// All rendering contexts use an identical pixel format
// main context will be reused
// Allow sharing of all display list and texture objects between rendering context
//
// NOTE: The best time to call wglShareLists is after creating the GL contexts 
// you want to share, but before you create any objects in either of the contexts. 
// If you create objects, then there is a chance that wglShareLists will fail.
// Create default VAO for shared context
// Delete default VAO for shared context
//DPI_AWARENESS dpiAwareness = GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(ctx->hwnd));
// Number of pixels per logical inch along the screen size.
// In a system with multiple display monitors, this value is the same for all monitors.
//int dpi = GetDpiForWindow(ctx->hwnd);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLPlatformWinEGL.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// hide fake window
// end marker
// GL_MAJOR_VERSION, GL_MINOR_VERSION 쿼리는 3.0 core context 부터 지원된다
// 아직 context 가 만들어지기 전이라면 glGetString 을 이용
// Create main context
// Create fake window for global RC
// Create EGL display connection
//mainContext->eglDisplay = eglGetDisplay(mainContext->hdc);
// Initialize EGL for this display
// Set the current rendering API
// Create a main EGL rendering context
// Once we've got a valid configuration we can create a window surface that'll be used for rendering
// Associate the EGL context with the EGL surface
// default FBO 
// Create default VAO for main context
// Delete default VAO for main context
// main context will be reused
/*ctx->eglDisplay = eglGetDisplay(ctx->hdc);
// Initialize EGL for this display
// Create a main EGL rendering context
// Create default VAO for shared context
// Delete default VAO for shared context
//DPI_AWARENESS dpiAwareness = GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(ctx->hwnd));
// Number of pixels per logical inch along the screen size.
// In a system with multiple display monitors, this value is the same for all monitors.
//int dpi = GetDpiForWindow(ctx->hwnd);
//gglFlush();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLPlatformXamarin.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Configure EAGLDrawable (CAEAGLLayer)
// Create FBO
// Create color buffer for display
// Get the size of the buffer
// Create depth buffer
// Allocate color buffer backing based on the current layer size
// Discard the unncessary depth buffer for now
//gglDiscardFramebufferEXT(GL_READ_FRAMEBUFFER_APPLE, 2, discards);
// @implementation EAGLView
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//// Create EAGLContext
//mainContext->eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];
//if (!mainContext->eaglContext) {
//    BLib::Error(FatalErr, L"Couldn't create main EAGLContext");
//}
//
//// Make current context
//[EAGLContext setCurrentContext:mainContext->eaglContext];
//BLib::Error(FatalErr, L"Minimum OpenGL extensions missing !!\nRequired OpenGL 3.3 or higher graphic card");
// gglXXX 함수 바인딩 및 확장 flag 초기화
// default FBO
// Create default VAO for main context
// Delete default VAO for main context
//	// Sets the current context to nil.
//	[EAGLContext setCurrentContext : nil];
//
//#if !__has_feature(objc_arc)
//	[mainContext->eaglContext release];
//#endif
//ctx->eaglContext = mainContext->eaglContext;
//ctx->eaglContext =  [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3 sharegroup : [mainContext->eaglContext sharegroup]];
//if (!ctx->eaglContext) {
//    BLib::Error(FatalErr, L"Couldn't create main EAGLContext");
//}
//   CGRect contentRect = [ctx->rootView bounds];
//ctx->eaglView = 0; // [[EAGLView alloc] initWithFrame:CGRectMake(0, 0, contentRect.size.width, contentRect.size.height)];
//   ctx->eaglView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
//    [ctx->eaglView setGLContext:ctx];
//   
//   [ctx->eaglView initFramebuffer];
//   
//   [ctx->rootView addSubview:ctx->eaglView];
//   
// = ctx->eaglView.framebuffer;
// Create default VAO for shared context
// TODO ANDROID
//if (ctx->eaglContext != mainContext->eaglContext) {
//       // Delete default VAO for shared context
//       gglDeleteVertexArrays(1, &ctx->defaultVAO);
//       
//#if !__has_feature(objc_arc)
//        [ctx->eaglContext release];
//#endif
//    
//    delete ctx->state;
//}
// Delete default VAO for shared context
//[EAGLContext setCurrentContext:mainContext->eaglContext];
//	EAGLContext *currentContext = [EAGLContext currentContext];
//if (currentContext != ctx->eaglContext)
// This ensures that previously submitted commands are delivered to the graphics hardware in a timely fashion.
//[EAGLContext setCurrentContext : ctx->eaglContext];
//#if USE_DISPLAY_LINK
//    [ctx->eaglView startDisplayLink];
//#endif
//    GLContext *ctx = ctxHandle == NullContext ? mainContext : contextList[ctxHandle];
//[ctx->eaglView drawView:nil];
//		CGSize viewSize = [ctx->eaglView bounds].size;
//		*windowWidth = viewSize.width;
//		*windowHeight = viewSize.height;
//		CGSize backingSize = [ctx->eaglView backingPixelSize];
//		*backingWidth = backingSize.width;
//		*backingHeight = backingSize.height;
//if (!gl_ignoreGLError.GetBool()) {
//	CheckError("OpenGLRHI::SwapBuffers");
//}
//if (gl_finish.GetBool()) {
//	glFinish();
//}
//   [currentContext->eaglView swapBuffers];
//   
//if (gl_debug.IsModified()) {
//	ggl_rebind(gl_debug.GetBool());
//	gl_debug.ClearModified();
//}
//assert(0);;
//[currentContext->eaglView setAnimationFrameInterval:interval];
//assert(0);; 
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLQuery.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLRenderTarget.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// numColorTextures may be greater than 1 due to MRT.
// NOTE: this is per-FBO state
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLShader.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// vertex shader input semantics
// fragment shader output semantics
// not deprecated yet
// :
// semantic name
// type or block tag
// block name
// type or precision qualifier
// type
// name
// maintain indentation
//headerText += "#extension GL_ARB_gpu_shader5 : enable\n";
//headerText += "#extension GL_ARB_geometry_shader4 : enable\n";
//headerText += "#extension GL_EXT_shader_texture_lod : enable\n";
// Set default precisions
// delete shader objects after linking GLSL program to save memory
// maximum length of the uniform name
// A uniform variable (either built-in or user-defined) is considered active if it is determined during 
// the link operation that it may be accessed during program execution. Therefore, program should have 
// previously been the target of a call to glLinkProgram
//
// If one or more elements of an array are active, the name of the array is returned in name, the type is 
// returned in type, and the size parameter returns the highest array element index used, plus one, 
// as determined by the compiler and/or linker
// http://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetActiveUniform.xml
// NOTE: size 는 highest array element index used 가 아닌 것 같다. 그냥 max array count 가 나옴
// TMU
// TMU
// built-in uniform 은 제외한다
// occupies 16 bytes per uniform
// binary search 를 위해 정렬
// binary search 를 위해 정렬
// binary search 를 위해 정렬
// columns = 4, rows = 3
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLState.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// !linearFrameBuffer;
//gglDisable(GL_ALPHA_TEST);
//gglDisable(GL_MULTISAMPLE);
// NVIDIA DRIVER BUG: GL_TEXTURE_CUBE_MAP_SEAMLESS 가 켜진 상태에서 some internal format 의 cubemap 을 read access 할때 crash 된다.
//gglDisable(GL_LIGHTING);
// Deprecated at OpenGL 3.0
//gglShadeModel(GL_SMOOTH);
//gglHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
//gglColor4f(1.0f, 1.0f, 1.0f, 1.0f);
//state_delta = ~0;
// polygon mode
// depth func
// blend func
//glBlendFuncSeparateEXT(blend_src, blend_dst, blend_src, blend_dst);
// color mask
// depth mask
// scissorRect 의 x, y 는 lower left corner
// This extension adds a framebuffer capability for sRGB framebuffer update and blending. When
// blending is disabled but the new sRGB updated mode is enabled (assume the framebuffer supports
// the capability), high-precision linear color component values for red, green, and blue generated
// by fragment coloring are encoded for sRGB prior to being written into the framebuffer.  When
// blending is enabled along with the new sRGB update mode, red, green, and  blue framebuffer color
// components are treated as sRGB values that are converted to linear color values, blended with
// the high-precision color values generated by fragment coloring, and then the blend result is
// encoded for sRGB just prior to being written into the framebuffer.
//gglLineWidth(Max(width, 0.0f));
// back 과 front 의 stencilState 가 다르면 양면 스텐실 적용
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLSync.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLTexture.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// NOTE: GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT is simply an alias for the 
// existing GL_COMPARE_R_TO_TEXTURE token in OpenGL 2.0; the alternate name  
// reflects the fact that the R coordinate is not always used.)  
// NOTE: OpenGL ES 에서는 compressed format 일 경우 GL_INVALID_OPERATION
// NOTE: GL_ARB_texture_non_power_of_two 익스텐션 스트링이 없다면,
// NPOT 텍스쳐는 밉맵이나 wrapmode 에 따라서 hw-accelerate 되지 않을수도 있다.
// 2의 승수 사이즈 맞추기
// 큐브맵일 경우에는 가로 세로 길이를 동일하게 맞춘다
// GL_READ_BUFFER 에서 읽어서 텍스쳐로 저장
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\RGLVertexFormat.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------   -------------------------
// Conventional Attribute Binding   Generic Attribute Binding
// ------------------------------   -------------------------
// vertex.position                  vertex.attrib[0]
// vertex.weight                    vertex.attrib[1]
// vertex.weight[0]                 vertex.attrib[1]
// vertex.normal                    vertex.attrib[2]
// vertex.color                     vertex.attrib[3]
// vertex.color.primary             vertex.attrib[3]
// vertex.color.secondary           vertex.attrib[4]
// vertex.fogcoord                  vertex.attrib[5]
// vertex.texcoord                  vertex.attrib[8]
// vertex.texcoord[0]               vertex.attrib[8]
// vertex.texcoord[1]               vertex.attrib[9]
// vertex.texcoord[2]               vertex.attrib[10]
// vertex.texcoord[3]               vertex.attrib[11]
// vertex.texcoord[4]               vertex.attrib[12]
// vertex.texcoord[5]               vertex.attrib[13]
// vertex.texcoord[6]               vertex.attrib[14]
// vertex.texcoord[7]               vertex.attrib[15]
// vertex.texcoord[n]               vertex.attrib[8+n]
/*else {
// if normalized is set to GL_TRUE, it indicates that values stored in an integer format are to be mapped to the range[-1, 1]
// (for signed values) or [0, 1](for unsigned values) when they are accessed and converted to floating point. Otherwise, 
// values will be converted to floats directly without normalization.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\AndroidOpenGL.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\OpenGL.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 3.0
// 3.2
// 3.0
// 2.1
// 3.1
// 3.0
// NOTE: Do not call gglXXX function in CheckGLError
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\OpenGL3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 3.3
// 4.3
// 3.3
// 4.0
// 4.3
// 4.3
// Any GL error; dangerous undefined behavior; any GLSL or ARB shader compiler and linker errors;
// Severe performance warnings; GLSL or other shader compiler and linker warnings; use of currently deprecated behavior
// Performance warnings from redundant state changes; trivial undefined behavior
// The GL
// The window system, such as WGL or GLX
// The GLSL shader compiler or compilers for other extension - provided languages
// External debuggers or third - party middleware libraries
// The application
// Sources that do not fit to any of the ones listed above
// Events that generated an error
// Behavior that has been marked for deprecation
// Behavior that is undefined according to the specification
// Use of extensions or shaders in a way that is highly vendor - specific
// Implementation - dependent performance warnings
// Types of events that do not fit any of the ones listed above
//GL_COMPRESSED_SIGNED_RED_RGTC1 GL_COMPRESSED_LUMINANCE_LATC1_EXT;
//GL_COMPRESSED_SIGNED_RG_RGTC2 GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\OpenGL4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\OpenGLES3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\XamarinOpenGL.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\LuaVM.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// VS Code Lua Debugger by devCAT: https://marketplace.visualstudio.com/items?itemName=devCAT.lua-debug
// Set lua_debuggeeController to "vscode_debuggee_controller"
// MobDebug in ZeroBrane Studio https://github.com/pkulchenko/MobDebug
// Set lua_debuggeeController to "mobdebug_controller"
//BE_LOG("Lua version %.1f\n", state->Version());
// Redirect global print function
// Math
// Common
// Input
// Screen
// Physics
// Str
// Guid
// File
// Object
// Asset
// Component
// Game World
//state->Require("blueshift");
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_AnimAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_AnimControllerAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_Asset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_MapAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_MaterialAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_MeshAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_PrefabAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_ShaderAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_SkeletonAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_SoundAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Asset\LuaModule_TextureAsset.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComAnimation.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComAnimator.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComAudioListener.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComAudioSource.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComBoxCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCamera.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCapsuleCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCharacterController.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCharacterJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComConstantForce.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComCylinderCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComFixedJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComHingeJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComLight.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComMeshCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComParticleSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_Component.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComRenderable.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComRigidBody.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComScript.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSensor.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSkinnedMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSliderJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSocketJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSphereCollider.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSpline.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComSpringJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComStaticMeshRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComTextRenderer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComTransform.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Component class should be registered first
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComVehicleWheel.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Components\LuaModule_ComWheelJoint.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Core\LuaModule_Guid.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Core\LuaModule_Object.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Core\LuaModule_Str.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Engine\LuaModule_Common.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\File\LuaModule_File.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\File\LuaModule_FileSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Game\LuaModule_Entity.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Game\LuaModule_GameWorld.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Input\LuaModule_InputSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_AABB.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Angles.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Color3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Color4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Complex.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Cylinder.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Frustum.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Mat2.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Mat3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Mat3x4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Mat4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Math.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_OBB.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//"set_from_points", &OBB::SetFromPoints,
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Plane.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Point.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Quaternion.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Ray.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Rect.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// index start from zero
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Rotation.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Sphere.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Vec2.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Vec3.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Math\LuaModule_Vec4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Physics\LuaModule_Physics.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Scripting\Screen\LuaModule_Screen.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Simd\Simd.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// pointer to generic SIMD implementation
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Simd\Simd_AVX.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// defined(__X86__)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Simd\Simd_Generic.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// row 0
// row 1
// row 2
// row 3
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Simd\Simd_SSE4.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//_mm_prefetch((const char *)(src_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src1_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src1_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src1_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src0_ptr + 16), _MM_HINT_NTA);
//_mm_prefetch((const char *)(src1_ptr + 16), _MM_HINT_NTA);
// Row 0
// Row 1
// Row 2
// Row 3
//_mm_prefetch(src_ptr + 64, _MM_HINT_NTA);
//_mm_mfence();
//_mm_prefetch(src_ptr + 128, _MM_HINT_NTA);
//_mm_prefetch(src_ptr + 192, _MM_HINT_NTA);
//_mm_mfence();
// copy 2k into temporary buffer
// Now copy from L1 to system memory
// optimized memory copy routine that handles all alignment cases and block sizes efficiently
// copy up to the first 16 byte aligned boundary
// if there are multiple blocks of 2kB
// if there are blocks of 64 bytes
// copy any remaining bytes
// use the regular one if we cannot copy 16 byte aligned
// #if defined(__X86__)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\Pcm.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// RIFF WAVE
// Ogg Vorbis
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\Pcm_DecodeOgg.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
// Vorbis file callback
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------
// 최소 읽기 가능 크기 4
// 읽을 크기 보다 실제로 읽은 크기가 더 커져 버린 경우
//--------------------------------------------------------------------------------------------------
// Vorbis memory file callback
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\Pcm_DecodeWav.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//--------------------------------------------------------------------------------------------------
// RIFF wave chunk id
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
// predefined IMA ADPCM data
//--------------------------------------------------------------------------------------------------
// 0 ~ 3, decrease the step size
// 4 ~ 7, increase the step size
//--------------------------------------------------------------------------------------------------
// IMA ADPCM decode functions
//--------------------------------------------------------------------------------------------------
// 채널 별로 4 바이트 초기값 (preamble) 을 읽는다
// 채널 별로 4 바이트씩 (채널 별로 8 개의 샘플) 읽어서 처리한다
// 스텝 값을 구한다
// 다음 스텝 인덱스 보정
// 차이값을 구한다 (diff = (nibble + 0.5) * step / 4)
// 차이값을 더해 산정한다
// 디코딩 된 최종값 (signed 16 bit) 저장
//----------------------------------------------------------------------------------------------------------------------
// 한 블럭의 크기
// 읽을 크기 보다 실제로 읽은 크기가 더 커져 버린 경우
// 초과된 량은 버퍼에 저장해 놓는다
// TODO: IMPLEMENT THIS !
// skip 'RIFF'
// read wave length (파일 크기에서 8 을 뺀값)
// skip 'WAVE' signature
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\Sound.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// If this sound have a original sound pointer, this is the duplicated one
// Find a reusable duplicated sound buffer which is currently not playing
// Only non-looping sound can be reusable
// Forces to stop and reuse duplicated sound if maximum reusable count is reached
// If not found, duplicate original sound buffer
// The volume of each sound must be multiplied by the master volume.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundBufferAL.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundBufferDS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundBufferSLES.cpp
// The buffers that are queued in a player object are used in place and
// are not required to be copied by the device, although this may be 
// implementation dependent.T he application developer should be aware 
// that modifying the content of a buffer after it has been queued is 
// undefined and can cause audio corruption.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSourceAL.cpp
// The distance that the source will be the loudest (if the listener is
// closer, it won't be any louder than if they were at this distance)
// The distance that the source will be the quietest (if the listener is
// farther, it won't be any quieter than if they were at this distance)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSourceDS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//ds3dBuffer->SetVelocity(sound->velocity.x, sound->velocity.y, sound->velocity.z, DS3D_DEFERRED);
// Do linear attenuation
// add the write offset as block size
// wrap the write offset because it's circular buffer
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSourceSLES.cpp
// Callback that is registered if the source needs to loop
// Data location
// PCM format info
// SL_PCMSAMPLEFORMAT_FIXED_16;
// SL_PCMSAMPLEFORMAT_FIXED_16;
// Combine location and format into source
// Output location
// Data sink
// Create audio player with source and sink
/*, SL_IID_3DLOCATION*/ };
/*, SL_BOOLEAN_FALSE*/ };
// Realize the player
// Get the play interface
// Get the volume interface
// Get the buffer queue interface
// Get the 3d location interface
// If looping, register a callback to requeue the buffer
//result = (*slSeek)->SetLoop(slSeek, SL_BOOLEAN_TRUE, 0, SL_TIME_UNKNOWN);
// Do linear attenuation
// on some android devices, the value for GetPosition wraps back to 0 when the playback is done, however it's very possible
// for us to try to check for IsSourceFinished when the Position is genuinely "0". Therefore, we'll flip hasPositionUpdated once
// we've actually started the sound to denote a wrap-back 0 position versus a real 0 position
// set the player's state to stopped
// set the player's state to paused
// set the player's state to playing
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSystem.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// FIXME
// Sounds to be sorted by priority
// TODO: SoundSystem::Update 함수를 별도 쓰레드로 바꿀것
// Stop any sources that have finished
// Remove from the play list
// Sort sounds by priority decending order
// Stop sources that have lower priority first
// Play sources
// Update playing time of each playing sounds
// FIXME: playingTime is not precise for now
// Update system volume if it is modified by cvar
//--------------------------------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSystemAL.cpp
// Verify that a given extension is available for the current context
// Retrieve a list of available devices
// Each device name is separated by a single nullptr character
// and the list is terminated with 2 nullptr characters
// Retrieve the default device name
// Reset the error stack
// Open the default device
// Get the OpenAL version
// Create context
// Set active context
//alDopplerFactor(1.0); // 1.2 = exaggerate the pitch shift by 20%
//alDopplerVelocity(343.0f); // m/s this may need to be scaled at some point
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSystemDS.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// No HW driver
// Create primary sound
// | DSBCAPS_CTRLVOLUME;
//dsbd.dwBufferBytes = 0;
//dsbd.lpwfxFormat = nullptr;
//memset(&dsbd.guid3DAlgorithm, 0, sizeof(dsbd.guid3DAlgorithm));
// Set the primary sound format
// Get actual format of the primary sound
//this->numChannels = fmt.nChannels;
//this->sampleRates = fmt.nSamplesPerSec;
//this->bitsWidth = fmt.wBitsPerSample;
// Start mixer engine !
// Get the listener interface
// Set the listener properties
// no attenuation needed because we attenuate volume manually
//s_rolloff.GetFloat();
// Initialize sources
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\Sound\SoundSystemSLES.cpp
// Create the SL engine object
// Realize the SL engine object
// Get the SL engine interface, which is needed in order to create other objects
// Create output mix object
// Realize the output mix object
// Create listener object
// Realize the listener object
// Initialize sources
// Delete sources
// Destroy output mix object, and invalidate all associated interfaces
// Destroy engine object, and invalidate all associated interfaces
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\StaticBatching\MeshCombiner.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Skip if this entity has mesh component that is already combined with others
// Enumerate combinable entities
// Sort entities by material
// TODO: Check BatchingStatic
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\StaticBatching\StaticBatch.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\CUDA.cpp
// Defines for GPU Architecture types (using the SM version to determine the # of cores per SM
// 0xMm (hexidecimal notation), M = SM Major version, and m = SM minor version
// Tesla Generation (SM 1.0) G80 class
// Tesla Generation (SM 1.1) G8x class
// Tesla Generation (SM 1.2) G9x class
// Tesla Generation (SM 1.3) GT200 class
// Fermi Generation (SM 2.0) GF100 class
// Fermi Generation (SM 2.1) GF10x class
// Fermi Generation (SM 3.0) GK10x class
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\Main.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Strip "TestBase.app/Contents/MacOS"
// Strip "Bin/macOS/<Configuration>"
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\TestContainer.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\TestCUDA.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define TEST_CUDA       1
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\TestLua.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Lua function that returns single value
// Lua function that returns multiple values
// Register function pointer to Lua
// Register lambda to Lua
// call by lvalue reference
// call by lvaue / rvalue reference
// index start from zero
// Register static member function (like global function)
// Register static member variable (like global variable)
// ---- TEST CODE ----
// get value by reference
//selector["name"] = "hello";
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\TestMath.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestBase\TestSIMD.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//BE_LOG("  Result: %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n",
//  matrixC[0], matrixC[1], matrixC[2], matrixC[3], matrixC[4], matrixC[5], matrixC[6], matrixC[7], matrixC[8], matrixC[9], matrixC[10], matrixC[11], matrixC[12], matrixC[13], matrixC[14], matrixC[15]);
//BE_LOG("  Result: %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n",
//  matrixC[0], matrixC[1], matrixC[2], matrixC[3], matrixC[4], matrixC[5], matrixC[6], matrixC[7], matrixC[8], matrixC[9], matrixC[10], matrixC[11], matrixC[12], matrixC[13], matrixC[14], matrixC[15]);	
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\AndroidMain.cpp
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// FIXME: wait until finishing java UI thread
/*
// by all means at this point, ASensorManager_getInstance should be available
// If a sensor has data, process it now.
/*float maginitude = event.acceleration.x * event.acceleration.x + event.acceleration.y * event.acceleration.y;
// When our app gains focus, we start monitoring the accelerometer.
// We'd like to get 60 events per second (in us).
// We'd like to get 60 events per second (in microseconds).
// When our app loses focus, we stop monitoring the accelerometer.
// This is to avoid consuming battery while not being used.
// Process the next main command.
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Process the next input event.
// TODO: Implement this
// ACTION_MOVE events are batched, unlike the other events.
// Set window format to 8888
// app command callback
// input event callback
// Prepare to monitor accelerometer
// extern "C"
/**
// loop waiting for stuff to do.
// Read all pending events.
// If not animating, we will block forever waiting for events.
// If animating, we loop until all events are read, then continue
// to draw the next frame of animation.
// Process this event.
// Check if we are exiting.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\Application.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// bgra
//precision highp float;
//precision highp float;
// Set projection matrix to flip vertically
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\Precompiled.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\WinMain.cpp
// Copyright(c) 2017 POLYGONTEK
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http ://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//#define CREATE_SUB_WINDOW
// The title bar text
//::SetTimer(hwnd, 0, 100, nullptr);
//wcex.hbrBackground    = (HBRUSH)GetStockObject(BLACK_BRUSH);
//wcex.hbrBackground    = (HBRUSH)GetStockObject(BLACK_BRUSH);
// FBO cannot be shared, so we should create FBO for each context
// Disable automatic DPI scaling.
// Initialize global strings
// Perform application initialization
//BE1::rhi.DisplayContext(mainContext);
// Parse the menu selections:
// prevent to close sub window
//BE1::rhi.DisplayContext(subContext);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\asio\include\asio\impl\src.cpp
//
// impl/src.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2015 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\bestfit.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// Geometric Tools, Inc.
// http://www.geometrictools.com
// Copyright (c) 1998-2006.  All Rights Reserved
//
// The Wild Magic Library (WM3) source code is supplied under the terms of
// the license agreement
//     http://www.geometrictools.com/License/WildMagic3License.pdf
// and may not be copied or disclosed except in accordance with the terms
// of that agreement.
// the dot product
//diagonalize the matrix.
//
//sort eigenvalues in decreasing order, e[0] >= ... >= e[iSize-1]
// locate maximum eigenvalue
// swap eigenvalues
// swap eigenvectors
// change sign on the first column
// namespace BestFit
//
// reciprocol of total weighting
//
// apply vertex weighting!
// sume of the squares of the differences.
// sume of the squares of the differences.
// sume of the squares of the differences.
// setup the eigensolver
// compute eigenstuff, smallest eigenvalue is in last position
// the minimum energy
// returns the diagonal distance
// return true if the two AABB's overlap.
// if the maximum is less than our minimum on any axis
// if the minimum is greater than our maximum on any axis
// if the minimum is greater than our maximum on any axis
// if the minimum is greater than our maximum on any axis
// the extents overlap
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\bestfitobb.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// computes the OBB for this set of points relative to this transform matrix.
// inverse rotate translate
// 180 degree sweep on all three axes.
// 16 steps on each axis.
// the volume of the cube
// yes, we found an improvement.
// sweep 1/2 the distance as the last time.
// no improvement, so just
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\cd_hull.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
/*----------------------------------------------------------------------
//*****************************************************
/*****************************************************
//********* Stan Melax's vector math template needed
/********* Stan Melax's vector math template needed
//*****************************************************
/*****************************************************
//----------------------------------
//-------- 2D --------
//--------- 3D ---------
// 3D
//operator float *() { return &x;};
// due to ambiguity and inconsistent standards ther are no overloaded operators for mult such as va*vb.
// the 3 rows of the Matrix
// its just 3x3 so we simply do that cofactor method
//-------- 4D Math --------
//operator float *() { return &x;};
// the 4 rows
// Turns a 3D float3 4D vector4 by appending w
//-------- Quaternion ------------
// returns quat q where q*v0=v1
//------ Euler Angle -----
//------- Plane ----------
// distance below origin - the D from plane equasion Ax+By+Cz+D=0
//--------- Utility Functions ------
// projects a onto infinite line p0p1
//------------ float3 (3D) --------------
// this routine, normalize, is ok, provided magnitude works!!
// yes this could go here
// the statement v1*v2 is ambiguous since there are 3 types
// of vector multiplication
//  - componantwise (for example combining colors)
//  - dot product
//  - cross product
// Therefore we never declare/implement this function.
// So we will never see:  float3 operator*(float3 a,float3 b)
//------------ float3x3 ---------------
// reverse indexs i&j to take transpose
// Matrix check=a*b; // Matrix 'check' should be the identity (or close to it)
//--------------- 4D ----------------
// yes this actually works
//  Dont implement m*v for now, since that might confuse us
//  All our transforms are based on multiplying the "row" vector on the left
//float4   operator*(const float4x4& m , const float4&   v )
//{
//	return float4(dot(v,m.x),dot(v,m.y),dot(v,m.z),dot(v,m.w));
//}
// view space height
// view space width
/* temp array for pairs */
/* array of transpose source matrix */
/* determinant */
/* transpose matrix */
/* calculate pairs for first 8 elements (cofactors) */
/* calculate first 8 elements (cofactors) */
/* calculate pairs for second 8 elements (cofactors) */
/* calculate second 8 elements (cofactors) */
/* calculate determinant */
/* calculate matrix inverse */
//--------- Quaternion --------------
// The following is equivalent to:
//return (q.getmatrix() * v);
// must multiply with the quat on the left
//------------- Plane --------------
//   Transforms the plane to the space defined by the
//   given position/orientation.
//--------- utility functions -------------
//        RotationArc()
// Given two vectors v0 and v1 this function
// returns quaternion q where q*v0==v1.
// Routine taken from game programming gems.
// Comment these two lines out if you know its not needed.
// If vector is already unit length then why do it again?
// 180 about x axis
// builds a 4x4 transformation matrix based on orientation q and translation v
// returns the point where the line p0-p1 intersects the plane n&d
// return the normal of the triangle
// inscribed by v0, v1, and v2
//v.x = bmin.x;
//v.x = bmax.x;
//v.y = bmin.y;
// vy = bmax.y;
// v.z = bmin.z;
// v.z = bmax.z;
// routine taken from game programming gems.
// Implement track ball functionality to spin stuf on the screen
//  cop   center of projection
//  cor   center of rotation
//  dir1  old mouse direction
//  dir2  new mouse direction
// pretend there is a sphere around cor.  Then find the points
// where dir1 and dir2 intersect that sphere.  Find the
// rotation that takes the first point to the second.
// compute plane
// since trackball proportional to distance from cop
// By using the cached plane distances d0 and d1
// we can optimize the following:
//     the_point = planelineintersection(nrml,dist,v0,v1);
// let inside = 0 if outside
//**************************************************************************
/**************************************************************************
//*** Stan Melax's array template, needed to compile his hull generation code
/*** Stan Melax's array template, needed to compile his hull generation code
//**************************************************************************
/**************************************************************************
// operator ArrayRet<Type> &() { return *(ArrayRet<Type> *)this;} // this worked but i suspect could be dangerous
// assert object t is in the array.
// to allocate space
//*********************************************************************
/*********************************************************************
//********  Hull header
/********  Hull header
//*********************************************************************
/*********************************************************************
// the other half of the edge (index into edges list)
// the vertex at the start of this edge (index into vertices list)
// the facet on which this edge lies (index into facets list)
// i sliced tangent to an edge and created 2 meaningless edges
// back to back quads
// existing vertex members of convex that are coplanar
// existing edges that members of convex that cross the splitplane
// do the side-of-plane tests
// ? vertscoplanar.Add(i);
// for debugging purposes
// for debugging only
//if((vertflag[edge0.v].planetest & vertflag[edge1.v].planetest)  == COPLANAR) {
//	assert(ecop==-1);
//	ecop=e;
//}
// both endpoints over plane
// at least one endpoint under, the other coplanar or under
// connect the neighbors
// both endpoints coplanar
// must check a 3rd point to see if UNDER
// make sure this edge is added to the "coplanar" list
// first is under 2nd is over
// connect the neighbors
//createdverts.Add(PlaneProject(slice,PlaneLineIntersection(slice,convex.vertices[edge0.v],convex.vertices[edgea.v])));
//createdverts.Add(PlaneLineIntersection(slice,convex.vertices[edge0.v],convex.vertices[edgea.v]));
/// hmmm something to think about: i might be able to output this edge regarless of
// wheter or not we know v-in yet.  ok i;ll try this now:
// we previously processed an edge  where we came under
// now we know about vout as well
// ADD THIS EDGE TO THE LIST OF EDGES THAT NEED NEIGHBOR ON PARTITION PLANE!!
// first is coplanar 2nd is over
// I hate this but i have to make sure part of this face is UNDER before ouputting this vert
// hmmm should make a note of the edge # for later on
// first is over next is under
// new vertex!!!
//createdverts.Add(PlaneLineIntersection(slice,convex.vertices[edge0.v],convex.vertices[edgea.v]));
//createdverts.Add(PlaneProject(slice,PlaneLineIntersection(slice,convex.vertices[edge0.v],convex.vertices[edgea.v])));
// find the new vertex that was created by edge[edge0.ea]
// for debugging only
// we previously processed an edge  where we went over
// now we know vin too
// ADD THIS EDGE TO THE LIST OF EDGES THAT NEED NEIGHBOR ON PARTITION PLANE!!
// output edge
// connect the neighbors
// first is over next is coplanar
// we previously processed an edge  where we came under
// now we know both endpoints
// ADD THIS EDGE TO THE LIST OF EDGES THAT NEED NEIGHBOR ON PARTITION PLANE!!
// do the modulo at the beginning of the loop
// add the new plane to the mix:
// Yuck - this is really ugly
// EPSILON???
//Array<btHullTriangle*> tris;
// simplex failed
// a valid interior point
//	int3 ti=*te;
// wtf we've already done this vertex
//if(v==p0 || v==p1 || v==p2 || v==p3) continue; // done these already
// now check for those degenerate cases where we have a flipped triangle or a really skinny triangle
// already done that vertex - algorithm needs to be able to terminate.
// delete tris[i];
//	float diameter = magnitude(bmax-bmin);
//	inflate *=diameter;   // RELATIVE INFLATION
// VectorMin(bmin,float3(0,0,0));
// VectorMax(bmax,float3(0,0,0));
// todo: add bounding cube planes to force bevel. or try instead not adding the diameter expansion ??? must think.
// ConvexH *convex = ConvexHMakeCube(bmin - float3(diameter,diameter,diameter),bmax+float3(diameter,diameter,diameter));
// might want to debug this case better!!!
// might want to debug this case better too!!!
//return c;
// new int[1+c->facets.count+c->edges.count];
// number of faces.
// new float3[c->vertices.count];
//*********************************************************************
/*********************************************************************
//********  HullLib header
/********  HullLib header
//*********************************************************************
/*********************************************************************
//*********************************************************************
/*********************************************************************
//********  HullLib implementation
/********  HullLib implementation
//*********************************************************************
/*********************************************************************
// describes the input request
// contains the resulst
// normalize point cloud, remove duplicates!
// scale vertices back to their original size.
// re-index triangle mesh so it refers to only used vertices, rebuild a new vertex table.
// if he wants the results as triangle!
// release memory allocated for this result, we are done with it.
// output number of vertices
// location to store the results.
/* close enough to consider two floating point numbers to be 'the same'. */
// one centimeter
// 1/5th the shortest non-zero edge.
// return cube
// normalize
// normalize
// normalize
// ok, it is close enough to the old one
// now let us see if it is further from the center of the point cloud than the one we already recorded.
// in which case we keep this one instead.
// ok..now make sure we didn't prune so many vertices it is now invalid.
// one centimeter
// 1/5th the shortest non-zero edge.
// add box
// original array index
// if already remapped
// index to new array
// new index mapping
// copy old vert to new vert array
// increment output vert count
// assign new index remapping
// namespace ConvexDecomposition
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\cd_wavefront.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
/*----------------------------------------------------------------------
/*******************************************************************/
/******************** InParser.h  ********************************/
/*******************************************************************/
// return TRUE to continue parsing, return FALSE to abort parsing process
// is data
// is a hard separator
// is a soft separator
// is a comment symbol, and everything past this character should be ignored
// use this file as source data to parse.
// returns true if entire file was parsed, false if it aborted for some reason
// convert source string into an arg list, this is a destructive parse.
// add a hard separator
// add a hard separator
// comment character, treated as 'end of string'
// set up default symbols for hard seperator and comment symbol of the '#' character.
// non seperator,neither hard nor soft
// whether or not *I* allocated the buffer and am responsible for deleting it.
// ascii data to parse.
// length of data
/*******************************************************************/
/******************** InParser.cpp  ********************************/
/*******************************************************************/
// zero byte terminate end of file marker.
// skip any leading spaces
// if it is an open quote
// replace close quote with zero byte EOS
// add any hard separators, skip any spaces
// add non-hard argument.
// continue..until we hit an eos ..
// until we hit EOS
// if we hit a space, stomp a zero byte, and exit
// if we hit a hard separator, stomp a zero byte and store the hard separator argument
// end of while loop...
// returns true if entire file was parsed, false if it aborted for some reason
// if there is any data to parse at all...
// skip line feed, if it is in the carraige-return line-feed format...
// lasst line.
// convert source string into an arg list, this is a destructive parse.
// skip any leading spaces
// if it is an open quote
// replace close quote with zero byte EOS
// add any hard separators, skip any spaces
// add non-hard argument.
// continue..until we hit an eos ..
// until we hit EOS
// if we hit a space, stomp a zero byte, and exit
// if we hit a hard separator, stomp a zero byte and store the hard separator argument
// end of while loop...
/*******************************************************************/
/******************** Geometry.h  ********************************/
/*******************************************************************/
/*******************************************************************/
/******************** Obj.h  ********************************/
/*******************************************************************/
// return TRUE to continue parsing, return FALSE to abort parsing process
/*******************************************************************/
/******************** Obj.cpp  ********************************/
/*******************************************************************/
//static const char * GetArg(const char **argv,int i,int argc)
//{
// const char * ret = 0;
// if ( i < argc ) ret = argv[i];
// return ret;
//}
// return TRUE to continue parsing, return FALSE to abort parsing process
//if ( stricmp(argv[0],"v") == 0 && argc == 4 )
//     else if ( stricmp(argv[0],"vt") == 0 && argc == 3 )
//  else if ( stricmp(argv[0],"vn") == 0 && argc == 4 )
//  else if ( stricmp(argv[0],"f") == 0 && argc >= 4 )
// need to generate a normal!
// not currently implemented
// do the fan
//New MS STL library checks indices in debug build, so zero causes an assert if it is empty.
// load a wavefront obj returns number of triangles that were loaded.  Data is persists until the class is destructed.
// namespace ConvexDecomposition
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\concavity.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// clip this line segment against this triangle.
// return the intersection distance.
// already been added...
//gLog->Display("*********** FEATURE MATCH *************\r\n");
//gLog->Display("Plane: %0.4f,%0.4f,%0.4f   %0.4f\r\n", m.mNormal.x, m.mNormal.y, m.mNormal.z, m.mPlaneD );
//gLog->Display("*********************************************\r\n");
//gLog->Display("   HullPlane: %0.4f,%0.4f,%0.4f   %0.4f\r\n", t.mNormal.x, t.mNormal.y, t.mNormal.z, t.mPlaneD );
//gLog->Display("*** PLANE MATCH!!!\r\n");
// can't be near coplaner!
//gLog->Display("*********************************************\r\n");
//gLog->Display("   HullPlaneNearest: %0.4f,%0.4f,%0.4f   %0.4f\r\n", nearest.mNormal.x, nearest.mNormal.y, nearest.mNormal.z, nearest.mPlaneD );
//gLog->Display("No match\r\n");
//gLog->Display("*********************************************\r\n");
// if not already processed
// must be within 80% of the concavity of the parent.
// see if this triangle is a 'feature' triangle.  Meaning it shares an
// edge with any existing feature triangle and is within roughly the same
// concavity of the parent.
// it is now part of a feature.
// add it to the feature list.
//					  callback->ConvexDebugTri( t.mP1.Ptr(), t.mP2.Ptr(),t.mP3.Ptr(), color );
// add it to the feature list.
//				callback->ConvexDebugTri( t.mP1.Ptr(), t.mP2.Ptr(),t.mP3.Ptr(), color );
// eliminated for this feature, but might be valid for the next one..
// plane equation to split on
// ok..now..for each triangle on the original mesh..
// we extrude the points to the nearest point on the hull.
//			callback->ConvexDebugTri(p1,p2,p3,0xFFFFFF);
//
// we have not pre-computed the plane equation for each triangle in the convex hull..
// 'feature' triangles.
// ok..now we extract the triangles which form the maximum concavity.
//
// namespace ConvexDecomposition
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\ConvexBuilder.cpp
// inflate 1/10th on each edge
// inflate 1/10th on each edge
// inflate 1/10th on each edge
// if their AABB's (with a little slop) don't overlap, then return.
// ok..we are going to combine both meshes into a single mesh
// and then we are going to compute the concavity...
//don't do anything if hull is empty
// sort the convex hulls, largest volume to least...
// the output hulls...
// don't try to merge a hull with itself, that be stoopid
// if we can merge these two....
// keep combinging hulls until I can't combine any more...
// before we hand it back to the application, we need to regenerate the hull based on the
// limits given by the user.
// the high resolution hull...
// maximum number of vertices allowed in the output
// do skin width computation.
// the volume of the hull.
// compute the best fit OBB
// compute the OBB volume.
// get the translation component of the 4x4 matrix.
// extract the orientation as a quaternion.
//hulls.heapSort(CHullSort());
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\ConvexDecomposition.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// do *not* process degenerate triangles!
// if great than 5% of the total volume is concave, go ahead and keep splitting.
// ok..now we are going to 'split' all of the input triangles against this plane!
// ok... here we recursively call
// namespace ConvexDecomposition
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\fitsphere.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
/*
/* Routine to calculate tight bounding sphere over    */
/* a set of points in 3D */
/* This contains the routine find_bounding_sphere(), */
/* the struct definition, and the globals used for parameters. */
/* The abs() of all coordinates must be < BIGNUMBER */
/* Code written by Jack Ritter and Lyle Rains. */
/* hundred million */
/* FIRST PASS: find 6 minima/maxima points */
/* New xminimum point */
/* Set xspan = distance between the 2 points xmin & xmax (squared) */
/* Same for y & z spans */
/* Set points dia1 & dia2 to the maximally separated pair */
/* assume xspan biggest */
/* dia1,dia2 is a diameter of initial sphere */
/* calc initial center */
/* calculate initial radius**2 and radius */
/* x component of radius vector */
/* y component of radius vector */
/* z component of radius vector */
/* SECOND PASS: increment current sphere */
/* do r**2 test first */
/* this point is outside of current sphere */
/* calc radius of new sphere */
/* for next r**2 compare */
/* calc center of new sphere */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\float_math.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// inverse rotate translate the point.
// Multiply inverse-translated source vector by inverted rotation transform
// set 4x4 matrix to identity.
// convert euler (in radians) to a dest 4x4 matrix (translation set to zero)
// convert euler angles to quaternion.
// convert quaterinion rotation to matrix, zeros out the translation component.
// rotate a vector directly by a quaternion.
// convert the 3x3 portion of a 4x4 matrix into a quaterion as x,y,z,w
// check the diagonal
// diagonal is negative
// return's the volume of a sphere of this radius (4/3 PI * R cubed )
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\meshvolume.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// compute the volume of the tetrahedran relative to the origin.
// compute the volume of the tetrahdren relative to the root vertice
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\planetri.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// it is 'in front' within the provided epsilon value.
// assumes that the points are on opposite sides of the plane!
// the plane equation in Ax+By+Cz+D format
// the source triangle.
// stride in bytes of the input and output triangles
// the co-planer epsilon value.
// the triangle in front of the
// number of vertices in the 'front' triangle
// the triangle in back of the plane
// the number of vertices in the 'back' triangle.
// get the three vertices of the triangle.
// compute the side of the plane each vertex is on
// if all three vertices are on the same side of the plane.
// if all three are in front of the plane, then copy to the 'front' output triangle.
// if all three are in 'abck' then copy to the 'back' output triangle.
// if all three points are on the same side of the plane return result
// ok.. we need to split the triangle at the plane.
// First test ray segment P1 to P2
// if these are both on the same side...
// split the point
// Next test ray segment P2 to P3
// if these are both on the same side...
// split the point
// Next test ray segment P3 to P1
// if these are both on the same side...
// split the point
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\raytri.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
/* a = b - c */
// at this stage we can compute t to find out where
// the intersection point is on the line
// ray intersection
// this means that there is a line intersection
// but not a ray intersection
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\splitplane.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
//  callback->ConvexDebugBound(b1.mMin,b1.mMax,0x00FF00);
//  callback->ConvexDebugBound(b2.mMin,b2.mMax,0xFFFF00);
//  callback->ConvexDebugTri(p1,p2,p3,0xFF0000);
// namespace ConvexDecomposition
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\ConvexDecomposition\vlookup.cpp
/*----------------------------------------------------------------------
// http://codesuppository.blogspot.com
//
// mailto: jratcliff@infiniplex.net
//
// http://www.amillionpixels.us
//
// CodeSnippet provided by John W. Ratcliff
// on March 23, 2006.
//
// mailto: jratcliff@infiniplex.net
//
// Personal website: http://jratcliffscarab.blogspot.com
// Coding Website:   http://codesuppository.blogspot.com
// FundRaising Blog: http://amillionpixels.blogspot.com
// Fundraising site: http://www.amillionpixels.us
// New Temple Site:  http://newtemple.blogspot.com
//
// This snippet shows how to 'hide' the complexity of
// the STL by wrapping some useful piece of functionality
// around a handful of discrete API calls.
//
// This API allows you to create an indexed triangle list
// from a collection of raw input triangles.  Internally
// it uses an STL set to build the lookup table very rapidly.
//
// Here is how you would use it to build an indexed triangle
// list from a raw list of triangles.
//
// (1) create a 'VertexLookup' interface by calling
//
//     VertexLook vl = Vl_createVertexLookup();
//
// (2) For each vertice in each triangle call:
//
//     unsigned int i1 = Vl_getIndex(vl,p1);
//     unsigned int i2 = Vl_getIndex(vl,p2);
//     unsigned int i3 = Vl_getIndex(vl,p3);
//
//     save the 3 indices into your triangle list array.
//
// (3) Get the vertex array by calling:
//
//     const float *vertices = Vl_getVertices(vl);
//
// (4) Get the number of vertices so you can copy them into
//     your own buffer.
//     unsigned int vcount = Vl_getVcount(vl);
//
// (5) Release the VertexLookup interface when you are done with it.
//     Vl_releaseVertexLookup(vl);
//
// Teaches the following lessons:
//
//    How to wrap the complexity of STL and C++ classes around a
//    simple API interface.
//
//    How to use an STL set and custom comparator operator for
//    a complex data type.
//
//    How to create a template class.
//
//    How to achieve significant performance improvements by
//    taking advantage of built in STL containers in just
//    a few lines of code.
//
//    You could easily modify this code to support other vertex
//    formats with any number of interpolants.
// vertice to locate.
// clear the vertice pool.
// ordered list.
// set of vertices.
// namespace Vlookup
// get index.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\Extras\GIMPACTUtils\btGImpactConvexDecompositionShape.cpp
/*
//gimpact.sourceforge.net/
//calc centroid, to shift vertices around center of mass
//const unsigned int *src = result.mHullIndices;
// collect vertices
// build convex shape
// add convex shape
//trans.setOrigin(centroid);
// add convex shape
//m_compoundShape->addChildShape(convexShape);
//collect vertices
//collect indices
//convexDecomposition.performConvexDecomposition(desc);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\Bullet3Common\b3AlignedAllocator.cpp
/*
//bulletphysics.org
//detect memory leaks
//this generic allocator provides the total allocated number of bytes
//??
//B3_DEBUG_MEMORY_ALLOCATIONS
//	b3Printf("b3AlignedAllocInternal %d, %x\n",size,ptr);
//	b3Printf("b3AlignedFreeInternal %x\n",ptr);
//B3_DEBUG_MEMORY_ALLOCATIONS
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\Bullet3Common\b3Logging.cpp
/*
//Originally written by Erwin Coumans
//_WIN32
//is this portable?
//is this portable?
//is this portable?
///The developer can route b3Printf output using their own implementation
//#define B3_MAX_DEBUG_STRING_LENGTH 2048
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\Bullet3Common\b3Vector3.cpp
/*
//typedef  uint32_t uint4 __attribute__ ((vector_size(16)));
/// zzzz
/// xyxy
// memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
// Faster loop without cleanup code for full tiles
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
// If we found a new max
// copy the new max across all lanes of our max accumulator
// find first occurrence of that max
// local_count must be a multiple of 4
// record where it is.
// account for work we've already done
// Deal with the last < STACK_ARRAY_COUNT vectors
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
// counter the offset
//AT&T Code style assembly
// move max out of the way to avoid propagating NaNs in max \n\
// vertices[0]      \n\
// vertices[1]      \n\
// vertices[0]      \n\
// x0y0x1y1         \n\
// vertices[2]      \n\
// vertices[3]      \n\
// x0y0x1y1 * vLo   \n\
// z0w0z1w1         \n\
// vertices[2]      \n\
// x2y2x3y3         \n\
// x2y2x3y3 * vLo   \n\
// z2w2z3w3         \n\
// z0z1z2z3         \n\
// z0z1z2z3 * vHi   \n\
// x0y0x1y1 * vLo   \n\
// x0x1x2x3 * vLo.x \n\
// y0y1y2y3 * vLo.y \n\
// x + y            \n\
// x + y + z        \n\
// record result for later scrutiny \n\
// record max, restore max   \n\
// advance loop counter\n\
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
//__APPLE__
// process the last few points
// Calculate 3 dot products, transpose, duplicate v2
// xyxy.lo
// z?z?.lo
// z0z1z2z2
// xyxy
// control the order here so that max is never NaN even if x is nan
// if we found a new max.
// we found a new max. Search for it
// find max across the max vector, place in all elements of max -- big latency hit here
// It is slightly faster to do this part in scalar code when count < 8. However, the common case for
// this where it actually makes a difference is handled in the early out at the top of the function,
// so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
// complexity, and removed it.
// scan for the first occurence of max in the array
// local_count must be a multiple of 4
/// zzzz
/// xyxy
// memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
// Faster loop without cleanup code for full tiles
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
// If we found a new min
// copy the new min across all lanes of our min accumulator
// find first occurrence of that min
// local_count must be a multiple of 4
// record where it is.
// account for work we've already done
// Deal with the last < STACK_ARRAY_COUNT vectors
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
// counter the offset
// move min out of the way to avoid propagating NaNs in min \n\
// vertices[0]      \n\
// vertices[1]      \n\
// vertices[0]      \n\
// x0y0x1y1         \n\
// vertices[2]      \n\
// vertices[3]      \n\
// x0y0x1y1 * vLo   \n\
// z0w0z1w1         \n\
// vertices[2]      \n\
// x2y2x3y3         \n\
// z2w2z3w3         \n\
// x2y2x3y3 * vLo   \n\
// z0z1z2z3         \n\
// z0z1z2z3 * vHi   \n\
// x0y0x1y1 * vLo   \n\
// x0x1x2x3 * vLo.x \n\
// y0y1y2y3 * vLo.y \n\
// x + y            \n\
// x + y + z        \n\
// record result for later scrutiny \n\
// record min, restore min   \n\
// advance loop counter\n\
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// process the last few points
// Calculate 3 dot products, transpose, duplicate v2
// xyxy.lo
// z?z?.lo
// z0z1z2z2
// xyxy
// control the order here so that min is never NaN even if x is nan
// if we found a new min.
// we found a new min. Search for it
// find min across the min vector, place in all elements of min -- big latency hit here
// It is slightly faster to do this part in scalar code when count < 8. However, the common case for
// this where it actually makes a difference is handled in the early out at the top of the function,
// so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
// complexity, and removed it.
// scan for the first occurence of min in the array
// local_count must be a multiple of 4
/*return*/ _r; })
// select best answer between hi and lo results
// select best answer between even and odd results
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// select best answer between hi and lo results
// select best answer between even and odd results
// select best answer between hi and lo results
// select best answer between even and odd results
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// select best answer between hi and lo results
// select best answer between even and odd results
/* __APPLE__ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btAxisSweep3.cpp
//Bullet Continuous Collision Detection and Physics Library
//Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/
//
// btAxisSweep3
//
// Copyright (c) 2006 Simon Hobbs
//
// This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
// 1 handle is reserved as sentinel
// 1 handle is reserved as sentinel
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btBroadphaseProxy.cpp
/*
//continuousphysics.com/Bullet/
// fix warning LNK4221: This object file does not define any previously undefined public symbols, so it will not be used by any link operation that consumes this library
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btDbvt.cpp
/*
//continuousphysics.com/Bullet/
///btDbvt implementation by Nathanael Presson
//
//
//
//
// volume+edge lengths
//
//
//
//
//
//
//
//
//
//
// Partitions leaves such that leaves[0, n) are on the
// left of axis, and leaves[n, count) are on the right
// of axis. returns N.
// swap out of place nodes
//
//
//
//
//
// Api
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/*
//[1] btDbvtVolume intersections
//[2] btDbvtVolume merges
//[3] btDbvt::collideTT
//[4] btDbvt::collideTT self
//[5] btDbvt::collideTT xform
//[6] btDbvt::collideTT xform,self
//[7] btDbvt::rayTest
//[8] insert/remove
//[9] updates (teleport)
//[10] updates (jitter)
//[11] optimize (incremental)
//[12] btDbvtVolume notequal
//[13] culling(OCL+fullsort)
//[14] culling(OCL+qsort)
//[15] culling(KDOP+qsort)
//[16] insert/remove batch
//[17] select
// Benchmark 1
// Benchmark 2
// Benchmark 3
// Benchmark 4
// Benchmark 5
// Benchmark 6
// Benchmark 7
// Benchmark 8
// Benchmark 9
// Benchmark 10
// Benchmark 11
// Benchmark 12
// Benchmark 13
// Benchmark 14
// Benchmark 15
// Benchmark 16
// Benchmark 17
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btDbvtBroadphase.cpp
/*
//bulletphysics.org
///btDbvtBroadphase implementation by Nathanael Presson
//
// Profiling
//
//
// Helpers
//
//
//
//
//
//
// Colliders
//
/* Tree collider	*/
//
// btDbvtBroadphase
//
//
//
//
/*shapeType*/,
/*dispatcher*/)
//bproxy->aabb			=	btDbvtVolume::FromMM(aabbMin,aabbMax);
//
// for this function to be threadsafe, each thread must have a separate copy
// of this stack.  This could be thread-local static to avoid dynamic allocations,
// instead of just a local.
//todo(erwincoumans, "why do we get tsan issue here?")
//threadIndex < m_rayTestStacks.size())
//if (threadIndex < m_rayTestStacks.size())
// use per-thread preallocated stack if possible to avoid dynamic allocations
//process all children, that overlap with  the given AABB bounds
//
/*dispatcher*/)
/* fixed -> dynamic set	*/
/* dynamic set				*/
/* Moving				*/
/* Teleporting			*/
//
/*dispatcher*/)
/* fixed -> dynamic set	*/
/* dynamic set				*/
/* Teleporting			*/
//
//perform a sort, to find duplicates and to sort 'invalid' pairs to the end
//important to perform AABB check that is consistent with the broadphase
//remove duplicate
//should have no algorithm
//perform a sort, to sort 'invalid' pairs to the end
//
/*printf("---------------------------------------------------------\n");
/* optimize				*/
/* dynamic -> fixed set	*/
/* collide dynamics		*/
/* clean up				*/
//
//
//
//
//reset internal dynamic tree data structures
//
//
/*{"4096o.10%",4096,10,0,8192,(btScalar)0.005,(btScalar)100},
/* Begin			*/
/* Create objects	*/
/* First update		*/
/* Updates			*/
/* Clean up			*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btDispatcher.cpp
/*
//continuousphysics.com/Bullet/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btOverlappingPairCache.cpp
/*
//continuousphysics.com/Bullet/
/*if (proxyId1 > proxyId2)
//#include <stdio.h>
//grow hashtable and next table
/*if (proxyId1 > proxyId2) 
// New hash value with new mask
/*if (proxyId1 > proxyId2) 
// New hash value with new mask
/*for(int i=0;i<m_overlappingPairArray.size();++i)
//this is where we add an actual pair, so also call the 'ghost'
//hash with new capacity
//	pair->m_pProxy0 = proxy0;
//	pair->m_pProxy1 = proxy1;
/*if (proxyId1 > proxyId2)
// Remove the pair from the hash table.
// We now move the last pair into spot of the
// pair being removed. We need to fix the hash
// table indices to support the move.
// If the removed pair is the last pair, we are done.
// Remove the last pair from the hash table.
/* missing swap here too, Nat. */
// Copy the last pair into the remove pair's spot.
// Insert the last pair into the hash table
//#include <stdio.h>
//	printf("m_overlappingPairArray.size()=%d\n",m_overlappingPairArray.size());
///need to keep hashmap in sync with pair address, so rebuild all
//don't add overlap with own
///this findPair becomes really slow. Either sort the list to speedup the query, or
///use a different solution. It is mainly used for Removing overlapping pairs. Removal could be delayed.
///we could keep a linked list in each proxy, and store pair in one of the proxies (with lowest memory address)
///Also we can use a 2D bitmap, which can be useful for a future GPU implementation
//btAssert(it != m_overlappingPairSet.end());
//#include <stdio.h>
//should already be sorted
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btQuantizedBvh.cpp
/*
//continuousphysics.com/Bullet/
//m_traversalMode(TRAVERSAL_STACKLESS_CACHE_FRIENDLY)
//m_traversalMode(TRAVERSAL_RECURSIVE)
//PCK: add this line
///assumes that caller filled in the m_quantizedLeafNodes
//now we have an array of leafnodes in m_leafNodes
///if the entire tree is small then subtree size, we need to create a header info for the tree
//PCK: update the copy of the size
//PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
///just for debugging, to visualize the individual patches/subtrees
//DEBUG_PATCH_COLORS
//enlarge the AABB to avoid division by zero when initializing the quantization values
//DEBUG_TREE_BUILDING
//DEBUG_TREE_BUILDING
//DEBUG_TREE_BUILDING
//calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.
//set the min aabb to 'inf' or a max value, and set the max aabb to a -inf/minimum value.
//the aabb will be expanded during buildTree/mergeInternalNodeAabb with actual node values
//can't use btVector3(SIMD_INFINITY,SIMD_INFINITY,SIMD_INFINITY)) because of quantization
//can't use btVector3(-SIMD_INFINITY,-SIMD_INFINITY,-SIMD_INFINITY)) because of quantization
//internalNode->m_escapeIndex;
//build left child tree
//build right child tree
//DEBUG_TREE_BUILDING
//escapeIndex is the number of nodes of this subtree
//PCK: update the copy of the size
//sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
//swap
//if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
//otherwise the tree-building might fail due to stack-overflows in certain cases.
//unbalanced1 is unsafe: it can cause stack overflows
//bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));
//unbalanced2 should work too: always use center (perfect balanced trees)
//bool unbalanced2 = true;
//this should be safe too:
//either choose recursive traversal (walkTree) or stackless (walkStacklessTree)
///quantize query AABB
//unsupported
//PCK: unsigned instead of bool
//catch bugs in tree data
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
/*
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
//process left and right children
//PCK: unsigned instead of bool
/* Quick pruning by quantized box */
/* Add box cast extents to bounding box */
///what about division by zero? --> just set rayDirection[i] to 1.0
//catch bugs in tree data
/* Add box cast extents */
//perhaps profile if it is worth doing the aabbOverlap test first
///careful with this check: need to check division by zero (above) and fix the unQuantize method
///thanks Joerg/hiker for the reproduction case!
///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
///what about division by zero? --> just set rayDirection[i] to 1.0
/* Quick pruning by quantized box */
/* Add box cast extents to bounding box */
//#define VISUALLY_ANALYZE_BVH 1
//some code snippet to debugDraw aabb, to visually analyze bvh structure
//need some global access to a debugDrawer
//VISUALLY_ANALYZE_BVH
//catch bugs in tree data
//PCK: unsigned instead of bool
// only interested if this is closer than any previous hit
/* Add box cast extents */
///careful with this check: need to check division by zero (above) and fix the unQuantize method
///thanks Joerg/hiker for the reproduction case!
///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858
//BT_PROFILE("btRayAabb2");
//btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
//#define VISUALLY_ANALYZE_BVH 1
//some code snippet to debugDraw aabb, to visually analyze bvh structure
//need some global access to a debugDrawer
//VISUALLY_ANALYZE_BVH
//catch bugs in tree data
//PCK: unsigned instead of bool
//PCK: unsigned instead of bool
//This traversal can be called from Playstation 3 SPU
//PCK: unsigned instead of bool
//always use stackless
/*
//recursive traversal
//PCK: include
//PCK: consts
// I changed this to 0 since the extra padding is not needed or used.
//BVH_ALIGNMENT_BLOCKS * BVH_ALIGNMENT;
/*i_dataBufferSize */, bool i_swapEndian) const
/*	if (i_dataBufferSize < calculateSerializeBufferSize() || o_alignedDataBuffer == NULL || (((unsigned)o_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
///check alignedment for buffer?
// construct the class so the virtual function table, etc will be set up
// Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
// this clears the pointer in the member variable it doesn't really do anything to the data
// it does call the destructor on the contained objects, but they are all classes with no destructor defined
// so the memory (which is not freed) is left alone
// this clears the pointer in the member variable it doesn't really do anything to the data
// it does call the destructor on the contained objects, but they are all classes with no destructor defined
// so the memory (which is not freed) is left alone
//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
// Now serialize the subtree headers
// need to clear padding in destination buffer
// this clears the pointer in the member variable it doesn't really do anything to the data
// it does call the destructor on the contained objects, but they are all classes with no destructor defined
// so the memory (which is not freed) is left alone
// this wipes the virtual function table pointer at the start of the buffer for the class
// || (((unsigned)i_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
// Must call placement new to fill in virtual function table, etc, but we don't want to overwrite most data, so call a special version of the constructor
// Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
//(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
// Now serialize the subtree headers
// Constructor that prevents btVector3's default constructor from being called
/* ownsMemory */) : m_bvhAabbMin(self.m_bvhAabbMin),
///fills the dataBuffer and returns the struct name (and 0 on failure)
// Fill padding with zeros to appease msan.
//	printf("quantizedData->m_numQuantizedContiguousNodes=%d\n",quantizedData->m_numQuantizedContiguousNodes);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\BroadphaseCollision\btSimpleBroadphase.cpp
/*
//continuousphysics.com/Bullet/
// allocate handles buffer and put all handles on free list
//any UID will do, we just avoid too trivial values (0,1) for debugging purposes
/*dispatcher*/)
//should never happen, but don't let the game crash ;-)
//validate();
/*dispatcher*/)
//then remove non-overlapping ones
//first check for new overlapping pairs
//perform a sort, to find duplicates and to sort 'invalid' pairs to the end
//callback->processOverlap(pair);
//remove duplicate
//should have no algorithm
//		m_overlappingPairArray.swap(i,m_overlappingPairArray.size()-1);
//		m_overlappingPairArray.pop_back();
///if you don't like to skip the invalid pairs in the array, execute following code:
//perform a sort, to sort 'invalid' pairs to the end
//CLEAN_INVALID_PAIRS
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btActivatingCollisionAlgorithm.cpp
/*
//bulletphysics.com
//,
//m_colObj0(0),
//m_colObj1(0)
//,
//m_colObj0(0),
//m_colObj1(0)
//	if (ci.m_dispatcher1->needsCollision(colObj0,colObj1))
//	{
//		m_colObj0 = colObj0;
//		m_colObj1 = colObj1;
//
//		m_colObj0->activate();
//		m_colObj1->activate();
//	}
//		m_colObj0->activate();
//		m_colObj1->activate();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btBox2dBox2dCollisionAlgorithm.cpp
/*
//www.gphysics.com
///btBox2dBox2dCollisionAlgorithm, with modified b2CollidePolygons routines from the Box2D library.
///The modifications include: switching from b2Vec to btVector3, redefinition of b2Dot, b2Cross
//#include <stdio.h>
//  refreshContactPoints is only necessary when using persistent contact points. otherwise all points are newly added
/*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
//not yet
//b2ContactID id;
//b2ContactID id;
// Start with no output points
// Calculate the distance of end points to the line
// If the points are behind the plane
// If the points are on different sides of the plane
// Find intersection point of edge and plane
// Find the separation between poly1 and poly2 for a give edge normal on poly1.
// Convert normal from poly1's frame into poly2's frame.
// Find support vertex on poly2 for -normal.
// Find the max separation between poly1 and poly2 using edge normals from poly1.
// Vector pointing from the centroid of poly1 to the centroid of poly2.
// Find edge normal on poly1 that has the largest projection onto d.
// Get the separation for the edge normal.
// Check the separation for the previous edge normal.
// Check the separation for the next edge normal.
// Find the best edge and the search direction.
// Perform a local search for the best edge normal.
// Get the normal of the reference edge in poly2's frame.
// Find the incident edge on poly2.
// Build the clip vertices for the incident edge.
//	c[0].id.features.referenceEdge = (unsigned char)edge1;
//	c[0].id.features.incidentEdge = (unsigned char)i1;
//	c[0].id.features.incidentVertex = 0;
//	c[1].id.features.referenceEdge = (unsigned char)edge1;
//	c[1].id.features.incidentEdge = (unsigned char)i2;
//	c[1].id.features.incidentVertex = 1;
// Find edge normal of max separation on A - return if separating axis is found
// Find edge normal of max separation on B - return if separation axis is found
// Choose reference edge as min(minA, minB)
// Find incident edge
// Clip
// The normal points from 1 to 2
// reference poly
// incident poly
// reference edge
// TODO_ERIN use "radius" of poly for absolute tolerance.
//btVector3 dv = v12 - v11;
// Clip incident edge against extruded edge1 side edges.
// Clip to box side 1
// Clip to negative box side 1
// Now clipPoints2 contains the clipped points.
//b2ManifoldPoint* cp = manifold->points + pointCount;
//btScalar separation = separation;
//cp->localPoint1 = b2MulT(xfA, clipPoints2[i].v);
//cp->localPoint2 = b2MulT(xfB, clipPoints2[i].v);
//			cp->id = clipPoints2[i].id;
//			cp->id.features.flip = flip;
//	manifold->pointCount = pointCount;}
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btBoxBoxCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
/// report a contact. internally this will be kept persistent, and contact reduction is done
//USE_PERSISTENT_CONTACTS
//  refreshContactPoints is only necessary when using persistent contact points. otherwise all points are newly added
//USE_PERSISTENT_CONTACTS
/*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btBoxBoxDetector.cpp
/*
//continuousphysics.com/Bullet/
///ODE box-box collision detection is adapted to work with Bullet
// given two boxes (p1,R1,side1) and (p2,R2,side2), collide them together and
// generate contact points. this returns 0 if there is no contact otherwise
// it returns the number of contacts generated.
// `normal' returns the contact normal.
// `depth' returns the maximum penetration depth along that normal.
// `return_code' returns a number indicating the type of contact that was
// detected:
//        1,2,3 = box 2 intersects with a face of box 1
//        4,5,6 = box 1 intersects with a face of box 2
//        7..15 = edge-edge contact
// `maxc' is the maximum number of contacts allowed to be generated, i.e.
// the size of the `contact' array.
// `contact' and `skip' are the contact array information provided to the
// collision functions. this function only fills in the position and depth
// fields.
/*PURE_INLINE btScalar dDOT   (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,1,1); }
// @@@ this needs to be made more robust
// find all the intersection points between the 2D rectangle with vertices
// at (+/-h[0],+/-h[1]) and the 2D quadrilateral with vertices (p[0],p[1]),
// (p[2],p[3]),(p[4],p[5]),(p[6],p[7]).
//
// the intersection points are returned as x,y pairs in the 'ret' array.
// the number of intersection points is returned by the function (this will
// be in the range 0 to 8).
// q (and r) contain nq (and nr) coordinate points for the current (and
// chopped) polygons
// direction notation: xy[0] = x axis, xy[1] = y axis
// chop q along the line xy[dir] = sign*h[dir]
// go through all points in q and all lines between adjacent points
// this point is inside the chopping line
// this line crosses the chopping line
// given n points in the plane (array p, of size 2*n), generate m points that
// best represent the whole set. the definition of 'best' here is not
// predetermined - the idea is to select points that give good box-box
// collision detection behavior. the chosen point indexes are returned in the
// array iret (of size m). 'i0' is always the first entry in the array.
// n must be in the range [1..8]. m must be in the range [1..n]. i0 must be
// in the range [0..n-1].
// compute the centroid of the polygon in cx,cy
// compute the angle of each point w.r.t. the centroid
// search for points that have angles closest to A[i0] + i*(2*pi/m).
// iret is not allowed to keep this value, but it sometimes does, when diff=#QNAN0
// ensure iret got set
/*contact*/, int /*skip*/, btDiscreteCollisionDetectorInterface::Result& output);
/*contact*/, int /*skip*/, btDiscreteCollisionDetectorInterface::Result& output)
// get vector from centers of box 1 to box 2, relative to box 1
// get pp = p relative to body 1
// get side lengths / 2
// Rij is R1'*R2, i.e. the relative rotation between R1 and R2
// for all 15 possible separating axes:
//   * see if the axis separates the boxes. if so, return 0.
//   * find the depth of the penetration along the separating axis (s2)
//   * if this is the largest depth so far, record it.
// the normal vector will be set to the separating axis with the smallest
// depth. note: normalR is set to point to a column of R1 or R2 if that is
// the smallest depth normal so far. otherwise normalR is 0 and normalC is
// set to a vector relative to body 1. invert_normal is 1 if the sign of
// the normal should be flipped.
// separating axis = u1,u2,u3
// separating axis = v1,v2,v3
// note: cross product axes need to be scaled when s is computed.
// normal (n1,n2,n3) is relative to box 1.
// separating axis = u1 x (v1,v2,v3)
// separating axis = u2 x (v1,v2,v3)
// separating axis = u3 x (v1,v2,v3)
// if we get to this point, the boxes interpenetrate. compute the normal
// in global coordinates.
// compute contact point(s)
// an edge from box 1 touches an edge from box 2.
// find a point pa on the intersecting edge of box 1
// find a point pb on the intersecting edge of box 2
//contact[0].pos[i] = btScalar(0.5)*(pa[i]+pb[i]);
//contact[0].depth = *depth;
//
// okay, we have a face-something intersection (because the separating
// axis is perpendicular to a face). define face 'a' to be the reference
// face (i.e. the normal vector is perpendicular to this) and face 'b' to be
// the incident face (the closest face of the other box).
// nr = normal vector of reference face dotted with axes of incident box.
// anr = absolute values of nr.
// find the largest compontent of anr: this corresponds to the normal
// for the indident face. the other axis numbers of the indicent face
// are stored in a1,a2.
// compute center point of incident face, in reference-face coordinates
// find the normal and non-normal axis numbers of the reference box
// find the four corners of the incident face, in reference-face coordinates
// 2D coordinate of incident face (x,y pairs)
// optimize this? - we have already computed this data above, but it is not
// stored in an easy-to-index format. for now it's quicker just to recompute
// the four dot products.
// find the size of the reference face
// intersect the incident and reference faces
// this should never happen
// convert the intersection points into reference-face coordinates,
// and compute the contact position and depth for each point. only keep
// those points that have a positive (penetrating) depth. delete points in
// the 'ret' array as necessary so that 'point' and 'ret' correspond.
// penetrating contact points
// depths for those points
// number of penetrating contact points found
// this should never happen
// we can't generate more contacts than we actually have
// we have less contacts than we need, so we use them all
// we have less contacts than we need, so we use them all
//pointInWorld[i] = point[j*3+i] + pa[i];
// we have more contacts than are wanted, some of them must be culled.
// find the deepest point, it is always the first contact.
//      dContactGeom *con = CONTACT(contact,skip*j);
//    for (i=0; i<3; i++) con->pos[i] = point[iret[j]*3+i] + pa[i];
//  con->depth = dep[iret[j]];
/*debugDraw*/, bool /*swapResults*/)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCollisionDispatcher.cpp
/*
//continuousphysics.com/Bullet/
//btAssert(gNumManifold < 65535);
//optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)
//we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
//make sure to increase the m_defaultMaxPersistentManifoldPoolSize in the btDefaultCollisionConstructionInfo/btDefaultCollisionConfiguration
//printf("releaseManifold: gNumManifold %d\n",gNumManifold);
//here you can do filtering
//no response between two static/kinematic bodies:
//broadphase filtering already deals with this
//BT_DEBUG
///interface for iterating all overlapping collision pairs, no matter how those pairs are stored (array, set, map etc)
///this is useful for the collision dispatcher.
/*btCollisionPairCallback& operator=(btCollisionPairCallback& other)
//m_blockedForChanges = true;
//m_blockedForChanges = false;
//by default, Bullet will use this near callback
//dispatcher will keep algorithms persistent in the collision pair
//discrete collision detection query
//continuous collision detection query, time of impact (toi)
//warn user for overflow?
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCollisionDispatcherMt.cpp
/*
//continuousphysics.com/Bullet/
// iterations per task
//optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)
//we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
//make sure to increase the m_defaultMaxPersistentManifoldPoolSize in the btDefaultCollisionConstructionInfo/btDefaultCollisionConfiguration
// batch updater will update manifold pointers array after finishing, so
// only need to update array when not batch-updating
//btAssert( !btThreadsAreRunning() );
//btAssert( !btThreadsAreRunning() );
// batch updater will update manifold pointers array after finishing, so
// only need to update array when not batch-updating
// reconstruct the manifolds array to ensure determinism
// update the indices (used when releasing manifolds)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCollisionObject.cpp
/*
//continuousphysics.com/Bullet/
//@todo
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCollisionWorld.cpp
/*
//continuousphysics.com/Bullet/
//for raycasting
//for raycasting
//for raycasting
//#define DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
//#define USE_BRUTEFORCE_RAYBROADPHASE 1
//RECALCULATE_AABB is slower, but benefit is that you don't need to call 'stepSimulation'  or 'updateAabbs' before using a rayTest
//#define RECALCULATE_AABB_RAYCAST 1
//When the user doesn't provide dispatcher or broadphase, create basic versions (and delete them in destructor)
///for debug drawing
//for debug rendering
//clean up remaining objects
//
// only clear the cached algorithms
//
//calculate new AABB
//check that the object isn't already added
// do not add the same object to more than one collision world
//calculate new AABB
//need to increase the aabb for contact thresholds
//moving objects should be moderately sized, probably something wrong if not
//something went wrong, investigate
//this assert is unwanted in 3D modelers (danger of loosing work)
//only update aabb of active objects
//bool removeFromBroadphase = false;
//
// only clear the cached algorithms
//
//    btAssert(iObj >= 0 && iObj < m_collisionObjects.size()); // trying to remove an object that was never added or already removed previously?
// slow linear search
//swapremove
//		BT_PROFILE("rayTestConvex");
//btContinuousConvexCollision convexCaster(castShape,convexShape,&simplexSolver,0);
//use kF_UseSubSimplexConvexCastRaytest by default
//add hit
//todo: figure out what this is about. When is rayFromTest.getBasis() not identity?
//rotate normal into worldspace
//USE_SUBSIMPLEX_CONVEX_CAST
//ConvexCast::CastResult
//@BP Mod
//			BT_PROFILE("rayTestConcave");
///optimized version for btBvhTriangleMeshShape
///optimized version for btScaledBvhTriangleMeshShape
//scale the ray positions
//perform raycast in the underlying btBvhTriangleMeshShape
//generic (slower) case
//ConvexCast::CastResult
//@BP Mod
//			BT_PROFILE("rayTestCompound");
// replace collision shape so that callback can determine the triangle
//DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
//BT_PROFILE("convexSweepConvex");
//btScalar(1.);//??
//btGjkConvexCast convexCaster2(castShape,convexShape,&simplexSolver);
//btSubsimplexConvexCast convexCaster3(castShape,convexShape,&simplexSolver);
//add hit
//BT_PROFILE("convexSweepbtBvhTriangleMesh");
// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
//ConvexCast::CastResult
//add hit
//BT_PROFILE("convexSweepConcave");
// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
//ConvexCast::CastResult
// Processing leaf node
///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
///terminate further ray tests, once the closestHitFraction reached zero
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
//btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
//getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
//btScalar hitLambda = m_resultCallback.m_closestHitFraction;
//culling already done by broadphase
//if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
//BT_PROFILE("rayTest");
/// use the broadphase to accelerate the search for objects, based on their aabb
/// and for each object with ray-aabb overlap, perform an exact ray test
//USE_BRUTEFORCE_RAYBROADPHASE
///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
///terminate further convex sweep tests, once the closestHitFraction reached zero
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
/// use the broadphase to accelerate the search for objects, based on their aabb
/// and for each object with ray-aabb overlap, perform an exact ray test
/// unfortunately the implementation for rayTest and convexSweepTest duplicated, albeit practically identical
/* Compute AABB that encompasses angular movement */
/// go over all objects, and if the ray intersects their aabb + cast shape aabb,
// do a ray-shape query using convexCaster (CCD)
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
//could use resultCallback.m_closestHitFraction, but needs testing
//USE_BRUTEFORCE_RAYBROADPHASE
//BP mod, store contact triangles.
//experimental feature info, for per-triangle material etc.
//only perform raycast if filterMask matches
//discrete collision detection query
///contactTest performs a discrete collision test against all objects in the btCollisionWorld, and calls the resultCallback.
///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
///it reports one or more contact points (including the one with deepest penetration)
//discrete collision detection query
// Draw a small simplex at the center of the object
//radius doesn't include the margin, so draw with margin
//+coneShape->getMargin();
//+coneShape->getMargin();
/// for polyhedral shapes
///@todo pass camera, for some culling? no -> we are not a graphics lib
//todo: pass camera for some culling
//DebugDrawcallback drawCallback;
//btCollisionObject* obA = static_cast<btCollisionObject*>(contactManifold->getBody0());
//btCollisionObject* obB = static_cast<btCollisionObject*>(contactManifold->getBody1());
///keep track of shapes already serialized
//serialize all collision objects
//don't serialize empty manifolds, they just take space
//(may have to do it anyway if it destroys determinism)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCollisionWorldImporter.cpp
/*
//bulletphysics.org
//for btBulletSerializedArrays definition
//SUPPORT_GIMPACT_SHAPE_IMPORT
//		printf("shapeMap.insert(%x,%x)\n",shapeData,shape);
//USE_INTERNAL_EDGE_UTILITY
//USE_INTERNAL_EDGE_UTILITY
//SUPPORT_GIMPACT_SHAPE_IMPORT                                                                        \
//The btCapsuleShape* API has issue passing the margin/scaling/halfextents unmodified through the API \
//so deal with this
//box->initializePolyhedralFeatures();
//+margin;
//	int sz = sizeof(btConvexHullShapeData);
//	int sz2 = sizeof(btConvexInternalShapeData);
//	int sz3 = sizeof(btCollisionShapeData);
//BT_USE_DOUBLE_PRECISION
//hullShape->initializePolyhedralFeatures();
//USE_INTERNAL_EDGE_UTILITY
//printf("trimesh->m_collisionMargin=%f\n",trimesh->m_collisionMargin);
//btCompoundShapeChildData* childShapeDataArray = &compoundData->m_childShapePtr[0];
//btCompoundShapeChildData* ptr = &compoundData->m_childShapePtr[i];
//sizeof(btShortIntIndexTripletData);
//create a new btStridingMeshInterfaceData that is an exact copy of shapedata and store it in the WorldImporter
///the m_3indices8 was not initialized in some Bullet versions, this can cause crashes at loading time
///we catch it by only dealing with m_3indices8 if none of the other indices are initialized
//btAdjustInternalEdgeContacts(cp,colObj1,colObj0, partId1,index1, BT_TRIANGLE_CONVEX_BACKFACE_MODE);
//btAdjustInternalEdgeContacts(cp,colObj1,colObj0, partId1,index1, BT_TRIANGLE_CONVEX_DOUBLE_SIDED+BT_TRIANGLE_CONCAVE_DOUBLE_SIDED);
//USE_INTERNAL_EDGE_UTILITY
/*
//todo: flags etc
//SUPPORT_GIMPACT_SHAPE_IMPORT
// query for data
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCompoundCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//wrong child trans, but unused (hopefully)
//backup
//perform an AABB check first
//the contactpoint is still projected back using the original inverted worldtrans
///detect swapping case
///btCompoundShape might have changed:
////make sure the internal child collision algorithm caches are still valid
///clear and update all
//use a dynamic aabb tree to cull potential child-overlaps
///we need to refresh all contact manifolds
///note that we should actually recursively traverse all children, btCompoundShape can nested more then 1 level deep
///so we should add a 'refreshManifolds' in the btCollisionAlgorithm
//??necessary?
//process all children, that overlap with  the given AABB bounds
//iterate over all children, perform an AABB check inside ProcessChildShape
//iterate over all children, perform an AABB check inside ProcessChildShape
//if not longer overlapping, remove the algorithm
//perform an AABB check first
//needs to be fixed, using btCollisionObjectWrapper and NOT modifying internal data structures
//We will use the OptimizedBVH, AABB tree to cull potential child-overlaps
//If both proxies are Compound, we will deal with that directly, by performing sequential/parallel tree traversals
//given Proxy0 and Proxy1, if both have a tree, Tree0 and Tree1, this means:
//determine overlapping nodes of Proxy1 using Proxy0 AABB against Tree1
//then use each overlapping node AABB against Tree0
//and vise versa.
//btCollisionShape* childShape = compoundShape->getChildShape(i);
//backup
//btTransform	newChildWorldTrans = orgTrans*childTrans ;
//btCollisionShape* tmpShape = colObj->getCollisionShape();
//colObj->internalSetTemporaryCollisionShape( childShape );
//revert back
//colObj->internalSetTemporaryCollisionShape( tmpShape);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btCompoundCompoundCollisionAlgorithm.cpp
/*
//bulletphysics.org
//USE_LOCAL_STACK will avoid most (often all) dynamic memory allocations due to resizing in processCollision and MycollideTT
//backup
//perform an AABB check first
///btCompoundShape might have changed:
////make sure the internal child collision algorithm caches are still valid
///clear all
///we need to refresh all contact manifolds
///note that we should actually recursively traverse all children, btCompoundShape can nested more then 1 level deep
///so we should add a 'refreshManifolds' in the btCollisionAlgorithm
//printf("#compound-compound child/leaf overlap =%d                      \r",callback.m_numOverlapPairs);
//remove non-overlapping child pairs
//iterate over all children, perform an AABB check inside ProcessChildShape
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btConvex2dConvex2dAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//#include <stdio.h>
/* numPerturbationIterations */, int /* minimumPointsPerturbationThreshold */)
//
// Convex-Convex collision algorithm
//
//swapped?
//comment-out next line to test multi-contact generation
//resultOut->getPersistentManifold()->clearManifold();
//TODO: if (dispatchInfo.m_useContinuous)
///Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold
///Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold
///col0->m_worldTransform,
//An adhoc way of testing the Continuous Collision Detection algorithms
//One object is approximated as a sphere, to simplify things
//Starting in penetration should report no time of impact
//For proper CCD, better accuracy and handling of 'allowed' penetration should be added
//also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)
/// Convex0 against sphere for Convex1
//todo: allow non-zero sphere sizes, for better approximation
//SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
///Simplification, one object is simplified as a sphere
//ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
//store result.m_fraction in both bodies
/// Sphere (for convex0) against Convex1
//todo: allow non-zero sphere sizes, for better approximation
//SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
///Simplification, one object is simplified as a sphere
//ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
//store result.m_fraction in both bodies
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btConvexConcaveCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//
// create the manifold from the dispatcher 'manifold pool'
//
//just for debugging purposes
//printf("triangle %d",m_triangleCount++);
///debug drawing of the overlapping triangles
//correct transform?
//recalc aabbs
//CollisionShape* triangleShape = static_cast<btCollisionShape*>(triBody->m_collisionShape);
//m_btConvexTriangleCallback.m_manifoldPtr->clearManifold();
//quick approximation using raycast, todo: hook up to the continuous collision detection (one of the btConvexCast)
//only perform CCD above a certain threshold, this prevents blocking on the long run
//because object in a blocked ccd state (hitfraction<1) get their linear velocity halved each frame...
//const btVector3& from = convexbody->m_worldTransform.getOrigin();
//btVector3 to = convexbody->m_interpolationWorldTransform.getOrigin();
//todo: only do if the motion exceeds the 'radius'
//do a swept sphere for now
//GjkConvexCast	convexCaster(&pointShape,convexShape,&simplexSolver);
//ContinuousConvexCollision convexCaster(&pointShape,convexShape,&simplexSolver,0);
//local space?
//is this available?
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btConvexConvexAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
///Specialized capsule-capsule collision algorithm has been added for Bullet 2.75 release to increase ragdoll performance
///If you experience problems with capsule-capsule collision, try to define BT_DISABLE_CAPSULE_CAPSULE_COLLIDER and report it in the Bullet forums
///with reproduction case
//#define BT_DISABLE_CAPSULE_CAPSULE_COLLIDER 1
//#define ZERO_MARGIN
//#include <stdio.h>
///////////
// compute the parameters of the closest points on each line segment
// compute the closest points relative to segment centers.
// translation between centers
// compute the closest points of the capsule line segments
// the vector between the closest points
// offsets from segment centers to their closest points
// parameters on line segment
//degenerate case where 2 capsules are likely at the same location: take a vector tangential to 'directionA'
// compute the contact normal
//////////
//#define DEBUG_CONTACTS 1
//DEBUG_CONTACTS
//
// Convex-Convex collision algorithm
//
//swapped?
//comment-out next line to test multi-contact generation
//resultOut->getPersistentManifold()->clearManifold();
//m_manifoldPtr->clearManifold();
//m_manifoldPtr->clearManifold();
//m_manifoldPtr->clearManifold();
//BT_DISABLE_CAPSULE_CAPSULE_COLLIDER
//USE_SEPDISTANCE_UTIL2
//TODO: if (dispatchInfo.m_useContinuous)
//USE_SEPDISTANCE_UTIL2
//if (dispatchInfo.m_convexMaxDistanceUseCPT)
//{
//	input.m_maximumDistanceSquared = min0->getMargin() + min1->getMargin() + m_manifoldPtr->getContactProcessingThreshold();
//} else
//{
//		}
//now perturbe directions to get multiple contact points
//USE_SEPDISTANCE_UTIL2
///btBoxShape is an exception: its vertices are created WITH margin so don't subtract it
//gjkPairDetector.getClosestPoints(input,dummy,dispatchInfo.m_debugDraw);
//ZERO_MARGIN                                                    \
//btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2(); \
//if (l2>SIMD_EPSILON)
//gjkPairDetector.getCachedSeparatingAxis()*(1.f/l2);
//minDist = -1e30f;//gjkPairDetector.getCachedSeparatingDistance();
//gjkPairDetector.getCachedSeparatingDistance()+min0->getMargin()+min1->getMargin();
//gjkPairDetector.getCachedSeparatingDistance()<0.f;
//-(min0->getMargin()+min1->getMargin());
//				printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());
//we can also deal with convex versus triangle (without connectivity data)
//tri->initializePolyhedralFeatures();
//initializePolyhedralFeatures performs a convex hull computation, not needed for a single triangle
//	 printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());
//ZERO_MARGIN
// = dummy.m_normalOnBInWorld;
//minDist = dummy.m_depth;
//minDist = gjkPairDetector.getCachedSeparatingDistance();
//maxDist = threshold;
//now perform 'm_numPerturbationIterations' collision queries with the perturbated collision objects
//perform perturbation when more then 'm_minimumPointsPerturbationThreshold' points
//DEBUG_CONTACTS
//USE_SEPDISTANCE_UTIL2
///Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold
///Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold
///col0->m_worldTransform,
//An adhoc way of testing the Continuous Collision Detection algorithms
//One object is approximated as a sphere, to simplify things
//Starting in penetration should report no time of impact
//For proper CCD, better accuracy and handling of 'allowed' penetration should be added
//also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)
/// Convex0 against sphere for Convex1
//todo: allow non-zero sphere sizes, for better approximation
//SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
///Simplification, one object is simplified as a sphere
//ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
//store result.m_fraction in both bodies
/// Sphere (for convex0) against Convex1
//todo: allow non-zero sphere sizes, for better approximation
//SubsimplexConvexCast ccd0(&sphere,min0,&voronoiSimplex);
///Simplification, one object is simplified as a sphere
//ContinuousConvexCollision ccd(min0,min1,&voronoiSimplex,0);
//store result.m_fraction in both bodies
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btConvexPlaneCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//#include <stdio.h>
//now perturbe the convex-world transform
/// report a contact. internally this will be kept persistent, and contact reduction is done
/// report a contact. internally this will be kept persistent, and contact reduction is done
//the perturbation algorithm doesn't work well with implicit surfaces such as spheres, cylinder and cones:
//they keep on rolling forever because of the additional off-center contact points
//so only enable the feature for polyhedral shapes (btBoxShape, btConvexHullShape etc)
//now perform 'm_numPerturbationIterations' collision queries with the perturbated collision objects
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btDefaultCollisionConfiguration.cpp
/*
//continuousphysics.com/Bullet/
//USE_BUGGY_SPHERE_BOX_ALGORITHM
//btDefaultCollisionConfiguration::btDefaultCollisionConfiguration(btStackAlloc*	stackAlloc,btPoolAllocator*	persistentManifoldPool,btPoolAllocator*	collisionAlgorithmPool)
//default CreationFunctions, filling the m_doubleDispatch table
//USE_BUGGY_SPHERE_BOX_ALGORITHM
//convex versus plane
///calculate maximum element size, big enough to fit any collision algorithm in the memory pool
//USE_BUGGY_SPHERE_BOX_ALGORITHM
//USE_BUGGY_SPHERE_BOX_ALGORITHM
//failed to find an algorithm
//USE_BUGGY_SPHERE_BOX_ALGORITHM
//failed to find an algorithm
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btEmptyCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btGhostObject.cpp
/*
//bulletphysics.com
///btGhostObject should have been removed from the world, so no overlapping objects
///if this linearSearch becomes too slow (too many overlapping objects) we should add a more appropriate data structure
//not found
/* Compute AABB that encompasses angular movement */
/// go over all objects, and if the ray intersects their aabb + cast shape aabb,
// do a ray-shape query using convexCaster (CCD)
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
//could use resultCallback.m_closestHitFraction, but needs testing
//only perform raycast if filterMask matches
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btHashedSimplePairCache.cpp
/*
//continuousphysics.com/Bullet/
//BT_DEBUG_COLLISION_PAIRS
/*if (indexA > indexB) 
//#include <stdio.h>
//grow hashtable and next table
// New hash value with new mask
// New hash value with new mask
//hash with new capacity
/*if (indexA > indexB) 
// Remove the pair from the hash table.
// We now move the last pair into spot of the
// pair being removed. We need to fix the hash
// table indices to support the move.
// If the removed pair is the last pair, we are done.
// Remove the last pair from the hash table.
/* missing swap here too, Nat. */
// Copy the last pair into the remove pair's spot.
// Insert the last pair into the hash table
//#include <stdio.h>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btInternalEdgeUtility.cpp
//#define DEBUG_INTERNAL_EDGE
//DEBUG_INTERNAL_EDGE
//BT_INTERNAL_EDGE_DEBUG_DRAW
//skip self-collisions
//skip duplicates (disabled for now)
//if ((m_partIdA <= partId) && (m_triangleIndexA <= triangleIndex))
//	return;
//search for shared vertices and edges
///skip degenerate triangles
///skip degenerate triangles
///degenerate case
///degenerate case
//shared vertex
//shared edge
//we need to make sure the edge is in the order V2V0 and not V0V2 so that the signs are correct
//btTriangleShape tB(triangle[0],triangle[1],triangle[2]);
//btVector3 calculatedNormalB = normalA;
///@todo: check if we need some epsilon, due to floating point imprecision
//alternatively use
//btVector3 calculatedNormalB2 = quatRotate(orn,normalA);
//DEBUG_INTERNAL_EDGE
//DEBUG_INTERNAL_EDGE
//DEBUG_INTERNAL_EDGE
//				printf("warning: duplicate triangle\n");
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
//the user pointer shouldn't already be used for other purposes, we intend to store connectivity info there!
//PHY_ScalarType indexType=0;
// Given a point and a line segment (defined by two points), compute the closest point
// in the line.  Cap the point at the endpoints of the line segment.
// Handle degenerate lines
// Clamp the point to conform to the segment's endpoints
//we only have a local triangle normal, not a local contact normal -> only normal in world space...
//either compute the current angle all in local space, or all in world space
/// Changes a btManifoldPoint collision normal to the normal from the mesh.
//btAssert(colObj0->getCollisionShape()->getShapeType() == TRIANGLE_SHAPE_PROXYTYPE);
//btVector3 center = (v0+v1+v2)*btScalar(1./3.);
//btScalar dot = tri_normal.dot(cp.m_normalWorldOnB);
//BT_INTERNAL_EDGE_DEBUG_DRAW
//is this necessary?
// Get closest edge
//
// Edge 0 -> 1
//
// Edge 1 -> 2
//
// Edge 2 -> 0
//
//BT_INTERNAL_EDGE_DEBUG_DRAW
//DEBUG_INTERNAL_EDGE
//					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
// Reproject collision point along normal. (what about cp.m_distance1?)
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//DEBUG_INTERNAL_EDGE
//					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
// Reproject collision point along normal.
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//BT_INTERNAL_EDGE_DEBUG_DRAW
//DEBUG_INTERNAL_EDGE
//				printf("hitting convex edge\n");
//					cp.m_distance1 = cp.m_distance1 * newNormal.dot(cp.m_normalWorldOnB);
// Reproject collision point along normal.
//DEBUG_INTERNAL_EDGE
//fix tri_normal so it pointing the same direction as the current local contact normal
//if the tri_normal is pointing opposite direction as the current local contact normal, skip it
//modify the normal to be the triangle normal (or backfacing normal)
// Reproject collision point along normal.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btManifoldResult.cpp
/*
//continuousphysics.com/Bullet/
///This is to allow MaterialCombiner/Custom Friction/Restitution values
///User can override this material combiner by implementing gContactAddedCallback and setting body0->m_collisionFlags |= btCollisionObject::customMaterialCallback;
//DEBUG_PART_INDEX
//order in manifold needs to match
//	if (depth > m_manifoldPtr->getContactProcessingThreshold())
//BP mod, store contact triangles.
//printf("depth=%f\n",depth);
///@todo, check this for any side effects
//const btManifoldPoint& oldPoint = m_manifoldPtr->getContactPoint(insertIndex);
//User can override friction and/or restitution
//and if either of the two bodies requires custom material
//experimental feature info, for per-triangle material etc.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btSimulationIslandManager.cpp
/*
//continuousphysics.com/Bullet/
//#include <stdio.h>
/* dispatcher */, btCollisionWorld* colWorld)
// put the index into m_controllers into m_tag
//Adding filtering here
// do the union find
// put the islandId ('find' value) into m_tag
//Set the correct object offset in Collision Object Array
//STATIC_SIMULATION_ISLAND_OPTIMIZATION
// put the index into m_controllers into m_tag
// do the union find
// put the islandId ('find' value) into m_tag
//STATIC_SIMULATION_ISLAND_OPTIMIZATION
/// function object that routes calls to operator<
//we are going to sort the unionfind array, and store the element id in the size
//afterwards, we clean unionfind, to make sure no-one uses it anymore
//update the sleeping state for bodies, if all are sleeping
//int numSleeping = 0;
//				printf("error in island management\n");
//					printf("error in island management\n");
//					printf("error in island management\n");
//#define SPLIT_ISLANDS 1
//#ifdef SPLIT_ISLANDS
//#endif //SPLIT_ISLANDS
///@todo: check sleeping conditions!
//kinematic objects don't merge islands, but wake up all connected objects
//filtering for response
///@todo: this is random access, it can be walked 'cache friendly'!
// Sort manifolds, based on islands
// Sort the vector using predicate and std::sort
//std::sort(islandmanifold.begin(), islandmanifold.end(), btPersistentManifoldSortPredicate);
//tried a radix sort, but quicksort/heapsort seems still faster
//@todo rewrite island management
//btPersistentManifoldSortPredicateDeterministic sorts contact manifolds based on islandid,
//but also based on object0 unique id and object1 unique id
//m_islandmanifold.heapSort(btPersistentManifoldSortPredicate());
//now process all active islands (sets of manifolds for now)
//int islandId;
//	printf("Start Islands\n");
//traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
//find the accompanying contact manifold for this islandId
/// Process the actual simulation, only if not sleeping/deactivated
//			printf("Island callback of size:%d bodies, %d manifolds\n",islandBodies.size(),numIslandManifolds);
// else if(!splitIslands)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btSphereBoxCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//#include <stdio.h>
/// report a contact. internally this will be kept persistent, and contact reduction is done
//not yet
// convert the sphere position to the box's local space
// Determine the closest point to the sphere center in the box
//if there is no penetration, we are done
//special case if the sphere center is inside the box
//compute the penetration details
//	v3PointOnSphere = sphereRelPos - (normal * fRadius);
// transform back in world space
//	tmp = m44T(v3PointOnSphere);
//	v3PointOnSphere = tmp;
//project the center of the sphere on the closest face of the box
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btSphereSphereCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//don't do this, it disables warmstarting
///iff distance positive, don't generate a new contact
//CLEAR_MANIFOLD
///distance (negative means penetration)
///point on A (worldspace)
///btVector3 pos0 = col0->getWorldTransform().getOrigin() - radius0 * normalOnSurfaceB;
///point on B (worldspace)
/// report a contact. internally this will be kept persistent, and contact reduction is done
//CLEAR_MANIFOLD
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btSphereTriangleCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
/// report a contact. internally this will be kept persistent, and contact reduction is done
///@todo: tighter bounds
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\btUnionFind.cpp
/*
//continuousphysics.com/Bullet/
///this is a special operation, destroying the content of btUnionFind.
///it sorts the elements, based on island id, in order to make it easy to iterate over islands
//first store the original body index, and islandId
//STATIC_SIMULATION_ISLAND_OPTIMIZATION
// Sort the vector using predicate and std::sort
//std::sort(m_elements.begin(), m_elements.end(), btUnionFindElementSortPredicate);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionDispatch\SphereTriangleDetector.cpp
/*
//continuousphysics.com/Bullet/
//	output.m_distance = btScalar(BT_LARGE_FLOAT);
//move sphere into triangle space
// See also geometrictools.com
// Basic idea: D = |p - (lo + t0*lv)| where t0 = lv . (p - lo) / lv . lv
//triangle facing the other way
// Check for contact / intersection
// Inside the contact wedge - touches a point on the shell plane
// Could be inside one of the contact capsules
// Yep, we're inside a capsule, and record the capsule with smallest distance
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btBox2dShape.cpp
/*
//continuousphysics.com/Bullet/
//{
//btScalar margin = btScalar(0.);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btBoxShape.cpp
/*
//bulletphysics.org
//btScalar margin = btScalar(0.);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btBvhTriangleMeshShape.cpp
/*
//bulletphysics.org
//#define DISABLE_BVH
///Bvh Concave triangle mesh is a static-triangle mesh shape with Bounding Volume Hierarchy optimization.
///Uses an interface to access the triangles to allow for sharing graphics/physics triangles.
//construct bvh from meshInterface
//DISABLE_BVH
//construct bvh from meshInterface
//DISABLE_BVH
/* Perform ray vs. triangle collision here */
/* Perform ray vs. triangle collision here */
//perform bvh tree traversal and report overlapping triangles to 'callback'
//brute force traverse all triangles
//first get all the nodes
//DEBUG_TRIANGLE_MESH
//DEBUG_TRIANGLE_MESH
//DISABLE_BVH
///m_localAabbMin/m_localAabbMax is already re-calculated in btTriangleMeshShape. We could just scale aabb, but this needs some more work
//rebuild the bvh...
// update the scaling without rebuilding the bvh
///fills the dataBuffer and returns the struct name (and 0 on failure)
//BT_USE_DOUBLE_PRECISION
//BT_USE_DOUBLE_PRECISION
// Fill padding with zeros to appease msan.
//make sure not to use calculateSerializeBufferSize because it is used for in-place
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btCapsuleShape.cpp
/*
//bulletphysics.org
//as an approximation, take the inertia of the box that bounds the spheres
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btCollisionShape.cpp
/*
//bulletphysics.org
/*
///@todo cache this value, to improve performance
//start with static aabb
// add linear motion
///@todo: simd would have a vector max/min operation, instead of per-element access
//add conservative angular motion
///fills the dataBuffer and returns the struct name (and 0 on failure)
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btCompoundShape.cpp
/*
//bulletphysics.org
//m_childTransforms.push_back(localTransform);
//m_childShapes.push_back(shape);
//extend the local aabbMin/aabbMax
///update the dynamic aabb tree
//int index = m_children.size()-1;
// Find the children containing the shape specified, and remove those children.
//note: there might be multiple children using the same shape!
// Recalculate the local aabb
// Brute force, it iterates over all the shapes left.
//extend the local aabbMin/aabbMax
///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
//avoid an illegal AABB when there are no children
//approximation: take the inertia from the aabb for now
//compute inertia tensor in coordinate system of compound shape
//add inertia tensor
//compute inertia tensor of pointmass at o
//add inertia tensor of pointmass
//		childScale = childScale * (childTrans.getBasis() * scaling);
//extend the local aabbMin/aabbMax
///fills the dataBuffer and returns the struct name (and 0 on failure)
//don't serialize shapes that already have been serialized
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConcaveShape.cpp
/*
//bulletphysics.org
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConeShape.cpp
/*
//bulletphysics.org
///choose upAxis index
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvex2dShape.cpp
/*
//bulletphysics.org
///this linear upscaling is not realistic, but we don't deal with large mass ratios...
///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexHullShape.cpp
/*
//bulletphysics.org
// Here we take advantage of dot(a, b*c) = dot(a*b, c).  Note: This is true mathematically, but not numerically.
// FIXME: may violate encapsulation of m_unscaledPoints
//use 'w' component of supportVerticesOut?
// dot(a*b,c) = dot(a,b*c)
//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexHullShape with the Raytracer Demo
//not yet
///fills the dataBuffer and returns the struct name (and 0 on failure)
//int szc = sizeof(btConvexHullShapeData);
//	int sz2 = sizeof(btVector3DoubleData);
//	int sz3 = sizeof(btVector3FloatData);
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexInternalShape.cpp
/*
//bulletphysics.org
//use localGetSupportingVertexWithoutMargin?
//__SPU__
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexPointCloudShape.cpp
/*
//bulletphysics.org
// Here we take advantage of dot(a*b, c) = dot( a, b*c) to do less work. Note this transformation is true mathematically, not numerically.
//    btVector3 scaled = vec * m_localScaling;
//FIXME: may violate encapsulation of m_unscaledPoints
// dot( a*c, b) = dot(a, b*c)
//WARNING: don't swap next lines, the w component would get overwritten!
//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexHullShape with the Raytracer Demo
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexPolyhedron.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs
//
//USE_CONNECTED_FACES
//		const btScalar r = m_radius / sqrtf(2.0f);
// Refine the box
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexShape.cpp
/*
//bulletphysics.org
///not supported on IBM SDK, until we fix the alignment of btVector3
//__SPU__
//__SPU__
//mapping of halfextents/dimension onto radius/height depends on how cylinder local orientation is (upAxis)
// should never reach here
/* TODO: This should be bumped up to btCollisionShape () */
/* fall through */
// should never reach here
// * convexShape->getLocalScaling().getX();
/* fall through */
// should never reach here
//__SPU__
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btConvexTriangleMeshShape.cpp
/*
//bulletphysics.org
///It's not nice to have all this virtual function overhead, so perhaps we can also gather the points once
///but then we are duplicating
//use 'w' component of supportVerticesOut?
///@todo: could do the batch inside the callback!
//currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection
//Please note that you can debug-draw btConvexTriangleMeshShape with the Raytracer Demo
//cache this?
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btCylinderShape.cpp
/*
//bulletphysics.org
//Until Bullet 2.77 a box approximation was used, so uncomment this if you need backwards compatibility
//#define USE_BOX_INERTIA_APPROXIMATION 1
/*
// square of cylinder radius
// square of cylinder height
// get cylinder dimension
// get indices of radius and height of cylinder
// cylinder is aligned along x
// cylinder is aligned along z
// cylinder is aligned along y
// calculate squares
// calculate tensor terms
// set diagonal elements of inertia tensor
// cylinder is aligned along x
// cylinder is aligned along z
// cylinder is aligned along y
//USE_BOX_INERTIA_APPROXIMATION
//approximation of box shape
//USE_BOX_INERTIA_APPROXIMATION
//mapping depends on how cylinder local orientation is
// extents of the cylinder is: X,Y is for radius, and Z for height
//mapping depends on how cylinder local orientation is
// extents of the cylinder is: X,Y is for radius, and Z for height
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btEmptyShape.cpp
/*
//bulletphysics.org
///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btHeightfieldTerrainShape.cpp
/*
//bulletphysics.org
// legacy constructor: support only float or unsigned char,
// 	and min height is zero
// previously, height = uchar * maxHeight / 65535.
// So to preserve legacy behavior, heightScale = maxHeight / 65535
// validation
// && "bad width");
// && "bad length");
// && "null heightfield data");
// btAssert(heightScale) -- do we care?  Trust caller here
// && "bad min/max height");
// && "bad upAxis--should be in range [0,2]");
// && "Bad height data type enum");
// initialize member variables
// determine min/max axis-aligned bounding box (aabb) values
//need to get valid m_upAxis
// && "Bad m_upAxis");
// remember origin (defined as exact middle of aabb)
/// This returns the "raw" (user's initial) height, not the actual height.
/// The actual height needs to be adjusted to be relative to the center
///   of the heightfield's AABB.
/// this returns the vertex in bullet-local coordinates
//need to get valid m_upAxis
/// given input vector, return quantized version
/**
/*isMax*/) const
/// process all triangles within the provided axis-aligned bounding box
/**
// scale down the input aabb's so they are in local (non-scaled) coordinates
// account for local origin
//quantize the aabbMin and aabbMax, and adjust the start/end ranges
// expand the min/max quantized values
// this is to catch the case where the input aabb falls between grid points!
//need to get valid m_upAxis
//first triangle
//second triangle
//  getVertex(x,j,vertices[0]);//already got this vertex before, thanks to Danny Chapman
//first triangle
//second triangle
//getVertex(x,j+1,vertices[1]);
//moving concave objects not supported
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btMiniSDF.cpp
//
//Based on code from DiscreGrid, https://github.com/InteractiveComputerGraphics/Discregrid
//example:
//GenerateSDF.exe -r "32 32 32" -d "-1.6 -1.6 -.6 1.6 1.6 .6" concave_box.obj
//The MIT License (MIT)
//
//Copyright (c) 2017 Dan Koschier
//
//memcpy
// Corner nodes.
// Edge nodes.
//.cast<unsigned int>().eval();
//.diagonal().eval();
//auto phi = m_coefficients[field_id][i].dot(shape_function_(xi, 0));
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btMinkowskiSumShape.cpp
/*
//bulletphysics.org
///@todo: could make recursive use of batching. probably this shape is not used frequently.
//inertia of the AABB of the Minkowski sum
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btMultimaterialTriangleMeshShape.cpp
/*
//bulletphysics.org
/// This file was created by Alex Silverman
//#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
///Obtains the material for a specific triangle
// return the pointer to the place with the friction for the triangle
// TODO: This depends on whether it's a moving mesh or not
// BUG IN GIMPACT
//return (btScalar*)(&materialBase[triangleMaterialBase[(triIndex-1) * triangleMaterialStride] * materialStride]);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btMultiSphereShape.cpp
/*
//bulletphysics.org
//btScalar startMargin = btScalar(BT_LARGE_FLOAT);
//as an approximation, take the inertia of the box that bounds the spheres
///fills the dataBuffer and returns the struct name (and 0 on failure)
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btOptimizedBvh.cpp
/*
//bulletphysics.org
// NodeArray	triangleNodes;
//with quantization?
//for child nodes
// for quantization
// The partId and triangle index must fit in the same (positive) integer
//negative indices are reserved for escapeIndex
//PCK: add these checks for zero dimensions of aabb
//initialize quantization values
//now we have an array of leafnodes in m_leafNodes
//now we have an array of leafnodes in m_leafNodes
///if the entire tree is small then subtree size, we need to create a header info for the tree
//PCK: update the copy of the size
//PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
///now update all subtree headers
//incrementally initialize quantization values
///we should update all quantization values, using updateBvhNodes(meshInterface);
///but we only update chunks that overlap the given aabb
//PCK: unsigned instead of bool
//get access info to trianglemesh data
//recalc aabb from triangle data
//triangles->getLockedReadOnlyVertexIndexBase(vertexBase,numVerts,
//combine aabb from both children
///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
//we don't add additional data so just do a static upcast
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btPolyhedralConvexShape.cpp
/*
//bulletphysics.org
//	   btScalar margin = getMargin();
//face->addIndex(v1);
//BT_RECONSTRUCT_FACES
//printf("face=%d\n",face);
//compute face normals
//degenerate?
//merge coplanar faces and copy them to m_polyhedron
//do the merge: use Graham Scan 2d convex hull
//				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);
//if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
// invalidate...
// are there rejected vertices?
// this is in the hull...
// this vertex is rejected -- is anybody else using this vertex?
// is this a face of the current coplanar group?
// ignore this face...
// does this face use this rejected vertex?
// this rejected vertex is used in another face -- reject merge
// do this merge!
//BT_RECONSTRUCT_FACES
//__SPU__
//__SPU__
//not yet, return box inertia
//__SPU__
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btScaledBvhTriangleMeshShape.cpp
/*
//bulletphysics.org
///support negative scaling
///don't make this a movable object!
//	btAssert(0);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btSdfCollisionShape.cpp
//"E:/develop/bullet3/data/toys/ground_hole64_64_8.cdf");//ground_cube.cdf");
/*unsigned int field_id=0;
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btShapeHull.cpp
/*
//bulletphysics.org
//btShapeHull was implemented by John McCutchan.
/*margin*/, int highres)
// free temporary hull result that we just copied
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btSphereShape.cpp
/*
//bulletphysics.org
//broken due to scaling
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btStaticPlaneShape.cpp
/*
//bulletphysics.org
//	btAssert( btFuzzyZero(m_planeNormal.length() - btScalar(1.)) );
/*
//this is where the triangles are generated, given AABB and plane equation (normal/constant)
//tangentDir0/tangentDir1 can be precalculated
//moving concave objects not supported
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btStridingMeshInterface.cpp
/*
//bulletphysics.org
///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
//upper bound
///unlike that developers want to pass in double-precision meshes in single-precision Bullet build
///so disable this feature by default
///see patch http://code.google.com/p/bullet/issues/detail?id=213
//first calculate the total aabb for all triangles
///fills the dataBuffer and returns the struct name (and 0 on failure)
//void* uniquePtr = 0;
//	int numtotalphysicsverts = 0;
//	btVector3 triangle[3];
//	btVector3 meshScaling = getScaling();
///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
//indices = 3*numtriangles
// Fill padding with zeros to appease msan.
// Fill padding with zeros to appease msan.
//unknown index type
//for now convert to float, might leave it at double
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTetrahedronShape.cpp
/*
//bulletphysics.org
//just transform the vertices in worldspace, and take their AABB
//euler formula, F-E+V = 2, so E = F+V-2
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleBuffer.cpp
/*
//bulletphysics.org
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleCallback.cpp
/*
//bulletphysics.org
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleIndexVertexArray.cpp
/*
//bulletphysics.org
// this is intentionally an int see notes in header
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleIndexVertexMaterialArray.cpp
/*
//bulletphysics.org
///This file was created by Alex Silverman
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleMesh.cpp
/*
//bulletphysics.org
//return index of new/existing vertex
///@todo: could use acceleration structure for this
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btTriangleMeshShape.cpp
/*
//bulletphysics.org
//#define DEBUG_TRIANGLE_MESH
//check aabb in triangle-space, before doing this
//moving concave objects not supported
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\CollisionShapes\btUniformScalingShape.cpp
/*
//bulletphysics.org
///this linear upscaling is not realistic, but we don't deal with large mass ratios...
///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btContactProcessing.cpp
/*
//gimpact.sourceforge.net/
//fill key contacts
//sort keys
// Merge contacts
//same points
//merge contact
//)
//add new contact
//divide
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btGenericPoolAllocator.cpp
/*! \file btGenericPoolAllocator.cpp
/*
//continuousphysics.com/Bullet/
/// *************** btGenericMemoryPool ******************///////////
// find an avaliable free node with the correct size
// not found
// post: ptr contains the node index, and revindex the index in m_free_nodes
// post: finalsize>=0, m_allocated_sizes[ptr] has the requested size
// preserve free node, there are some free memory
// delete free node
// swap with end
//! Allocates memory in pool
/*!
// a free node is found
// allocate directly on pool
// not space
// calc offset
//other pool
// far away
// find free position
/// *******************! btGenericPoolAllocator *******************!///
// destroy pools
// creates a pool
// failback
//! Allocates memory in pool
/*!
/// ************** STANDARD ALLOCATOR ***************************///
// main allocator
// global allocator
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btGImpactBvh.cpp
/*! \file gim_box_set.h
/*
//gimpact.sourceforge.net/
//! Gets the average time in miliseconds of tree collisions
//	float avgtime = g_count_traversing;
//	g_count_traversing = 0;
//	return avgtime;
//TRI_COLLISION_PROFILING
/////////////////////// btBvhTree /////////////////////////////////
// average of centers
//sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
//swap
//swapLeafNodes(i,splitIndex);
//if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
//otherwise the tree-building might fail due to stack-overflows in certain cases.
//unbalanced1 is unsafe: it can cause stack overflows
//bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));
//unbalanced2 should work too: always use center (perfect balanced trees)
//bool unbalanced2 = true;
//this should be safe too:
//We have a leaf node
//calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.
//split axis
//split axis
//calc this node bounding box
//build left branch
//build right branch
//! stackless build tree
// initialize node count to 0
// allocate nodes
////////////////////////////////////class btGImpactBvh
//const GIM_BVH_TREE_NODE * nodepointer = get_node_pointer(nodecount);
//get left bound
//! this rebuild the entire set
//obtain primitive boxes
//! returns the indices of the primitives in the m_primitive_manager
//catch bugs in tree data
//next subnode
//skip node
//! returns the indices of the primitives in the m_primitive_manager
//catch bugs in tree data
//next subnode
//skip node
//	box1.appy_transform_trans_cache(trans_cache_1to0);
//	return box0.has_collision(box1);
//stackless recursive collision routine
//avoid colliding internal nodes
// collision result
//collide left recursive
//collide right recursive
//collide left recursive
//collide right recursive
//collide left0 left1
//collide left0 right1
//collide right0 left1
//collide right0 right1
// else if node1 is not a leaf
// else if node0 is not a leaf
//TRI_COLLISION_PROFILING
//TRI_COLLISION_PROFILING
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btGImpactCollisionAlgorithm.cpp
/*
//gimpact.sourceforge.net/
/*
//! Class for accessing the plane equation
//////////////////////////////////////////////////////////////////////////////////////////////
//TRI_COLLISION_PROFILING
//! Retrieving shapes shapes
/*!
//!@{
//select retriever
//!@}
//! Gets the average time in miliseconds of tree collisions
//! Gets the average time in miliseconds of triangle collisions
//TRI_COLLISION_PROFILING
// post :	checkManifold is called
//collide two convex shapes
//build planes
// test conservative
//specialized function
//general function
//collide two convex shapes
//collide two shapes
//collide child shape
//test box against plane
//add contact
//create the callback
//getting the trimesh AABB
// Ensure that gContactProcessedCallback is called for concave shapes.
///////////////////////////////////// REGISTERING ALGORITHM //////////////////////////////////////////////
//! Use this function for register the algorithm externally
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btGImpactQuantizedBvh.cpp
/*! \file gim_box_set.h
/*
//gimpact.sourceforge.net/
//! Gets the average time in miliseconds of tree collisions
//	float avgtime = g_q_count_traversing;
//	g_q_count_traversing = 0;
//	return avgtime;
//TRI_COLLISION_PROFILING
/////////////////////// btQuantizedBvhTree /////////////////////////////////
//calc globa box
// average of centers
//sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
//swap
//swapLeafNodes(i,splitIndex);
//if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
//otherwise the tree-building might fail due to stack-overflows in certain cases.
//unbalanced1 is unsafe: it can cause stack overflows
//bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));
//unbalanced2 should work too: always use center (perfect balanced trees)
//bool unbalanced2 = true;
//this should be safe too:
//We have a leaf node
//calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.
//split axis
//split axis
//calc this node bounding box
//build left branch
//build right branch
//! stackless build tree
// initialize node count to 0
// allocate nodes
////////////////////////////////////class btGImpactQuantizedBvh
//const GIM_BVH_TREE_NODE * nodepointer = get_node_pointer(nodecount);
//get left bound
//! this rebuild the entire set
//obtain primitive boxes
//! returns the indices of the primitives in the m_primitive_manager
//quantize box
//catch bugs in tree data
//next subnode
//skip node
//! returns the indices of the primitives in the m_primitive_manager
//catch bugs in tree data
//next subnode
//skip node
//	box1.appy_transform_trans_cache(trans_cache_1to0);
//	return box0.has_collision(box1);
//stackless recursive collision routine
//avoid colliding internal nodes
// collision result
//collide left recursive
//collide right recursive
//collide left recursive
//collide right recursive
//collide left0 left1
//collide left0 right1
//collide right0 left1
//collide right0 right1
// else if node1 is not a leaf
// else if node0 is not a leaf
//TRI_COLLISION_PROFILING
//TRI_COLLISION_PROFILING
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btGImpactShape.cpp
/*
//gimpact.sourceforge.net/
// moved from .h to .cpp because of conditional compilation
// (The setting of BT_THREADSAFE may differ between various cpp files, so it is best to
// avoid using it in h files)
// If threadsafe is requested, this object uses a different lock/unlock
//  model with the btStridingMeshInterface -- lock once when the object is constructed
//  and unlock once in the destructor.
// The other way of locking and unlocking for each collision check in the narrowphase
// is not threadsafe.  Note these are not thread-locks, they are calls to the meshInterface's
// getLockedReadOnlyVertexIndexBase virtual function, which by default just returns a couple of
// pointers.  In theory a client could override the lock function to do all sorts of
// things like reading data from GPU memory, or decompressing data on the fly, but such things
// do not seem all that likely or useful, given the performance cost.
// moved from .h to .cpp because of conditional compilation
// moved from .h to .cpp because of conditional compilation
// called in the narrowphase -- not threadsafe!
// moved from .h to .cpp because of conditional compilation
// called in the narrowphase -- not threadsafe!
// Calc box inertia
// Calc box inertia
// Calc box inertia
///fills the dataBuffer and returns the struct name (and 0 on failure)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\btTriangleShapeEx.cpp
/*! \file btGImpactTriangleShape.h
/*
//gimpact.sourceforge.net/
///class btPrimitiveTriangle
// classify points on other triangle
// classify points on this triangle
// edge 0
// edge 1
// edge 2
//create planes
// plane v vs U points
//Reject
//find most deep interval face1
// too far
//Normal pointing to this triangle
//Clip tri1 by tri2 edges
//Reject
//find most deep interval face1
// too far
////check most dir for contacts
///class btTriangleShapeEx: public btTriangleShape
// classify points on other triangle
// classify points on this triangle
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\gim_box_set.cpp
/*
//gimpact.sourceforge.net/
// average of centers
//sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
//swap
//if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
//otherwise the tree-building might fail due to stack-overflows in certain cases.
//unbalanced1 is unsafe: it can cause stack overflows
//bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));
//unbalanced2 should work too: always use center (perfect balanced trees)
//bool unbalanced2 = true;
//this should be safe too:
//we got a leaf
//configure inner node
//calc this node bounding box
//calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.
//split axis
//configure this inner node : the left node index
//build left child tree
//configure this inner node : the right node index
//build right child tree
//configure this inner node : the escape index
//! stackless build tree
// initialize node count to 0
// allocate nodes
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\gim_contact.cpp
/*
//gimpact.sourceforge.net/
//fill key contacts
//sort keys
// Merge contacts
//same points
//merge contact
//)
//add new contact
//divide
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\gim_memory.cpp
/*
//gimpact.sourceforge.net/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\Gimpact\gim_tri_collision.cpp
/*! \file gim_tri_collision.h
/*
//gimpact.sourceforge.net/
//! if returns false, the faces are paralele
/* here we know that D0D2<=0.0 */
/* that is D0, D1 are on the same side, D2 on the other or on the plane */
/* here we know that d0d1<=0.0 */
/* here we know that d0d1<=0.0 or that D0!=0.0 */
//! clip triangle
/*!
// edge 0
// edge 1
// edge 2
/*GUINT i0 = (tri_plane.closestAxis()+1)%3;
// edge 0
// edge 1
// edge 2
//swap
//! Test verifying interval intersection with the direction between planes
/*!
// Compute direction of intersection line
//faces near paralele
//normalize
// Compute interval for triangle 1
//edge indices
//edge scale
// Compute interval for triangle 2
//edge indices
//edge scale
//proyected vertices
//proyected intervals
// midpoint
// midpoint
// face U casts face V
// face V casts face U
// closest points
// calc edges and separation
//calc distance between two lines instead
// normalize
//distance negative
//edge_edge_dir *= -1.0f; //normal pointing from V to U
// face V casts face U
// face U casts face V
// closest points
// calc edges and separation
//calc distance between two lines instead
// normalize
//distance negative
//edge_edge_dir *= -1.0f; //normal pointing from V to U
//! collides by two sides
//create planes
// plane v vs U points
// same sign on all of them + not equal 0 ?
//we need test behind the triangle plane
//never intersect
//reorder triangle v
//never intersect
//Look if we need to invert the triangle
//centroid
//reorder triangle v
// plane U vs V points
// same sign on all of them + not equal 0 ?
//we need test behind the triangle plane
//never intersect
//reorder triangle u
//never intersect
//Look if we need to invert the triangle
//centroid
//reorder triangle v
/* bl = cross_line_intersection_test();
//take edge direction too
//}
//edge edge separation
//clip face against other
//TODO
//clip U points against V
//clip V points against U
/*class GIM_TRIANGLE_CALCULATION_CACHE
//! clip triangle
// edge 0
// edge 1
// edge 2
//! collides only on one side
//create planes
// plane v vs U points
//Reject
//find most deep interval face1
// too far
//Normal pointing to triangle1
//contacts1.m_separating_normal *= -1.f;
//Clip tri1 by tri2 edges
//Reject
//find most deep interval face1
// too far
////check most dir for contacts
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btContinuousConvexCollision.cpp
/*
//continuousphysics.com/Bullet/
/// This maximum should not be necessary. It allows for untested/degenerate cases in production code.
/// You don't want your game ever to lock-up.
//convex versus plane
/// compute linear and angular velocity for this interval, to interpolate
//btScalar epsilon = btScalar(0.001);
//first solution, using GJK
//	result.drawCoordSystem(sphereTr);
//not close enough
//don't report time of impact for motion away from the contact normal (or causes minor penetration)
//todo: next check with relative epsilon
//n.setValue(0,0,0);
//break;
//interpolate to next lambda
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btConvexCast.cpp
/*
//continuousphysics.com/Bullet/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btGjkConvexCast.cpp
/*
//continuousphysics.com/Bullet/
/// compute linear velocity for this interval, to interpolate
//assume no rotation/angular velocity, assert here?
//btScalar epsilon = btScalar(0.001);
//first solution, using GJK
//	result.drawCoordSystem(sphereTr);
//m_penetrationDepthSolver);
//we don't use margins during CCD
//	gjk.setIgnoreMargin(true);
//not close enough
//todo: report a failure
//todo: next check with relative epsilon
//n.setValue(0,0,0);
//interpolate to next lambda
//??
//is n normalized?
//don't report time of impact for motion away from the contact normal (or causes minor penetration)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btGjkEpa2.cpp
/*
//continuousphysics.com/Bullet/
/*
//for debug printf
//__SPU__
// Config
/* GJK	*/
//BT_USE_DOUBLE_PRECISION
/* EPA	*/
// Shorthands
// MinkowskiDiff
//__SPU__
//__SPU__
// GJK
/* Types		*/
/* Fields		*/
/* Methods		*/
/* Initialize solver		*/
/* Initialize simplex		*/
/* Loop						*/
/* Check zero							*/
/* Touching or inside				*/
/* Append new vertice in -'v' direction	*/
/* Return old simplex				*/
/* Update lastw					*/
/* Check for termination				*/
/* Return old simplex				*/
/* Reduce simplex						*/
/* Valid	*/
/* Return old simplex				*/
/* Internals	*/
// EPA
/* Types		*/
/* Fields		*/
/* Methods		*/
/* Clean up				*/
/* Orient simplex		*/
/* Build initial hull	*/
/* Fallback		*/
// Outward facing edge normal direction, on triangle plane
// Only care about the sign to determine inside/outside, so not normalization required
// Outside of edge a->b
// Pick distance vertex a
// Pick distance vertex b
// Pick distance to edge a->b
// Origin projects to the interior of the triangle
// Use distance to triangle plane
//
/* Results		*/
/* Shape		*/
// namespace gjkepa2_impl
//
// Api
//
//
//
//
//
//
//__SPU__
/* Symbols cleanup		*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btGjkEpaPenetrationDepthSolver.cpp
/*
//continuousphysics.com/Bullet/
//failed to find a distance/penetration
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btGjkPairDetector.cpp
/*
//continuousphysics.com/Bullet/
//#define TEST_NON_VIRTUAL 1
//for debug printf
//__SPU__
//must be above the machine epsilon
//!< Support point in minkowski sum
//!< Support point in obj1
//!< Support point in obj2
//!< index of last added point
// here is no check on boundaries
// here is no check on boundaries in sake of speed
// The computation comes from solving equation of segment:
//      S(t) = x0 + t.d
//          where - x0 is initial point of segment
//                - d is direction of segment from x0 (|d| > 0)
//                - t belongs to <0, 1> interval
//
// Than, distance from a segment to some point P can be expressed:
//      D(t) = |x0 + t.d - P|^2
//          which is distance from any point on segment. Minimization
//          of this function brings distance from P to segment.
// Minimization of D(t) leads to simple quadratic equation that's
// solving is straightforward.
//
// Bonus of this method is witness point for free.
// direction of segment
// precompute vector from P to x0
// recycling variables
// Computation comes from analytic expression for triangle (x0, B, C)
//      T(s, t) = x0 + s.d1 + t.d2, where d1 = B - x0 and d2 = C - x0 and
// Then equation for distance is:
//      D(s, t) = | T(s, t) - P |^2
// This leads to minimization of quadratic function of two variables.
// The solution from is taken only if s is between 0 and 1, t is
// between 0 and 1 and t + s < 1, otherwise distance from segment is
// computed.
// get last added as A
// get the other point
// compute AB oriented segment
// compute AO vector
// dot product AB . AO
// check if origin doesn't lie on AB segment
// check if origin is in area where AB segment is
// origin is in outside are of A
// origin is in area where AB segment is
// keep simplex untouched and set direction to
// AB x AO x AB
// get last added as A
// get the other points
// check touching contact
// check if triangle is really triangle (has area > 0)
// if not simplex can't be expanded and thus no itersection is found
// compute AO vector
// compute AB and AC segments and ABC vector (perpendircular to triangle)
// C is already in place
// get last added as A
// get the other points
// check if tetrahedron is really tetrahedron (has volume > 0)
// if it is not simplex can't be expanded and thus no intersection is
// found
// check if origin lies on some of tetrahedron's face - if so objects
// intersect
// compute AO, AB, AC, AD segments and ABC, ACD, ADB normal vectors
// side (positive or negative) of B, C, D relative to planes ACD, ADB
// and ABC respectively
// whether origin is on same side of ACD, ADB, ABC as B, C, D
// respectively
// origin is in tetrahedron
// rearrange simplex to triangle and call btDoSimplex3()
// B is farthest from the origin among all of the tetrahedron's
// points, so remove it from the list and go on with the triangle
// case
// D and C are in place
// C is farthest
// (!AD_O)
// simplex contains segment only one segment
// simplex contains triangle
// btSimplexSize(simplex) == 4
// tetrahedron - this is the only shape which can encapsule origin
// so btDoSimplex4() also contains test on it
//for CCD we don't use margins
//this is to catch invalid input, perhaps check for #NaN?
//we add a separate implementation to check if the convex shapes intersect
//See also "Real-time Collision Detection with Implicit Objects" by Leif Olvang
//Todo: integrate the simplex penetration check directly inside the Bullet btVoronoiSimplexSolver
//and remove this temporary code from libCCD
//this fixes issue https://github.com/bulletphysics/bullet3/issues/1703
//note, for large differences in shapes, use double precision build!
// start iterations
// obtain support point
// check if farthest point in Minkowski difference in direction dir
// isn't somewhere before origin (the test on negative dot product)
// - because if it is, objects are not intersecting at all.
//no intersection, besides margin
// add last support vector to simplex
// if btDoSimplex returns 1 if objects intersect, -1 if objects don't
// intersect and 0 if algorithm should continue
// intersection found
// intersection not found
// intersection not found
//no intersection, besides margin
// intersection not found
//status = 0;
//printf("Intersect!\n");
//printf("not intersect\n");
//printf("dir=%f,%f,%f\n",dir[0],dir[1],dir[2]);
//while (true)
// potential exit, they don't overlap
//checkPenetration = false;
//exit 0: the new point is already in the simplex, or we didn't come any closer
// are we getting any closer ?
//add current vertex to simplex
//calculate the closest point to the origin (update vector v)
///warning: this termination condition leads to some problems in 2d test case see Bullet/Demos/Box2dDemo
//
//redundant m_simplexSolver->compute_points(pointOnA, pointOnB);
//are we getting any closer ?
//				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
//degeneracy, this is typically due to invalid/uninitialized worldtransforms for a btCollisionObject
//bool check = (!m_simplexSolver->fullSimplex() && squaredDistance > SIMD_EPSILON * m_simplexSolver->maxVertex());
//do we need this backup_closest here ?
//				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
//valid normal
//normalize
//if (checkPenetration && !isValid)
//penetration case
//if there is no way to handle penetrations, bail out
// Penetration depth case.
//only replace valid penetrations when the result is deeper (check)
///this is another degenerate case, where the initial GJK calculation reports a degenerate case
///EPA reports no penetration, and the second GJK (using the supporting vector without margin)
///reports a valid positive distance. Use the results of the second GJK instead of failing.
///thanks to Jacob.Langford for the reproduction case
///http://code.google.com/p/bullet/issues/detail?id=250
//only replace valid distances when the distance is less
//printf("EPA didn't return a valid value\n");
///todo: need to track down this EPA penetration solver degeneracy
///the penetration solver reports penetration but the contact normal
///connecting the contact points is pointing in the opposite direction
///until then, detect the issue and revert the normal
//printf("invalid gjk query\n");
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btMinkowskiPenetrationDepthSolver.cpp
/*
//continuousphysics.com/Bullet/
//just take fixed number of orientation, and sample the penetration depth in that direction
//find smallest delta
// __SPU__
//find smallest delta
//USE_BATCHED_SUPPORT
//add the margins
//no penetration
///scale dependent
//#define DEBUG_DRAW 1
//DEBUG_DRAW
//minProj;
//the penetration depth is over-estimated, relax it
//DEBUG_DRAW
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btPersistentManifold.cpp
/*
//continuousphysics.com/Bullet/
///gContactCalcArea3Points will approximate the convex hull area using 3 points
///when setting it to false, it will use 4 points to compute the area: it is more accurate but slower
//DEBUG_PERSISTENCY
//DEBUG_PERSISTENCY
// It calculates possible 3 area constructed from random 4 points and returns the biggest one.
//todo: Following 3 cross production can be easily optimized by SIMD.
//calculate 4 possible cases areas, and take biggest area
//also need to keep 'deepest'
//KEEP_DEEPEST_POINT
//sort cache so best points come first, based on area
//DEBUG_PERSISTENCY
/// first refresh worldspace positions and distance
/// then
//contact becomes invalid when signed distance exceeds margin (projected on contactnormal direction)
//todo: friction anchor may require the contact to be around a bit longer
//contact also becomes invalid when relative movement orthogonal to normal exceeds margin
//contact point processed callback
//
//m_index1a = manifoldDataPtr->m_index1a;
//m_index1a = manifoldDataPtr->m_index1a;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btPolyhedralContactClipping.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs
//for FLT_MAX
// Clips a face to the back of a plane
// Start < 0, end < 0, so output endVertex
// Start < 0, end >= 0, so output intersection
// Start >= 0, end < 0 so output intersection and end
// This version is ~11.000 cycles (4%) faster overall in one of the tests.
//	IR(p[0]) = IR(extents[0])|(IR(sv[0])&SIGN_BITMASK);
//	IR(p[1]) = IR(extents[1])|(IR(sv[1])&SIGN_BITMASK);
//	IR(p[2]) = IR(extents[2])|(IR(sv[2])&SIGN_BITMASK);
//TEST_INTERNAL_OBJECTS
// compute the parameters of the closest points on each line segment
// compute the closest points relative to segment centers.
//#ifdef TEST_INTERNAL_OBJECTS
//#endif
// Test normals from hullA
// Test normals from hullB
// Test edges
//		printf("edge-edge\n");
//add an edge-edge contact
// clip polygon to back of planes of all faces of hull A that are adjacent to witness face
//.cross(WorldEdge0);
//int otherFace=0;
//clip face
//#define ONLY_REPORT_DEEPEST_POINT
// only keep points that are behind the witness face
//				printf("clamped: depth=%f to minDist=%f\n",depth,minDist);
//ONLY_REPORT_DEEPEST_POINT
//	const btVector3 c0 = transA * hullA.m_localCenter;
//	const btVector3 c1 = transB * hullB.m_localCenter;
//const btVector3 DeltaC2 = c0 - c1;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btRaycastCallback.cpp
/*
//continuousphysics.com/Bullet/
//#include <stdio.h>
//@BP Mod
// same sign
// Backface, skip check
// Now we have the intersection point on the plane, we'll see if it's inside the triangle
// Add an epsilon as a tolerance for the raycast,
// in case the ray hits exacly on the edge of the triangle.
// It must be scaled for the triangle size.
//@BP Mod
// Triangle normal isn't normalized
//@BP Mod - Allow for unflipped normal when raycasting against backfaces
//#define  USE_SUBSIMPLEX_CONVEX_CAST 1
//if you reenable USE_SUBSIMPLEX_CONVEX_CAST see commented out code below
//btGjkConvexCast	convexCaster(m_convexShape,&triangleShape,&simplexSolver);
//#USE_SUBSIMPLEX_CONVEX_CAST
//add hit
/* btContinuousConvexCast's normal is already in world space */
/*
//rotate normal into worldspace
//USE_SUBSIMPLEX_CONVEX_CAST
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btSubSimplexConvexCast.cpp
/*
//continuousphysics.com/Bullet/
///take relative motion
//interpolate to next lambda
//	x = s + lambda * r;
//m_simplexSolver->reset();
//check next line
///Just like regular GJK only add the vertex if it isn't already (close) to current vertex, it would lead to divisions by zero and NaN etc.
//todo: check this normal for validity
//n=v;
//printf("V=%f , %f, %f\n",v[0],v[1],v[2]);
//printf("DIST2=%f\n",dist2);
//printf("numverts = %i\n",m_simplexSolver->numVertices());
//int numiter = MAX_ITERATIONS - maxIter;
//	printf("number of iterations: %d", numiter);
//don't report a time of impact when moving 'away' from the hitnormal
//don't report time of impact for motion away from the contact normal (or causes minor penetration)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletCollision\NarrowPhaseCollision\btVoronoiSimplexSolver.cpp
/*
//continuousphysics.com/Bullet/
//clear the simplex, remove all the vertices
//add a vertex
//== m_simplexVectorW[0]
//closest point origin from line segment
//reduce to 1 point
//reduce to 1 point
//closest point origin from triangle
//					printf("sub distance got penetration\n");
//degenerate case == false, penetration = true + zero
//closest point origin from tetrahedron
//return/calculate the closest vertex
//return the current simplex
//btScalar maxV = btScalar(0.);
//w is in the current (reduced) simplex
//check in case lastW is already removed
// Check if P in vertex region outside A
// a; // barycentric coordinates (1,0,0)
// Check if P in vertex region outside B
// b; // barycentric coordinates (0,1,0)
// Check if P in edge region of AB, if so return projection of P onto AB
//return a + v * ab; // barycentric coordinates (1-v,v,0)
// Check if P in vertex region outside C
//c; // barycentric coordinates (0,0,1)
// Check if P in edge region of AC, if so return projection of P onto AC
//return a + w * ac; // barycentric coordinates (1-w,0,w)
// Check if P in edge region of BC, if so return projection of P onto BC
// return b + w * (c - b); // barycentric coordinates (0,1-w,w)
// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
//	return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = btScalar(1.0) - v - w
/// Test if point p and d lie on opposite sides of plane through abc
// [AP AB AC]
// [AD AB AC]
//		printf("affine dependent/degenerate\n");//
// Points on opposite sides if expression signs are opposite
// Start out assuming point inside all halfspaces, so closest to itself
// If point outside face abc then compute closest point on abc
// Update best closest point if (squared) distance is less than current best
//convert result bitmask!
// Repeat test for face acd
//convert result bitmask!
// Repeat test for face adb
//convert result bitmask!
// Repeat test for face bdc
//convert result bitmask!
//
//help! we ended up full !
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Character\btKinematicCharacterController.cpp
/*
//bulletphysics.com
// static helper method
///@todo Interact with dynamic objects,
///Ride kinematicly animated platforms properly
///More realistic (or maybe just a config option) falling
/// -> Should integrate falling velocity manually and use that in stepDown()
///Support jumping
///Support ducking
///need to transform normal into worldspace
/*
//www-cs-students.stanford.edu/~adityagp/final/node3.html
/*
/*
// use walk direction by default, legacy behavior
// 3G acceleration.
// Terminal velocity of a sky diver in m/s.
// ?
// Here we must refresh the overlapping paircache as the penetrating movement itself or the
// previous recovery iteration might have used setWorldTransform and pushed us into an object
// that is not in the previous cache contents from the last timestep, as will happen if we
// are pushed into a new AABB overlap. Unhandled this means the next convex sweep gets stuck.
//
// Do this by calling the broadphase's setAabb with the moved AABB, this will update the broadphase
// paircache and the ghostobject's internal paircache at the same time.    /BW
//	btScalar maxPen = btScalar(0.0);
// TODO: cause problems on slopes, not sure if it is needed
//if (dist < maxPen)
//{
//	maxPen = dist;
//	m_touchingNormal = pt.m_normalWorldOnB * directionSign;//??
//}
//printf("touching %f\n", dist);
//manifold->clearManifold();
//	printf("m_touchingNormal = %f,%f,%f\n",m_touchingNormal[0],m_touchingNormal[1],m_touchingNormal[2]);
// phase 1: up
/* FIXME: Handle penetration properly */
// Only modify the position if the hit was a slope and not a wall or ceiling.
// we moved up only a fraction of the step height
// fix penetration if we hit a ceiling for example
//printf("character could not recover from penetration = %d\n", numPenetrationLoops);
//tangentMag != 0.0)
//			printf("parComponent=%f,%f,%f\n",parComponent[0],parComponent[1],parComponent[2]);
//			printf("perpComponent=%f,%f,%f\n",perpComponent[0],perpComponent[1],perpComponent[2]);
//		printf("movementLength don't normalize a zero vector\n");
// printf("m_normalizedDirection=%f,%f,%f\n",
// 	m_normalizedDirection[0],m_normalizedDirection[1],m_normalizedDirection[2]);
// phase 2: forward and strafe
//	printf("distance2=%f\n",distance2);
// we moved only a fraction
//btScalar hitDistance;
//hitDistance = (callback.m_hitPointWorld - m_currentPosition).length();
//			m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
/* See Quake2: "If velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners." */
//				printf("currentDir: don't normalize a zero vector\n");
// phase 3: down
/*btScalar additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;
//set double test for 2x the step drop, to check for a large drop vs small drop
//test a double fall height, to see if the character should interpolate it's fall (full) or not (partial)
//test a double fall height, to see if the character should interpolate it's fall (large) or not (small)
//redo the velocity calculation when falling a small amount, for fast stairs motion
//for larger falls, use the smoother/slower interpolated movement by not touching the target position
//re-run previous tests
// we dropped a fraction of the height -> hit floor
//printf("hitpoint: %g - pos %g\n", callback.m_hitPointWorld.getY(), m_currentPosition.getY());
//due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually
// we dropped the full height
//undo previous target change
//printf("full drop - %g, %g\n", m_currentPosition.getY(), m_targetPosition.getY());
//	printf("setVelocity!\n");
//	printf("  interval: %f\n", timeInterval);
//	printf("  velocity: (%f, %f, %f)\n",
//		 velocity.x(), velocity.y(), velocity.z());
// HACK: if we are moving in the direction of the up, treat it as a jump :(
//there is a component in walkdirection for vertical velocity
//clear pair cache
//	printf("m_targetPosition=%f,%f,%f\n",m_targetPosition[0],m_targetPosition[1],m_targetPosition[2]);
//	printf("playerStep(): ");
//	printf("  dt = %f", dt);
// integrate for angular velocity
// quick check...
//		printf("\n");
// no motion
//btVector3 lvel = m_walkDirection;
//btScalar c = 0.0f;
// apply damping
// Update fall velocity.
//	printf("walkDirection(%f,%f,%f)\n",walkDirection[0],walkDirection[1],walkDirection[2]);
//	printf("walkSpeed=%f\n",walkSpeed);
//todo: Experimenting with behavior of controller when it hits a ceiling..
//bool hitUp = stepUp (collisionWorld);
//if (hitUp)
//{
//	m_verticalVelocity -= m_gravity * dt;
//	if (m_verticalVelocity > 0.0 && m_verticalVelocity > m_jumpSpeed)
//	{
//		m_verticalVelocity = m_jumpSpeed;
//	}
//	if (m_verticalVelocity < 0.0 && btFabs(m_verticalVelocity) > btFabs(m_fallSpeed))
//	{
//		m_verticalVelocity = -btFabs(m_fallSpeed);
//	}
//	m_verticalOffset = m_verticalVelocity * dt;
//	xform = m_ghostObject->getWorldTransform();
//}
//printf("  time: %f", m_velocityTimeInterval);
// still have some time left for moving!
// how far will we move while we are moving?
//printf("  dtMoving: %f", dtMoving);
// okay, step
//todo: Experimenting with max jump height
//if (m_wasJumping)
//{
//	btScalar ds = m_currentPosition[m_upAxis] - m_jumpPosition[m_upAxis];
//	if (ds > m_maxJumpHeight)
//	{
//		// substract the overshoot
//		m_currentPosition[m_upAxis] -= ds - m_maxJumpHeight;
//		// max height was reached, so potential energy is at max
//		// and kinematic energy is 0, thus velocity is 0.
//		if (m_verticalVelocity > 0.0)
//			m_verticalVelocity = 0.0;
//	}
//}
// printf("\n");
//printf("character could not recover from penetration = %d\n", numPenetrationLoops);
//set orientation with new up
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btBatchedConstraints.cpp
/*
//continuousphysics.com/Bullet/
//for memset
//
// validate: for debugging only. Verify coloring of bodies, that no body is touched by more than one batch in any given phase
//
// detect and run-length encode constraint rows that repeat the same bodies
// we walk the array in reverse to avoid overwriteing
// flatten mergeIndexes
// e.g. in case where A was merged into B and then B was merged into C, we need A to point to C instead of B
// Note: loop goes forward through batches because batches always merge from higher indexes to lower,
//     so by going from low to high it reduces the amount of trail-following
// follow trail of merges to the end
// update batchIds to account for merges
// if this constraint references a batch that was merged into another batch
// update batchId
//int maxNumBatches = numPhases * maxNumBatchesPerPhase;
// for each batch, keep an index into the next available slot in the m_constraintIndices array
// record the start of each batch in m_constraintIndices array
// if any batches were emitted this phase,
// output phase
// for each phase
// sort the batches from largest to smallest (can be helpful to some task schedulers)
//
// PreallocatedMemoryHelper -- helper object for allocating a number of chunks of memory in a single contiguous block.
//                             It is generally more efficient to do a single larger allocation than many smaller allocations.
//
// Example Usage:
//
//  btVector3* bodyPositions = NULL;
//  btBatchedConstraintInfo* conInfos = NULL;
//  {
//    PreallocatedMemoryHelper<8> memHelper;
//    memHelper.addChunk( (void**) &bodyPositions, sizeof( btVector3 ) * bodies.size() );
//    memHelper.addChunk( (void**) &conInfos, sizeof( btBatchedConstraintInfo ) * numConstraints );
//    void* memPtr = malloc( memHelper.getSizeToAllocate() );  // allocate the memory
//    memHelper.setChunkPointers( memPtr );  // update pointers to chunks
//  }
// is it a dynamic constraint?
// (can be done in parallel)
//iBody0; // pseudorandom choice to distribute evenly amongst phases
// is it a dynamic constraint?
// for each dimension x,y,z,
// force bit off
// force bit on
// for each dimension x,y,z,
// calculate chunk coordinates
// for each dimension x,y,z,
//
// setupSpatialGridBatchesMt -- generate batches using a uniform 3D grid
//
/*
//
// if we need to reallocate
// allocate 6.25% extra to avoid repeated reallocs
// compute bounding box around all dynamic bodies
// (could be done in parallel)
//int dynamicBodyCount = 0;
//dynamicBodyCount++;
// find max extent of all dynamic constraints
// (could be done in parallel)
// if we can collapse an axis, it will cut our number of phases in half which could be more efficient
// pick the smallest axis to collapse, leaving us with the greatest number of cells in our grid
//for each dimension
// collapse it
// each chunk is 2x2x2 group of cells
// suceptible to integer overflow
// should roughly cut numCells in half
// for each dynamic body, compute grid coords
// (can be done in parallel)
// if phase is legit,
// all constraints have been assigned a batchId
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btConeTwistConstraint.cpp
/*
//#define CONETWIST_USE_OBSOLETE_SOLVER true
//always reserve 6 rows: object transform is not available on SPU
// set jacobian
// set right hand side
// angular limits
// m_swingCorrection is always positive or 0
//linear part
//positional error (zeroth order error)
//this is the error projected on the normal
// apply motor
// compute current and predicted transforms
// compute desired transforms in world
// compute desired omegas in world
// compute delta omegas
// compute weighted avg axis of dOmega (weighting based on inertias)
// no motor: do a little damping
// joint limits
///solve angular part
// solve swing limit
// Clamp the accumulated impulse
// don't let cone response affect twist
// (this can happen since body A's twist doesn't match body B's AND we use an elliptical cone limit)
// solve twist limit
// only damp when moving towards limit (m_twistAxis flipping is important)
// Clamp the accumulated impulse
//		btVector3 impulse = m_twistAxis * impulseMag;
//__SPU__
// Get Frame into world space
// Calculate necessary axis & factors
// Twist limits
//		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? m_limitSoftness : btScalar(0.);
//__SPU__
// twist axis in constraint's space
// compute rotation of A wrt B (in constraint space)
// it is assumed that setMotorTarget() was alredy called
// and motor target m_qTarget is within constraint limits
// TODO : split rotation to pure swing and pure twist
// compute desired transforms in world
// compute rotation of A wrt B (in constraint space)
// split rotation into cone and twist
// (all this is done from B's perspective. Maybe I should be averaging axes...)
// compute limit ratio: 0->1, where
// 0 == beginning of soft limit
// 1 == hard/real limit
// swing correction tries to get back to soft limit
// adjustment of swing axis (based on ellipse normal)
// Calculate necessary axis & factors
// you haven't set any limits;
// or you're trying to set at least one of the swing limits too small. (if so, do you really want a conetwist constraint?)
// anyway, we have either hinge or fixed joint
// fixed. We'll need to add one more row to constraint
// hinge around Y axis
//					if(!(btFuzzyZero(y)))
// hinge around Z axis
//					if(!btFuzzyZero(z))
// twist correction tries to get back to soft limit
// given a cone rotation in constraint space, (pre: twist must already be removed)
// this method computes its corresponding swing angle and axis.
// more interestingly, it computes the cone/swing limit (angle) for this cone "pose".
// out
// out
// out
// non-zero twist?! this should never happen.
// Compute limit for given swing. tricky:
// Given a swing axis, we're looking for the intersection with the bounding cone ellipse.
// (Since we're dealing with angles, this ellipse is embedded on the surface of a sphere.)
// For starters, compute the direction from center to surface of ellipse.
// This is just the perpendicular (ie. rotate 2D vector by PI/2) of the swing axis.
// (vSwingAxis is the cone rotation (in z,y); change vars and rotate to (x,y) coords.)
// Now, we use the slope of the vector (using x/yEllipse) and find the length
// of the line that intersects the ellipse:
//  x^2   y^2
//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
//  a^2   b^2
// Do the math and it should be clear.
// if xEllipse == 0, we have a pure vSwingAxis.z rotation: just use swingspan1
// test!
/*swingLimit = m_swingSpan2;
// this should never happen!
// compute x/y in ellipse using cone angle (0 -> 2*PI along surface of cone)
// Use the slope of the vector (using x/yEllipse) and find the length
// of the line that intersects the ellipse:
//  x^2   y^2
//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
//  a^2   b^2
// Do the math and it should be clear.
// if xEllipse == 0, just use axis b (1)
// convert into point in constraint space:
// note: twist is x-axis, swing 1 and 2 are along the z and y axes respectively
// given a twist rotation in constraint space, (pre: cone must already be removed)
// this method computes its corresponding angle and axis.
// out
// out
// long way around. flip quat and recalculate.
// this should never happen
// the swing axis is computed as the "twist-free" cone rotation,
// but the cone limit is not circular, but elliptical (if swingspan1 != swingspan2).
// so, if we're outside the limits, the closest way back inside the cone isn't
// along the vector back to the center. better (and more stable) to use the ellipse normal.
// convert swing axis to direction from center to surface of ellipse
// (ie. rotate 2D vector by PI/2)
// do the math...
// avoid division by 0. and we don't need an update if z == 0.
// compute gradient/normal of ellipse surface at current "point"
// adjust y/z to represent normal at point (instead of vector to point)
// convert ellipse direction back to swing axis
//btTransform trACur = m_rbA.getCenterOfMassTransform();
//btTransform trBCur = m_rbB.getCenterOfMassTransform();
//	btTransform trABCur = trBCur.inverse() * trACur;
//	btQuaternion qABCur = trABCur.getRotation();
//	btTransform trConstraintCur = (trBCur * m_rbBFrame).inverse() * (trACur * m_rbAFrame);
//btQuaternion qConstraintCur = trConstraintCur.getRotation();
// clamp motor target to within limits
//m_limitSoftness;
// split into twist and cone
// clamp cone
// clamp twist
// eddy todo: limitSoftness used here???
///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
///return the local value of parameter
//calculateTransforms();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btContactConstraint.cpp
/*
//continuousphysics.com/Bullet/
//response  between two dynamic objects without friction and no restitution, assuming 0 penetration depth
// * damping;
//bilateral constraint between two dynamic objects
//this jacobian entry could be re-used for all iterations
//todo: move this into proper structure
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btFixedConstraint.cpp
/*
//bulletphysics.org
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btGearConstraint.cpp
/*
//bulletphysics.org
/// Implemented by Erwin Coumans. The idea for the constraint comes from Dimitris Papavasiliou.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btGeneric6DofConstraint.cpp
/*
//continuousphysics.com/Bullet/
/*
//gimpact.sf.net
///not providing rigidbody A means implicitly using worldspace for body A
///MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
//	// rot =  cy*cz          -cy*sz           sy
//	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
//	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
//
// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
//////////////////////////// btRotationalLimitMotor ////////////////////////////////////
//Free from violation
//low limit violation
//High limit violation
//Free from violation
//current error correction
// current velocity difference
// correction velocity
//no need for applying force
// correction impulse
// clip correction impulse
///@todo: should clip against accumulated impulse
// sort with accumulated impulses
//////////////////////////// End btRotationalLimitMotor ////////////////////////////////////
//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////
//Free from violation
//low limit violation
//High limit violation
//Free from violation
///find relative velocity
//    btVector3 rel_pos1 = pointInA - body1.getCenterOfMassPosition();
//    btVector3 rel_pos2 = pointInB - body2.getCenterOfMassPosition();
/// apply displacement correction
//positional error (zeroth order error)
//handle the limits
//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////
// in euler angle mode we do not actually constrain the angular velocity
// along the axes axis[0] and axis[2] (although we do use axis[1]) :
//
//    to get			constrain w2-w1 along		...not
//    ------			---------------------		------
//    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
//    d(angle[1])/dt = 0	ax[1]
//    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
//
// constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
// to prove the result for angle[0], write the expression for angle[0] from
// GetInfo1 then take the derivative. to prove this for angle[2] it is
// easier to take the euler rate expression for d(angle[2])/dt with respect
// to the components of w and set that to 0.
//  get weight factors depending on masses
//test limits
// Clear accumulated impulses for the next simulation step
//calculates transform
//  const btVector3& pivotAInW = m_calculatedTransformA.getOrigin();
//  const btVector3& pivotBInW = m_calculatedTransformB.getOrigin();
// not used here
//    btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
//    btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();
//linear part
// angular part
//calculates error angle
// Create angular atom
//__SPU__
//prepare constraint
//test linear limits
//test angular limits
//pre-allocate all 6
// for stability better to solve angular limits first
// leave old version for compatibility
//prepare constraint
// for stability better to solve angular limits first
// leave old version for compatibility
//	int row = 0;
//solve linear limits
// re-use rotational motor code
// rotations around orthos to current axis
//solve angular limits
// if the joint is powered, or has joint limits, add in the extra row
// get vector from bodyB to frameB in WCS
// get its projection to constraint axis
// get vector directed from bodyB to constraint axis (and orthogonal to it)
// same for bodyA
// get desired offset between frames A and B along constraint axis
// desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis
// get offset vectors relA and relB
// Linear Torque Decoupling vector
// if we're limited low and high simultaneously, the joint motor is
// ineffective
// limited low and high simultaneously
// deal with bounce
// calculate joint velocity
//make sure that if no body -> angVelB == zero vec
//                        if (body1)
//make sure that if no body -> angVelB == zero vec
//                        if (body1)
// only apply bounce if the velocity is incoming, and if the
// resulting c[] exceeds what we already have.
///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
///return the local value of parameter
// we want right coordinate system
// now get constraint frame in local coordinate systems
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btGeneric6DofSpring2Constraint.cpp
/*
//continuousphysics.com/Bullet/
/*
/// 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/// Added support for generic constraint solver through getInfo1/getInfo2 methods
/*
//gimpact.sf.net
///not providing rigidbody A means implicitly using worldspace for body A
// MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
// rot =  cy*cz          -cy*sz           sy
//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
// rot =  cy*cz          -sz           sy*cz
//        cy*cx*sz+sx*sy  cx*cz        sy*cx*sz-cy*sx
//        cy*sx*sz-cx*sy  sx*cz        sy*sx*sz+cx*cy
// rot =  cy*cz+sy*sx*sz  cz*sy*sx-cy*sz  cx*sy
//        cx*sz           cx*cz           -sx
//        cy*sx*sz-cz*sy  sy*sz+cy*cz*sx  cy*cx
// rot =  cy*cz   sy*sx-cy*cx*sz   cx*sy+cy*sz*sx
//        sz           cz*cx           -cz*sx
//        -cz*sy  cy*sx+cx*sy*sz   cy*cx-sy*sz*sx
// rot =  cz*cy-sz*sx*sy    -cx*sz   cz*sy+cy*sz*sx
//        cy*sz+cz*sx*sy     cz*cx   sz*sy-cz*xy*sx
//        -cx*sy              sx     cx*cy
// rot =  cz*cy   cz*sy*sx-cx*sz   sz*sx+cz*cx*sy
//        cy*sz   cz*cx+sz*sy*sx   cx*sz*sy-cz*sx
//        -sy          cy*sx         cy*cx
// in euler angle mode we do not actually constrain the angular velocity
// along the axes axis[0] and axis[2] (although we do use axis[1]) :
//
//    to get			constrain w2-w1 along		...not
//    ------			---------------------		------
//    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
//    d(angle[1])/dt = 0	ax[1]
//    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
//
// constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
// to prove the result for angle[0], write the expression for angle[0] from
// GetInfo1 then take the derivative. to prove this for angle[2] it is
// easier to take the euler rate expression for d(angle[2])/dt with respect
// to the components of w and set that to 0.
//Is this the "line of nodes" calculation choosing planes YZ (B coordinate system) and xy (A coordinate system)? (http://en.wikipedia.org/wiki/Euler_angles)
//The two planes are non-homologous, so this is a TaitBryan angle formalism and not a proper Euler
//Extrinsic rotations are equal to the reversed order intrinsic rotations so the above xyz extrinsic rotations (axes are fixed) are the same as the zy'x" intrinsic rotations (axes are refreshed after each rotation)
//that is why xy and YZ planes are chosen (this will describe a zy'x" intrinsic rotation) (see the figure on the left at http://en.wikipedia.org/wiki/Euler_angles under TaitBryan angles)
// x' = Nperp = N.cross(axis2)
// y' = N = axis2.cross(axis0)
// z' = z
//
// x" = X
// y" = y'
// z" = ??
//in other words:
//first rotate around z
//second rotate around y'= z.cross(X)
//third rotate around x" = X
//Original XYZ extrinsic rotation order.
//Planes: xy and YZ normals: z, X.  Plane intersection (N) is z.cross(X)
//planes: xz,ZY normals: y, X
//first rotate around y
//second rotate around z'= y.cross(X)
//third rotate around x" = X
//planes: yx,XZ normals: z, Y
//first rotate around z
//second rotate around x'= z.cross(Y)
//third rotate around y" = Y
//planes: yz,ZX normals: x, Y
//first rotate around x
//second rotate around z'= x.cross(Y)
//third rotate around y" = Y
//planes: zx,XY normals: y, Z
//first rotate around y
//second rotate around x'= y.cross(Z)
//third rotate around z" = Z
//planes: zy,YX normals: x, Z
//first rotate around x
//second rotate around y' = x.cross(Z)
//third rotate around z" = Z
//prepare constraint
//test linear limits
//test angular limits
// for stability better to solve angular limits first
//solve linear limits
// re-use rotational motor code
//rotAllowed is a bit of a magic from the original 6dof. The calculation of it here is something that imitates the original behavior as much as possible.
// rotations around orthos to current axis (it is used only when one of the body is static)
//order of rotational constraint rows
// get vector from bodyB to frameB in WCS
// same for bodyA
//btScalar cfm = 1.0 / ((1.0/info->fps)*limot->m_springStiffness+ limot->m_springDamping);
//if(cfm > 0.99999)
//	cfm = 0.99999;
//btScalar erp = (1.0/info->fps)*limot->m_springStiffness / ((1.0/info->fps)*limot->m_springStiffness + limot->m_springDamping);
//info->m_constraintError[srow] = info->fps * erp * error * (rotational ? -1.0 : 1.0);
//info->m_lowerLimit[srow] = -SIMD_INFINITY;
//info->m_upperLimit[srow] = SIMD_INFINITY;
//limit stiffness (the spring should not be sampled faster that the quarter of its angular frequency)
//avoid damping that would blow up the spring
// after the spring force affecting the body(es) the new velocity will be
// vel + f / m * (rotational ? -1 : 1)
// so in theory this should be set here for m_constraintError
// (with m_constraintError we set a desired velocity for the affected body(es))
// however in practice any value is fine as long as it is greater then the "proper" velocity,
// because the m_lowerLimit and the m_upperLimit will determinate the strength of the final pulling force
// so it is much simpler (and more robust) just to simply use inf (with the proper sign)
// (Even with our best intent the "new" velocity is only an estimation. If we underestimate
// the "proper" velocity that will weaken the spring, however if we overestimate it, it doesn't
// matter, because the solver will limit it according the force limit)
// you may also wonder what if the current velocity (vel) so high that the pulling force will not change its direction (in this iteration)
// will we not request a velocity with the wrong direction ?
// and the answer is not, because in practice during the solving the current velocity is subtracted from the m_constraintError
// so the sign of the force that is really matters
//override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
//If no axis is provided, it uses the default axis for this constraint.
//return the local value of parameter
// we want right coordinate system
// now get constraint frame in local coordinate systems
//wrap between -PI and PI, see also
//https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi
// handle boundary cases resulted from floating-point cut off:
//////////////////////////// btRotationalLimitMotor2 ////////////////////////////////////
//we can't normalize the angles here because we would lost the sign that we use later, but it doesn't seem to be a problem
//////////////////////////// btTranslationalLimitMotor2 ////////////////////////////////////
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btGeneric6DofSpringConstraint.cpp
/*
// it is assumed that calculateTransforms() have been called before this call
//btVector3 relVel = m_rbB.getLinearVelocity() - m_rbA.getLinearVelocity();
// get current position of constraint
// calculate difference
// spring force is (delta * m_stiffness) according to Hooke's Law
// get current position of constraint
// calculate difference
// spring force is (-delta * m_stiffness) according to Hooke's Law
// this will be called by constraint solver at the constraint setup stage
// set current motor parameters
// do the rest of job for constraint setup
// we want right coordinate system
// now get constraint frame in local coordinate systems
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btHinge2Constraint.cpp
/*
// constructor
// anchor, axis1 and axis2 are in world coordinate system
// axis1 must be orthogonal to axis2
// build frame basis
// 6DOF constraint uses Euler angles and to define limits
// it is assumed that rotational order is :
// Z - first, allowed limits are (-PI,PI);
// new position of Y - second (allowed limits are (-PI/2 + epsilon, PI/2 - epsilon), where epsilon is a small positive number
// used to prevent constraint from instability on poles;
// new position of X, allowed limits are (-PI,PI);
// So to simulate ODE Universal joint we should use parent axis as Z, child axis as Y and limit all other DOFs
// Build the frame in world coordinate system first
// we want right coordinate system
// now get constraint frame in local coordinate systems
// sei limits
// like front wheels of a car
// enable suspension
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btHingeConstraint.cpp
/*
//continuousphysics.com/Bullet/
//#define HINGE_USE_OBSOLETE_SOLVER false
// since no frame is given, assume this to be zero angle and just pick rb transform axis
//start with free
// since no frame is given, assume this to be zero angle and just pick rb transform axis
// fixed axis in worldspace
//start with free
//start with free
///not providing rigidbody B means implicitly using worldspace for body B
//start with free
//calculate two perpendicular jointAxis, orthogonal to hingeAxis
//these two jointAxis require equal angular velocities for both bodies
//this is unused for now, it's a todo
// clear accumulator
// test angular limit
//Compute K = J*W*J' for hinge axis
//__SPU__
//update m_accumulatedAngle
// Fixed 3 linear + 2 angular
//always add the row, to avoid computation (data is not available yet)
//prepare constraint
// limit 3rd anguar as well
//always add the 'limit' row, to avoid computation (data is not available yet)
// Fixed 3 linear + 2 angular
///the regular (virtual) implementation getInfo2 already performs 'testLimit' during getInfo1, so we need to do it now
// transforms in world space
// pivot point
//#if 0
// linear (all fixed)
// linear RHS
// make rotations around X and Y equal
// the hinge axis should be the only unconstrained
// rotational axis, the angular velocity of the two bodies perpendicular to
// the hinge axis should be equal. thus the constraint equations are
//    p*w1 - p*w2 = 0
//    q*w1 - q*w2 = 0
// where p and q are unit vectors normal to the hinge axis, and w1 and w2
// are the angular velocity vectors of the two bodies.
// get hinge axis (Z)
// get 2 orthos to hinge axis (X, Y)
// set the two hinge angular rows
// compute the right hand side of the constraint equation. set relative
// body velocities along p and q to bring the hinge back into alignment.
// if ax1,ax2 are the unit length hinge axes as computed from body1 and
// body2, we need to rotate both bodies along the axis u = (ax1 x ax2).
// if `theta' is the angle between ax1 and ax2, we need an angular velocity
// along u to cover angle erp*theta in one step :
//   |angular_velocity| = angle/time = erp*theta / stepsize
//                      = (erp*fps) * theta
//    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
//                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
// ...as ax1 and ax2 are unit length. if theta is smallish,
// theta ~= sin(theta), so
//    angular_velocity  = (erp*fps) * (ax1 x ax2)
// ax1 x ax2 is in the plane space of ax1, so we project the angular
// velocity to p and q to find the right hand side.
// check angular limits
// last filled row
// if the hinge has joint limits or motor, add in the extra row
// the joint motor is ineffective
// limited low and high simultaneously
// low limit
// high limit
// bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
// only apply bounce if the velocity is incoming, and if the
// resulting c[] exceeds what we already have.
// low limit
// high limit - all those computations are reversed
// if(limit)
// if angular limit or powered
//	btScalar angle = btAtan2Fast(swingAxis.dot(refAxis0), swingAxis.dot(refAxis1));
// Compute limit information
// convert target from body to constraint space
// extract "pure" hinge component
// compute angular target, clamped to limits
// long way around. flip quat and recalculate.
// compute angular velocity
// transforms in world space
// pivot point
//	btVector3 pivotAInW = trA.getOrigin();
//	btVector3 pivotBInW = trB.getOrigin();
// difference between frames in WCS
// now get weight factors depending on masses
// get the desired direction of hinge axis
// as weighted sum of Z-orthos of frameA and frameB in WCS
// fill first 3 rows
// we want: velA + wA x relA == velB + wB x relB
// last filled row
// get vector from bodyB to frameB in WCS
// get its projection to hinge axis
// get vector directed from bodyB to hinge axis (and orthogonal to it)
// same for bodyA
// get offset vectors relA and relB
// now choose average ortho to hinge axis
// make one more ortho
// fill three rows
// to make constraint between static and dynamic objects more rigid
// remove wA (or wB) from equation if angular limit is hit
// to make constraint between static and dynamic objects more rigid
// remove wA (or wB) from equation
// compute three elements of right hand side
// the hinge axis should be the only unconstrained
// rotational axis, the angular velocity of the two bodies perpendicular to
// the hinge axis should be equal. thus the constraint equations are
//    p*w1 - p*w2 = 0
//    q*w1 - q*w2 = 0
// where p and q are unit vectors normal to the hinge axis, and w1 and w2
// are the angular velocity vectors of the two bodies.
// compute the right hand side of the constraint equation. set relative
// body velocities along p and q to bring the hinge back into alignment.
// if ax1A,ax1B are the unit length hinge axes as computed from bodyA and
// bodyB, we need to rotate both bodies along the axis u = (ax1 x ax2).
// if "theta" is the angle between ax1 and ax2, we need an angular velocity
// along u to cover angle erp*theta in one step :
//   |angular_velocity| = angle/time = erp*theta / stepsize
//                      = (erp*fps) * theta
//    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
//                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
// ...as ax1 and ax2 are unit length. if theta is smallish,
// theta ~= sin(theta), so
//    angular_velocity  = (erp*fps) * (ax1 x ax2)
// ax1 x ax2 is in the plane space of ax1, so we project the angular
// velocity to p and q to find the right hand side.
//??
// check angular limits
// last filled row
// if the hinge has joint limits or motor, add in the extra row
// the joint motor is ineffective
// limited low and high simultaneously
// low limit
// high limit
// bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
// only apply bounce if the velocity is incoming, and if the
// resulting c[] exceeds what we already have.
// low limit
// high limit - all those computations are reversed
// if(limit)
// if angular limit or powered
///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
///return the local value of parameter
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btNNCGConstraintSolver.cpp
/*
//continuousphysics.com/Bullet/
/*bodies */, int /*numBodies*/, btPersistentManifold** /*manifoldPtr*/, int /*numManifolds*/, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* /*debugDrawer*/)
// uncomment this for a bit less random ((iteration & 7) == 0)
//contact/friction constraints are not solved more than
// deltaflengthsqrprev can be 0 only if the solver solved the problem exactly in the previous iteration. In this case we should have quit, but mainly for debug reason with this 'hack' it is now allowed to continue the calculation
///solve all contact constraints
//SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
//solve the friction constraints after all contact constraints, don't interleave them
///solve all friction constraints
// deltaflengthsqrprev can be 0 only if the solver solved the problem exactly in the previous iteration. In this case we should have quit, but mainly for debug reason with this 'hack' it is now allowed to continue the calculation
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btPoint2PointConstraint.cpp
/*
//continuousphysics.com/Bullet/
///we need it for both methods
//retrieve matrices
// anchor points in global coordinates with respect to body PORs.
// set jacobian
//	btVector3 a2n = -a2;
// set right hand side
//printf("info->m_constraintError[%d]=%f\n",j,info->m_constraintError[j]);
//
///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
///return the local value of parameter
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btSequentialImpulseConstraintSolver.cpp
/*
//continuousphysics.com/Bullet/
//#define COMPUTE_IMPULSE_DENOM 1
//#define BT_ADDITIONAL_DEBUG
//It is not necessary (redundant) to refresh contact manifolds, this refresh has been moved to the collision algorithms.
//#include "btJacobianEntry.h"
//#include "btSolverBody.h"
//#include "btSolverConstraint.h"
//for memset
//#define VERBOSE_RESIDUAL_PRINTF 1
///This is the scalar reference implementation of solving a single constraint row, the innerloop of the Projected Gauss Seidel/Sequential Impulse constraint solver
///Below are optional SSE2 and SSE4/FMA3 versions. We assume most hardware has SSE2. For SSE4/FMA3 we perform a CPU feature check.
//	const btScalar delta_rel_vel	=	deltaVel1Dotn-deltaVel2Dotn;
// a*b + c
// -(a*b) + c
// USE_FMA3
// a*b + c
// -(a*b) + c
// USE_FMA
// c + a*b
// c - a*b
// Project Gauss Seidel or the equivalent Sequential Impulse
// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
// sum
// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
//BT_ALLOW_SSE4
//USE_SIMD
// Project Gauss Seidel or the equivalent Sequential Impulse
//BT_ALLOW_SSE4
//USE_SIMD
//BT_ALLOW_SSE4
//USE_SIMD
//See ODE: adam's all-int straightforward(?) dRandInt (0..n-1)
// seems good; xor-fold and modulus
// note: probably more aggressive than it needs to be -- might be
//       able to get away without one or two of the innermost branches.
//printf("rel_vel =%f\n", rel_vel);
// transform to local coordinates
//apply anisotropic friction
// ... and transform it back to global coordinates
//		btScalar positionalError = 0.f;
//		btScalar positionalError = 0.f;
// dynamic body
// Dynamic bodies can only be in one island, so it's safe to write to the companionId
//
// NOTE: must test for kinematic before static because some kinematic objects also
//   identify as "static"
//
// Kinematic bodies can be in multiple islands at once, so it is a
// race condition to write to them, so we use an alternate method
// to record the solverBodyId
// if no table entry yet,
// create a table entry for this body
// Incorrectly set collision object flags can degrade performance in various ways.
//it could be a multibody link collider
// all fixed bodies (inf mass) get mapped to a single solver id
// BT_THREADSAFE
//body has already been converted
//convert both active and kinematic objects (for their velocity)
//			return 0;//assume first one is a fixed solver body
// BT_THREADSAFE
//	const btVector3& pos1 = cp.getPositionWorldOnA();
//	const btVector3& pos2 = cp.getPositionWorldOnB();
//			btVector3 rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin();
//			btVector3 rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();
//rel_pos1 = pos1 - bodyA->getWorldTransform().getOrigin();
//rel_pos2 = pos2 - bodyB->getWorldTransform().getOrigin();
//cfm = 1 /       ( dt * kp + kd )
//erp = dt * kp / ( dt * kp + kd )
//COMPUTE_IMPULSE_DENOM
//			btVector3 vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : btVector3(0,0,0);
///warm starting (or zero if disabled)
// * damping;
//combine position and velocity into rhs
//-solverConstraint.m_contactNormal1.dot(bodyA->m_externalForce*bodyA->m_invMass-bodyB->m_externalForce/bodyB->m_invMass)*solverConstraint.m_jacDiagABInv;
//split position and velocity into rhs and m_rhsPenetration
//	btRigidBody* bodyA = btRigidBody::upcast(colObj0);
//	btRigidBody* bodyB = btRigidBody::upcast(colObj1);
///avoid collision response between two static objects
/////setup the friction constraints
///Bullet has several options to set the friction directions
///By default, each contact has only a single friction direction that is recomputed automatically very frame
///based on the relative linear velocity.
///If the relative velocity it zero, it will automatically compute a friction direction.
///You can also enable two friction directions, using the SOLVER_USE_2_FRICTION_DIRECTIONS.
///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
///
///If you choose SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
///
///The user can manually override the friction directions for certain contacts using a contact callback,
///and use contactPoint.m_contactPointFlags |= BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED
///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
///this will give a conveyor belt effect
///
//??
//			btCollisionObject* colObj0=0,*colObj1=0;
// these vectors are already cleared in initSolverBody, no need to redundantly clear again
//bodyAPtr->internalGetDeltaLinearVelocity().setValue(0.f,0.f,0.f);
//bodyAPtr->internalGetDeltaAngularVelocity().setValue(0.f,0.f,0.f);
//bodyAPtr->internalGetPushVelocity().setValue(0.f,0.f,0.f);
//bodyAPtr->internalGetTurnVelocity().setValue(0.f,0.f,0.f);
//bodyBPtr->internalGetDeltaLinearVelocity().setValue(0.f,0.f,0.f);
//bodyBPtr->internalGetDeltaAngularVelocity().setValue(0.f,0.f,0.f);
//bodyBPtr->internalGetPushVelocity().setValue(0.f,0.f,0.f);
//bodyBPtr->internalGetTurnVelocity().setValue(0.f,0.f,0.f);
//check this
///the size of btSolverConstraint needs be a multiple of btScalar
///finalize the constraint setup
//sign of normal?
//todo: get from globalInfo?
//already filled in by getConstraintInfo2
//calculate the total number of contraint rows
///setup the btSolverConstraints
// BT_THREADSAFE
//btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
//initSolverBody(&fixedBody,0);
// if solver mode has changed,
// update solver functions to use SIMD or non-SIMD
//make sure that dynamic bodies exist for all (enabled) constraints
//make sure that dynamic bodies exist for all contact manifolds
//BT_ADDITIONAL_DEBUG
//convert all bodies
//	btContactSolverInfo info = infoGlobal;
///@todo: use stack allocator for such temporarily memory, same for solver bodies/constraints
/*bodies */, int /*numBodies*/, btPersistentManifold** /*manifoldPtr*/, int /*numManifolds*/, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* /*debugDrawer*/)
// uncomment this for a bit less random ((iteration & 7) == 0)
//contact/friction constraints are not solved more than
///solve all joint constraints
///solve all contact constraints
//SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
//solve the friction constraints after all contact constraints, don't interleave them
///solve all friction constraints
///this is a special step to resolve penetrations (just for contacts)
//for ( int iteration = maxIterations-1  ; iteration >= 0;iteration--)
//	float f = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
//	printf("pt->m_appliedImpulseLateral1 = %f\n", f);
//printf("pt->m_appliedImpulseLateral1 = %f\n", pt->m_appliedImpulseLateral1);
//do a callback here?
/*RGM ???? */
/// btSequentialImpulseConstraintSolver Sequentially applies impulses
/*dispatcher*/)
//you need to provide at least some bodies
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btSequentialImpulseConstraintSolverMt.cpp
/*
//continuousphysics.com/Bullet/
// some task schedulers don't like nested loops
// setup rolling friction constraints
// put the largest axis first
// disable constraint
// setup friction constraints
//	setupFrictionConstraint(solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal, desiredVelocity, cfmSlip);
///Bullet has several options to set the friction directions
///By default, each contact has only a single friction direction that is recomputed automatically very frame
///based on the relative linear velocity.
///If the relative velocity it zero, it will automatically compute a friction direction.
///You can also enable two friction directions, using the SOLVER_USE_2_FRICTION_DIRECTIONS.
///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
///
///If you choose SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
///
///The user can manually override the friction directions for certain contacts using a contact callback,
///and set the cp.m_lateralFrictionInitialized to true
///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
///this will give a conveyor belt effect
///
//??
//
// getOrInitSolverBody is threadsafe only for a single thread per solver (with potentially multiple solvers)
//
// getOrInitSolverBodyThreadsafe -- attempts to be fully threadsafe (however may affect determinism)
//
// dynamic body
// Dynamic bodies can only be in one island, so it's safe to write to the companionId
// now that we have the lock, check again
//
// NOTE: must test for kinematic before static because some kinematic objects also
//   identify as "static"
//
// Kinematic bodies can be in multiple islands at once, so it is a
// race condition to write to them, so we use an alternate method
// to record the solverBodyId
// now that we have the lock, check again
// if no table entry yet,
// need to acquire both locks
// now that we have the lock, check again
// create a table entry for this body
// all fixed bodies (inf mass) get mapped to a single solver id
// now that we have the lock, check again
// A contact manifold between 2 static object should not exist!
// check the collision flags of your objects if this assert fires.
// Incorrectly set collision object flags can degrade performance in various ways.
// possibly parallel part
// allocate the friction constraints
// allocate rolling friction constraints
// allocate 3 (although we may use only 2 sometimes)
// indicate there is no rolling friction for this contact point
// = m_manifoldCachedInfoArray;
/* DISABLES CODE */ (false))
// sequential
// may alter ordering of bodies which affects determinism
// serial part
// if we need to reallocate, reserve some extra so we don't have to reallocate again next frame
//calculate the total number of contraint rows
///setup the btSolverConstraints
// non-batched
// uncomment this for a bit less random ((iteration & 7) == 0)
///solve all joint constraints
// this loop is only used for cone-twist constraints,
// it would be nice to skip this loop if none of the constraints need it
// solve all contact, contact-friction, and rolling friction constraints interleaved
//SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
// don't interleave them
// solve all contact constraints
// solve all contact friction constraints
// solve all rolling friction constraints
// apply sliding friction
// apply rolling friction
// apply penetration constraint
// apply sliding friction
// apply rolling friction
// randomize ordering of phases
// for each batch,
// randomize ordering of constraints within the batch
// randomize ordering of joint constraints
//contact/friction constraints are not solved more than numIterations
//
// We do not generate batches for rolling friction constraints. We assume that
// one of two cases is true:
//
//  1. either most bodies in the simulation have rolling friction, in which case we can use the
//     batches for contacts and use a lookup table to translate contact indices to rolling friction
//     (ignoring any contact indices that don't map to a rolling friction constraint). As long as
//     most contacts have a corresponding rolling friction constraint, this should parallelize well.
//
//  -OR-
//
//  2. few bodies in the simulation have rolling friction, so it is not worth trying to use the
//     batches from contacts as most of the contacts won't have corresponding rolling friction
//     constraints and most threads would end up doing very little work. Most of the time would
//     go to threading overhead, so we don't bother with threading.
//
// use batching if there are many rolling friction constraints
// no batching, also ignores SOLVER_RANDMIZE_ORDER
//for ( int iContact = iBegin; iContact < iEnd; ++iContact)
//{
//    const btSolverConstraint& contactConstraint = m_tmpSolverContactConstraintPool[ iContact ];
//    btManifoldPoint* pt = (btManifoldPoint*) contactConstraint.m_originalContactPoint;
//    btAssert( pt );
//    pt->m_appliedImpulse = contactConstraint.m_appliedImpulse;
//    pt->m_appliedImpulseLateral1 = m_tmpSolverContactFrictionConstraintPool[ contactConstraint.m_frictionIndex ].m_appliedImpulse;
//    if ( m_numFrictionDirections == 2 )
//    {
//        pt->m_appliedImpulseLateral2 = m_tmpSolverContactFrictionConstraintPool[ contactConstraint.m_frictionIndex + 1 ].m_appliedImpulse;
//    }
//}
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btSliderConstraint.cpp
/*
//continuousphysics.com/Bullet/
/*
///not providing rigidbody A means implicitly using worldspace for body A
//	m_frameInA.getOrigin() = m_rbA.getCenterOfMassTransform()(m_frameInA.getOrigin());
// Fixed 2 linear + 2 angular
//prepare constraint
// limit 3rd linear as well
// limit 3rd angular as well
// Fixed 2 linear + 2 angular + 1 limit (even if not used)
// along X
//linear part
//		btScalar rot = btAtan2Fast(axisB0.dot(axisA1), axisB0.dot(axisA0));
// difference between frames in WCS
// now get weight factors depending on masses
// get the desired direction of slider axis
// as weighted sum of X-orthos of frameA and frameB in WCS
// construct two orthos to slider axis
// old way - use frameA
// get 2 orthos to slider axis (Y, Z)
// make rotations around these orthos equal
// the slider axis should be the only unconstrained
// rotational axis, the angular velocity of the two bodies perpendicular to
// the slider axis should be equal. thus the constraint equations are
//    p*w1 - p*w2 = 0
//    q*w1 - q*w2 = 0
// where p and q are unit vectors normal to the slider axis, and w1 and w2
// are the angular velocity vectors of the two bodies.
// compute the right hand side of the constraint equation. set relative
// body velocities along p and q to bring the slider back into alignment.
// if ax1A,ax1B are the unit length slider axes as computed from bodyA and
// bodyB, we need to rotate both bodies along the axis u = (ax1 x ax2).
// if "theta" is the angle between ax1 and ax2, we need an angular velocity
// along u to cover angle erp*theta in one step :
//   |angular_velocity| = angle/time = erp*theta / stepsize
//                      = (erp*fps) * theta
//    angular_velocity  = |angular_velocity| * (ax1 x ax2) / |ax1 x ax2|
//                      = (erp*fps) * theta * (ax1 x ax2) / sin(theta)
// ...as ax1 and ax2 are unit length. if theta is smallish,
// theta ~= sin(theta), so
//    angular_velocity  = (erp*fps) * (ax1 x ax2)
// ax1 x ax2 is in the plane space of ax1, so we project the angular
// velocity to p and q to find the right hand side.
//	btScalar k = info->fps * info->erp * getSoftnessOrthoAng();
// last filled row
// next two rows.
// we want: velA + wA x relA == velB + wB x relB ... but this would
// result in three equations, so we project along two orthos to the slider axis
// get vector from bodyB to frameB in WCS
// get its projection to slider axis
// get vector directed from bodyB to slider axis (and orthogonal to it)
// same for bodyA
// get desired offset between frames A and B along slider axis
// desired vector from projection of center of bodyA to projection of center of bodyB to slider axis
// get offset vectors relA and relB
// now choose average ortho to slider axis
// make one more ortho
// fill two rows
// to make constraint between static and dynamic objects more rigid
// remove wA (or wB) from equation if angular limit is hit
// old way - maybe incorrect if bodies are not on the slider axis
// see discussion "Bug in slider constraint" http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=4024&start=0
// compute two elements of right hand side
//	k = info->fps * info->erp * getSoftnessOrthoLin();
// check linear limits
// if the slider has joint limits or motor, add in the extra row
// linear torque decoupling step:
//
// we have to be careful that the linear constraint forces (+/- ax1) applied to the two bodies
// do not create a torque couple. in other words, the points that the
// constraint force is applied at must lie along the same ax1 axis.
// a torque couple will result in limited slider-jointed free
// bodies from gaining angular momentum.
// this is needed only when bodyA and bodyB are both dynamic.
// The old way. May be incorrect if bodies are not on the slider axis
// Linear Torque Decoupling vector (a torque)
// right-hand part
// the joint motor is ineffective
// limited low and high simultaneously
// low limit
// high limit
// bounce (we'll use slider parameter abs(1.0 - m_dampingLimLin) for that)
// only apply bounce if the velocity is incoming, and if the
// resulting c[] exceeds what we already have.
// low limit
// high limit - all those computations are reversed
// if(limit)
// if linear limit
// check angular limits
// if the slider has joint limits, add in the extra row
// the joint motor is ineffective
// limited low and high simultaneously
// low limit
// high limit
// bounce (we'll use slider parameter abs(1.0 - m_dampingLimAng) for that)
// only apply bounce if the velocity is incoming, and if the
// resulting c[] exceeds what we already have.
// low limit
// high limit - all those computations are reversed
// if(limit)
// if angular limit or powered
///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
///return the local value of parameter
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btSolve2LinearConstraint.cpp
/*
//continuousphysics.com/Bullet/
//this jacobian entry could be re-used for all iterations
//const btScalar vel0 = jacA.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
//const btScalar vel1 = jacB.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
//	btScalar penetrationImpulse = (depth*contactTau*timeCorrection)  * massTerm;//jacDiagABInv
// calculate rhs (or error) terms
// dC/dv * dv = -C
// jacobian * impulse = -error
//
//impulse = jacobianInverse * -error
// inverting 2x2 symmetric system (offdiagonal are equal!)
//
//imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
//imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * - nonDiag * invDet;
//[a b]								  [d -c]
//[c d] inverse = (1 / determinant) * [-b a] where determinant is (ad - bc)
//[jA nD] * [imp0] = [dv0]
//[nD jB]   [imp1]   [dv1]
//this jacobian entry could be re-used for all iterations
//const btScalar vel0 = jacA.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
//const btScalar vel1 = jacB.getRelativeVelocity(linvelA,angvelA,linvelB,angvelB);
// calculate rhs (or error) terms
// dC/dv * dv = -C
// jacobian * impulse = -error
//
//impulse = jacobianInverse * -error
// inverting 2x2 symmetric system (offdiagonal are equal!)
//
//imp0 = dv0 * jacA.getDiagonal() * invDet + dv1 * -nonDiag * invDet;
//imp1 = dv1 * jacB.getDiagonal() * invDet + dv0 * - nonDiag * invDet;
//[a b]								  [d -c]
//[c d] inverse = (1 / determinant) * [-b a] where determinant is (ad - bc)
//[jA nD] * [imp0] = [dv0]
//[nD jB]   [imp1]   [dv1]
//both positive
// now imp0>0 imp1<0
// now imp0>0 imp1<0
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btTypedConstraint.cpp
/*
//continuousphysics.com/Bullet/
///fills the dataBuffer and returns the struct name (and 0 on failure)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\ConstraintSolver\btUniversalConstraint.cpp
/*
// constructor
// anchor, axis1 and axis2 are in world coordinate system
// axis1 must be orthogonal to axis2
// build frame basis
// 6DOF constraint uses Euler angles and to define limits
// it is assumed that rotational order is :
// Z - first, allowed limits are (-PI,PI);
// new position of Y - second (allowed limits are (-PI/2 + epsilon, PI/2 - epsilon), where epsilon is a small positive number
// used to prevent constraint from instability on poles;
// new position of X, allowed limits are (-PI,PI);
// So to simulate ODE Universal joint we should use parent axis as Z, child axis as Y and limit all other DOFs
// Build the frame in world coordinate system first
// we want right coordinate system
// now get constraint frame in local coordinate systems
// sei limits
// we want right coordinate system
// now get constraint frame in local coordinate systems
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Dynamics\btDiscreteDynamicsWorld.cpp
/*
//bulletphysics.org
//collision detection
//rigidbody & constraints
///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
//also add all non-contact constraints/joints for this island
//find the first constraint for this island
//count the number of constraints in this island
//printf("deferred\n");
//only delete it when we created it
///would like to iterate over m_nonStaticRigidBodies, but unfortunately old API allows
///to switch status _after_ adding kinematic objects to the world
///fix it for Bullet 3.x release
//to calculate velocities next frame
///@todo: iterate over awake simulation islands!
//need to check if next line is ok
//it might break backward compatibility (people applying forces on sleeping objects get never cleared and accumulate on wake-up
///apply gravity, call this once per timestep
///@todo: iterate over awake simulation islands!
//we need to call the update at least once, even for sleeping objects
//otherwise the 'graphics' transform never updates properly
///@todo: add 'dirty' flag
//if (body->getActivationState() != ISLAND_SLEEPING)
//	BT_PROFILE("synchronizeMotionStates");
//iterate  over all collision objects
//iterate over all active rigid bodies
//fixed timestep with interpolation
//variable timestep
//process some debugging flags
//clamp the number of substeps, to prevent simulation grinding spiralling down to a halt
//BT_NO_PROFILE
///apply gravity, predict motion
///perform collision detection
///solve contact and other joint constraints
///CallbackTriggers();
///integrate transforms
///update vehicle simulation
//Make sure the two bodies of a type constraint are different (possibly add this to the btTypedConstraint constructor?)
//	btAssert(0);
/// solve all the constraints for this island
//merge islands based on speculative contact manifolds too
//Store the island id in each body
//ignore result if there is no contact response
//toB.getOrigin()-fromB.getOrigin();
//don't report time of impact for motion away from the contact normal (or causes minor penetration)
//don't collide with itself
///don't do CCD when the collision filters are not matching
//call needsResponse, see http://code.google.com/p/bullet/issues/detail?id=179
///don't do CCD when there are already contact points (touching contact/penetration)
///internal debugging variable. this value shouldn't be too high
//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
//printf("clamped integration to hit fraction = %f\n",fraction);
//don't apply the collision response right now, it will happen next frame
//if you really need to, you can uncomment next 3 lines. Note that is uses zero restitution.
//btScalar appliedImpulse = 0.f;
//btScalar depth = 0.f;
//appliedImpulse = resolveSingleCollision(body,(btCollisionObject*)sweepResults.m_hitCollisionObject,sweepResults.m_hitPointWorld,sweepResults.m_hitNormalWorld,getSolverInfo(), depth);
///this should probably be switched on by default, but it is not well tested yet
//if (pt.getDistance()>0 && combinedRestitution>0 && pt.m_appliedImpulse != 0.f)
//don't integrate/update velocities here, it happens in the constraint solver
//BT_NO_PROFILE
// that ideally should draw the same frame
//const btScalar length = btScalar(5);
///note: the code for D6_SPRING_2_CONSTRAINT_TYPE is identical to D6_CONSTRAINT_TYPE, the D6_CONSTRAINT_TYPE+D6_SPRING_CONSTRAINT_TYPE will likely become obsolete/deprecated at some stage
//serialize all collision objects
//BT_USE_DOUBLE_PRECISION
//BT_USE_DOUBLE_PRECISION
// Fill padding with zeros to appease msan.
//BT_USE_DOUBLE_PRECISION
//BT_USE_DOUBLE_PRECISION
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Dynamics\btDiscreteDynamicsWorldMt.cpp
/*
//bulletphysics.org
//collision detection
//rigidbody & constraints
///
/// btConstraintSolverPoolMt
///
// #if BT_THREADSAFE
// failed, try the next one
// create the solvers for me
// pass in fully constructed solvers (destructor will delete them)
// delete all solvers
///solve a group of constraints
///
/// btDiscreteDynamicsWorldMt
///
/// solve all the constraints for this island
//don't integrate/update velocities here, it happens in the constraint solver
// num of iterations per task for task scheduler
// num of iterations per task for task scheduler
// num of iterations per task for task scheduler
// tell Bullet's threads to sleep, so other threads can run
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Dynamics\btRigidBody.cpp
/*
//continuousphysics.com/Bullet/
//'temporarily' global variables
//moved to btCollisionObject
//todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities
//if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform
//printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());
///applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping
//On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74
//todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway
//#define USE_OLD_DAMPING_METHOD 1
//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
//Fg = m * a
// Convert to body coordinates
// Residual vector
// Jacobian
//	btMatrix3x3 Jinv = J.inverse();
//	btVector3 omega_div = Jinv*f;
// Single Newton-Raphson update
//Solve33(J, f);
// Back to world coordinates
// use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.
// calculate using implicit euler step so it's stable.
// use newtons method to find implicit solution for new angular velocity (w')
// f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0
// df/dw' = I + 1xIw'*step + w'xI*step
// one step of newton's method
//const btMatrix3x3 dfw_inv = dfw.inverse();
//dw = dfw_inv*fw;
/// clamp angular velocity. collision calculations will fail on higher angular velocities
///disable collision with the 'other' body
//don't add constraints that are already referenced
//btAssert(index == m_constraintRefs.size());
//don't remove constraints that are not referenced
///fills the dataBuffer and returns the struct name (and 0 on failure)
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Dynamics\btSimpleDynamicsWorld.cpp
/*
//continuousphysics.com/Bullet/
/*
///apply gravity, predict motion
///perform collision detection
///solve contact constraints
///integrate transforms
///@todo: iterate over awake simulation islands!
///@todo: iterate over awake simulation islands!
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Dynamics\btSimulationIslandManagerMt.cpp
/*
//continuousphysics.com/Bullet/
// for s_minimumContactManifoldsForBatching
//#include <stdio.h>
// rough estimate of the cost of a batch, used for merging
/// function object that routes calls to operator<
// append bodies
// append manifolds
// append constraints
// reset island pools
// check whether allocated islands are sorted by body capacity (largest to smallest)
// mark all islands free (but avoid deallocation)
// search for existing island
// if we've made a large enough batch,
// next time start a new batch
// need to allocate a batch island
// search for free island
// try to reuse a previously allocated island
// linear search for smallest island that can hold our bodies
// if found, shrink array while maintaining ordering
// no free island found, allocate
// TODO: change this to use the pool allocator
//we are going to sort the unionfind array, and store the element id in the size
//afterwards, we clean unionfind, to make sure no-one uses it anymore
//update the sleeping state for bodies, if all are sleeping
//int numSleeping = 0;
//				printf("error in island management\n");
//					printf("error in island management\n");
//					printf("error in island management\n");
// create explicit islands and add bodies to each
// find end index
// check if island is sleeping
// want to count the number of bodies before allocating the island to optimize memory usage of the Island structures
// add bodies to island
// walk all the manifolds, activating bodies touched by kinematic objects, and add each manifold to its Island
///@todo: check sleeping conditions!
//kinematic objects don't merge islands, but wake up all connected objects
//filtering for response
// scatter manifolds into various islands
// if island not sleeping,
// walk constraints
// scatter constraints into various islands
// if island is not sleeping,
// sort islands in order of decreasing batch size
// merge small islands to satisfy minimum batch size
// find first small batch island
// merge islands from the back of the list
// figure out how many islands we want to merge and find out how many bodies, manifolds and constraints we will have
// reserve space for these pointers to minimize reallocation
// merge islands
// shrink array to exclude the islands that were merged from
// serial dispatch
//
// if there are islands with many contacts, it may be faster to submit these
// large islands *serially* to a single parallel constraint solver, and then later
// submit the remaining smaller islands in parallel to multiple sequential solvers.
//
// Some task schedulers do not deal well with nested parallelFor loops. One implementation
// of OpenMP was actually slower than doing everything single-threaded. Intel TBB
// on the other hand, seems to do a pretty respectable job with it.
//
// When solving islands in parallel, the worst case performance happens when there
// is one very large island and then perhaps a smattering of very small
// islands -- one worker thread takes the large island and the remaining workers
// tear through the smaller islands and then sit idle waiting for the first worker
// to finish. Solving islands in parallel works best when there are numerous small
// islands, roughly equal in size.
//
// By contrast, the other approach -- the parallel constraint solver -- is only
// able to deliver a worthwhile speedup when the island is large. For smaller islands,
// it is difficult to extract a useful amount of parallelism -- the overhead of grouping
// the constraints into batches and sending the batches to worker threads can nullify
// any gains from parallelism.
//
// We take advantage of the fact the islands are sorted in order of decreasing size
// OK to submit the rest of the array in parallel
// serial dispatch to parallel solver for large islands (if any)
// parallel dispatch to sequential solvers for rest
///@todo: this is random access, it can be walked 'cache friendly'!
///@todo: check sleeping conditions!
//kinematic objects don't merge islands, but wake up all connected objects
//traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
// m_activeIslands array should now contain all non-sleeping Islands, and each Island should
// have all the necessary bodies, manifolds and constraints.
// if we want to merge islands with small batch counts,
// dispatch islands to solver
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBody.cpp
/*
//#include "Bullet3Common/b3Logging.h"
// #define INCLUDE_GYRO_TERM
// this is a squared velocity (m^2 s^-2)
// in seconds
// namespace
// rotates vectors in 'from' frame to vectors in 'to' frame
// vector from origin of 'from' frame to origin of 'to' frame, in 'to' coordinates
// top part of input vector
// bottom part of input vector
// top part of output vector
// bottom part of output vector
// namespace
//
// Implementation of class btMultiBody
//
/*deprecatedUseMultiDof*/)
/*deprecatedDisableParentCollision*/)
//
//
//
//
//
//
//
//
//
//m_dofCount for joint-space vels + m_dofCount^2 for "D" matrices + delta-pos vector (6 base "vels" + joint "vels")
//two 3-vectors (i.e. one six-vector) for each system dof	("h" matrices)
// 'result' is in frame i. transform it to frame parent(i)
// 'result' is now in the base frame. transform it to world frame
// world to base
// find position in parent frame, then transform to current frame
// Calculates the velocities of each link (and the base) in its local frame
// transform parent vel into this frame, store in omega[i+1], vel[i+1]
// now add qidot * shat_i
// TODO: would be better not to allocate memory here
// we will do the factor of 0.5 at the end
// TODO: would be better not to allocate memory here
//renamed it from vecMulVecTranspose (http://en.wikipedia.org/wiki/Outer_product); maybe it should be moved to btVector3 like dot and cross?
//
// Implement Featherstone's algorithm to calculate joint accelerations (q_double_dot)
// and the base linear & angular accelerations.
// We apply damping forces in this routine as well as any external forces specified by the
// caller (via addBaseForce etc).
// output should point to an array of 6 + num_links reals.
// Format is: 3 angular accelerations (in world frame), 3 linear accelerations (in world frame),
// num_links joint acceleration values.
// We added support for multi degree of freedom (multi dof) joints.
// In addition we also can compute the joint reaction forces. This is performed in a second pass,
// so that we can include the effect of the constraint solver forces (computed in the PGS LCP solver)
// Temporary matrices/vectors -- use scratch space from caller
// so that we don't have to keep reallocating every frame
//multidof? ("Y"s use it and it is used to store qdd) => 2 x m_dofCount
//btScalar * r_ptr = &scratch_r[0];
// "output" holds the q_double_dot results
// vhat_i  (top = angular, bottom = linear part)
//
// zhat_i^A
//
// chat_i  (note NOT defined for the base)
//
// Ihat_i^A.
// Cached 3x3 rotation matrices from parent frame to this frame.
// hhat_i, ahat_i
// hhat is NOT stored for the base (but ahat is)
//
// Y_i, invD_i
//
//aux variables
//spatial velocity due to the joint motion (i.e. without predecessors' influence)
//"D" matrix; it's dofxdof for each body so asingle 6x6 D matrix will do
//D^{-1} * Y [dofxdof x dofx1 = dofx1] <=> D^{-1} * u; better moved to buffers since it is recalced in calcAccelerationDeltasMultiDof; num_dof of btScalar would cover all bodies
//holds results of the SolveImatrix op; it is a spatial motion vector (accel)
//Y - h^{T} * a; it's dofx1 for each body so a single 6x1 temp is enough
//6 temporary spatial force vectors
//spatial transform from parent to child
//inertia matrix temp
/////////////////
// ptr to the joint accel part of the output
// Start of the algorithm proper.
// First 'upward' loop.
// Combines CompTreeLinkVelocities and InitTreeLinks from Mirtich.
//m_baseQuat assumed to be alias!?
//create the vector of spatial velocity of the base by transforming global-coor linear and angular velocities into base-local coordinates
//external forces
//adding damping terms (only)
//
//p += vhat x Ihat vhat - done in a simpler way
//
//init the spatial AB inertia (it has the simple form thanks to choosing local body frames origins at their COMs)
//
//
//
// now set vhat_i to its true value by doing
// vhat_i += qidot * shat_i
// remember vhat_i is really vhat_p(i) (but in current frame) at this point	=> we need to add velocity across the inboard joint
//
// vhat_i is vhat_p(i) transformed to local coors + the velocity across the i-th inboard joint
//spatVel[i+1] = fromParent * spatVel[parent+1] + spatJointVel;
// we can now calculate chat_i
// calculate zhat_i^A
//
//external forces
//
//adding damping terms (only)
// calculate Ihat_i^A
//init the spatial AB inertia (it has the simple form thanks to choosing local body frames origins at their COMs)
//
//
//
//p += vhat x Ihat vhat - done in a simpler way
//
//btVector3 temp = m_links[i].m_mass * spatVel[i+1].getAngular().cross(spatVel[i+1].getLinear());
////clamp parent's omega
//btScalar parOmegaMod = temp.length();
//btScalar parOmegaModMax = 1000;
//if(parOmegaMod > parOmegaModMax)
//	temp *= parOmegaModMax / parOmegaMod;
//zeroAccSpatFrc[i+1].addLinear(temp);
//printf("|zeroAccSpatFrc[%d]| = %.4f\n", i+1, temp.length());
//temp = spatCoriolisAcc[i].getLinear();
//printf("|spatCoriolisAcc[%d]| = %.4f\n", i+1, temp.length());
//printf("w[%d] = [%.4f %.4f %.4f]\n", i, vel_top_angular[i+1].x(), vel_top_angular[i+1].y(), vel_top_angular[i+1].z());
//printf("v[%d] = [%.4f %.4f %.4f]\n", i, vel_bottom_linear[i+1].x(), vel_bottom_linear[i+1].y(), vel_bottom_linear[i+1].z());
//printf("c[%d] = [%.4f %.4f %.4f]\n", i, coriolis_bottom_linear[i].x(), coriolis_bottom_linear[i].y(), coriolis_bottom_linear[i].z());
// 'Downward' loop.
// (part of TreeForwardDynamics in Mirtich.)
//
//
//unroll the loop?
//determine h*D^{-1}
//
//determine (h*D^{-1}) * h^{T}
//
//
// Second 'upward' loop
// (part of TreeForwardDynamics in Mirtich)
// now do the loop over the m_links
//	qdd = D^{-1} * (Y - h^{T}*apar) = (S^{T}*I*S)^{-1} * (tau - S^{T}*I*cor - S^{T}*zeroAccFrc - S^{T}*I*apar)
//	a = apar + cor + Sqdd
//or
//	qdd = D^{-1} * (Y - h^{T}*(apar+cor))
//	a = apar + Sqdd
//
//D^{-1} * (Y - h^{T}*apar)
//shift the reaction forces to the joint frame
//linear (force) component is the same
//shift the angular (torque, moment) component using the relative position,  m_links[i].m_dVector
// transform base accelerations back to the world frame.
/////////////////
//printf("q = [");
//printf("%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f ", m_baseQuat.x(), m_baseQuat.y(), m_baseQuat.z(), m_baseQuat.w(), m_basePos.x(), m_basePos.y(), m_basePos.z());
//for(int link = 0; link < getNumLinks(); ++link)
//	for(int dof = 0; dof < m_links[link].m_dofCount; ++dof)
//		printf("%.6f ", m_links[link].m_jointPos[dof]);
//printf("]\n");
////
//printf("qd = [");
//for(int dof = 0; dof < getNumDofs() + 6; ++dof)
//	printf("%.6f ", m_realBuf[dof]);
//printf("]\n");
//printf("qdd = [");
//for(int dof = 0; dof < getNumDofs() + 6; ++dof)
//	printf("%.6f ", output[dof]);
//printf("]\n");
/////////////////
// Final step: add the accelerations (times dt) to the velocities.
/////
//btScalar angularThres = 1;
//btScalar maxAngVel = 0.;
//bool scaleDown = 1.;
//for(int link = 0; link < m_links.size(); ++link)
//{
//	if(spatVel[link+1].getAngular().length() > maxAngVel)
//	{
//		maxAngVel = spatVel[link+1].getAngular().length();
//		scaleDown = angularThres / spatVel[link+1].getAngular().length();
//		break;
//	}
//}
//if(scaleDown != 1.)
//{
//	for(int link = 0; link < m_links.size(); ++link)
//	{
//		if(m_links[link].m_jointType == btMultibodyLink::eRevolute || m_links[link].m_jointType == btMultibodyLink::eSpherical)
//		{
//			for(int dof = 0; dof < m_links[link].m_dofCount; ++dof)
//				getJointVelMultiDof(link)[dof] *= scaleDown;
//		}
//	}
//}
/////
/////////////////////
//rot_from_parent[i+1] = btMatrix3x3(m_links[i].m_cachedRotParentToThis);    /// <- done
//rot_from_world[i+1] = rot_from_parent[i+1] * rot_from_world[parent+1];		/// <- done
// vhat_i = i_xhat_p(i) * vhat_p(i)
//nice alternative below (using operator *) but it generates temps
/////////////////////////////////////////////////////////////
// now set vhat_i to its true value by doing
// vhat_i += qidot * shat_i
// remember vhat_i is really vhat_p(i) (but in current frame) at this point	=> we need to add velocity across the inboard joint
///solve I * x = rhs, so the result = invI * rhs
// in the case of 0 m_links (i.e. a plain rigid body, not a multibody) rhs * invI is easier
/// Special routine for calculating the inverse of a spatial inertia matrix
///the 6x6 matrix is stored as 4 blocks of 3x3 matrices
//multiply result = invI * rhs
///solve I * x = rhs, so the result = invI * rhs
// in the case of 0 m_links (i.e. a plain rigid body, not a multibody) rhs * invI is easier
/// Special routine for calculating the inverse of a spatial inertia matrix
///the 6x6 matrix is stored as 4 blocks of 3x3 matrices
//multiply result = invI * rhs
// Temporary matrices/vectors -- use scratch space from caller
// so that we don't have to keep reallocating every frame
// zhat_i^A (scratch space)
// rot_from_parent (cached from calcAccelerations)
// hhat (cached), accel (scratch)
// hhat is NOT stored for the base (but ahat is)
// Y_i (scratch), invD_i (cached)
////////////////
//aux variables
//D^{-1} * Y [dofxdof x dofx1 = dofx1] <=> D^{-1} * u; better moved to buffers since it is recalced in calcAccelerationDeltasMultiDof; num_dof of btScalar would cover all bodies
//holds results of the SolveImatrix op; it is a spatial motion vector (accel)
//Y - h^{T} * a; it's dofx1 for each body so a single 6x1 temp is enough
//6 temporary spatial force vectors
/////////////////
// First 'upward' loop.
// Combines CompTreeLinkVelocities and InitTreeLinks from Mirtich.
// Fill in zero_acc
// -- set to force/torque on the base, zero otherwise
//test forces
// 'Downward' loop.
// (part of TreeForwardDynamics in Mirtich.)
// Zp += pXi * (Zi + hi*Yi/Di)
//
// ptr to the joint accel part of the output
// Second 'upward' loop
// (part of TreeForwardDynamics in Mirtich)
// now do the loop over the m_links
//
// transform base accelerations back to the world frame.
/////////////////
//printf("delta = [");
//for(int dof = 0; dof < getNumDofs() + 6; ++dof)
//	printf("%.2f ", output[dof]);
//printf("]\n");
/////////////////
// step position by adding dt * velocity
//btVector3 v = getBaseVel();
//m_basePos += dt * v;
//
//note: the !pqd case assumes m_realBuf holds with base velocity at 3,4,5 (should be wrapped for safety)
//
///////////////////////////////
//local functor for quaternion integration (to avoid error prone redundancy)
//"exponential map" based on btTransformUtil::integrateTransform(..)
//baseBody	=>	quat is alias and omega is global coor
//!baseBody	=>	quat is alibi and omega is local coor
//if quat is not m_baseQuat, it is alibi => ok
//limit the angular motion
// use Taylor's expansions of sync function
// sync(fAngle) = sin(c*fAngle)/t
//equivalent to: quat = (btQuaternion(axis.x(),axis.y(),axis.z(),btCos( fAngle*dt*btScalar(0.5) )) * quat.inverse()).inverse();
///////////////////////////////
//pQuatUpdateFun(getBaseOmega(), m_baseQuat, true, dt);
//
//note: the !pqd case assumes m_realBuf starts with base omega (should be wrapped for safety)
//
//printf("pBaseOmega = %.4f %.4f %.4f\n", pBaseOmega->x(), pBaseOmega->y(), pBaseOmega->z());
//printf("pBaseVel = %.4f %.4f %.4f\n", pBaseVel->x(), pBaseVel->y(), pBaseVel->z());
//printf("baseQuat = %.4f %.4f %.4f %.4f\n", pBaseQuat->x(), pBaseQuat->y(), pBaseQuat->z(), pBaseQuat->w());
// Finally we can update m_jointPos for each of the m_links
// temporary space
//(num_links + base) offsets + (num_links + base) normals_lin + (num_links + base) normals_ang
//scratch_r.resize(m_dofCount);
//btScalar *results = m_dofCount > 0 ? &scratch_r[0] : 0;
//convenience
// omega coeffients first.
// then v coefficients
//create link-local versions of p_minus_com and normal
// Set remaining jac values to zero for now.
// Qdot coefficients, if necessary.
// TODO: (Also, we are making 3 separate calls to this function, for the normal & the 2 friction directions,
// which is resulting in repeated work being done...)
// calculate required normals & positions in the local frames.
// transform to local frame
// calculate the jacobian entry
// + m_links[i].getAxisBottom(0));
// Now copy through to output.
//printf("jac[%d] = ", link);
//printf("%.2f\t", jac[6 + m_links[link].m_dofOffset + dof]);
//printf("]\n");
// motion is computed as omega^2 + v^2 + (sum of squares of joint velocities)
// Cached 3x3 rotation matrices from parent frame to this frame.
//m_baseQuat assumed to be alias!?
///base + num m_links
//	float pos[4]={posr.x(),posr.y(),posr.z(),1};
//			float pos[4]={posr.x(),posr.y(),posr.z(),1};
///fills the dataBuffer and returns the struct name (and 0 on failure)
// Fill padding with zeros to appease msan.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyConstraint.cpp
//for testing (BTMBP2PCONSTRAINT_BLOCK_ANGULAR_MOTION_TEST macro)
//these two used to be inited to posAworld and posBworld (respectively) but it does not seem necessary
//determine jacobian of this 1D constraint in terms of multibodyA's degrees of freedom
//resize..
//copy/determine
//multiBodyA->fillContactJacobianMultiDof(solverConstraint.m_linkA, posAworld, constraintNormalLin, jac1, data.scratch_r, data.scratch_v, data.scratch_m);
//determine the velocity response of multibodyA to reaction impulses of this constraint (i.e. A[i,i] for i=1,...n_con: multibody's inverse inertia with respect to this 1D constraint)
//resize..
//=> each constraint row has the constrained tree dofs allocated in m_deltaVelocitiesUnitImpulse
//determine..
//if(rb0)
//determine jacobian of this 1D constraint in terms of multibodyB's degrees of freedom
//resize..
//copy/determine..
//multiBodyB->fillContactJacobianMultiDof(solverConstraint.m_linkB, posBworld, -constraintNormalLin, &data.m_jacobians[solverConstraint.m_jacBindex], data.scratch_r, data.scratch_v, data.scratch_m);
//determine velocity response of multibodyB to reaction impulses of this constraint (i.e. A[i,i] for i=1,...n_con: multibody's inverse inertia with respect to this 1D constraint)
//resize..
//determine..
//if(rb1)
//determine the "effective mass" of the constrained multibodyA with respect to this 1D constraint (i.e. 1/A[i,i])
//
//
//disable the constraint row to handle singularity/redundant constraint
//compute rhs and remaining solverConstraint fields
//cp.m_combinedFriction;
///warm starting (or zero if disabled)
/*
// * damping;
//split impulse is not implemented yet for btMultiBody*
//if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
//split impulse is not implemented yet for btMultiBody*
//  if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
//combine position and velocity into rhs
/*else
//split position and velocity into rhs and m_rhsPenetration
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyConstraintSolver.cpp
/*
//bulletphysics.org
//solve featherstone non-contact constraints
//printf("m_multiBodyNonContactConstraints = %d\n",m_multiBodyNonContactConstraints.size());
//solve featherstone normal contact
//iteration&1? j0 : m_multiBodyNormalContactConstraints.size()-1-j0;
//solve featherstone frictional contact
//iteration&1? j1 : m_multiBodyTorsionalFrictionContactConstraints.size()-1-j1;
//adjust friction limits here
//iteration&1? j1 : m_multiBodyFrictionContactConstraints.size()-1-j1;
//iteration&1? j1 : m_multiBodyFrictionContactConstraints.size()-1-j1;
//iteration&1? j1 : m_multiBodyFrictionContactConstraints.size()-1-j1;
//adjust friction limits here
//m_jacDiagABInv = 1./denom
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//m_jacDiagABInv = 1./denom
//m_jacDiagABInv = 1./denom
//deltaImpulseA = sumAclipped-cA.m_appliedImpulse;
//cA.m_appliedImpulse = sumAclipped;
//deltaImpulseB = sumBclipped-cB.m_appliedImpulse;
//cB.m_appliedImpulse = sumBclipped;
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
//DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//cfm = 1 /       ( dt * kp + kd )
//erp = dt * kp / ( dt * kp + kd )
//disable the constraint row to handle singularity/redundant constraint
//compute rhs and remaining solverConstraint fields
///warm starting (or zero if disabled)
//disable warmstarting for btMultiBody, it has issues gaining energy (==explosion)
//infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
// * damping;	//note for friction restitution is always set to 0 (check above) so it is acutally velocityError = -rel_vel for friction
//	if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
//combine position and velocity into rhs
/*else
//split position and velocity into rhs and m_rhsPenetration
// btScalar invTimeStep = btScalar(1)/infoGlobal.m_timeStep;
//disable the constraint row to handle singularity/redundant constraint
//compute rhs and remaining solverConstraint fields
// * damping;	//note for friction restitution is always set to 0 (check above) so it is acutally velocityError = -rel_vel for friction
//	btSolverBody* solverBodyA = mbA ? 0 : &m_tmpSolverBodyPool[solverBodyIdA];
//	btSolverBody* solverBodyB = mbB ? 0 : &m_tmpSolverBodyPool[solverBodyIdB];
///avoid collision response between two static objects
//	if (!solverBodyA || (solverBodyA->m_invMass.isZero() && (!solverBodyB || solverBodyB->m_invMass.isZero())))
//	return;
//only a single rollingFriction per manifold
//		btRigidBody* rb0 = btRigidBody::upcast(colObj0);
//		btRigidBody* rb1 = btRigidBody::upcast(colObj1);
//			const btVector3& pos1 = cp.getPositionWorldOnA();
//			const btVector3& pos2 = cp.getPositionWorldOnB();
/////setup the friction constraints
///Bullet has several options to set the friction directions
///By default, each contact has only a single friction direction that is recomputed automatically every frame
///based on the relative linear velocity.
///If the relative velocity is zero, it will automatically compute a friction direction.
///You can also enable two friction directions, using the SOLVER_USE_2_FRICTION_DIRECTIONS.
///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
///
///If you choose SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
///
///The user can manually override the friction directions for certain contacts using a contact callback,
///and set the cp.m_lateralFrictionInitialized to true
///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
///this will give a conveyor belt effect
///
/*
//??
//setMultiBodyFrictionConstraintImpulse( solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal);
//todo:
//ENABLE_FRICTION
//btPersistentManifold* manifold = 0;
//the contact doesn't involve any Featherstone btMultiBody, so deal with the regular btRigidBody/btCollisionObject case
//also convert the multibody constraints, if any
//printf("btMultiBodyConstraintSolver::solveGroup: numBodies=%d, numConstraints=%d\n", numBodies, numConstraints);
//todo: get rid of those temporary memory allocations for the joint feedback
//bod->addBaseForce(m_gravity * bod->getBaseMass());
//bod->addLinkForce(j, m_gravity * bod->getLinkMass(j));
//b3Printf("force = %f,%f,%f\n",force[0],force[1],force[2]);//[0],torque[1],torque[2]);
//b3Printf("t = %f,%f,%f\n",force[0],force[1],force[2]);//[0],torque[1],torque[2]);
//write back the delta v to the multi bodies, either as applied impulse (direct velocity change)
//or as applied force, so we can measure the joint reaction forces easier
//printf("pt->m_appliedImpulseLateral1 = %f\n", pt->m_appliedImpulseLateral1);
//do a callback here?
//multibody joint feedback
//apply the joint feedback into all links of the btMultiBody
//todo: double-check the signs of the applied impulse
//@todo: m_originalContactPoint is not initialized for btMultiBodySolverConstraint
/*RGM ???? */
//printf("solveMultiBodyGroup: numBodies=%d, numConstraints=%d, numManifolds=%d, numMultiBodyConstraints=%d\n", numBodies, numConstraints, numManifolds, numMultiBodyConstraints);
//printf("solveMultiBodyGroup start\n");
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyDynamicsWorld.cpp
/*
//bulletphysics.org
//merge islands based on speculative contact manifolds too
//merge islands linked by Featherstone link colliders
//merge islands linked by multibody constraints
//Store the island id in each body
///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
//also add all non-contact constraints/joints for this island
//find the first constraint for this island
//count the number of constraints in this island
//count the number of multi body constraints in this island
//if (m_solverInfo->m_minimumSolverBatchSize<=1)
//{
//	m_solver->solveGroup( bodies,numBodies,manifolds, numManifolds,startConstraint,numCurConstraints,*m_solverInfo,m_debugDrawer,m_dispatcher);
//} else
//printf("deferred\n");
//printf("mb contacts = %d, mb constraints = %d\n", mbContacts, m_multiBodyConstraints.size());
//split impulse is not yet supported for Featherstone hierarchies
//	getSolverInfo().m_splitImpulse = false;
//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
//multidof? ("Y"s use it and it is used to store qdd)
//if (!isSleeping)
//BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
//multidof? ("Y"s use it and it is used to store qdd)
//
//convenience
/////
//copy q0 to scratch_q0 and qd0 to scratch_qd0
//
//
////
//
//
//
//
//calc qdd0 from: q0 & qd0
//calc q1 = q0 + h/2 * qd0
//calc qd1 = qd0 + h/2 * qdd0
//
//calc qdd1 from: q1 & qd1
//calc q2 = q0 + h/2 * qd1
//calc qd2 = qd0 + h/2 * qdd1
//
//calc qdd2 from: q2 & qd2
//calc q3 = q0 + h * qd2
//calc qd3 = qd0 + h * qdd2
//
//calc qdd3 from: q3 & qd3
//
//calc q = q0 + h/6(qd0 + 2*(qd1 + qd2) + qd3)
//calc qd = qd0 + h/6(qdd0 + 2*(qdd1 + qdd2) + qdd3)
//delta_q[i] = h*scratch_qd0[i];
//delta_qd[i] = h*scratch_qdd0[i];
//
//
//bod->stepPositionsMultiDof(1, 0, &delta_q[0]);
//ugly hack which resets the cached data to t0 (needed for constraint solver)
//BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
//if (!isSleeping)
/// solve all the constraints for this island
//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)
//multidof? ("Y"s use it and it is used to store qdd)
//integrate and update the Featherstone hierarchies
///base + num m_links
//draw the joint axis
//1,1,1);
//1,1,1);
//1,1,1);
//if (!isSleeping)
//BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY
// BT_PROFILE("clearMultiBodyForces");
//serialize all collision objects
//serialize all multibody links (collision objects)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyFixedConstraint.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
//at least store the applied impulses
//at least store the applied impulses
//not implemented yet
// Convert local points back to world
//i>=3
// that ideally should draw the same frame
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyGearConstraint.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
// only positions need to be updated -- data.m_jacobians and force
// directions were set in the ctor and never change.
//don't crash
// note: we rely on the fact that data.m_jacobians are
// always initialized to zero by the Constraint ctor
// row 0: the lower bound
//expect either prismatic or revolute joint type for now
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyJointLimitConstraint.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
//:btMultiBodyConstraint(body,0,link,-1,2,true),
// the data.m_jacobians never change, so may as well
// initialize them here
// row 0: the lower bound
// row 1: the upper bound
//jacobianA(1)[offset] = -1;
// only positions need to be updated -- data.m_jacobians and force
// directions were set in the ctor and never change.
// row 0: the lower bound
//multidof: this is joint-type dependent
// row 1: the upper bound
//todo: consider adding some safety threshold here
//why assume it's zero?
//expect either prismatic or revolute joint type for now
// * damping;
//combine position and velocity into rhs
//split position and velocity into rhs and m_rhsPenetration
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyJointMotor.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
// the data.m_jacobians never change, so may as well
// initialize them here
// note: we rely on the fact that data.m_jacobians are
// always initialized to zero by the Constraint ctor
// row 0: the lower bound
// row 0: the lower bound
//:btMultiBodyConstraint(body,0,link,-1,1,true),
// only positions need to be updated -- data.m_jacobians and force
// directions were set in the ctor and never change.
//don't crash
//expect either prismatic or revolute joint type for now
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyMLCPConstraintSolver.cpp
/*
//bulletphysics.org
// pointer to enclosing dxJoint object
// *other* body this joint is connected to
//-1 for null
// Helper function to compute a delta velocity in the constraint space.
// Faster version of computeDeltaVelocityInConstraintSpace that can be used when contactNormal and linearJacobian are
// identical.
// Helper function to compute a delta velocity in the constraint space.
// Assumed at least one system is multibody
//	btScalar* w = 0;
//	int nub = 0;
//m_limitDependencies[i]>=0)
//
//find free jointNode slot for sbA
//NonInitializing();
//find free jointNode slot for sbA
//NonInitializing();
//compute JinvM = J*invM.
//	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
//	btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;
//printf("%d joint i %d and j0: %d: ",count++,i,j0);
// compute diagonal blocks of m_A
//int sbA = m_allConstraintPtrArray[row__]->m_solverBodyIdA;
//	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
// add cfm to the diagonal of m_A
///fill the upper triangle of the matrix, to make it symmetric
// 1. Compute b
// Note that rhsPenetration is currently always zero because the split impulse hasn't been implemented for multibody yet.
// 2. Compute lo and hi
// 3. Construct A matrix by using the impulse testing
// Compute the diagonal of A, which is A(i, i)
// Computes the off-diagonals of A:
//   a. The rest of i-th row of A, from A(i, i+1) to A(i, n)
//   b. The rest of i-th column of A, from A(i+1, i) to A(n, i)
// Set the off-diagonal values of A. Note that A is symmetric.
// Add CFM to the diagonal of m_A
// 4. Initialize x
// If using split impulse, we solve 2 separate (M)LCPs
// TODO(JS): Do we really need these copies when solveMLCP takes them as const?
// 1. Setup for rigid-bodies
// 2. Setup for multi-bodies
//   a. Collect all different kinds of constraint as pointers into one array, m_allConstraintPtrArray
//   b. Set the index array for frictional contact constraints, m_limitDependencies
// i. Setup for rigid bodies
// The btSequentialImpulseConstraintSolver moves all friction constraints at the very end, we can also interleave them instead
// ii. Setup for multibodies
// The btSequentialImpulseConstraintSolver moves all friction constraints at the very end, we can also interleave them instead
// Construct MLCP terms
// Fallback to btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations if the solution isn't valid.
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
// DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
//note: update of the actual velocities (below) in the multibody does not have to happen now since m_deltaVelocities can be applied after all iterations
//it would make the multibody solver more like the regular one with m_deltaVelocities being equivalent to btSolverBody::m_deltaLinearVelocity/m_deltaAngularVelocity
// DIRECTLY_UPDATE_VELOCITY_DURING_SOLVER_ITERATIONS
// Do nothing
// Do nothing
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodyPoint2Point.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
//at least store the applied impulses
//at least store the applied impulses
//not implemented yet
//	int i=1;
//memset(&constraintRow,0xffffffff,sizeof(btMultiBodySolverConstraint));
// Convert local points back to world
//sucks but let it be this way "for the time being"
//@todo: support the case of btMultiBody versus btRigidBody,
//see btPoint2PointConstraint::getInfo2NonVirtual
//sucks but let it be this way "for the time being"
// that ideally should draw the same frame
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodySliderConstraint.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
//at least store the applied impulses
//at least store the applied impulses
//not implemented yet
// Convert local points back to world
//i>=2
// that ideally should draw the same frame
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Featherstone\btMultiBodySphericalJointMotor.cpp
/*
//bulletphysics.org
///This file was written by Erwin Coumans
// note: we rely on the fact that data.m_jacobians are
// always initialized to zero by the Constraint ctor
// row 0: the lower bound
// row 0: the lower bound
// only positions need to be updated -- data.m_jacobians and force
// directions were set in the ctor and never change.
//don't crash
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\MLCPSolvers\btDantzigLCP.cpp
/*************************************************************************
/*
//memcpy
//***************************************************************************
/***************************************************************************
// use fast btLCP object
// option 1 : matrix row pointers (less data copying)
// option 2 : no matrix row pointers (slightly faster inner loops)
//#define NOROWPTRS
//#define BTATYPE btScalar *
//#define BTAROW(i) (m_A+(i)*m_nskip)
/* solve L*X=B, with B containing 1 right hand sides.
/* declare variables - Z matrix, p and q vectors, etc */
/* compute all 2 x 1 blocks of X */
/* compute all 2 x 1 block of X, from rows i..i+2-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* compute outer product and add it to the Z matrix */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* end of inner loop */
/* compute left-over iterations */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* finish computing the X(i) block */
/* end of outer loop */
/* solve L*X=B, with B containing 2 right hand sides.
/* declare variables - Z matrix, p and q vectors, etc */
/* compute all 2 x 2 blocks of X */
/* compute all 2 x 2 block of X, from rows i..i+2-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* compute outer product and add it to the Z matrix */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* end of inner loop */
/* compute left-over iterations */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* finish computing the X(i) block */
/* end of outer loop */
/* solve L*(D*l)=a, l is scaled elements in 2 x i block at A(i,0) */
/* scale the elements in a 2 x i block at A(i,0), and also */
/* compute Z = the outer product matrix that we'll need. */
/* compute left-over iterations */
/* solve for diagonal 2 x 2 block at A(i,i) */
/* factorize 2 x 2 block Z,dee */
/* factorize row 1 */
/* factorize row 2 */
/* done factorizing 2 x 2 block */
/* compute the (less than 2) rows at the bottom */
/* scale the elements in a 1 x i block at A(i,0), and also */
/* compute Z = the outer product matrix that we'll need. */
/* compute left-over iterations */
/* solve for diagonal 1 x 1 block at A(i,i) */
/* factorize 1 x 1 block Z,dee */
/* factorize row 1 */
/* done factorizing 1 x 1 block */
//default: *((char*)0)=0;  /* this should never happen! */
/* this should never happen! */
/* solve L*X=B, with B containing 1 right hand sides.
/* declare variables - Z matrix, p and q vectors, etc */
/* compute lskip values */
/* compute all 4 x 1 blocks of X */
/* compute all 4 x 1 block of X, from rows i..i+4-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* end of inner loop */
/* compute left-over iterations */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* finish computing the X(i) block */
/* end of outer loop */
/* compute rows at end that are not a multiple of block size */
/* compute all 1 x 1 block of X, from rows i..i+1-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* end of inner loop */
/* compute left-over iterations */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* advance pointers */
/* finish computing the X(i) block */
/* solve L^T * x=b, with b containing 1 right hand side.
/* declare variables - Z matrix, p and q vectors, etc */
//  int lskip3;
/* special handling for L and B because we're solving L1 *transpose* */
/* compute lskip values */
//lskip3 = 3*lskip1;
/* compute all 4 x 1 blocks of X */
/* compute all 4 x 1 block of X, from rows i..i+4-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* end of inner loop */
/* compute left-over iterations */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* finish computing the X(i) block */
/* end of outer loop */
/* compute rows at end that are not a multiple of block size */
/* compute all 1 x 1 block of X, from rows i..i+1-1 */
/* set the Z matrix to 0 */
/* the inner loop that computes outer products and adds them to Z */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* end of inner loop */
/* compute left-over iterations */
/* load p and q values */
/* compute outer product and add it to the Z matrix */
/* finish computing the X(i) block */
//***************************************************************************
/***************************************************************************
// swap row/column i1 with i2 in the n*n matrix A. the leading dimension of
// A is nskip. this only references and swaps the lower triangle.
// if `do_fast_row_swaps' is nonzero and row pointers are being used, then
// rows will be swapped by exchanging row pointers. otherwise the data will
// be copied.
// swap rows, by swapping row pointers
// Only swap till i2 column to match A plain storage variant.
// swap columns the hard way
// swap two indexes in the n*n LCP problem. i1 must be <= i2.
//***************************************************************************
/***************************************************************************
//
// two index sets C and N are kept. each set holds a subset of
// the variable indexes 0..n-1. an index can only be in one set.
// initially both sets are empty.
//
// the index set C is special: solutions to A(C,C)\A(C,i) can be generated.
//***************************************************************************
/***************************************************************************
// interface comments.
//
// `p' records the permutation of A,x,b,w,etc. p is initially 1:n and is
// permuted as the other vectors/matrices are permuted.
//
// A,x,b,w,lo,hi,state,findex,p,c are permuted such that sets C,N have
// contiguous indexes. the don't-care indexes follow N.
//
// an L*D*L' factorization is maintained of A(C,C), and whenever indexes are
// added or removed from the set C the factorization is updated.
// thus L*D*L'=A[C,C], i.e. a permuted top left nC*nC submatrix of A.
// the leading dimension of the matrix L is always `nskip'.
//
// at the start there may be other indexes that are unbounded but are not
// included in `nub'. btLCP will permute the matrix so that absolutely all
// unbounded vectors are at the start. thus there may be some initial
// permutation.
//
// the algorithms here assume certain patterns, particularly with respect to
// index transfer.
// size of each index set
// A rows
// permuted LCP problem data
// L*D*L' factorization of set C
// because we can assume C and N span 1:i-1
// make matrix row pointers
// initially unpermuted
/*
//printf ("--> %d %d\n",i1,i2);
// permute the problem so that *all* the unbounded variables are at the
// start, i.e. look for unbounded variables not included in `nub'. we can
// potentially push up `nub' this way and get a bigger initial factorization.
// note that when we swap rows/cols here we must not just swap row pointers,
// as the initial factorization relies on the data being all in one chunk.
// variables that have findex >= 0 are *not* considered to be unbounded even
// if lo=-inf and hi=inf - this is because these limits may change during the
// solution process.
// if there are unbounded variables at the start, factorize A up to that
// point and solve for x. this puts all indexes 0..nub-1 into C.
// permute the indexes > nub such that all findex variables are at the end
// print info about indexes
/*
// ell,Dell were computed by solve1(). note, ell = D \ L1solve (L,A(i,C))
// nC value is outdated after this line
// if nub>0, initial part of aptr unpermuted
// nC value is outdated after this line
// @@@ TO DO LATER
// if we just finish here then we'll go back and re-solve for
// delta_x. but actually we can be more efficient and incrementally
// update delta_x here. but if we do this, we wont have ell and Dell
// to use in updating the factorization later.
//btScalar gamma2 = W21 * dee;
//#define _GETA(i,j) (A[(i)*nskip+(j)])
// deleting last row/col is easy
// snip out row/column r from L and d
// remove a row/column from the factorization, and adjust the
// indexes (black magic!)
// nC value is outdated after this line
// we could try to make this matrix-vector multiplication faster using
// outer product matrix tricks, e.g. with the dMultidotX() functions.
// but i tried it and it actually made things slower on random 100x100
// problems because of the overhead involved. so we'll stick with the
// simple method for now.
// the `Dell' and `ell' that are computed here are saved. if index i is
// later added to the factorization then they can be reused.
//
// @@@ question: do we need to solve for entire delta_x??? yes, but
//     only if an x goes below 0 during the step.
// if nub>0, initial part of aptr[] is guaranteed unpermuted
// now we have to un-permute x and w
// btLCP_FAST
//***************************************************************************
/***************************************************************************
//	printf("btSolveDantzigLCP n=%d\n",n);
// check restrictions on lo and hi
// if all the variables are unbounded then we can just factor, solve,
// and return
// for i in N, state[i] is 0 if x(i)==lo(i) or 1 if x(i)==hi(i)
// create LCP object. note that tmp is set to delta_w to save space, this
// optimization relies on knowledge of how tmp is used, so be careful!
// loop over all indexes adj_nub..n-1. for index i, if x(i),w(i) satisfy the
// LCP conditions then i is added to the appropriate index set. otherwise
// x(i),w(i) is driven either +ve or -ve to force it to the valid region.
// as we drive x(i), x(C) is also adjusted to keep w(C) at zero.
// while driving x(i) we maintain the LCP conditions on the other variables
// 0..i-1. we do this by watching out for other x(i),w(i) values going
// outside the valid region, and then switching them between index sets
// when that happens.
// the index i is the driving index and indexes i+1..n-1 are "dont care",
// i.e. when we make changes to the system those x's will be zero and we
// don't care what happens to those w's. in other words, we only consider
// an (i+1)*(i+1) sub-problem of A*x=b+w.
// if we've hit the first friction index, we have to compute the lo and
// hi values based on the values of x already computed. we have been
// permuting the indexes, so the values stored in the findex vector are
// no longer valid. thus we have to temporarily unpermute the x vector.
// for the purposes of this computation, 0*infinity = 0 ... so if the
// contact constraint's normal force is 0, there should be no tangential
// force applied.
// un-permute x into delta_w, which is not being used at the moment
// set lo and hi values
// thus far we have not even been computing the w values for indexes
// greater than i, so compute w[i] now.
// if lo=hi=0 (which can happen for tangential friction when normals are
// 0) then the index will be assigned to set N with some state. however,
// set C's line has zero size, so the index will always remain in set N.
// with the "normal" switching logic, if w changed sign then the index
// would have to switch to set C and then back to set N with an inverted
// state. this is pointless, and also computationally expensive. to
// prevent this from happening, we use the rule that indexes with lo=hi=0
// will never be checked for set changes. this means that the state for
// these indexes may be incorrect, but that doesn't matter.
// see if x(i),w(i) is in a valid region
// this is a degenerate case. by the time we get to this test we know
// that lo != 0, which means that lo < 0 as lo is not allowed to be +ve,
// and similarly that hi > 0. this means that the line segment
// corresponding to set C is at least finite in extent, and we are on it.
// NOTE: we must call lcp.solve1() before lcp.transfer_i_to_C()
// we must push x(i) and w(i)
// find direction to push on x(i)
// compute: delta_x(C) = -dir*A(C,C)\A(C,i)
// note that delta_x[i] = dirf, but we wont bother to set it
// compute: delta_w = A*delta_x ... note we only care about
// delta_w(N) and delta_w(i), the rest is ignored
// find largest step we can take (size=s), either to drive x(i),w(i)
// to the valid LCP region or to drive an already-valid variable
// outside the valid region.
// index switching command
// si = index to switch if cmd>3
// was (hi[i]-x[i])/dirf	// step to x(i)=hi(i)
// was (lo[i]-x[i])/dirf	// step to x(i)=lo(i)
// don't bother checking if lo=hi=0
//static char* cmdstring[8] = {0,"->C","->NL","->NH","N->C",
//			     "C->NL","C->NH"};
//printf ("cmd=%d (%s), si=%d\n",cmd,cmdstring[cmd],(cmd>3) ? si : i);
// if s <= 0 then we've got a problem. if we just keep going then
// we're going to get stuck in an infinite loop. instead, just cross
// our fingers and exit with the current solution.
//          printf("LCP internal error, s <= 0 (s=%.4e)",(double)s);
// apply x = x + s * delta_x
// apply w = w + s * delta_w
//        void *tmpbuf;
// switch indexes between sets if necessary
// done
// done
// done
// keep going
// keep going
// keep going
// for (;;)
// else
// for (int i=adj_nub; i<n; ++i)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\MLCPSolvers\btLemkeAlgorithm.cpp
/* Copyright (C) 2004-2013 MBSim Development Team
//The original version is here
//https://code.google.com/p/mbsim-env/source/browse/trunk/kernel/mbsim/numerics/linear_complementarity_problem/lemke_algorithm.cc
//This file is re-distributed under the ZLib license, with permission of the original author
//Math library was replaced from fmatvec to a the file src/LinearMath/btMatrixX.h
//STL/std::vector replaced by btAlignedObjectArray
//BT_DEBUG_OSTREAM
// If next epsilon yields 1, then break, because current
// epsilon is the machine epsilon.
//		printf( "\nCalculated Machine epsilon: %G\n", machEps );
/* = 0*/)
//BT_DEBUG_OSTREAM
//, INIT, 0.);
//
//BT_DEBUG_OSTREAM
//   btVectorXu q_;
//   q_ >> A(0, 2 * dim + 1, dim - 1, 2 * dim + 1);
//At first, all w-values are in the basis
//  int pivotRowIndex = q_.minIndex();//minIndex(q_);     // first row is that with lowest q-value
// remember the col of z0 for ending algorithm afterwards
// first col is that of z0
//  cout << "A: " << A << endl;
//BT_DEBUG_OSTREAM
//        maxloops = UINT_MAX; //TODO: not a really nice way, problem is: maxloops should be 2^dim (=1<<dim), but this could exceed UINT_MAX and thus the result would be 0 and therefore the lemke algorithm wouldn't start but probably would find a solution within less then UINT_MAX steps. Therefore this constant is used as a upper border right now...
/*start looping*/
//  cout << "A: " << A << endl;
//BT_DEBUG_OSTREAM
/*find new column index */
//if a w-value left the basis get in the correspondent z-value
//else do it the other way round and get in the corresponding w-value
/*the column becomes part of the basis*/
//if z0 leaves the basis the solution is found --> one last elimination step is necessary
//update basis
//BT_DEBUG_OSTREAM
//BT_DEBUG_OSTREAM
// cout << "A: " << A << endl;
//BT_DEBUG_OSTREAM
//q_[i];
//, INIT, 0.)
//		if (DEBUGLEVEL) {
//	  cout << "Rows(" << row << ") = " << Rows[row] << endl;
// }
//=Rows[j] - Rows[i]
//  if (DEBUGLEVEL)
//  cout << "v " << v << endl;
//BT_DEBUG_OSTREAM
//#ifdef BT_DEBUG_OSTREAM
//#ifdef BT_DEBUG_OSTREAM
//then z0 is in the base
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\MLCPSolvers\btMLCPSolver.cpp
/*
//bulletphysics.org
///original version written by Erwin Coumans, October 2013
//	int numBodies = m_tmpSolverBodyPool.size();
//	printf("m_limitDependencies.size() = %d\n",m_limitDependencies.size());
///The btSequentialImpulseConstraintSolver moves all friction constraints at the very end, we can also interleave them instead
//if using split impulse, we solve 2 separate (M)LCPs
//		printf("solve first LCP\n");
// pointer to enclosing dxJoint object
// *other* body this joint is connected to
//-1 for null
//	btScalar* w = 0;
//	int nub = 0;
//m_limitDependencies[i]>=0)
//
//find free jointNode slot for sbA
//NonInitializing();
//find free jointNode slot for sbA
//NonInitializing();
//compute JinvM = J*invM.
//	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
//	btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;
//printf("%d joint i %d and j0: %d: ",count++,i,j0);
// compute diagonal blocks of m_A
//int sbA = m_allConstraintPtrArray[row__]->m_solverBodyIdA;
//	btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
// add cfm to the diagonal of m_A
///fill the upper triangle of the matrix, to make it symmetric
// add cfm to the diagonal of m_A
//	m_x.setZero();
//		printf("m_A(%d,%d)\n", m_A.rows(),m_A.cols());
//check if solution is valid, and otherwise fallback to btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations
//btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
//	btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;
//	printf("m_fallback = %d\n",m_fallback);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Vehicle\btRaycastVehicle.cpp
/*
//
// basically most of the code is general for 2 or 4 wheel vehicles, but some of it needs to be reviewed
//
//	up = right.cross(fwd);
//	up.normalize();
//rotate around steering over de wheelAxleWS
//wheel.m_steering);
//wheel_info.setContactFriction(btScalar(0.0));
///@todo for driving on dynamic/movable objects!;
//wheel.m_raycastInfo.m_groundObject = object;
//clamp on max suspension travel
//put wheel info as in rest position
/*if (getRigidBody()->getMotionState())
//
// simulate suspension
//
//btScalar depth;
//depth =
//apply suspension force
//damping of rotation when not in contact
//	Spring
// Damper
// RESULT
// calculate j that moves us to zero relative velocity
//calculate the impulse, so that the wheels don't move sidewards
//collapse all those loops into one!
//switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)
//wheelInfo.m_engineForce* timeStep;
// apply the impulses
// fix. It only worked if car's up was along Y - VT.
//apply friction impulse on the ground
//debug wheels (cylinders)
//	RayResultCallback& resultCallback;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletDynamics\Vehicle\btWheelInfo.cpp
/*
// for pointvelocity
// Not in contact : position wheel in a nice (rest length) position
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletInverseDynamics\IDMath.cpp
// requirements for axis length deviation from 1.0
// experimentally set from random euler angle rotation matrices
// only used for tests -- so just loop here for portability
// [1  0 0]
// [0  c s]
// [0 -s c]
// [c 0 -s]
// [0 1  0]
// [s 0  c]
// [ c s 0]
// [-s c 0]
// [ 0 0 1]
// test if all upper left determinants are positive
// upper 1x1
// upper 2x2
// test if all upper left determinants are positive
// upper 1x1
// upper 2x2
// test if all upper left determinants are positive
// upper 1x1
// upper 2x2
// TODO(Thomas) do we really want this?
//			  in cases where the inertia tensor about the center of mass is zero,
//			  the determinant of the inertia tensor about the joint axis is almost
//			  zero and can have a very small negative value.
// check triangle inequality, must have I(i,i)+I(j,j)>=I(k,k)
// check positive/zero diagonal elements
// accept zero
// check symmetry
// check for unit length column vectors
// check for orthogonal column vectors
// check determinant (rotation not reflection)
// namespace btInverseDynamics
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletInverseDynamics\MultiBodyTree.cpp
// temporarily set gravity to zero, to ensure we get the actual accelerations
// check if axis is unit vector
// sanity check for mass properties. Zero mass is OK.
// error message printed in function call
//return -1;
// 1 allocate internal MultiBody structure
// 2 build new index set assuring index(parent) < index(child)
// 3 setup internal kinematic and dynamic data
// Set joint Jacobians. Note that the dimension is always 3x1 here to avoid variable sized
// matrices.
// NOTE/TODO: dimension really should be zero ..
// NOTE/TODO: this is not really correct.
// the Jacobians should be 3x3 matrices here !
// NOTE/TODO: this is not really correct.
// the Jacobians should be 3x3 matrices here !
// 4 assign degree of freedom indices & build per-joint-type index arrays
// 5 do some pre-computations ..
// 6. make sure all user forces are set to zero, as this might not happen
//	in the vector ctors.
// namespace btInverseDynamics
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletInverseDynamics\details\MultiBodyTreeImpl.cpp
// indent
// this is adapted from URDF2Bullet.
// TODO: fix this and print proper graph (similar to git --log --graph)
// first grandchild
// do nothing
// sanity check
// multiple bodies are directly linked to the environment, ie, not a single root
// should never happen
// relative kinematics that are not a function of q, u, dot_u
// no static data
//todo: review
// resize & initialize jacobians to zero.
//
// 1. relative kinematics
// 2. update contributions to equations of motion for every body.
// 3.4 update dynamic terms (rate of change of angular & linear momentum)
// 3. calculate full set of forces at parent joint
// (not directly calculating the joint force along the free direction
// simplifies inclusion of fixed joints.
// An alternative would be to fuse bodies in a pre-processing step,
// but that would make changing masses online harder (eg, payload masses
// added with fixed  joints to a gripper)
// Also, this enables adding zero weight bodies as a way to calculate frame poses
// for force elements, etc.
// sum of forces and moments acting on this body from its children
// 4. Calculate Joint forces.
// These are the components of force_at_joint/moment_at_joint
// in the free directions given by Jac_JT/Jac_JR
// 4.1 revolute joints
// (*joint_forces)(body.m_q_index) = body.m_Jac_JR.transpose() * body.m_moment_at_joint;
// 4.2 for prismatic joints
// (*joint_forces)(body.m_q_index) = body.m_Jac_JT.transpose() * body.m_force_at_joint;
// 4.3 floating bodies (6-DoF joints)
// 4.4 spherical bodies (3-DoF joints)
//todo: review
// 1. update relative kinematics
// 1.1 for revolute
// 1.2 for prismatic
// 1.3 fixed joints: nothing to do
// 1.4 6dof joints:
//todo: review
// 2. absolute kinematic quantities (vector valued)
// NOTE: this should be optimized by specializing for different body types
// (e.g., relative rotation is always zero for prismatic joints, etc.)
// calculations for root body
// 3.1 update absolute positions and orientations:
// will be required if we add force elements (eg springs between bodies,
// or contacts)
// not required right now, added here for debugging purposes
// 3.2 update absolute velocities
// 3.3 update absolute accelerations
// NOTE: assumption: dot(J_JR) = 0; true here, but not for general joints
// add gravitational acceleration to root body
// this is an efficient way to add gravitational terms,
// but it does mean that the kinematics are no longer
// correct at the acceleration level
// NOTE: To get correct acceleration kinematics, just set world_gravity to zero
// 2.1 update absolute positions and orientations:
// will be required if we add force elements (eg springs between bodies,
// or contacts)  not required right now added here for debugging purposes
// 2.2 update absolute velocities
// 2.3 update absolute accelerations
// NOTE: assumption: dot(J_JR) = 0; true here, but not for general joints
// body_Jac_T = body_T_parent.transpose();
//todo: review
// rotational part
// rotational part
// translational part
// this should never happen
// TODO add configurable abort/crash function
// This calculates the joint space mass matrix for the multibody system.
// The algorithm is essentially an implementation of "method 3"
// in "Efficient Dynamic Simulation of Robotic Mechanisms" (Walker and Orin, 1982)
// (Later named "Composite Rigid Body Algorithm" by Featherstone).
//
// This implementation, however, handles branched systems and uses a formulation centered
// on the origin of the body-fixed frame to avoid re-computing various quantities at the com.
// TODO add optimized zeroing function?
// 1. update relative kinematics
// 1.1 for revolute joints
// from reference orientation (q=0) of body-fixed frame to current orientation
// 1.2 for prismatic joints
// body.m_body_T_parent= fixed
// 1.3 fixed joints: nothing to do
// 1.4 6dof joints:
// calculate mass, center of mass and inertia of "composite rigid body",
// ie, sub-tree starting at current body
// Shift the reference point for the child subtree inertia using the
// Huygens-Steiner ("parallel axis") theorem.
// (First shift from child origin to child com, then from there to this body's
// origin)
// determine DoF-range for body
// loop over the DoFs used by this body
// local joint jacobians (ok as is for 1-DoF joints)
// set jacobians for 6-DoF joints
//todo: review
// rest of the mass matrix column upwards
// 1. for multi-dof joints, rest of the dofs of this body
//todo: review
// 2. ancestor dofs
//todo: review
// set jacobians for 6-DoF joints
// utility macro
// namespace btInverseDynamics
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletInverseDynamics\details\MultiBodyTreeInitCache.cpp
// does not add a degree of freedom
// m_num_dofs+=0;
// NOTE: This function assumes that proper indices were provided
//	   User2InternalIndex from utils can be used to facilitate this.
// namespace btInverseDynamics
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btDefaultSoftBodySolver.cpp
/*
//continuousphysics.com/Bullet/
// Initial we will clearly need to update solver constants
// For now this is global for the cloths linked with this solver - we should probably make this body specific
// for performance in future once we understand more clearly when constants need to be updated
// In this case the data is already in the soft bodies so there is no need for us to do anything
// updateSoftBodies
// Solve constraints for non-solver softbodies
// btDefaultSoftBodySolver::solveConstraints
// Currently only support CPU output buffers
// TODO: check for DX11 buffers. Take all offsets into the same DX11 buffer
// and use them together on a single kernel call if possible by setting up a
// per-cloth target buffer array for the copy kernel.
// btDefaultSoftBodySolver::copySoftBodyToVertexBuffer
// For the default solver just leave the soft body to do its collision processing
// btDefaultSoftBodySolver::processCollision
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftBody.cpp
/*
//continuousphysics.com/Bullet/
///btSoftBody implementation by Nathanael Presson
//
/* Init		*/
/* Default material	*/
/* Nodes			*/
/* Collision shape	*/
///for now, create a collision shape internally
//
//for now, delete the internal shape
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//const btScalar kPR = m_cfg.kPR;
//const btScalar kVC = m_cfg.kVC;
/* Aerodynamics			*/
// Check angle of attack
// cos(10) = 0.98480
// Check if the velocity change resulted by aero drag force exceeds the current velocity of the node.
/* Compute forces	*/
//	const btScalar kPR = m_cfg.kPR;
//	const btScalar kVC = m_cfg.kVC;
// Check angle of attack
// cos(10) = 0.98480
// Check if the velocity change resulted by aero drag force exceeds the current velocity of the node.
/* Compute forces	*/
//
/* Set velocity for the entire body										*/
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* Weights		*/
/* Pos		*/
/* Aqq		*/
//
//
//
//
//
//
//
//
//
//
//
//
//
/* Build graph	*/
//special optimized case for distance == 2
/* Build node links */
///generic Floyd's algorithm
/* Build links	*/
//
//
//
//
/* Initialize		*/
/* Iterate			*/
/* Merge		*/
/* Master		*/
/* Terminate	*/
//create a cluster for each tetrahedron (if tetrahedra exist) or each face
//for self-collision
//
/* Filter out		*/
/* Fill edges		*/
/* Intersect		*/
/* Refine links		*/
/* Refine faces		*/
/* Cut				*/
/* Nodes		*/
/* Links		*/
/* Faces		*/
/* Clean orphans	*/
//
//
//	const btVector3	d=m_nodes[node0].m_x-m_nodes[node1].m_x;
//
//
//
/* Update				*/
/* Prepare				*/
/* Forces				*/
/* Integrate			*/
/* Clusters				*/
/* Bounds				*/
/* Nodes				*/
/* Faces				*/
/* Pose					*/
/* Match				*/
/* Clear contacts		*/
/* Optimize dbvt's		*/
//
/* Apply clusters		*/
/* Prepare links		*/
/* Prepare anchors		*/
/* Solve velocities		*/
/* Solve			*/
/* Update			*/
/* Solve positions		*/
/* Solve drift			*/
/* Apply clusters		*/
//
//
/*bodies*/, int /*count*/, int /*iterations*/)
/// placeholder
//
//
/* Update			*/
//
//
//
//
//
//
/* Full search	*/
/* Use dbvt	*/
//
//
//
//	const btRigidBody *tmpRigid = btRigidBody::upcast(colObjWrap->getCollisionObject());
//const btTransform &wtr = tmpRigid ? tmpRigid->getWorldTransform() : colObjWrap->getWorldTransform();
//todo: check which transform is needed here
//
//
/*if( m_acceleratedSoftBody )
// If we have an accelerated softbody we need to obtain the bounds correctly
// For now (slightly hackily) just have a very large AABB
// TODO: Write get bounds kernel
// If that is updating in place, atomic collisions might be low (when the cloth isn't perfectly aligned to an axis) and we could
// probably do a test and exchange reasonably efficiently.
// ??? to investigate...
//}
//
/* Com			*/
/* Rotation		*/
//
/* Face area		*/
/* Node area		*/
// initialize node area as zero
/* Links		*/
//
/* Inertia	*/
/* Frame	*/
//
//const btScalar			invn=1/(btScalar)n;
/* Frame				*/
/* Inertia			*/
/* Constant	*/
/* Sphere	*/ 
/* Actual	*/
/* Velocities			*/
/* Matching				*/
/* Dbvt					*/
//
//
//
//
//	const btScalar					f0=m_sst.sdt;
//const btScalar					f1=f0/2;
//
//
//
//
//
//
//
//
//
//
//
//
//	const btScalar					dt =			m_sst.sdt;
//const bool						as_vaero =		as_aero	&&
//												(m_cfg.aeromodel < btSoftBody::eAeroModel::F_TwoSided);
//const bool						as_faero =		as_aero	&&
//												(m_cfg.aeromodel >= btSoftBody::eAeroModel::F_TwoSided);
/* Per vertex forces			*/
/* Aerodynamics			*/
/* Pressure				*/
/* Volume				*/
/* Per face forces				*/
//	btSoftBody::Face&	f=m_faces[i];
/* Aerodynamics			*/
//
//
// c0 is the impulse matrix, c3 is 1 - the friction coefficient or 0, c4 is the contact hardness coefficient
//
//
//
//
//
//
//
//support self-collision if CL_SELF flag set
//only self-collision for Cluster, not Vertex-Face yet
/* common					*/
/* psb0 nodes vs psb1 faces	*/
/* psb1 nodes vs psb0 faces	*/
///fills the dataBuffer and returns the struct name (and 0 on failure)
//SoftBodyMaterialData** memPtr = chunk->m_oldPtr;
//serialize it here
//pose for shape matching
//clusters for convex-cluster collision detection
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftBodyConcaveCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
//make this configurable
//
// create the manifold from the dispatcher 'manifold pool'
//
//	  m_manifoldPtr = m_dispatcher->getNewManifold(m_convexBody,m_triBody);
//	m_dispatcher->releaseManifold( m_manifoldPtr );
//necessary?
//just for debugging purposes
//printf("triangle %d",m_triangleCount++);
///debug drawing of the overlapping triangles
//copy over user pointers to temporary shape
//btCollisionObjectWrapper triBody(0,tm, ob, btTransform::getIdentity());//ob->getWorldTransform());//??
//m_manifoldPtr);
//aabb filter is already applied!
//btCollisionObject* colObj = static_cast<btCollisionObject*>(m_convexProxy->m_clientObject);
//	if (m_softBody->getCollisionShape()->getShapeType()==
//		btVector3 other;
//		other=(triangle[0]+triangle[1]+triangle[2])*0.333333f;
//		other+=normal*22.f;
//		btBU_Simplex1to4 tm(triangle[0],triangle[1],triangle[2],other);
//btTriangleShape tm(triangle[0],triangle[1],triangle[2]);
//	tm.setMargin(m_collisionMarginTriangle);
//copy over user pointers to temporary shape
//btTransform::getIdentity());//??
//m_manifoldPtr);
//btCollisionObject* convexBody = m_isSwapped ? body1 : body0;
//	if (convexBody->getCollisionShape()->isConvex())
//			resultOut->setPersistentManifold(m_btSoftBodyTriangleCallback.m_manifoldPtr);
//	resultOut->refreshContactPoints();
//quick approximation using raycast, todo: hook up to the continuous collision detection (one of the btConvexCast)
//only perform CCD above a certain threshold, this prevents blocking on the long run
//because object in a blocked ccd state (hitfraction<1) get their linear velocity halved each frame...
//const btVector3& from = convexbody->m_worldTransform.getOrigin();
//btVector3 to = convexbody->m_interpolationWorldTransform.getOrigin();
//todo: only do if the motion exceeds the 'radius'
//do a swept sphere for now
//GjkConvexCast	convexCaster(&pointShape,convexShape,&simplexSolver);
//ContinuousConvexCollision convexCaster(&pointShape,convexShape,&simplexSolver,0);
//local space?
//is this available?
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftBodyHelpers.cpp
/*
//continuousphysics.com/Bullet/
///btSoftBodyHelpers.cpp by Nathanael Presson
//
//
//
//
//
//
//
//
//
//
/* Clusters	*/
//printf("face=%d\n",face);
/* Velocities	*/
/* Frame		*/
//		btSoftBody::Cluster& c=*psb->m_clusters[i];
//		idraw->drawLine(c.m_com,c.m_framexform*btVector3(10,0,0),btVector3(1,0,0));
//		idraw->drawLine(c.m_com,c.m_framexform*btVector3(0,10,0),btVector3(0,1,0));
//		idraw->drawLine(c.m_com,c.m_framexform*btVector3(0,0,10),btVector3(0,0,1));
/* Nodes	*/
/* Links	*/
/* Normals	*/
/* Contacts	*/
/* Faces	*/
/* Tetras	*/
/* Anchors	*/
/* Notes	*/
/* Node tree	*/
/* Face tree	*/
/* Cluster tree	*/
/* Joints		*/
//const btSoftBody::AJoint*	pja=(const btSoftBody::AJoint*)pj;
//
/*stress*/)
//
//
//
//The btSoftBody object from the BulletSDK includes an array of Nodes and Links. These links appear
// to be first set up to connect a node to between 5 and 6 of its neighbors [480 links],
//and then to the rest of the nodes after the execution of the Floyd-Warshall graph algorithm
//[another 930 links].
//The way the links are stored by default, we have a number of cases where adjacent links share a node in common
// - this leads to the creation of a data dependency through memory.
//The PSolve_Links() function reads and writes nodes as it iterates over each link.
//So, we now have the possibility of a data dependency between iteration X
//that processes link L with iteration X+1 that processes link L+1
//because L and L+1 have one node in common, and iteration X updates the positions of that node,
//and iteration X+1 reads in the position of that shared node.
//
//Such a memory dependency limits the ability of a modern CPU to speculate beyond
//a certain point because it has to respect a possible dependency
//- this prevents the CPU from making full use of its out-of-order resources.
//If we re-order the links such that we minimize the cases where a link L and L+1 share a common node,
//we create a temporal gap between when the node position is written,
//and when it is subsequently read. This in turn allows the CPU to continue execution without
//risking a dependency violation. Such a reordering would result in significant speedups on
//modern CPUs with lots of execution resources.
//In our testing, we see it have a tremendous impact not only on the A7,
//but also on all x86 cores that ship with modern Macs.
//The attached source file includes a single function (ReoptimizeLinkOrder) which can be called on a
//btSoftBody object in the solveConstraints() function before the actual solver is invoked,
//or right after generateBendingConstraints() once we have all 1410 links.
//===================================================================
//
//
// This function takes in a list of interdependent Links and tries
// to maximize the distance between calculation
// of dependent links.  This increases the amount of parallelism that can
// be exploited by out-of-order instruction processors with large but
// (inevitably) finite instruction windows.
//
//===================================================================
// A small structure to track lists of dependent link calculations
// A link calculation that is dependent on this one
// Positive values = "input A" while negative values = "input B"
// Next dependence in the list
// Dependency list constants
// Must be less than REOP_NOT_DEPENDENT
/* This can be replaced by a btSoftBody pointer */)
// Allocate temporary buffers
// What link calculation produced this node's current values?
// Link calculation input is dependent upon prior calculation #N
// List of ready-to-process link calculations (# of links, maximum)
// Dependent-on-me list elements (2x# of links, maximum)
// Start nodes of dependent-on-me lists, one for each link
// Copy the original, unsorted links to a side buffer
// Clear out the node setup and ready list
// Initial link analysis to set up data structures
// Note which prior link calculations we are dependent upon & build up dependence lists
// Add this link to the initial ready list, if it is not dependent on any other links
// Probably not needed now
// Update the nodes to mark which ones are calculated by this link
// Process the ready list and create the sorted list of links
// -- By treating the ready list as a queue, we maximize the distance between any
//    inter-dependent node calculations
// -- All other (non-related) nodes in the ready list will automatically be inserted
//    in between each set of inter-dependent link calculations by this loop
// Use ready list to select the next link to process
// Copy the next-to-calculate link back into the original link array
// Free up any link inputs that are dependent on this one
// Add this dependent link calculation to the ready list if *both* inputs are clear
// Probably not needed now
// Delete the temporary buffers
//
//
/* Create nodes	*/
/* Create links	*/
/* Finished		*/
//
/* Create nodes	*/
/* Create links	and faces */
/* Finished		*/
//
/*
/* Create nodes		*/
/* Create links	and faces	*/
/* Finished	*/
/*
//
//
//
/*??*/
/* Create from TetGen .ele, .face, .node data							*/
//int			bound=0;
//	sn>>index;
//	sn>>x;sn>>y;sn>>z;
//for(int j=0;j<nattrb;++j)
//	sn>>a;
//if(hasbounds)
//	sn>>bound;
//se>>ntetra;se>>ncorner;se>>neattrb;
//se>>index;
//se>>ni[0];se>>ni[1];se>>ni[2];se>>ni[3];
//for(int j=0;j<neattrb;++j)
//	se>>a;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftBodyRigidBodyCollisionConfiguration.cpp
/*
//continuousphysics.com/Bullet/
//replace pool by a new one, with potential larger size
///calculate maximum element size, big enough to fit any collision algorithm in the memory pool
///creation of soft-soft and soft-rigid, and otherwise fallback to base class implementation
///try to handle the softbody interactions first
///softbody versus convex
///convex versus soft body
///softbody versus convex
///convex versus soft body
///fallback to the regular rigid collision shape
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftMultiBodyDynamicsWorld.cpp
/*
//continuousphysics.com/Bullet/
//softbody & helpers
// Let the solver grab the soft bodies and if necessary optimize for it
///solve soft bodies constraints
//self collisions
///update soft bodies
// End solver-wise simulation step
// ///////////////////////////////
// Solve constraints solver-wise
// Set the soft body solver that will deal with this body
// to be the world's solver
///what about division by zero? --> just set rayDirection[i] to INF/1e30
///terminate further ray tests, once the closestHitFraction reached zero
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
//btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
//getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
//btScalar hitLambda = m_resultCallback.m_closestHitFraction;
//culling already done by broadphase
//if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
/// use the broadphase to accelerate the search for objects, based on their aabb
/// and for each object with ray-aabb overlap, perform an exact ray test
//USE_BRUTEFORCE_RAYBROADPHASE
// get the normal
// normal always point toward origin of the ray
//serialize all collision objects
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftRigidCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
///TODO: include all the shapes that the softbody can collide with
///alternatively, implement special case collision algorithms (just like for rigid collision shapes)
//#include <stdio.h>
/*mf*/, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper*, const btCollisionObjectWrapper*, bool isSwapped)
//m_ownManifold(false),
//m_manifoldPtr(mf),
//m_softBody->m_overlappingRigidBodies.remove(m_rigidCollisionObject);
/*if (m_ownManifold)
//printf("btSoftRigidCollisionAlgorithm\n");
//	const btCollisionObjectWrapper* softWrap = m_isSwapped?body1Wrap:body0Wrap;
//	const btCollisionObjectWrapper* rigidWrap = m_isSwapped?body0Wrap:body1Wrap;
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftRigidDynamicsWorld.cpp
/*
//continuousphysics.com/Bullet/
//softbody & helpers
// Let the solver grab the soft bodies and if necessary optimize for it
///solve soft bodies constraints
//self collisions
///update soft bodies
// End solver-wise simulation step
// ///////////////////////////////
// Solve constraints solver-wise
// Set the soft body solver that will deal with this body
// to be the world's solver
///what about division by zero? --> just set rayDirection[i] to INF/1e30
///terminate further ray tests, once the closestHitFraction reached zero
//only perform raycast if filterMask matches
//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
//btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
//getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
//btScalar hitLambda = m_resultCallback.m_closestHitFraction;
//culling already done by broadphase
//if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
/// use the broadphase to accelerate the search for objects, based on their aabb
/// and for each object with ray-aabb overlap, perform an exact ray test
//USE_BRUTEFORCE_RAYBROADPHASE
// get the normal
// normal always point toward origin of the ray
//serialize all collision objects
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\BulletSoftBody\btSoftSoftCollisionAlgorithm.cpp
/*
//continuousphysics.com/Bullet/
/*mf*/, const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* /*obj0*/, const btCollisionObjectWrapper* /*obj1*/)
//m_ownManifold(false),
//m_manifoldPtr(mf)
/*dispatchInfo*/, btManifoldResult* /*resultOut*/)
/*body0*/, btCollisionObject* /*body1*/, const btDispatcherInfo& /*dispatchInfo*/, btManifoldResult* /*resultOut*/)
//not yet
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btAlignedAllocator.cpp
/*
//continuousphysics.com/Bullet/
//detect memory leaks
//BT_DEBUG_MEMORY_ALLOCATIONST_DEBUG_ALLOCATIONS
//this generic allocator provides the total allocated number of bytes
// to find some particular memory leak, you could do something like this:
//	if (allocId==172)
//	{
//		printf("catch me!\n");
//	}
//	if (size>1024*1024)
//	{
//		printf("big alloc!%d\n", size);
//	}
//??
//printf("deleting a NULL ptr, no effect\n");
//BT_DEBUG_MEMORY_ALLOCATIONS
//	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
//	printf("btAlignedFreeInternal %x\n",ptr);
//BT_DEBUG_MEMORY_ALLOCATIONS
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btConvexHull.cpp
/*
//www.melax.com/
//----------------------------------
//------- btPlane ----------
//--------- Utility Functions ------
// returns the point where the line p0-p1 intersects the plane n&d
// return the normal of the triangle
// inscribed by v0, v1, and v2
// Yuck - this is really ugly
// EPSILON???
// release compile fix
// simplex failed
// a valid interior point
//int3 ti=*te;
// wtf we've already done this vertex
//if(v==p0 || v==p1 || v==p2 || v==p3) continue; // done these already
// now check for those degenerate cases where we have a flipped triangle or a really skinny triangle
// already done that vertex - algorithm needs to be able to terminate.
//*********************************************************************
/*********************************************************************
//********  HullLib header
/********  HullLib header
//*********************************************************************
/*********************************************************************
//*********************************************************************
/*********************************************************************
//********  HullLib implementation
/********  HullLib implementation
//*********************************************************************
/*********************************************************************
// describes the input request
// contains the resulst
// normalize point cloud, remove duplicates!
//		if ( 1 ) // scale vertices back to their original size.
// re-index triangle mesh so it refers to only used vertices, rebuild a new vertex table.
// if he wants the results as triangle!
//				if ( 1 )
// release memory allocated for this result, we are done with it.
// XXX, might be broken
// output number of vertices
// location to store the results.
/* close enough to consider two btScalaring point numbers to be 'the same'. */
//	if ( 1 )
// one centimeter
// 1/5th the shortest non-zero edge.
// return cube
// normalize
// normalize
// normalize
//		if ( 1 )
/// XXX might be broken
// ok, it is close enough to the old one
// now let us see if it is further from the center of the point cloud than the one we already recorded.
// in which case we keep this one instead.
// ok..now make sure we didn't prune so many vertices it is now invalid.
//	if ( 1 )
// one centimeter
// 1/5th the shortest non-zero edge.
// add box
// original array index
// if already remapped
// index to new array
// new index mapping
// copy old vert to new vert array
// increment output vert count
// assign new index remapping
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btConvexHullComputer.cpp
/*
//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif
//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS
// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
//	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;
// rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
// bh=1 if difference is non-negative, bh=0 otherwise
// bl=1 if difference if non-zero, bl=0 if it is zero
// now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
// ebx has same sign as difference
// if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
// if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btGeometryUtil.cpp
/*
/*
// brute force:
//check if inside, and replace supportingVertexOut if needed
// brute force:
//point P out of 3 plane equations:
//	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )
//P =  -------------------------------------------------------------------------
//   N1 . ( N2 * N3 )
//check if inside, and replace supportingVertexOut if needed
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btPolarDecomposition.cpp
// namespace
// Use the 'u' and 'h' matrices for intermediate calculations
// The matrix is effectively singular so we cannot invert it
// Determine the delta to 'u'
// Update the matrices
// Check for convergence
// The algorithm has failed to converge to the specified tolerance, but we
// want to make sure that the matrices returned are in the right form.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btQuickprof.cpp
/*
// Credits: The Clock class was inspired by the Timer classes in
// Ogre (www.ogre3d.org).
//_XBOX
//_XBOX
//_WIN32
//required linking against rt (librt)
//BT_LINUX_REALTIME
//_WIN32
//__CELLOS_LV2__
///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
/// Resets the initial reference time.
//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
/// Returns the time in ms since the last call to reset or since
/// the btClock was created.
// Compute the number of millisecond ticks elapsed.
//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
//__CELLOS_LV2__
/// Returns the time in us since the last call to reset or since
/// the Clock was created.
//see https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx
//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
//__CELLOS_LV2__
//see https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx
//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
// attempt to get conversion to nanoseconds
//__APPLE__
//BT_LINUX_REALTIME
//__APPLE__
//__CELLOS_LV2__
/// Returns the time in s since the last call to reset or since
/// the Clock was created.
//	return 1000000.f;
/***************************************************************************************************
/***********************************************************************************************
/***********************************************************************************************
// Try to find this sub node
// We didn't find it, so add it
/***************************************************************************************************
/***************************************************************************************************
/***********************************************************************************************
/***********************************************************************************************
// Return will indicate whether we should back up to our parent (we may
// be profiling a recursive function)
/***********************************************************************************************
/***********************************************************************************************
/***********************************************************************************************
//recurse into children
//printf("what's wrong\n");
//BT_NO_PROFILE
// clang-format off
// TODO: Modern versions of iOS support TLS now with updated version checking.
// __thread is broken on Andorid clang until r12b. See
// https://github.com/android-ndk/ndk/issues/8
// __has_include(<android/ndk-version.h>)
// defined(__ANDROID__) && defined(__clang__)
// clang-format on
//BT_THREADSAFE
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btSerializer.cpp
// clang-format off
// clang-format on
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btSerializer64.cpp
// clang-format off
// clang-format on
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btThreads.cpp
/*
// for min and max
// #if BT_USE_OPENMP && BT_THREADSAFE
// use Microsoft Parallel Patterns Library (installed with Visual Studio 2010 and later)
// if you get a compile error here, check whether your version of Visual Studio includes PPL
// Visual Studio 2010 and later should come with it
// for GetProcessorCount()
// #if BT_USE_PPL && BT_THREADSAFE
// use Intel Threading Building Blocks for thread management
// #if BT_USE_TBB && BT_THREADSAFE
//
// Lightweight spin-mutex based on atomics
// Using ordinary system-provided mutexes like Windows critical sections was noticeably slower
// presumably because when it fails to lock at first it would sleep the thread and trigger costly
// context switching.
//
// for anything claiming full C++11 compliance, use C++11 atomics
// on GCC or Clang you need to compile with -std=c++11
// on MSVC, use intrinsics instead
// available since GCC 4.7 and some versions of clang
// todo: check for clang
// available since GCC 4.1
// note: this lock does not sleep the thread.
// spin
// note: this lock does not sleep the thread
// spin
// note: this lock does not sleep the thread
// spin
// note: this lock does not sleep the thread
// spin
// write 0
//#elif USE_MSVC_INTRINSICS
//#else //#elif USE_MSVC_INTRINSICS
//#if BT_THREADSAFE
// These should not be called ever
// #else //#if BT_THREADSAFE
// first count should come back 0
// no need to optimize this with atomics, it is only called ONCE per thread!
// wrap back to the first worker index
// useful for detecting if we are trying to do nested parallel-for calls
//
// BT_DETECT_BAD_THREAD_INDEX tries to detect when there are multiple threads assigned the same thread index.
//
// BT_DETECT_BAD_THREAD_INDEX is a developer option to test if
// certain assumptions about how the task scheduler manages its threads
// holds true.
// The main assumption is:
//   - when the threadpool is resized, the task scheduler either
//      1. destroys all worker threads and creates all new ones in the correct number, OR
//      2. never destroys a worker thread
//
// We make that assumption because we can't easily enumerate the worker threads of a task scheduler
// to assign nice sequential thread-indexes. We also do not get notified if a worker thread is destroyed,
// so we can't tell when a thread-index is no longer being used.
// We allocate thread-indexes as needed with a sequential global thread counter.
//
// Our simple thread-counting scheme falls apart if the task scheduler destroys some threads but
// continues to re-use other threads and the application repeatedly resizes the thread pool of the
// task scheduler.
// In order to prevent the thread-counter from exceeding the global max (BT_MAX_THREAD_COUNT), we
// wrap the thread counter back to 1. This should only happen if the worker threads have all been
// destroyed and re-created.
//
// BT_DETECT_BAD_THREAD_INDEX only works for Win32 right now,
// but could be adapted to work with pthreads
// #if BT_DETECT_BAD_THREAD_INDEX
// return a unique index per thread, main thread is 0, worker threads are in [1, BT_MAX_THREAD_COUNT)
// if not set
// set it
// this could indicate the task scheduler is breaking our assumptions about
// how threads are managed when threadpool is resized
// #if BT_DETECT_BAD_THREAD_INDEX
// for when all current worker threads are destroyed
// gThreadCounter is used to assign a thread-index to each worker thread in a task scheduler.
// The main thread is always thread-index 0, and worker threads are numbered from 1 to 63 (BT_MAX_THREAD_COUNT-1)
// The thread-indexes need to be unique amongst the threads that can be running simultaneously.
// Since only one task scheduler can be used at a time, it is OK for a pair of threads that belong to different
// task schedulers to share the same thread index because they can't be running at the same time.
// So each task scheduler needs to keep its own thread counter value
// restore saved thread counter
// save thread counter
// make sure we call this on main thread at least once before any workers run
// deactivate old task scheduler
// activate new task scheduler
// clear out thread ids
// #if BT_DETECT_BAD_THREAD_INDEX
// call btSetTaskScheduler() with a valid task scheduler first!
// #if BT_THREADSAFE
// non-parallel version of btParallelFor
// #if BT_THREADSAFE
// clear out thread ids
// #if BT_DETECT_BAD_THREAD_INDEX
// call btSetTaskScheduler() with a valid task scheduler first!
// #if BT_THREADSAFE
// non-parallel version of btParallelSum
//#else // #if BT_THREADSAFE
///
/// btTaskSchedulerSequential -- non-threaded implementation of task scheduler
///                              (really just useful for testing performance of single threaded vs multi)
///
///
/// btTaskSchedulerOpenMP -- wrapper around OpenMP task scheduler
///
// With OpenMP, because it is a standard with various implementations, we can't
// know for sure if every implementation has the same behavior of destroying all
// previous threads when resizing the threadpool
// hopefully, all previous threads get destroyed here
// #if BT_USE_OPENMP && BT_THREADSAFE
///
/// btTaskSchedulerTBB -- wrapper around Intel Threaded Building Blocks task scheduler
///
// destroys all previous threads
// #if BT_USE_TBB && BT_THREADSAFE
///
/// btTaskSchedulerPPL -- wrapper around Microsoft Parallel Patterns Lib task scheduler
///
// for parallelSum
// capping the thread count for PPL due to a thread-index issue
// PPL seems to destroy threads when threadpool is shrunk, but keeps reusing old threads
// force it to destroy old threads
// PPL dispatch
// note: MSVC 2010 doesn't support partitioner args, so avoid them
// note: MSVC 2010 doesn't support partitioner args, so avoid them
// #if BT_USE_PPL && BT_THREADSAFE
// create a non-threaded task scheduler (always available)
// create an OpenMP task scheduler (if available, otherwise returns null)
// create an Intel TBB task scheduler (if available, otherwise returns null)
// create a PPL task scheduler (if available, otherwise returns null)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\btVector3.cpp
/*
//continuousphysics.com/Bullet/
//for memset
//typedef  uint32_t uint4 __attribute__ ((vector_size(16)));
/// zzzz
/// xyxy
//memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
// Faster loop without cleanup code for full tiles
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
// If we found a new max
// copy the new max across all lanes of our max accumulator
// find first occurrence of that max
// local_count must be a multiple of 4
// record where it is.
// account for work we've already done
// Deal with the last < STACK_ARRAY_COUNT vectors
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// It is too costly to keep the index of the max here. We will look for it again later.  We save a lot of work this way.
// counter the offset
//AT&T Code style assembly
// move max out of the way to avoid propagating NaNs in max \n\
// vertices[0]      \n\
// vertices[1]      \n\
// vertices[0]      \n\
// x0y0x1y1         \n\
// vertices[2]      \n\
// vertices[3]      \n\
// x0y0x1y1 * vLo   \n\
// z0w0z1w1         \n\
// vertices[2]      \n\
// x2y2x3y3         \n\
// x2y2x3y3 * vLo   \n\
// z2w2z3w3         \n\
// z0z1z2z3         \n\
// z0z1z2z3 * vHi   \n\
// x0y0x1y1 * vLo   \n\
// x0x1x2x3 * vLo.x \n\
// y0y1y2y3 * vLo.y \n\
// x + y            \n\
// x + y + z        \n\
// record result for later scrutiny \n\
// record max, restore max   \n\
// advance loop counter\n\
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
//__APPLE__
// process the last few points
// Calculate 3 dot products, transpose, duplicate v2
// xyxy.lo
// z?z?.lo
// z0z1z2z2
// xyxy
// control the order here so that max is never NaN even if x is nan
// if we found a new max.
// we found a new max. Search for it
// find max across the max vector, place in all elements of max -- big latency hit here
// It is slightly faster to do this part in scalar code when count < 8. However, the common case for
// this where it actually makes a difference is handled in the early out at the top of the function,
// so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
// complexity, and removed it.
// scan for the first occurence of max in the array
// local_count must be a multiple of 4
/// zzzz
/// xyxy
//memset( stack_array, -1, STACK_ARRAY_COUNT * sizeof(stack_array[0]) );
// Faster loop without cleanup code for full tiles
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
// If we found a new min
// copy the new min across all lanes of our min accumulator
// find first occurrence of that min
// local_count must be a multiple of 4
// record where it is.
// account for work we've already done
// Deal with the last < STACK_ARRAY_COUNT vectors
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that min is never NaN even if x is nan
// It is too costly to keep the index of the min here. We will look for it again later.  We save a lot of work this way.
// counter the offset
// move min out of the way to avoid propagating NaNs in min \n\
// vertices[0]      \n\
// vertices[1]      \n\
// vertices[0]      \n\
// x0y0x1y1         \n\
// vertices[2]      \n\
// vertices[3]      \n\
// x0y0x1y1 * vLo   \n\
// z0w0z1w1         \n\
// vertices[2]      \n\
// x2y2x3y3         \n\
// z2w2z3w3         \n\
// x2y2x3y3 * vLo   \n\
// z0z1z2z3         \n\
// z0z1z2z3 * vHi   \n\
// x0y0x1y1 * vLo   \n\
// x0x1x2x3 * vLo.x \n\
// y0y1y2y3 * vLo.y \n\
// x + y            \n\
// x + y + z        \n\
// record result for later scrutiny \n\
// record min, restore min   \n\
// advance loop counter\n\
// do four dot products at a time. Carefully avoid touching the w element.
// x0y0x1y1
// z0?0z1?1
// x2y2x3y3
// z2?2z3?3
// control the order here so that max is never NaN even if x is nan
// process the last few points
// Calculate 3 dot products, transpose, duplicate v2
// xyxy.lo
// z?z?.lo
// z0z1z2z2
// xyxy
// control the order here so that min is never NaN even if x is nan
// if we found a new min.
// we found a new min. Search for it
// find min across the min vector, place in all elements of min -- big latency hit here
// It is slightly faster to do this part in scalar code when count < 8. However, the common case for
// this where it actually makes a difference is handled in the early out at the top of the function,
// so it is less than a 1% difference here. I opted for improved code size, fewer branches and reduced
// complexity, and removed it.
// scan for the first occurence of min in the array
// local_count must be a multiple of 4
//for sysctlbyname
/*return*/ _r; })
//support 64bit arm
/*return*/ _r; })
// select best answer between hi and lo results
// select best answer between even and odd results
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// select best answer between hi and lo results
// select best answer between even and odd results
// select best answer between hi and lo results
// select best answer between even and odd results
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// the next two lines should resolve to a single vswp d, d
// select best answer between hi and lo results
// select best answer between even and odd results
/* __APPLE__ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\TaskScheduler\btTaskScheduler.cpp
// directives for all worker threads packed into a single cacheline
// go to sleep
// wait for not checking job queue
// actively scan job queue for jobs
// call the functor body to do the work
// call the functor body to do the work
// by truncating bits of the result, we can make the parallelSum deterministic (at the expense of precision)
// truncate some bits
// prevent false sharing
// free old
// make sure we have enough memory allocated to store jobs
// make sure job queue is big enough
// lock free path. even if this is taken erroneously it isn't harmful
// own queue is empty, try to steal from neighbor
// do work
// while queue is empty,
// todo: spin wait a bit to avoid hammering the empty queue
// if jobs are incoming,
// reset clock
// if no jobs incoming and queue has been empty for the cooldown time, sleep
// go sleep
// prevent nested parallel-for
// ideal to have one job queue for each physical processor (except for the main thread which needs no queue)
// only worker threads get a job queue
// one queue per worker thread
// 2 threads share each queue
// 100 microseconds, threads go to sleep after this long if they have nothing to do
// no work for them yet
// if there is at least 1 worker,
// re-setup job stealing between queues to avoid attempting to steal from an inactive job queue
// have the main thread work until the job queues are empty
// done with jobs for now, tell workers to rest (but not sleep)
// wait for workers to finish any jobs in progress
// note this count of active workers is not necessarily totally reliable, because a worker thread could be
// just about to put itself to sleep. So we may on occasion fail to wake up all the workers. It should be rare.
// hint the task scheduler that we may not be using these threads for a little while
// need more than one job for multithreading
// prepare worker threads for incoming work
// submit all of the jobs
// first worker thread
// placement new
// first worker thread
// put the main thread to work on emptying the job queue and then wait for all workers to finish
// just run on main thread
// need more than one job for multithreading
// initialize summation
// prepare worker threads for incoming work
// submit all of the jobs
// first worker thread
// placement new
// first worker thread
// put the main thread to work on emptying the job queue and then wait for all workers to finish
// add up all the thread sums
// just run on main thread
// #if BT_THREADSAFE
// #else // #if BT_THREADSAFE
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\TaskScheduler\btThreadSupportPosix.cpp
/*
//bulletphysics.com
//for definition of pthread_barrier_t, see http://pages.cs.wisc.edu/~travitch/pthreads_primer.html
//_XOPEN_SOURCE
//for sysconf
///
/// getNumHardwareThreads()
///
///
/// https://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine
///
// btThreadSupportPosix helps to initialize/shutdown libspe2, start/stop SPU tasks and communication
//for taskDesc etc
//each tread will wait until this signal to start its work
// this is a copy of m_mainSemaphore,
//each tread will signal once it is finished with its work
// m_mainSemaphoresemaphore will signal, if and how many threads are finished with their work
// TODO: return the number of logical processors sharing the first L3 cache
// TODO: detect if CPU has hyperthreading enabled
// The number of threads should be equal to the number of available cores
// Todo: each worker should be linked to a single core, using SetThreadIdealProcessor.
// cleanup/shutdown Libspe2
/// Named semaphore begin
//        printf("Created \"%s\" Semaphore %p\n", name, tempSem);
//printf("Error creating Semaphore %d\n", errno);
/// Named semaphore end
//exit Thread
///send messages to SPUs
///we should spawn an SPU task here, and in 'waitForResponse' it should wait for response of the (one of) the first tasks that finished
// fire event to start new task
///check for messages from SPUs
///We should wait for (one of) the first tasks to finish (or other SPU messages), and report its response
///A possible response can be 'yes, SPU handled it', or 'no, please do a PPU fallback'
// wait for any of the threads to finish
// get at least one thread which has finished
// need to find an active spu
// main thread exists already
//checkPThreadFunction(sem_wait(mainSemaphore));
///tell the task scheduler we are done with the SPU tasks
// BT_THREADSAFE && !defined( _WIN32 )
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\LinearMath\TaskScheduler\btThreadSupportWin32.cpp
/*
//bulletphysics.com
// no info
// processors that share L3 cache are considered to be on the same team
// because they can more easily work together on the same data.
// Large performance penalties will occur if 2 or more threads from different
// teams attempt to frequently read and modify the same cache lines.
//
// On the AMD Ryzen 7 CPU for example, the 8 cores on the CPU are split into
// 2 CCX units of 4 cores each. Each CCX has a separate L3 cache, so if both
// CCXs are operating on the same data, many cycles will be spent keeping the
// two caches coherent.
///btThreadSupportWin32 helps to initialize/shutdown libspe2, start/stop SPU tasks and communication
//for taskDesc etc
//this one is calling 'Win32ThreadFunc'
//exit Thread
///fire event to start new task
//WaitForSingleObject(threadStatus.m_eventCompleteHandle, INFINITE);
///need to find an active spu
///The number of threads should be equal to the number of available cores - 1
// cap to max thread count (-1 because main thread already exists)
// set main thread affinity
//SetThreadPriority( handle, THREAD_PRIORITY_HIGHEST );
// highest priority -- can cause erratic performance when numThreads > numCores
//                     we don't want worker threads to be higher priority than the main thread or the main thread could get
//                     totally shut out and unable to tell the workers to stop
//SetThreadPriority( handle, THREAD_PRIORITY_BELOW_NORMAL );
// leave processor 0 for main thread
// bind each thread to only execute on processors of it's assigned team
//  - for single-socket Intel x86 CPUs this has no effect (only a single, shared L3 cache so there is only 1 team)
//  - for multi-socket Intel this will keep threads from migrating from one socket to another
//  - for AMD Ryzen this will keep threads from migrating from one CCX to another
///tell the task scheduler we are done with the SPU tasks
//defined(_WIN32) && BT_THREADSAFE
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\blas\complex_double.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\blas\complex_single.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\blas\double.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>
// Copyright (C) 2012 Chen-Pang He <jdh8@ms63.hinet.net>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\blas\single.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\blas\xerbla.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\cholesky.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2010-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// POTRF computes the Cholesky factorization of a real symmetric positive definite matrix A.
// POTRS solves a system of linear equations A*X = B with a symmetric
// positive definite matrix A using the Cholesky factorization
// A = U**T*U or A = L*L**T computed by DPOTRF.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\complex_double.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\complex_single.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\double.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\eigenvalues.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges
/*work*/, int* lwork, int *info))
// TODO exploit the work buffer
//   if(*info==0)
//   {
//     int nb = ILAENV( 1, 'SSYTRD', UPLO, N, -1, -1, -1 )
//          LWKOPT = MAX( 1, ( NB+2 )*N )
//          WORK( 1 ) = LWKOPT
// *
//          IF( LWORK.LT.MAX( 1, 3*N-1 ) .AND. .NOT.LQUERY )
//      $      INFO = -8
//       END IF
// *
//       IF( INFO.NE.0 ) THEN
//          CALL XERBLA( 'SSYEV ', -INFO )
//          RETURN
//       ELSE IF( LQUERY ) THEN
//          RETURN
//       END IF
//*info = 1;
/*info = 1;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\lu.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2010-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges
//GETRS solves a system of linear equations
//    A * X = B  or  A' * X = B
//  with a general N-by-N matrix A using the LU factorization computed  by GETRF
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Eigen\lapack\single.cpp
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2009-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\Etc\Etc.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
// C-style inteface to the encoder
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\Etc\EtcFilter.cpp
//inline float sincf( float x )
//{
//    x *= F_PI;
//    if (x < 0.01f && x > -0.01f)
//    {
//        return 1.0f + x*x*(-1.0f/6.0f + x*x*1.0f/120.0f);
//    }
//
//    return sinf(x)/x;
//}
//
//double bessel0(double x) 
//{
//    const double EPSILON_RATIO = 1E-16;
//    double xh, sum, pow, ds;
//    int k;
//
//    xh = 0.5 * x;
//    sum = 1.0;
//    pow = 1.0;
//    k = 0;
//    ds = 1.0;
//    while (ds > sum * EPSILON_RATIO) 
//    {
//        ++k;
//        pow = pow * (xh / k);
//        ds = pow * pow;
//        sum = sum + ds;
//    }
//
//    return sum;
//}
//**--------------------------------------------------------------------------
/**--------------------------------------------------------------------------
//** Returns:
/** Returns:
//**--------------------------------------------------------------------------
/**--------------------------------------------------------------------------
//{
//    double ratio = (x / half_width);
//    return bessel0(alpha * sqrt(1 - ratio * ratio)) / bessel0(alpha);
//}
//
//float Filter_Lanczos4Sinc(float x)
//{
//    if (x <= -4.0f || x >= 4.0f)    // half-width of 4
//    {
//        return 0.0;
//    }
//
//    return sinc(0.875f * x) * sinc(0.25f * x);
//}
//
//double Filter_Kaiser4( double t )
//{
//    return kaiser( 4.0, 3.0, t);
//}
//
//double Filter_KaiserOptimal( double t )
//{
//    return kaiser( 8.93, 3.0f, t);
//}                  
//**--------------------------------------------------------------------------
/**--------------------------------------------------------------------------
//**                          int destSize, 
/**                          int destSize, 
//**						  bool wrap,
/**						  bool wrap,
//**                          FilterWeights contrib[] )
/**                          FilterWeights contrib[] )
//** Description:
/** Description:
//**--------------------------------------------------------
/**--------------------------------------------------------
//**--------------------------------------------------------
/**--------------------------------------------------------
//**-------------------------------------------------------------------------
/**-------------------------------------------------------------------------
//**                       int srcWidth, int srcHeight, 
/**                       int srcWidth, int srcHeight, 
//**                       int destWidth, int destHeight, 
/**                       int destWidth, int destHeight, 
//** Returns: 0 on failure and 1 on success
/** Returns: 0 on failure and 1 on success
//**    weighted contributions of the pixels within the filter region.  The
/**    weighted contributions of the pixels within the filter region.  The
//**-------------------------------------------------------------------------
/**-------------------------------------------------------------------------
//**------------------------------------------------------------------------
/**------------------------------------------------------------------------
//**------------------------------------------------------------------------
/**------------------------------------------------------------------------
//**-------------------------------------------------------
/**-------------------------------------------------------
//**-------------------------------------------------------
/**-------------------------------------------------------
//**-------------------------------------------------------
/**-------------------------------------------------------
//**-------------------------------------------------------
/**-------------------------------------------------------
//**-------------------------------------------------------------------------
/**-------------------------------------------------------------------------
//**                       RGBCOLOR *pDstImage, int dstWidth, int dstHeight)
/**                       RGBCOLOR *pDstImage, int dstWidth, int dstHeight)
//** Description: This function runs a 2d box filter over the srouce image
/** Description: This function runs a 2d box filter over the srouce image
//**-------------------------------------------------------------------------
/**-------------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\Etc\EtcImage.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// fix conflict with Block4x4::AlphaMix
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// constructor using source image
// used to set state before Encode() is called
//
// ----------------------------------------------------------------------------------------------------
// constructor using encoding bits
// recreates encoding state using a previously encoded image
//
// ----------------------------------------------------------------------------------------------------
//
/*if (m_paucEncodingBits != nullptr)
// ----------------------------------------------------------------------------------------------------
// encode an image
// create a set of encoding bits that conforms to a_format
// find best fit using a_errormetric
// explore a range of possible encodings based on a_fEffort (range = [0:100])
// speed up process using a_uiJobs as the number of process threads (a_uiJobs must not excede a_uiMaxJobs)
//
// perform effort-based encoding
// m_psortedblocklist->Print();
//stop enocding when we did enough to satify the effort percentage
//since we already how many blocks each thread will process
//cap the thread limit to do the proper amount of work, and not more
//we have a lot of work to do, so lets multi thread it
// generate Etc2-compatible bit-format 4x4 blocks
// ----------------------------------------------------------------------------------------------------
// iterate the encoding thru the blocks with the worst error
// stop when a_uiMaxBlocks blocks have been iterated
// split the blocks between the process threads using a_uiMultithreadingOffset and a_uiMultithreadingStride
//
// ----------------------------------------------------------------------------------------------------
// determine which warnings to check for during Encode() based on encoding format
//
// ----------------------------------------------------------------------------------------------------
// examine source pixels to check for warnings
//
// ----------------------------------------------------------------------------------------------------
// return a string name for a given image format
//
// ----------------------------------------------------------------------------------------------------
// return a string name for the image's format
//
// ----------------------------------------------------------------------------------------------------
// init image blocks prior to encoding
// init block sorter for subsequent sortings
// check for encoding warnings
//
// init each block
// init block sorter
// ----------------------------------------------------------------------------------------------------
// run the first pass of the encoder
// the encoder generally finds a reasonable, fast encoding
// this is run on all blocks regardless of effort to ensure that all blocks have a valid encoding
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits (for the output file) based on the best encoding for each block
//
// ----------------------------------------------------------------------------------------------------
// return the image error
// image error is the sum of all block errors
//
// ----------------------------------------------------------------------------------------------------
// determine the encoding bits format based on the encoding format
// the encoding bits format is a family of bit encodings that are shared across various encoding formats
//
// determine encoding bits format from image format
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\Etc\EtcMath.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
// calculate the line that best fits the set of XY points contained in a_afX[] and a_afY[]
// use a_fSlope and a_fOffset to define that line
//
// if vertical line
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/* 
// ETC pixels are scanned vertically.  
// this mapping is for when someone wants to scan the ETC pixels horizontally
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding from a source image
// [a_uiSourceH,a_uiSourceV] is the location of the block in a_pimageSource
// a_paucEncodingBits is the place to store the final encoding
// a_errormetric is used for finding the best encoding
//
// set block encoder function
// ----------------------------------------------------------------------------------------------------
// initialization of encoding state from a prior encoding using encoding bits
// [a_uiSourceH,a_uiSourceV] is the location of the block in a_pimageSource
// a_paucEncodingBits is the place to read the prior encoding
// a_imageformat is used to determine how to interpret a_paucEncodingBits
// a_errormetric was used for the prior encoding
//
// set block encoder function
// ----------------------------------------------------------------------------------------------------
// set source pixels from m_pimageSource
// set m_alphamix
//
// alpha census
// copy source to consecutive memory locations
// convert from image horizontal scan to block vertical scan
// if pixel extends beyond source image because of block padding
// denotes border pixel
//get teh current pixel data, and store some of the attributes
//before capping values to fit the encoder type
//make sure we are getting a float between 0-1
// for formats with no alpha, set source alpha to 1
// for RGB8A1, set source alpha to 0.0 or 1.0
// set punch through flag
// ----------------------------------------------------------------------------------------------------
// return a name for the encoding mode
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialize the generic encoding for a 4x4 block
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// init the decoded pixels to -1 to mark them as undefined
// init the error to -1 to mark it as undefined
//
// ----------------------------------------------------------------------------------------------------
// calculate the error for the block by summing the pixel errors
//
// ----------------------------------------------------------------------------------------------------
// calculate the error between the source pixel and the decoded pixel
// the error amount is base on the error metric
//
// if a border pixel
// Favor Luma accuracy over Chroma, and Red over Blue 
// ErrorMetric::NUMERIC
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_ETC1.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// pixel processing order if the flip bit = 0 (horizontal split)
// pixel processing order if the flip bit = 1 (vertical split)
// pixel processing order for horizontal scan (ETC normally does a vertical scan)
// pixel indices for different block halves
// CW ranges that the ETC1 decoders use
// CW is basically a contrast for the different selector bits, since these values are offsets to the base color
// the first axis in the array is indexed by the CW in the encoding bits
// the second axis in the array is indexed by the selector bits
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// ----------------------------------------------------------------------------------------------------
// init the selectors from a prior encoding
//
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
// find best initial encoding to ensure block has a valid encoding
//
// ----------------------------------------------------------------------------------------------------
// algorithm:
// create a source average color for the Left, Right, Top and Bottom halves using the 8 pixels in each half
// note: the "gray line" is the line of equal delta RGB that goes thru the average color
// for each half:
//		see how close each of the 8 pixels are to the "gray line" that goes thru the source average color
//		create an error value that is the sum of the distances from the gray line
// h_error is the sum of Left and Right errors
// v_error is the sum of Top and Bottom errors
//
// ----------------------------------------------------------------------------------------------------
// calculate source pixel averages for each 2x2 quadrant in a 4x4 block
// these are used to determine the averages for each of the 4 different halves (left, right, top, bottom)
// ignore pixels that have alpha == NAN (these are border pixels outside of the source image)
// weight the averages based on a pixel's alpha
//
// treat alpha NAN as 0.0f
// check to see if there is at least 1 pixel with  non-zero alpha
// completely transparent block should not make it to this code
// ----------------------------------------------------------------------------------------------------
// try an ETC1 differential mode encoding
// use a_boolFlip to set the encoding F bit
// use a_uiRadius to alter basecolor components in the range[-a_uiRadius:a_uiRadius]
// use a_iGrayOffset1 and a_iGrayOffset2 to offset the basecolor to search for degenerate encodings
// replace the encoding if the encoding error is less than previous encoding
//
// find best halves that are within differential range
// see if the best of each half are in differential range
// else, find the next best halves that are in differential range
// sanity check
// ----------------------------------------------------------------------------------------------------
// try an ETC1 differential mode encoding for a half of a 4x4 block
// vary the basecolor components using a radius
//
// try each CW
// pre-compute decoded pixels for each selector
// add up all pixel errors
// if best CW so far
// ----------------------------------------------------------------------------------------------------
// try an ETC1 individual mode encoding
// use a_boolFlip to set the encoding F bit
// use a_uiRadius to alter basecolor components in the range[-a_uiRadius:a_uiRadius]
// replace the encoding if the encoding error is less than previous encoding
//
// use the best of each half
// ----------------------------------------------------------------------------------------------------
// try an ETC1 differential mode encoding for a half of a 4x4 block
// vary the basecolor components using a radius
//
// try each CW
// pre-compute decoded pixels for each selector
// add up all pixel errors
// if best CW so far
// ----------------------------------------------------------------------------------------------------
// try version 1 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 2 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 3 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 4 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// find the best selector for each pixel based on a particular basecolor and CW that have been previously set
// calculate the selectors for each half of the block separately
// set the block error as the sum of each half's error
//
// ----------------------------------------------------------------------------------------------------
// choose best selectors for half of the block
// calculate the error for half of the block
//
// try each CW
// add up all pixel errors
// if best CW so far
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// ----------------------------------------------------------------------------------------------------
// set the selectors in the encoding bits
//
// set index msb
// set index lsb
// ----------------------------------------------------------------------------------------------------
// set the decoded colors and decoded alpha based on the encoding state
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_R11.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// modifier values to use for R11, SR11, RG11 and SRG11
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// init RGB portion
// init R11 portion
// decode the red channel
// calc red error
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// artificially high value
// ----------------------------------------------------------------------------------------------------
// find the best combination of base color, multiplier and selectors
//
// a_uiSelectorsUsed limits the number of selector combinations to try
// a_fBaseRadius limits the range of base colors to try
// a_fMultiplierRadius limits the range of multipliers to try
//
// maps from virtual (monotonic) selector to ETC selector
// find min/max red
// ignore border pixels
// try each modifier table entry							  
// find best selector for each pixel
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_RG11.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// init RGB portion
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// artificially high value
// ----------------------------------------------------------------------------------------------------
// find the best combination of base color, multiplier and selectors
//
// a_uiSelectorsUsed limits the number of selector combinations to try
// a_fBaseRadius limits the range of base colors to try
// a_fMultiplierRadius limits the range of multipliers to try
//
// maps from virtual (monotonic) selector to etc selector
// find min/max Grn
// ignore border pixels
// try each modifier table entry							  
// find best selector for each pixel
//DecodePixelRed is not red channel specific
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_RGB8.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// handle ETC1 modes
// detect if there is a T, H or Planar mode present
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding if T mode is detected
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding if H mode is detected
//
// used to determine the LSB of the CW
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding if Planar mode is detected
//
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
// try encoding in Planar mode
// save this encoding if it improves the error
//
// init "try"
// ----------------------------------------------------------------------------------------------------
// try encoding in T mode or H mode
// save this encoding if it improves the error
//
// ----------------------------------------------------------------------------------------------------
// calculate original values for base colors
// store them in m_frgbaOriginalColor1 and m_frgbaOriginalColor2
//
// find pixel farthest from average gray line
// don't count transparent
// a transparent block should not reach this method
// set the original base colors to:
//		half way to the farthest pixel and
//		the mirror color on the other side of the average
// the "other side" might be out of range
// move base colors to find best fit
// find the center of pixels closest to each color
// don't count transparent pixels
// ----------------------------------------------------------------------------------------------------
// try encoding in T mode
// save this encoding if it improves the error
//
// since pixels that use base color1 don't use the distance table, color1 and color2 can be twiddled independently
// better encoding can be found if TWIDDLE_RADIUS is set to 2, but it will be much slower
//
// init "try"
// twiddle m_frgbaOriginalColor2_TAndH
// twiddle color2 first, since it affects 3 selectors, while color1 only affects one selector
//
// twiddle m_frgbaOriginalColor1_TAndH
// ----------------------------------------------------------------------------------------------------
// find best selector combination for TryT
// called on an encodingTry
//
// try each selector
// add up all of the pixel errors
// ----------------------------------------------------------------------------------------------------
// try encoding in T mode
// save this encoding if it improves the error
//
// since all pixels use the distance table, color1 and color2 can NOT be twiddled independently
// TWIDDLE_RADIUS of 2 is WAY too slow
//
// init "try"
// twiddle m_frgbaOriginalColor1_TAndH
// if color1 == color2, H encoding issues can pop up, so abort
// twiddle m_frgbaOriginalColor2_TAndH
// if color1 == color2, H encoding issues can pop up, so abort
// ----------------------------------------------------------------------------------------------------
// find best selector combination for TryH
// called on an encodingTry
//
// try each selector
// add up all of the pixel errors
// ----------------------------------------------------------------------------------------------------
// use linear regression to find the best fit for colors along the edges of the 4x4 block
//
// top edge
// left edge
// average with top edge
// right edge
// average with top edge
// bottom edge
// average with left edge
// quantize corner colors to 6/7/6
// ----------------------------------------------------------------------------------------------------
// try different corner colors by slightly changing R, G and B independently
//
// R, G and B decoding and errors are independent, so R, G and B twiddles can be independent
//
// return true if improvement
//
// ----------------------------------------------------------------------------------------------------
// try different corner colors by slightly changing R
//
// init "try"
// check for out of range
// check for out of range
// check for out of range
// don't bother with null twiddle
// ----------------------------------------------------------------------------------------------------
// try different corner colors by slightly changing G
//
// init "try"
// check for out of range
// check for out of range
// check for out of range
// don't bother with null twiddle
// ----------------------------------------------------------------------------------------------------
// try different corner colors by slightly changing B
//
// init "try"
// check for out of range
// check for out of range
// check for out of range
// don't bother with null twiddle
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state for T mode
//
// create an invalid R differential to trigger T mode
// make sure red overflows
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state for H mode
//
// colors and selectors may need to swap in order to generate lsb of distance index
//
// create an invalid R differential to trigger T mode
// make sure red doesn't overflow and green does
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state for Planar mode
//
// create valid RG differentials and an invalid B differential to trigger planar mode
// make sure red and green don't overflow and blue does
// ----------------------------------------------------------------------------------------------------
// set the decoded colors and decoded alpha based on the encoding state for T mode
//
// ----------------------------------------------------------------------------------------------------
// set the decoded colors and decoded alpha based on the encoding state for H mode
//
// ----------------------------------------------------------------------------------------------------
// set the decoded colors and decoded alpha based on the encoding state for Planar mode
//
// ----------------------------------------------------------------------------------------------------
// perform a linear regression for the a_uiPixels in a_pafrgbaPixels[]
//
// output the closest color line using a_pfrgbaSlope and a_pfrgbaOffset
//
// handle r, g and b separately.  don't bother with a
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_RGB8A1.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ####################################################################################################
// Block4x4Encoding_RGB8A1
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// detect if there is a T, H or Planar mode present
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding assuming the encoding is an ETC1 mode.
// if it isn't an ETC1 mode, this will be overwritten later
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding if T mode is detected
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding if H mode is detected
//
// used to determine the LSB of the CW
// ----------------------------------------------------------------------------------------------------
// for ETC1 modes, set the decoded colors and decoded alpha based on the encoding state
//
// ----------------------------------------------------------------------------------------------------
// for T mode, set the decoded colors and decoded alpha based on the encoding state
//
// ----------------------------------------------------------------------------------------------------
// for H mode, set the decoded colors and decoded alpha based on the encoding state
//
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// RGB8A1 can't use individual mode
// RGB8A1 with transparent pixels can't use planar mode
//
// ----------------------------------------------------------------------------------------------------
// find best initial encoding to ensure block has a valid encoding
//
// ----------------------------------------------------------------------------------------------------
// mostly copied from ETC1
// differences:
//		Block4x4Encoding_RGB8A1 encodingTry = *this;
//
// find best halves that are within differential range
// see if the best of each half are in differential range
// else, find the next best halves that are in differential range
// sanity check
// ----------------------------------------------------------------------------------------------------
// mostly copied from ETC1
// differences:
//		uses s_aafCwOpaqueUnsetTable
//		color for selector set to 0,0,0,0
//
// try each CW
// pre-compute decoded pixels for each selector
// add up all pixel errors
// if best CW so far
// ----------------------------------------------------------------------------------------------------
// try encoding in T mode
// save this encoding if it improves the error
//
// since pixels that use base color1 don't use the distance table, color1 and color2 can be twiddled independently
// better encoding can be found if TWIDDLE_RADIUS is set to 2, but it will be much slower
//
// init "try"
// twiddle m_frgbaOriginalColor2_TAndH
// twiddle color2 first, since it affects 3 selectors, while color1 only affects one selector
//
// twiddle m_frgbaOriginalColor1_TAndH
// ----------------------------------------------------------------------------------------------------
// find best selector combination for TryT
// called on an encodingTry
//
// try each selector
// add up all of the pixel errors
// ----------------------------------------------------------------------------------------------------
// try encoding in H mode
// save this encoding if it improves the error
//
// since all pixels use the distance table, color1 and color2 can NOT be twiddled independently
// TWIDDLE_RADIUS of 2 is WAY too slow
//
// init "try"
// twiddle m_frgbaOriginalColor1_TAndH
// if color1 == color2, H encoding issues can pop up, so abort
// twiddle m_frgbaOriginalColor2_TAndH
// if color1 == color2, H encoding issues can pop up, so abort
// ----------------------------------------------------------------------------------------------------
// find best selector combination for TryH
// called on an encodingTry
//
// abort if colors and CW will pose an encoding problem
// try each selector
// add up all of the pixel errors
// ----------------------------------------------------------------------------------------------------
// try version 1 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 2 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 3 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// try version 4 of the degenerate search
// degenerate encodings use basecolor movement and a subset of the selectors to find useful encodings
// each subsequent version of the degenerate search uses more basecolor movement and is less likely to
//		be successfull
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state if ETC1 mode
//
// there is no individual mode in RGB8A1
// in RGB8A1 encoding bits, opaque replaces differential
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state if T mode
//
// in RGB8A1 encoding bits, opaque replaces differential
// create an invalid R differential to trigger T mode
// make sure red overflows
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state if H mode
//
// colors and selectors may need to swap in order to generate lsb of distance index
//
// in RGB8A1 encoding bits, opaque replaces differential
// create an invalid R differential to trigger T mode
// make sure red doesn't overflow and green does
// ####################################################################################################
// Block4x4Encoding_RGB8A1_Opaque
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
// find best initial encoding to ensure block has a valid encoding
//
// set decoded alphas
// calculate alpha error
// ####################################################################################################
// Block4x4Encoding_RGB8A1_Transparent
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcBlock4x4Encoding_RGBA8.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ####################################################################################################
// Block4x4Encoding_RGBA8
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// initialization prior to encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits
//
// ----------------------------------------------------------------------------------------------------
// initialization from the encoding bits of a previous encoding
// a_pblockParent points to the block associated with this encoding
// a_errormetric is used to choose the best encoding
// a_pafrgbaSource points to a 4x4 block subset of the source image
// a_paucEncodingBits points to the final encoding bits of a previous encoding
//
// init RGB portion
// init A8 portion
// has to be done after InitFromEncodingBits()
// decode the alphas
// calc alpha error
// redo error calc to include alpha
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// similar to Block4x4Encoding_RGB8_Base::Encode_RGB8(), but with alpha added
//
// ----------------------------------------------------------------------------------------------------
// find the best combination of base alpga, multiplier and selectors
//
// a_fRadius limits the range of base alpha to try
//
// find min/max alpha
// ignore border pixels
// try each modifier table entry
// artificially high value
// find best selector for each pixel
// border pixels (NAN) should have zero error
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// set the RGB8 portion
// set the A8 portion
// ####################################################################################################
// Block4x4Encoding_RGBA8_Opaque
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// set the RGB8 portion
// set the A8 portion
// ####################################################################################################
// Block4x4Encoding_RGBA8_Transparent
// ####################################################################################################
// ----------------------------------------------------------------------------------------------------
// perform a single encoding iteration
// replace the encoding if a better encoding was found
// subsequent iterations generally take longer for each iteration
// set m_boolDone if encoding is perfect or encoding is finished based on a_fEffort
//
// ----------------------------------------------------------------------------------------------------
// set the encoding bits based on encoding state
//
// set the A8 portion
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcDifferentialTrys.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
// construct a list of trys (encoding attempts)
//
// a_frgbaColor1 is the basecolor for the first half
// a_frgbaColor2 is the basecolor for the second half
// a_pauiPixelMapping1 is the pixel order for the first half
// a_pauiPixelMapping2 is the pixel order for the second half
// a_uiRadius is the amount to vary the base colors
//
// quantize base colors
// ensure that trys with a_uiRadius don't overflow
// make sure components are within range
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcIndividualTrys.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
// construct a list of trys (encoding attempts)
//
// a_frgbaColor1 is the basecolor for the first half
// a_frgbaColor2 is the basecolor for the second half
// a_pauiPixelMapping1 is the pixel order for the first half
// a_pauiPixelMapping2 is the pixel order for the second half
// a_uiRadius is the amount to vary the base colors
//
// quantize base colors
// ensure that trys with a_uiRadius don't overflow
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcLib\EtcCodec\EtcSortedBlockList.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// ----------------------------------------------------------------------------------------------------
// construct an empty list
//
// allocate enough memory to add all of the image's 4x4 blocks later
// allocate enough buckets to sort the blocks
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// add a 4x4 block to the list
// the 4x4 block will be sorted later
//
// ----------------------------------------------------------------------------------------------------
// sort all of the 4x4 blocks that have been added to the list
//
// first, determine the maximum error, then assign an error range to each bucket
// next, determine which bucket each 4x4 block belongs to based on the 4x4 block's error
// add the 4x4 block to the appropriate bucket
// lastly, walk thru the buckets and add each bucket to a sorted linked list
//
// the resultant sorting is an approximate sorting from most to least error
//
// find max block error
// prevent divide by zero or divide by negative
//used for debugging
//int numDone = 0;
// put all of the blocks with unfinished encodings into the appropriate bucket
// if the encoding is done, don't add it to the list
//numDone++;
// calculate the appropriate sort bucket
// clamp to bucket index
// add block to bucket
//printf("num blocks already done: %d\n",numDone);
//link the blocks together across buckets
// ----------------------------------------------------------------------------------------------------
// clear all of the buckets.  normally done in preparation for a sort
//
// ----------------------------------------------------------------------------------------------------
// print out the list of sorted 4x4 blocks
// normally used for debugging
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcAnalysis.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
//sqrt fn()
// ----------------------------------------------------------------------------------------------------
//
// write log file
// output stats to both stdout and the analysis file
// scale == 1
// scale == 2, with modes
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// draw 2x image
// optionally display encoding modes
// ----------------------------------------------------------------------------------------------------
//
// output pixel coord of upper left corner of block
// draw scaled pixel
// ----------------------------------------------------------------------------------------------------
//
// output pixel coord of upper left corner of block
// outline
// H/V split
// individial
// draw mode
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcComparison.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
//
// read etc file
// construct image with encoding bits
// scale = 1
// scale = 2, with modes
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// output pixel coord of upper left corner of block
// equal
// better tthan reference
// worse than reference
// if 20% worse
// if 10% worse
// if 5% worse
// outline
// ----------------------------------------------------------------------------------------------------
//
// alloc memory for name
// first, try to find folder name of comparison image
// find last slash
// find penultimate slash
// otherwise use index as name
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcFile.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
//
// ***** TODO: add this later *****
// ----------------------------------------------------------------------------------------------------
//
// ***** TODO: add this later *****
// ----------------------------------------------------------------------------------------------------
//
// ***** TODO: add this later *****
//if we are using a ktx thats the size of a single block or less
//then make sure we use the 4x4 image as the single block
//if we are using a ktx thats the size of a single block or less
//then make sure we use the 4x4 image as the single block
//block position in pixels
// remove the bottom 2 bits to get the block coordinates 
// block location 
//int iBlockX = (a_iPixelX % 4) == 0 ? a_iPixelX / 4.0f : (a_iPixelX / 4) + 1;
//int iBlockY = (a_iPixelY % 4) == 0 ? a_iPixelY / 4.0f : (a_iPixelY / 4) + 1;
//m_paucEncodingBits += ((iBlockY * numXBlocks) + iBlockX) * uiEncodingBitsBytesPerBlock;
// ----------------------------------------------------------------------------------------------------
//
// Write u32 image size
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcFileHeader.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
//
// ETC1_RGB_NO_MIPMAPS
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// first four bytes of Byte[12] identifier
// next four bytes of Byte[12] identifier
// final four bytes of Byte[12] identifier
// ----------------------------------------------------------------------------------------------------
//
// Write header
// Write KeyAndValuePairs
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcMemTest.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// Use to convert bytes to KB
// Specify the width of the field in which to print the numbers. 
// The asterisk in the format specifier "%*I64d" takes an integer 
// argument and uses it to pad and right justify the number.
//MEMORYSTATUS status; // if 64 bit version isnt working, use 32bit version
//GlobalMemoryStatus(&status);
/*MEMORYSTATUSEX status;
// Show the amount of extended memory available.
//0 = c , 1= both c and c++ encoding, 2 = c++ encoding
//Image::Format format = (Image::Format)randomNumber;
//char *imgonnaleak = new char[1000];
//////////////C INTERFACE FIRST//////////////////////
//////////////C++ INTERFACE ///////////////////////////
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcSourceImage.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
//if stb_iamge is available, only use it to load files other than png
//we can load 8 or 16 bit pngs
//the pixel cords for the top left corner of the block
// in 1 block mode, we basically will have an img thats 4x4
// remove the bottom 2 bits to get the block coordinates 
// = &paucPixels[(iBlockY * iWidth + iBlockX) * iBytesPerPixel];
// convert pixels from RGBA* to ColorFloatRGBA
// reset coordinate for each row
// read each row
// ----------------------------------------------------------------------------------------------------
// sets m_pstrFilename, m_pstrName and m_pstrFileExtension
//
// ignore directory path
// find file extension and remove it from image name
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
// namespace Etc
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\EtcTool\EtcTool.cpp
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//Rec. 709 or BT.709...the default
//these are ignored if they are < 0
// for threading
//when both of these are >= 0 then single block mode is on
// ----------------------------------------------------------------------------------------------------
//
// this code tests for memory leaks
// Calculate the maximum number of possible mipmaps
// ----------------------------------------------------------------------------------------------------
// return true if usage message should be printed
//
// add null executable name
// read in tokens
// read in each line
// skip over lines with '#' in first char
// abort remainder of argfile with '%' in first char
//used for debugging...select a single block to encode
//supply the horiz and very pos of the block
//make sure we have two more args after -block
//take the output file name and extract the directory path so we can create the directory if nescacary
//find the last slash, to get the name of the directory
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
// print usage message and exit
//
// ----------------------------------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------------------------------
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\etc2comp\third_party\lodepng\lodepng.cpp
/*
/*
/*LODEPNG_COMPILE_CPP*/
/*Visual Studio: A few warning types are not desired here.*/
/*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/
/*VS does not like fopen, but fopen_s is not standard C so unusable here*/
/*_MSC_VER */
/*
/*The malloc, realloc and free functions defined here with "lodepng_" in front
/*LODEPNG_COMPILE_ALLOCATORS*/
/*LODEPNG_COMPILE_ALLOCATORS*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
// Tools for C, and common code for PNG and Zlib.                       // */
/* // Tools for C, and common code for PNG and Zlib.                       // */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*
/*version of CERROR_BREAK that assumes the common case where the error variable is named "error"*/
/*Set error var to the error code, and return it.*/
/*Try the code, if it returns error, also return the error.*/
/*Set error var to the error code, and return from the void function.*/
/*
/*dynamic vector of unsigned ints*/
/*size in number of unsigned longs*/
/*allocated size in bytes*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*error: not enough memory*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*success*/
/*resize and give all new elements the value*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*LODEPNG_COMPILE_ENCODER*/
/*LODEPNG_COMPILE_ZLIB*/
/////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/*dynamic vector of unsigned chars*/
/*used size*/
/*allocated size*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*error: not enough memory*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*success*/
/*LODEPNG_COMPILE_PNG*/
/*you can both convert from vector to buffer&size and vica versa. If you use
/*LODEPNG_COMPILE_ZLIB*/
/*returns 1 if success, 0 if failure ==> nothing done*/
/*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*returns 1 if success, 0 if failure ==> nothing done*/
/*null termination char*/
/*init a {char*, size_t} pair for use as string*/
/*free the above pair again*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_PNG*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*buffer must have at least 4 allocated bytes available*/
/*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/
/*todo: give error if resize failed*/
/*LODEPNG_COMPILE_ENCODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / File IO                                                                / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*provide some proper output values if error will happen*/
/*get filesize:*/
/*read contents of the file into the vector*/
/*the above malloc failed*/
/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
/*LODEPNG_COMPILE_DISK*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
// End of common code and tools. Begin of Zlib related code.            // */
/* // End of common code and tools. Begin of Zlib related code.            // */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*TODO: this ignores potential out of memory errors*/
/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\
/*add a new byte at the end*/\
/*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\
/*LODEPNG_COMPILE_ENCODER*/
/*LODEPNG_COMPILE_DECODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflate - Huffman                                                      / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*256 literals, the end code, some length codes, and 2 unused codes*/
/*the distance codes have their own symbols, 30 used, 2 unused*/
/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/
/*the base lengths represented by codes 257-285*/
/*the extra bits used by codes 257-285 (added to base length)*/
/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/
/*the extra bits of backwards distances (added to base)*/
/*the order in which "code length alphabet code lengths" are stored, out of this
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*
/*the lengths of the codes of the 1d-tree*/
/*maximum number of bits a single code can get*/
/*number of symbols in the alphabet = number of codes*/
/*function used for debug purposes to draw the tree in ascii art with C++*/
/*
/*the tree representation used by the decoder. return value is error*/
/*up to which node it is filled*/
/*position in the tree (1 of the numcodes columns)*/
/*alloc fail*/
/*
/*32767 here means the tree2d isn't filled there yet*/
/*the codes*/
/*the bits for this code*/
/*oversubscribed, see comment in lodepng_error_text*/
/*not yet filled in*/
/*last bit*/
/*put the current code in it*/
/*put address of the next step in here, first that address has to be found of course
/*addresses encoded with numcodes added to it*/
/*remove possible remaining 32767's*/
/*
/*alloc fail*/
/*alloc fail*/
/*step 1: count number of instances of each code length*/
/*step 2: generate the nextcode values*/
/*step 3: generate all the codes*/
/*
/*alloc fail*/
/*number of symbols*/
/*BPM: Boundary Package Merge, see "A Fast and Space-Economical Algorithm for Length-Limited Coding",
/*chain node for boundary package merge*/
/*the sum of all weights in this chain*/
/*index of this leaf node (called "count" in the paper)*/
/*the next nodes in this chain (null if last)*/
/*lists of chains*/
/*memory pool*/
/*two heads of lookahead chains per list*/
/*creates a new chain node with the given parameters, from the memory in the lists */
/*memory full, so garbage collect*/
/*mark only those that are in use*/
/*collect those that are free*/
/*make the qsort a stable sort*/
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
/*sum of the weights of the head nodes of the previous lookahead chains.*/
/*in the end we are only interested in the chain of the last list, so no
/*number of symbols with non-zero frequency*/
/*the symbols, only those with > 0 frequency*/
/*error: a tree of 0 symbols is not supposed to be made*/
/*error: represent all symbols*/
/*alloc fail*/
/*ensure at least two present symbols. There should be at least one symbol
/*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
/*alloc fail*/
/*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
/*Create the Huffman tree given the symbol frequencies*/
/*trim zeroes*/
/*number of symbols*/
/*alloc fail*/
/*initialize all lengths to 0*/
/*LODEPNG_COMPILE_ENCODER*/
/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
/*alloc fail*/
/*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
/*alloc fail*/
/*there are 32 distance codes, but 30-31 are unused*/
/*
/*error: end of input memory reached without endcode*/
/*
/*the symbol is decoded, return it*/
/*symbol not yet decoded, instead move tree position*/
/*error: it appeared outside the codetree*/
/*LODEPNG_COMPILE_DECODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Inflator (Decompressor)                                                / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/
/*TODO: check for out of memory errors*/
/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
/*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
/*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
/*lit,len code lengths*/
/*dist code lengths*/
/*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
/*the code tree for code length codes (the huffman tree for compressed huffman trees)*/
/*error: the bit pointer is or will go past the memory*/
/*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
/*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
/*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
/*error: the bit pointer is or will go past the memory*/
/*read the code length codes out of 3 * (amount of code length codes) bits*/
/*alloc fail*/);
/*if not, it must stay 0*/
/*now we can use this tree to read the lengths for the tree that this function will return*/
/*alloc fail*/);
/*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
/*a length code*/
/*repeat previous*/
/*read in the 2 bits that indicate repeat length (3-6)*/
/*set value to the previous code*/
/*can't repeat previous if i is 0*/
/*error, bit pointer jumps past memory*/
/*repeat this value in the next lengths*/
/*error: i is larger than the amount of codes*/
/*repeat "0" 3-10 times*/
/*read in the bits that indicate repeat length*/
/*error, bit pointer jumps past memory*/
/*repeat this value in the next lengths*/
/*error: i is larger than the amount of codes*/
/*repeat "0" 11-138 times*/
/*read in the bits that indicate repeat length*/
/*error, bit pointer jumps past memory*/
/*repeat this value in the next lengths*/
/*error: i is larger than the amount of codes*/
/*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
/*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
/*unexisting code, this can never happen*/
/*the length of the end code 256 must be larger than 0*/
/*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
/*end of error-while*/
/*inflate a block with dynamic of fixed Huffman tree*/
/*the huffman tree for literal and length codes*/
/*the huffman tree for distance codes*/
/*decode all symbols until end reached, breaks at end code*/
/*code_ll is literal, length or end code*/
/*literal symbol*/
/*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/
/*alloc fail*/);
/*length code*/
/*extra bits for length and distance*/
/*part 1: get length base*/
/*part 2: get extra bits and add the value of that to length*/
/*error, bit pointer will jump past memory*/
/*part 3: get distance code*/
/*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
/*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
/*error: invalid distance code (30-31 are never used)*/
/*part 4: get extra bits from distance*/
/*error, bit pointer will jump past memory*/
/*part 5: fill in all the out[n] values based on the length and dist*/
/*too long backward distance*/
/*alloc fail*/);
/*end code, break the loop*/
/*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
/*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
/*go to first boundary of byte*/
/*byte position*/
/*read LEN (2 bytes) and NLEN (2 bytes)*/
/*error, bit pointer will jump past memory*/
/*check if 16-bit NLEN is really the one's complement of LEN*/
/*error: NLEN is not one's complement of LEN*/
/*alloc fail*/
/*read the literal data: LEN bytes are now stored in the out buffer*/
/*error: reading outside of in buffer*/
/*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
/*byte position in the out buffer*/
/*error, bit pointer will jump past memory*/
/*error: invalid BTYPE*/
/*no compression*/
/*compression, BTYPE 01 or 10*/
/*LODEPNG_COMPILE_DECODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflator (Compressor)                                                  / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*bitlen is the size in bits of the code*/
/*search the index in the array, that has the largest value smaller than or equal to the given value,
/*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
/*values in encoded vector are those used by deflate:
/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3
/*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/
/*hash value to head circular pos - can be outdated if went around window*/
/*circular pos to prev circular pos*/
/*circular pos to hash value*/
/*TODO: do this not only for zeros but for any repeated byte. However for PNG
/*similar to head, but for chainz*/
/*those with same amount of zeros*/
/*length of zeros streak, used as a second hash chain*/
/*alloc fail*/
/*initialize hash table*/
/*same value as index indicates uninitialized*/
/*same value as index indicates uninitialized*/
/*A simple shift and xor hash is used. Since the data of PNGs is dominated
/*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
/*wpos = pos & (windowsize - 1)*/
/*
/*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
/*not sure if setting it to false for windowsize < 8192 is better or worse*/
/*the offset represents the distance in LZ77 terminology*/
/*error: windowsize smaller/larger than allowed*/
/*error: must be power of two*/
/*position for in 'circular' hash buffers*/
/*the length and offset found for the current position*/
/*search for the longest string*/
/*stop when went completely around the circular buffer*/
/*test the next characters*/
/*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
/*maximum supported length by deflate is max length*/
/*the longest length*/
/*the offset that is related to this longest length*/
/*jump out once a length of max length is found (speed gain). This also jumps
/*outdated hash value, happens if particular value was not encountered in whole last window*/
/*try the next byte*/
/*push the previous character as literal*/
/*alloc fail*/);
/*the same hashchain update will be done, this ensures no wrong alteration*/
/*idem*/
/*too big (or overflown negative) offset*/);
/*encode it as length/distance pair or literal value*/
/*only lengths of 3 or higher are supported as length/distance pair*/
/*alloc fail*/);
/*compensate for the fact that longer offsets have more extra bits, a
/*alloc fail*/);
/*end of the loop through each character of input*/
/////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
/*Decompressed data*/
/*
/*for a length code, 3 more things have to be added*/
/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
/*
/*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
/*tree for lit,len values*/
/*tree for distance codes*/
/*tree for encoding the code lengths representing tree_ll and tree_d*/
/*frequency of lit,len codes*/
/*frequency of dist codes*/
/*frequency of code length codes*/
/*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/
/*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/
/*bitlen_cl is the code length code lengths ("clcl"). The bit lengths of codes to represent tree_cl
/*
/*This while loop never loops due to a break at the end, it is here to
/*alloc fail*/);
/*no LZ77, but still will be Huffman compressed*/
/*alloc fail*/);
/*alloc fail*/);
/*Count the frequencies of lit, len and dist codes*/
/*there will be exactly 1 end code, at the end of the block*/
/*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
/*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
/*store the code lengths of both generated trees in bitlen_lld*/
/*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
/*amount of repititions*/
/*repeat code for zeroes*/
/*include the first zero*/
/*repeat code 17 supports max 10 zeroes*/
/*repeat code 18 supports max 138 zeroes*/
/*repeat code for value other than zero*/
/*too short to benefit from repeat code*/
/*generate tree_cl, the huffmantree of huffmantrees*/
/*alloc fail*/);
/*after a repeat code come the bits that specify the number of repetitions,
/*alloc fail*/);
/*lenghts of code length tree is in the order as specified by deflate*/
/*remove zeros at the end, but minimum size must be 4*/
/*alloc fail*/);
/*
/*Write block type*/
/*first bit of BTYPE "dynamic"*/
/*second bit of BTYPE "dynamic"*/
/*write the HLIT, HDIST and HCLEN values*/
/*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/
/*write the code lenghts of the code length alphabet*/
/*write the lenghts of the lit/len AND the dist alphabet*/
/*extra bits of repeat codes*/
/*write the compressed data symbols*/
/*error: the length of the end code 256 must be larger than 0*/
/*write the end code*/
/*end of error-while*/
/*cleanup*/
/*tree for literal values and length codes*/
/*tree for distance codes*/
/*first bit of BTYPE*/
/*second bit of BTYPE*/
/*LZ77 encoded*/
/*no LZ77, but still will be Huffman compressed*/
/*add END code*/
/*cleanup*/
/*the bit pointer*/
/*if(settings->btype == 2)*/
/*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
/*LODEPNG_COMPILE_DECODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                  */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
/*Return the adler32 of the bytes data[0..len-1]*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Zlib                                                                   / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*error, size of zlib data too small*/
/*read information from zlib header*/
/*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
/*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
/*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/
/*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
/*error: the specification of PNG says about the zlib stream:
/*error, adler checksum not correct, data must be corrupted*/
/*no error*/
/*LODEPNG_COMPILE_DECODER*/
/*initially, *out must be NULL and outsize 0, if you just give some random *out
/*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
/*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
/*ucvector-controlled version of the output buffer, for dynamic array*/
/* compress using the default or custom zlib function */
/*LODEPNG_COMPILE_ENCODER*/
/*no LODEPNG_COMPILE_ZLIB*/
/*no custom zlib function provided */
/*LODEPNG_COMPILE_DECODER*/
/*no custom zlib function provided */
/*LODEPNG_COMPILE_ENCODER*/
/*LODEPNG_COMPILE_ZLIB*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*this is a good tradeoff between speed and compression ratio*/
/*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
/*LODEPNG_COMPILE_ENCODER*/
/*LODEPNG_COMPILE_DECODER*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
// End of Zlib related code. Begin of PNG related code.                 // */
/* // End of Zlib related code. Begin of PNG related code.                 // */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / CRC32                                                                  / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* CRC polynomial: 0xedb88320 */
/*Return the CRC of the bytes buf[0..len-1].*/
/* !LODEPNG_NO_COMPILE_CRC */
/* !LODEPNG_NO_COMPILE_CRC */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*the current bit in bitstream must be 0 for this to work*/
/*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
/*LODEPNG_COMPILE_DECODER*/
/*the current bit in bitstream may be 0 or 1 for this to work*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*null termination char*/
/*the CRC is taken of the data and the 4 chunk type letters, not the length*/
/*integer overflow happened*/
/*alloc fail*/
/*integer overflow happened*/
/*alloc fail*/
/*1: length*/
/*2: chunk name (4 letters)*/
/*3: the data*/
/*4: CRC (of the chunkname characters and the data)*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / Color types and such                                                   / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*return type is a LodePNG error code*/
/*bd = bitdepth*/
/*grey*/
/*RGB*/
/*palette*/
/*grey + alpha*/
/*RGBA*/
/*allowed color type / bits combination*/
/*grey*/
/*RGB*/
/*palette*/
/*grey + alpha*/
/*RGBA*/
/*unexisting color type*/
/*bits per pixel is amount of channels * bits per channel*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*alloc fail*/
/*if one of the palette sizes is 0, then we consider it to be the same as the
/*a->palettesize != 0 && b->palettesize != 0*/) {
/*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with
/*allocate palette if empty*/
/*room for 256 colors with 4 bytes each*/
/*alloc fail*/
/*calculate bits per pixel out of colortype and bitdepth*/
/*4 or 6*/
/*will not overflow for any color type if roughly w * h < 268435455*/
/*will not overflow for any color type if roughly w * h < 268435455*/
/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer*/
/*will not overflow for any color type if roughly w * h < 268435455*/
/*LODEPNG_COMPILE_DECODER*/
/*LODEPNG_COMPILE_PNG*/
/*alloc fail*/
/******************************************************************************/
/*alloc fail*/
/******************************************************************************/
/*alloc fail*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
/*8 / bits - 1*/
/*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
/*filter out any other bits of the input value*/
/*
/*up to 16 pointers to ColorTree of next level*/
/*the payload. Only has a meaningful value if this is in the last level*/
/*returns -1 if color not present, its index otherwise*/
/*LODEPNG_COMPILE_ENCODER*/
/*color is not allowed to already exist.
/*put a pixel, given its RGBA color, into image of any color type*/
/*for palette*/,
/*((unsigned short)r + g + b) / 3*/;
/*take the most significant bits of grey*/
/*color not in palette*/
/*((unsigned short)r + g + b) / 3*/;
/*no error*/
/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
/*((unsigned)r + g + b) / 3*/;
/*((unsigned)r + g + b) / 3*/;
/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
/*highest possible value for this bit depth*/
/*This is an error according to the PNG spec, but common PNG decoders make it black instead.
/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color
/*highest possible value for this bit depth*/
/*This is an error according to the PNG spec, but most PNG decoders make it black instead.
/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
/*if the user specified output palette but did not give the values, assume
/*no error*/
/*function used for debug purposes with C++*/
/*void printColorProfile(LodePNGColorProfile* p)
/*Returns how many bits needed to represent given value (max 8 bit)*/
/*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
/*profile must already have been inited with mode.
/*Check if the 16-bit input is truly 16-bit*/
/*first and second byte differ*/
/*counting colors no longer useful, palette doesn't support 16-bit*/
/*PNG has no alphachannel modes with less than 8-bit per channel*/
/* Color key cannot be used if an opaque pixel also has that RGB color. */
/* < 16-bit */
/*only r is checked, < 8 bits is only relevant for greyscale*/
/*PNG has no colored modes with less than 8-bit per channel*/
/*PNG has no alphachannel modes with less than 8-bit per channel*/
/* Color key cannot be used if an opaque pixel also has that RGB color. */
/*PNG has no alphachannel modes with less than 8-bit per channel*/
/*make the profile's key always 16-bit for consistency - repeat each byte twice*/
/*Automatically chooses color type that gives smallest amount of bits in the
/*too few pixels to justify tRNS chunk overhead*/
/*PNG has no alphachannel modes with less than 8-bit per channel*/
/*grey without alpha, with potentially low bits*/
/*don't add palette overhead if image has only a few pixels*/
/*grey is less overhead*/
/*remove potential earlier palette*/
/*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
/*8-bit or 16-bit per channel*/
/*profile always uses 16-bit, mask converts it*/
/* #ifdef LODEPNG_COMPILE_ENCODER */
/*
/*shared values used by multiple Adam7 related functions*/
/*x start values*/
/*y start values*/
/*x delta values*/
/*y delta values*/
/*
/*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
/*calculate width and height in pixels of each pass*/
/*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
/*bits padded if needed to fill full byte at end of each scanline*/
/*only padded at end of reduced image*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Decoder                                                            / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*read the information from the header and store it in the LodePNGInfo. return value is error*/
/*error: the given data is empty*/
/*error: the data length is smaller than the length of a PNG header*/
/*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
/*error: the first 8 bytes are not the correct PNG signature*/
/*error: header size must be 13 bytes*/
/*error: it doesn't start with a IHDR chunk!*/
/*read the values given in the header*/
/*invalid CRC*/
/*error: only compression method 0 is allowed in the specification*/
/*error: only filter method 0 is allowed in the specification*/
/*error: only interlace methods 0 and 1 exist in the specification*/
/*
/*paethPredictor(0, precon[i], 0) is always precon[i]*/
/*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
/*error: unexisting filter type given*/
/*
/*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
/*the extra filterbyte added to each row*/
/*
/*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
/*bit pointers (for out and in buffer)*/
/*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/
/*
/*input and output bit pointers*/
/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
/*
/*error: invalid colortype*/
/*we can immediately filter into the out buffer, no other steps needed*/
/*interlace_method is 1 (Adam7)*/
/*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
/*remove padding bits in scanlines; after this there still may be padding
/*alloc fail*/
/*error: palette too big*/
/*R*/
/*G*/
/*B*/
/*alpha*/
/* OK */
/*error: more alpha values given than there are palette entries*/
/*error: this chunk must be 2 bytes for greyscale image*/
/*error: this chunk must be 6 bytes for RGB image*/
/*error: tRNS chunk not allowed for other color models*/
/* OK */
/*background color chunk (bKGD)*/
/*error: this chunk must be 1 byte for indexed color image*/
/*error: this chunk must be 2 bytes for greyscale image*/
/*error: this chunk must be 6 bytes for greyscale image*/
/* OK */
/*text chunk (tEXt)*/
/*not really a while loop, only used to break on error*/
/*even though it's not allowed by the standard, no error is thrown if
/*keyword too short or long*/
/*alloc fail*/
/*skip keyword null terminator*/
/*alloc fail*/
/*compressed text chunk (zTXt)*/
/*not really a while loop, only used to break on error*/
/*no null termination, corrupt?*/
/*keyword too short or long*/
/*alloc fail*/
/*the 0 byte indicating compression must be 0*/
/*no null termination, corrupt?*/
/*will fail if zlib error, e.g. if length is too small*/
/*international text chunk (iTXt)*/
/*not really a while loop, only used to break on error*/
/*Quick check if the chunk length isn't too small. Even without check
/*iTXt chunk too short*/
/*read the key*/
/*no null termination char, corrupt?*/
/*keyword too short or long*/
/*alloc fail*/
/*read the compression method*/
/*the 0 byte indicating compression must be 0*/
/*even though it's not allowed by the standard, no error is thrown if
/*read the langtag*/
/*alloc fail*/
/*read the transkey*/
/*alloc fail*/
/*read the actual text*/
/*will fail if zlib error, e.g. if length is too small*/
/*alloc fail*/);
/*invalid tIME chunk size*/
/* OK */
/*invalid pHYs chunk size*/
/* OK */
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
/*the data from idat chunks*/
/*for unknown chunk order*/
/*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*provide some proper output values if error will happen*/
/*reads header and resets other parameters in state->info_png*/
/*multiplication overflow*/
/*multiplication overflow possible further below. Allows up to 2^31-1 pixel
/*first byte of the first chunk after the header*/
/*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
/*the data in the chunk*/
/*error: size of the in buffer too small to contain next chunk*/
/*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
/*error: chunk length larger than the max PNG chunk size*/
/*error: size of the in buffer too small to contain next chunk*/
/*IDAT chunk, containing compressed image data*/
/*alloc fail*/);
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*IEND chunk*/
/*palette chunk (PLTE)*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*palette transparency chunk (tRNS)*/
/*background color chunk (bKGD)*/
/*text chunk (tEXt)*/
/*compressed text chunk (zTXt)*/
/*international text chunk (iTXt)*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*it's not an implemented chunk type, so ignore it: skip over the data*/
/*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*check CRC if wanted, only on known chunk types*/
/*invalid CRC*/
/*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
/*The extra *h is added because this are the filter bytes every scanline starts with*/
/*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/
/*alloc fail*/
/*decompressed size doesn't match prediction*/
/*alloc fail*/
/*same color type, no copying or converting of data needed*/
/*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
/*color conversion needed; sort of copy of the data*/
/*TODO: check if this works according to the statement in the documentation: "The converter can convert
/*unsupported color mode conversion*/
/*alloc fail*/
/*LODEPNG_COMPILE_DISK*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_DECODER*/
/*LODEPNG_COMPILE_DECODER*/
/*LODEPNG_COMPILE_ENCODER*/
/* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*chunkName must be string of 4 characters*/
/*fix the allocsize again*/
/*8 bytes PNG signature, aka the magic bytes*/
/*width*/
/*height*/
/*bit depth*/
/*color type*/
/*compression method*/
/*filter method*/
/*interlace method*/
/*add all channels except alpha channel*/
/*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
/*add only alpha channel*/
/*compress with the Zlib compressor*/
/*error: invalid keyword size*/
/*0 termination char*/
/*error: invalid keyword size*/
/*0 termination char*/
/*compression method: 0*/
/*error: invalid keyword size*/
/*null termination char*/
/*compression flag*/
/*compression method*/
/*null termination char*/
/*null termination char*/
/*not compressed*/
/*palette index*/
/*alloc fail*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*None*/
/*Sub*/
/*Up*/
/*Average*/
/*Paeth*/
/*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
/*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
/*unexisting filter type given*/
/* log2 approximation. A slight bit faster than std::log. */
/*
/*the width of a scanline in bytes, not including the filter type*/
/*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
/*
/*error: invalid color type*/
/*the extra filterbyte added to each row*/
/*filter type byte*/
/*adaptive filtering*/
/*five filtering attempts, one for each filter type*/
/*alloc fail*/
/*try the 5 filter types*/
/*calculate the sum of the result*/
/*For differences, each byte should be treated as signed, values above 127 are negative
/*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
/*now fill the out values*/
/*the first byte of a scanline will be the filter type*/
/*five filtering attempts, one for each filter type*/
/*alloc fail*/
/*try the 5 filter types*/
/*the filter type itself is part of the scanline*/
/*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
/*now fill the out values*/
/*the first byte of a scanline will be the filter type*/
/*the extra filterbyte added to each row*/
/*filter type byte*/
/*brute force filter chooser.
/*five filtering attempts, one for each filter type*/
/*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
/*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
/*alloc fail*/
/*try the 5 filter types*/
/*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/
/*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
/*the first byte of a scanline will be the filter type*/
/* unknown filter strategy */
/*The opposite of the removePaddingBits function
/*bit pointers*/
/*obp += diff; --> no, fill in some value in the padding bits too, to avoid
/*
/*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
/*bit pointers (for out and in buffer)*/
/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
/*
/*image size plus an extra byte per scanline + possible padding bits*/
/*alloc fail*/
/*non multiple of 8 bits per scanline, padding bits needed per scanline*/
/*alloc fail*/
/*we can immediately filter into the out buffer, no other steps needed*/
/*interlace_method is 1 (Adam7)*/
/*image size plus an extra byte per scanline + possible padding bits*/
/*alloc fail*/
/*alloc fail*/
/*alloc fail*/
/*
/*the value of the color with alpha 0, so long as color keying is possible*/
/*restart from beginning, to detect earlier opaque colors with key's value*/
/*when key, no opaque RGB may have key's RGB*/
/*fix the allocsize again*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*uncompressed version of the IDAT chunk data*/
/*provide some proper output values if error will happen*/
/*invalid palette size, it is only allowed to be 1-256*/
/*error: unexisting btype*/
/*error: unexisting interlace mode*/
/*error: unexisting color type given*/
/*error: unexisting color type given*/
/*alloc fail*/
/*while only executed once, to break on error*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*write signature and chunks*/
/*IHDR*/
/*unknown chunks between IHDR and PLTE*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*PLTE*/
/*tRNS*/
/*bKGD (must come between PLTE and the IDAt chunks*/
/*pHYs (must come before the IDAT chunks)*/
/*unknown chunks between PLTE and IDAT*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*IDAT (multiple IDAT chunks must be consecutive)*/
/*tIME*/
/*tEXt and/or zTXt*/
/*text chunk too large*/
/*text chunk too small*/
/*LodePNG version id in text chunk*/
/*it's shorter as tEXt than as zTXt chunk*/
/*iTXt*/
/*text chunk too large*/
/*text chunk too small*/
/*unknown chunks between IDAT and IEND*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*this isn't really a while loop; no error happened so break out now!*/
/*instead of cleaning the vector up, give it to the output*/
/*LODEPNG_COMPILE_DISK*/
/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
/*LODEPNG_COMPILE_ENCODER*/
/*LODEPNG_COMPILE_PNG*/
/*
/*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
/*while huffman decoding*/
/*while huffman decoding*/
/*end of out buffer memory reached while inflating:
/*Checks the magic file header, the first 8 bytes of the PNG file*/
/*more than 256 colors*/
/*jumped past tree while generating huffman tree, this could be when the
/*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/
/*(2^31-1)*/
/*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
/*length could be wrong, or data chopped off*/
/*file doesn't exist or couldn't be opened for reading*/
/*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
/*LODEPNG_COMPILE_ERROR_TEXT*/
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
// C++ Wrapper                                                          // */
/* // C++ Wrapper                                                          // */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/*get filesize*/
/*read contents of the file into the vector*/
/* OK */
/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
/* LODEPNG_COMPILE_DISK */
/* LODEPNG_COMPILE_DECODER */
/* LODEPNG_COMPILE_ENCODER */
/* LODEPNG_COMPILE_ZLIB */
/* LODEPNG_COMPILE_DECODER */
/* LODEPNG_COMPILE_DISK */
/* LODEPNG_COMPILE_DISK */
/* LODEPNG_COMPILE_ENCODER */
/* LODEPNG_COMPILE_PNG */
/* namespace lodepng */
/*LODEPNG_COMPILE_CPP*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\HACD\hacdGraph.cpp
/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)
// delete the edge (v1, v2)
// add v2 to v1 ancestors
// add v2's ancestors to v1's ancestors
// update adjacency information
// delete the vertex v2
// all CCs to -1
// we get the CCs
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\HACD\hacdHACD.cpp
/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)
//_CRT_SECURE_NO_WARNINGS
// vertex to triangle adjacency information
// two triangles are connected if they share exactly one edge
// we need a kd-tree structure to accelerate this part!
//std::swap<long>(v1, v2);
// delete old convex-hull
// create the edge's convex-hull
// update distPoints
// create the convex-hull
// if we face problems when constructing the visual-hull. really ugly!!!!
//			if (m_callBack) (*m_callBack)("\t Problem with convex-hull construction [HACD::ComputeEdgeCost]\n", 0.0, 0.0, 0);
/* && ptIndex < m_nPoints*/)
// add distance points from adjacent clusters
// compute boudary edges
// cluster's volume
// cluster's area  
// cluster's perimeter
// cluster's concavity
// cluster's priority
// update vertex info
// We apply the optimal ecol
//				std::cout << "v1 " << v1 << " v2 " << v2 << std::endl;
// recompute the adjacent edges costs
// Compute the surfaces and perimeters of all the faces
// we simplify the graph		
// compute the convex-hull
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\HACD\hacdICHull.cpp
/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)
// Compute the normal to the plane
// we have to create the first polyhedron
// go to the first added and not processed vertex
// not processed
// Compute the normal to the plane
// we have to create the first polyhedron
// not processed
// delete remaining points
// not processed
// find three non colinear points
// mark points as processed
// create two triangles
// find a fourth non-coplanar point to form tetrahedron
// compute the barycenter
// Compute the normal to the plane
// add dummy vertex placed at (bary + normal)
// if first face to be created
// create the three edges
// otherwise re-use existing edges (in reverse order)
// create the new face
// link edges to face f
// create two new edges if they don't already exist
// if the edge doesn't exits add it and mark the vertex as duplicated
// make the new face
// mark visible faces
// if no faces visible from p then p is inside the hull
// Mark edges in interior of visible region for deletion.
// Create a new face based on each border edge
// the visible face adjacent to e
//  set vertex[0] and vertex[1] to have the same orientation as the corresponding vertices of fv.
// index of e->m_vertices[0] in fv
// swap edges
// integrate the new faces into the data structure
// delete edges maked for deletion
// to be updated
// mark all vertices incident to some undeleted edge as on the hull
// delete all the vertices that have been processed but are not on the hull
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\HACD\hacdManifoldMesh.cpp
/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)
// updating the id's
// copying data
// generating mapping
// updating pointers
// triangle vectors
// ray vectors
// params to calc ray-plane intersect
// get triangle edge vectors and plane normal
// cross product
// triangle is degenerate
// do not deal with this case
// ray is parallel to triangle plane
// ray lies in triangle plane
// ray disjoint from plane
// get intersect point of ray with triangle plane
// ray goes away from triangle
// => no intersect
// for a segment, also test if (r > 1.0) => no intersect
// intersect point of ray and plane
// is I inside T?
// get and test parametric coords
// I is outside T
// I is outside T
// I is in T
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\jsoncpp\src\lib_json\json_reader.cpp
// Copyright 2007-2011 Baptiste Lepilleur and The JsonCpp Authors
// Copyright (C) 2016 InfoTeCS JSC. All rights reserved.
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
// if !defined(JSON_IS_AMALGAMATION)
// VC++ 9.0 and above 
// VC++ 14.0 and above
// VC++ 8.0
// Disable warning about strdup being deprecated.
// Define JSONCPP_DEPRECATED_STACK_LIMIT as an appropriate integer at compile time to change the stack limit
// see readValue()
// Implementation of class Features
// ////////////////////////////////
// Implementation of class Reader
// ////////////////////////////////
// Class Reader
// //////////////////////////////////////////////////////////////////
// std::istream_iterator<char> begin(sin);
// std::istream_iterator<char> end;
// Those would allow streamed input from a file, if parse() were a
// template function.
// Since JSONCPP_STRING is reference-counted, this at least does not
// create an extra copy.
// Set error location to start of doc, ideally should be first token found
// in doc
// readValue() may call itself only if it calls readObject() or ReadArray().
// These methods execute nodes_.push() just before and nodes_.pop)() just after calling readValue(). 
// parse() executes one nodes_.push(), so > instead of >=.
// "Un-read" the current token and mark the current value as a null
// token.
// Else, fall through...
// convert dos EOL
// convert Mac EOL
// Consume DOS EOL. It will be normalized in addComment.
// Break on Moc OS 9 EOL.
// stopgap for already consumed character
// integral part
// fractional part
// exponential part
// empty object
// error already set
// empty array
// error already set
// Accept Comment after last item in the array.
// Attempts to parse the number as an integer. If the number is
// larger than the maximum supported value of an integer then
// we decode the number as a double.
// TODO: Help the compiler do the div and mod at compile time or get rid of them.
// We've hit or exceeded the max value divided by 10 (rounded down). If
// a) we've only just touched the limit, b) this is the last digit, and
// c) it's small enough to fit in that rounding delta, we're okay.
// Otherwise treat this number as a double to avoid overflow.
// skip '"'
// do not include '"'
// surrogate pairs
// discard errors caused by recovery
// column & line start at 1
// Deprecated. Preserved for backward compatibility
// exact copy of Features
// OurFeatures
// exact copy of Implementation of class Features
// ////////////////////////////////
// Implementation of class Reader
// ////////////////////////////////
// exact copy of Reader, renamed to OurReader
// no impl
// no impl
// OurReader
// complete copy of Read impl, for OurReader
// Set error location to start of doc, ideally should be first token found
// in doc
//  To preserve the old behaviour we cast size_t to int.
// "Un-read" the current token and mark the current value as a null
// token.
// else, fall through ...
// else fall through
// convert dos EOL
// convert Mac EOL
// Consume DOS EOL. It will be normalized in addComment.
// Break on Moc OS 9 EOL.
// stopgap for already consumed character
// integral part
// fractional part
// exponential part
// empty object
// error already set
// empty array
// error already set
// Accept Comment after last item in the array.
// Attempts to parse the number as an integer. If the number is
// larger than the maximum supported value of an integer then
// we decode the number as a double.
// TODO: Help the compiler do the div and mod at compile time or get rid of them.
// We've hit or exceeded the max value divided by 10 (rounded down). If
// a) we've only just touched the limit, b) this is the last digit, and
// c) it's small enough to fit in that rounding delta, we're okay.
// Otherwise treat this number as a double to avoid overflow.
// Sanity check to avoid buffer overflow exploits.
// Avoid using a string constant for the format control string given to
// sscanf, as this can cause hard to debug crashes on OS X. See here for more
// info:
//
//     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
// skip '"'
// do not include '"'
// surrogate pairs
// discard errors caused by recovery
// column & line start at 1
// so we do not need to test for NULL
// static
//! [CharReaderBuilderStrictMode]
//! [CharReaderBuilderStrictMode]
// static
//! [CharReaderBuilderDefaults]
//! [CharReaderBuilderDefaults]
//////////////////////////////////
// global functions
// Note that we do not actually need a null-terminator.
// namespace Json
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\jsoncpp\src\lib_json\json_value.cpp
// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
// if !defined(JSON_IS_AMALGAMATION)
// size_t
// min()
// This is a walkaround to avoid the static initialization of Value::null.
// kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
// 8 (instead of 4) as a bit of future-proofing.
//static const unsigned char ALIGNAS(8) kNull[sizeof(Value)] = { 0 };
//const unsigned char& kNullRef = kNull[0];
//const Value& Value::null = reinterpret_cast<const Value&>(kNullRef);
//const Value& Value::nullRef = null;
// static
// for backwards compatibility, we'll leave these global references around, but DO NOT
// use them in JSONCPP library code any more!
// The constant is hard-coded because some compiler have trouble
// converting Value::maxUInt64 to a double correctly (AIX/xlC).
// Assumes that UInt64 is a 64 bits integer.
// defined(JSON_HAS_INT64)
// The casts can lose precision, but we are looking only for
// an approximate range. Might fail on edge cases though. ~cdunn
//return d >= static_cast<double>(min) && d <= static_cast<double>(max);
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
/** Duplicates the specified string value.
// Avoid an integer overflow in the call to malloc below by limiting length
// to a sane value.
/* Record the length as a prefix.
// Avoid an integer overflow in the call to malloc below by limiting length
// to a sane value.
// to avoid buffer over-run accidents by users later
/** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
// length==0 => we allocated the strings memory
// !JSONCPP_USING_SECURE_MEMORY
// JSONCPP_USING_SECURE_MEMORY
// namespace Json
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// ValueInternals...
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// if !defined(JSON_IS_AMALGAMATION)
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Value::CommentInfo
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// It seems that /**/ style comments are acceptable as well.
/**/ style comments are acceptable as well.
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Value::CZString
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// Notes: policy_ indicates if the string was allocated when
// a string is stored.
// allocate != duplicate
//+1 for null terminating character for sake of completeness but not actually necessary
//return strcmp(cstr_, other.cstr_) < 0;
// Assume both are strings.
//return strcmp(cstr_, other.cstr_) == 0;
// Assume both are strings.
//const char* Value::CZString::c_str() const { return cstr_; }
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Value::Value
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
/*! \internal Default constructor initialization must be equivalent to:
// allocated_ == false, so this is safe.
// defined(JSON_HAS_INT64)
// Move constructor
// unreachable
// if ( type_ != other.type_ )
// GCC 2.95.3 says:
// attempt to take address of bit-field structure member `Json::Value::type_'
// Beats me, but a temp solves the problem.
// unreachable
// if defined(JSON_HAS_INT64)
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
// This can fail (silently?) if the value is bigger than MAX_FLOAT.
// if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
// This is kind of strange. Not recommended.
/// Number of values in array or object
// size of the array is highest index + 1
// unreachable;
// Access an object value by name, create a null member if it does not exist.
// @pre Type of '*this' is object or null.
// @param key is null-terminated.
// NOTE!
// @param key is not null-terminated.
// shift left all items left, into the place of the "removed"
// erase the last one ("leftover")
//
//# ifdef JSON_USE_CPPTL
// EnumMemberNames
// Value::enumMemberNames() const
//{
//   if ( type_ == objectValue )
//   {
//      return CppTL::Enum::any(  CppTL::Enum::transform(
//         CppTL::Enum::keys( *(value_.map_), CppTL::Type<const CZString &>() ),
//         MemberNamesTransform() ) );
//   }
//   return EnumMemberNames();
//}
//
//
// EnumValues
// Value::enumValues() const
//{
//   if ( type_ == objectValue  ||  type_ == arrayValue )
//      return CppTL::Enum::anyValues( *(value_.map_),
//                                     CppTL::Type<const Value &>() );
//   return EnumValues();
//}
//
//# endif
// Note that maxInt64 (= 2^63 - 1) is not exactly representable as a
// double, so double(maxInt64) will be rounded up to 2^63. Therefore we
// require the value to be strictly less than the limit.
// JSON_HAS_INT64
// Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
// double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
// require the value to be strictly less than the limit.
// JSON_HAS_INT64
// Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
// double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
// require the value to be strictly less than the limit.
// JSON_HAS_INT64
// Always discard trailing newline, to aid indentation.
// class PathArgument
// //////////////////////////////////////////////////////////////////
// class Path
// //////////////////////////////////////////////////////////////////
/*path*/,
// Error: missing argument %d
// Error: bad argument type
/*path*/, int /*location*/) {
// Error: invalid path.
// Error: unable to resolve path (array value expected at position...
// Error: unable to resolve path (object value expected at position...)
// Error: unable to resolve path (object has no member named '' at
// position...)
// Error: node is not an array at position ...
// Error: node is not an object at position...
// namespace Json
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\jsoncpp\src\lib_json\json_writer.cpp
// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
// if !defined(JSON_IS_AMALGAMATION)
// Between VC++ 6.0 and VC++ 11.0
//Solaris
// QNX already defines isfinite
// VC++ 9.0 and above
// VC++ 14.0 and above
// VC++ 8.0
// Disable warning about strdup being deprecated.
// # if defined(JSON_HAS_INT64)
// Allocate a buffer that is more than large enough to store the 16 digits of
// precision requested below.
// Print into the buffer. We need not request the alternative representation
// that always has a decimal point because JSON doesn't distinguish the
// concepts of reals and integers.
// try to ensure we preserve the fact that this was given to us as a double on input
// IEEE standard states that NaN values will not compare to themselves
// oversized encoded characters are invalid
// surrogates aren't valid codepoints itself
// shouldn't be UTF-8 encoded
// oversized encoded characters are invalid
// oversized encoded characters are invalid
// We have to walk value and escape any special characters.
// Appending to JSONCPP_STRING is not efficient, but this should be rare.
// (Note: forward slashes are *not* rare, but I am not escaping them.)
// allescaped+quotes+NULL
// to avoid lots of mallocs
// case '/':
// Even though \/ is considered a legal escape in JSON, a bare
// slash is also legal, so I see no reason to escape it.
// (I hope I am not misunderstanding something.)
// blep notes: actually escaping \/ may be useful in javascript to avoid </
// sequence.
// Should add a flag to allow this compatibility mode and prevent this
// sequence from occurring.
// don't escape non-control characters
// (short escape sequence are applied above)
// codepoint is in Basic Multilingual Plane
// codepoint is not in Basic Multilingual Plane
// convert to surrogate pair first
// Class Writer
// //////////////////////////////////////////////////////////////////
// Class FastWriter
// //////////////////////////////////////////////////////////////////
// Is NULL possible for value.string_? No.
// Class StyledWriter
// //////////////////////////////////////////////////////////////////
// Is NULL possible for value.string_? No.
// output on a single line
// check if line length > max line length
// '[ ' + ', '*n + ' ]'
// already indented
// Comments may add new-line
// Comments are stripped of trailing newlines, so add one here
// Class StyledStreamWriter
// //////////////////////////////////////////////////////////////////
// Forget the stream, for safety.
// Is NULL possible for value.string_? No.
// output on a single line
// check if line length > max line length
// '[ ' + ', '*n + ' ]'
// blep intended this to look at the so-far-written string
// to determine whether we are already indented, but
// with a stream we cannot do that. So we rely on some saved state.
// The caller checks indented_.
// writeIndent();  // would include newline
//////////////////////////
// BuiltStyledStreamWriter
/// Scoped enums are not available until C++11.
/// Decide whether to write comments.
///< Drop all comments.
///< Recover odd behavior of previous versions (not implemented yet).
///< Keep all comments.
// Is NULL is possible for value.string_? No.
// output on a single line
// check if line length > max line length
// '[ ' + ', '*n + ' ]'
// blep intended this to look at the so-far-written string
// to determine whether we are already indented, but
// with a stream we cannot do that. So we rely on some saved state.
// The caller checks indented_.
// In this case, drop newlines too.
// writeIndent();  // would write extra newline
// static
///////////////
// StreamWriter
// so we do not need to test for NULL
// static
//! [StreamWriterBuilderDefaults]
//! [StreamWriterBuilderDefaults]
// namespace Json
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpvrt\PVRTError.cpp
/******************************************************************************
/*!***************************************************************************
/*****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpvrt\PVRTResourceFile.cpp
/******************************************************************************
// Get the file size
// read the data
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/****************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpvrt\PVRTString.cpp
/******************************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
// +1 for null termination
// extend CPVRTString if necessary
// Using low memory profile (but very slow append)
// append chars from _Ptr
// remove old CPVRTString if necessary
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
// +1 for null termination
// extend CPVRTString if necessary
// fill new space with _Ch
// set null terminator
// adjust length of string for new characters
// remove old CPVRTString if necessary
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
//const_reference at(size_t _Off) const;
//reference at(size_t _Off);
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
// check comparison starts within lhs CPVRTString
// value to return if no difference in actual comparisons between chars
// number of comparisons to do
// do actual comparison
// no difference found in compared characters
/*!***********************************************************************
/*_Off*/, size_t _Count) const
// check comparison starts within lhs CPVRTString
// value to return if no difference in actual comparisons between chars
// number of comparisons to do
// do actual comparison
// no difference found in compared characters
/*!***********************************************************************
/*!***********************************************************************
// check comparison starts within lhs CPVRTString
// value to return if no difference in actual comparisons between chars
// number of comparisons to do
// do actual comparison
// no difference found in compared characters
/*!***********************************************************************
// check comparison starts within lhs CPVRTString
// value to return if no difference in actual comparisons between chars
// number of comparisons to do
// do actual comparison
// no difference found in compared characters
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
// return if no match
/*!***********************************************************************
// compare against each char from _Ptr
// return if no match
/*!***********************************************************************
// compare against each char from _Str
// return if no match
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// There are not enough caracters in current String
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
// return if considered character differed from all characters from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
// return if considered character differed from all characters from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
// return if considered character differed from all characters from _Ptr
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Str
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Str
/*!***********************************************************************
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Ptr
/*!***********************************************************************
// compare against each char from _Str
/*!***********************************************************************
/*!***********************************************************************
//CPVRTString& CPVRTString::insert(size_t _P0, const char* _Ptr)
//{
//	return replace(_P0, 0, _Ptr);
//}
//CPVRTString& CPVRTString::insert(size_t _P0, const char* _Ptr, size_t _Count)
//{
//	return replace(_P0, 0, _Ptr, _Count);
//}
//CPVRTString& CPVRTString::insert(size_t _P0, const CPVRTString& _Str)
//{
//	return replace(_P0, 0, _Str);
//}
//CPVRTString& CPVRTString::insert(size_t _P0, const CPVRTString& _Str, size_t _Off, size_t _Count)
//{
//	return replace(_P0, 0, _Str, _Off, _Count);
//}
//CPVRTString& CPVRTString::insert(size_t _P0, size_t _Count, char _Ch)
//{
//	return replace(_P0, 0, _Count, _Ch);
//}
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
//CPVRTString& replace(size_t _Pos1, size_t _Num1, const char* _Ptr)
//CPVRTString& replace(size_t _Pos1, size_t _Num1, const CPVRTString& _Str)
//CPVRTString& replace(size_t _Pos1, size_t _Num1, const char* _Ptr, size_t _Num2)
//CPVRTString& replace(size_t _Pos1, size_t _Num1, const CPVRTString& _Str, size_t _Pos2, size_t _Num2)
//CPVRTString& replace(size_t _Pos1, size_t _Num1, size_t _Count, char _Ch)
/*!***********************************************************************
/*!***********************************************************************
//size_t rfind(char _Ch, size_t _Off = npos) const;
//size_t rfind(const char* _Ptr, size_t _Off = npos) const;
//size_t rfind(const char* _Ptr, size_t _Off = npos, size_t _Count) const;
//size_t rfind(const CPVRTString& _Str, size_t _Off = npos) const;
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*************************************************************************
/*!***********************************************************************
/*!***********************************************************************
// can't find an actual \ or /, so return an empty string
/*!***********************************************************************
// can't find an actual \ or / so leave it be
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
/*!***********************************************************************
///*!***************************************************************************
/*!***************************************************************************
// Substitute one character by another
// Substitute one string by another ( Need time to improved )
// _USING_PVRTSTRING_
/*****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpvrt\PVRTTexture.cpp
/******************************************************************************
/*****************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***************************************************************************
/*!***********************************************************************
/*!***********************************************************************
//Non-compressed formats all return 1.
/*!***********************************************************************
//The smallest divisible sizes for a pixel format
//If the pixel format is compressed, get the pixel format's minimum dimensions.
//Needs to be 64-bit integer to support 16kx16k and higher sizes.
//Get the dimensions of the current MIP Map level.
//If pixel format is compressed, the dimensions need to be padded.
//Add the current MIP Map's data size to the total.
//Get the dimensions of the specified MIP Map level.
//If pixel format is compressed, the dimensions need to be padded.
//Work out the specified MIP Map's data size
//The number of faces/surfaces to register the size of.
//Multiply the data size by number of faces and surfaces specified, and return.
/*!***********************************************************************
//Setup variables
//Map the old enum to the new format.
//Check if this is a cube map.
//Setup the new header.
//Legacy headers have a MIP Map count of 0 if there is only the top level. New Headers have a count of 1.
//Only compute the number of surfaces if it's a V2 header, else default to 1 surface.
//Clear any currently stored MetaData, or it will be inaccurate.
//Check if this is a normal map.
//Get a reference to the correct block.
//Set up the block.
//Setup the data for the block.
//Copy the bumpScale into the data.
//Clear the string
//Copy the bumpOrder into the data.
//Increment the meta data size.
//Check if for vertical flip orientation.
//Get the correct meta data block
//Set the block up.
//Initialise the block to default orientation.
//Set the block oriented upwards.
//Increment the meta data size.
/*!***********************************************************************
//Default value.
/*****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\LuaCpp\BaseFunc.cpp
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\LuaCpp\MetatableRegistry.cpp
// push the name_table
// push the key
// push the name
// names_table[type] = name
// pops the names_table
// push the new metatable which is exist in the registry
// Actual result.
// push the metatable_table
// push the key
// push the metatable
// metatable_table[type] = metatable
// pops the metatable_table
// get metatable_table[type] and push it
// if type has a valid metatable
// set metatable
// get name_table[type] and push it
// Get type name by TypeID
// get name_table[type] and push it
// Get type name of the value at the given index
// Check type at the given index
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\LuaCpp\Selector.cpp
// install handler, and swap(handler, function) on lua stack
// pushes all arguments
// call lua function with error handler
// remove error handler
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\LuaCpp\State.cpp
/* remove lib */
// Remove path
// lua_load pushes the compiled chunk as a Lua function on top of the stack. 
// Otherwise, it pushes an error message.
// Assume that function already pushed on top
// Push new environment table for sandboxing (1)
// Set and pop (0)
// Push again (1)
// Push new metatable (2)
// Push global table (3)
// Do metatable[__index] = _G and pop (2)
// Set metatable of sandbox table and pop (1)
// Pop and set sandbox table as the new environment (using upvalue) of the current function (0)
// Pop and set sandbox table as the new environment of the current function (0)
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\LuaCpp\Util.cpp
// Make nil and values not convertible to string human readable.
// call debug.traceback
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\NvTriStrip\src\NvTriStrip\NvTriStrip.cpp
////////////////////////////////////////////////////////////////////////////////////////
//private data
////////////////////////////////////////////////////////////////////////////////////////
// SetListsOnly()
//
// If set to true, will return an optimized list, with no strips at all.
//
// Default value: false
//
////////////////////////////////////////////////////////////////////////////////////////
// SetCacheSize()
//
// Sets the cache size which the stripfier uses to optimize the data.
// Controls the length of the generated individual strips.
// This is the "actual" cache size, so 24 for GeForce3 and 16 for GeForce1/2
// You may want to play around with this number to tweak performance.
//
// Default value: 16
//
////////////////////////////////////////////////////////////////////////////////////////
// SetStitchStrips()
//
// bool to indicate whether to stitch together strips into one huge strip or not.
// If set to true, you'll get back one huge strip stitched together using degenerate
//  triangles.
// If set to false, you'll get back a large number of separate strips.
//
// Default value: true
//
////////////////////////////////////////////////////////////////////////////////////////
// SetMinStripSize()
//
// Sets the minimum acceptable size for a strip, in triangles.
// All strips generated which are shorter than this will be thrown into one big, separate list.
//
// Default value: 0
//
////////////////////////////////////////////////////////////////////////////////////////
//Cleanup strips / faces, used by generatestrips
//delete strips
//delete faces
////////////////////////////////////////////////////////////////////////////////////////
//SameTriangle()
//
//Returns true if the two triangles defined by firstTri and secondTri are the same
// The "same" is defined in this case as having the same indices with the same winding order
//
//hash this triangle
//check triangles in this bin
//check triangles in this bin
//check triangles in this bin
////////////////////////////////////////////////////////////////////////////////////////
// GenerateStrips()
//
// in_indices: input index list, the indices you would use to render
// in_numIndices: number of entries in in_indices
// primGroups: array of optimized/stripified PrimitiveGroups
// numGroups: number of groups returned
//
// Be sure to call delete[] on the returned primGroups to avoid leaking mem
//
//put data in format that the stripifier likes
//do actual stripification
//stitch strips together
//if we're outputting only lists, we're done
//count the total number of indices
//add in the list
//do strips
//degenerates are of no use with lists
//we've removed a tri, reduce the number of indices
//do lists
//if we're stitching strips together, we better get back only one strip from CreateStrips()
//convert to output format
//for the strips
//we've got a list as well, increment
//first, the strips
//if we've got multiple strips, we need to figure out the correct length
//we add 1 to account for the -1 separating strips
//this doesn't break the stitched case since we'll exit the loop
//next, the list
//the face group is the last one
//validate generated data against input
//hash input indices on first index
//ignore degenerates
//swap v1 and v2
//ignore degenerates
//clean up everything
////////////////////////////////////////////////////////////////////////////////////////
// RemapIndices()
//
// Function to remap your indices to improve spatial locality in your vertex buffer.
//
// in_primGroups: array of PrimitiveGroups you want remapped
// numGroups: number of entries in in_primGroups
// numVerts: number of vertices in your vertex buffer, also can be thought of as the range
//  of acceptable values for indices in your primitive groups.
// remappedGroups: array of remapped PrimitiveGroups
//
// Note that, according to the remapping handed back to you, you must reorder your 
//  vertex buffer.
//
//caches oldIndex --> newIndex conversion
//loop over primitive groups
//init remapped group
//we haven't seen this index before
//point to "last" vertex in VB
//add to index cache, increment
//we've seen this index before
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\NvTriStrip\src\NvTriStrip\NvTriStripObjects.cpp
///////////////////////////////////////////////////////////////////////////////////////////
// FindEdgeInfo()
//
// find the edge info for these two indices
//
// we can get to it through either array
// because the edge infos have a v0 and v1
// and there is no order except how it was
// first created.
///////////////////////////////////////////////////////////////////////////////////////////
// FindOtherFace
//
// find the other face sharing these vertices
// exactly like the edge info above
//
//we've hit a degenerate
///////////////////////////////////////////////////////////////////////////////////////////
// BuildStripifyInfo()
//
// Builds the list of all face and edge infos
//
// reserve space for the face infos, but do not resize them.
// we actually resize the edge infos, so we must initialize to NULL
// iterate through the triangles of the triangle list
// grab the indices
//we disregard degenerates
// create the face info and add it to the list of faces, but only if this exact face doesn't already 
//  exist in the list
// grab the edge infos, creating them if they do not already exist
//since one of it's edges isn't in the edge data structure, it can't already exist in the face structure
// create the info
// update the linked list on both 
// set face 0
// grab the edge infos, creating them if they do not already exist
// create the info
// update the linked list on both 
// set face 0
// grab the edge infos, creating them if they do not already exist
// create the info
// update the linked list on both 
// set face 0
//cleanup pointers that point to this deleted face
///////////////////////////////////////////////////////////////////////////////////////////
// FindStartPoint()
//
// Finds a good starting point, namely one which has only one neighbor
//
//return i;
//return -1;
///////////////////////////////////////////////////////////////////////////////////////////
// FindGoodResetPoint()
//  
// A good reset point is one near other commited areas so that
// we know that when we've made the longest strips its because
// we're stripifying in the same general orientation.
//
// we hop into different areas of the mesh to try to get
// other large open spans done.  Areas of small strips can
// just be left to triangle lists added at the end.
//first time, find a face with few neighbors (look for an edge of the mesh)
//meshJump += 0.1f;
//if (meshJump > 1.0f)
//	meshJump = .05f;
// if this guy isn't visited, try him
// update the index and clamp to 0-(numFaces-1)
// update the meshJump
// return the best face we found
///////////////////////////////////////////////////////////////////////////////////////////
// GetUniqueVertexInB()
//
// Returns the vertex unique to faceB
//
// nothing is different
///////////////////////////////////////////////////////////////////////////////////////////
// GetSharedVertices()
//
// Returns the (at most) two vertices shared between the two faces
//
///////////////////////////////////////////////////////////////////////////////////////////
// GetNextIndex()
//
// Returns vertex of the input face which is "next" in the input index list
//
// shouldn't get here, but let's try and fail gracefully
///////////////////////////////////////////////////////////////////////////////////////////
// IsMarked()
//
// If either the faceInfo has a real strip index because it is
// already assign to a committed strip OR it is assigned in an
// experiment and the experiment index is the one we are building
// for, then it is marked and unavailable
///////////////////////////////////////////////////////////////////////////////////////////
// MarkTriangle()
//
// Marks the face with the current strip ID
//
//bools to indicate whether a vertex is in the faceVec or not
//the face is not unique, all it's vertices exist in the face vector
//if we get out here, it's unique
///////////////////////////////////////////////////////////////////////////////////////////
// Build()
//
// Builds a strip forward as far as we can go, then builds backwards, and joins the two lists
//
// used in building the strips forward and backward
// build forward... start with the initial face
// easiest way to get v2 is to use this function which requires the
// other indices to already be in the list.
//
// build the forward list
//
//check to see if this next face is going to cause us to die soon
//uh, oh, we're following a dead end, try swapping
//we only swap if it buys us something
//add a "fake" degenerate face
// add this to the strip
// add the index
//nv0 = nv1;
//nv1 = NvStripifier::GetNextIndex(scratchIndices, nextFace);
// and get the next face
// tempAllFaces is going to be forwardFaces + backwardFaces
// it's used for Unique()
//
// reset the indices for building the strip backwards and do so
//
//this tests to see if a face is "unique", meaning that its vertices aren't already in the list
// so, strips which "wrap-around" are not allowed
//check to see if this next face is going to cause us to die soon
//uh, oh, we're following a dead end, try swapping
//we only swap if it buys us something
//add a "fake" degenerate face
// add this to the strip
//this is just so Unique() will work
// add the index
//nv0 = nv1;
//nv1 = NvStripifier::GetNextIndex(scratchIndices, nextFace);
// and get the next face
// Combine the forward and backwards stripification lists and put into our own face vector
///////////////////////////////////////////////////////////////////////////////////////////
// Combine()
//
// Combines the two input face vectors and puts the result into m_faces
//
// add backward faces
// add forward faces
///////////////////////////////////////////////////////////////////////////////////////////
// SharesEdge()
//
// Returns true if the input face and the current strip share an edge
//
//check v0->v1 edge
//check v1->v2 edge
//check v2->v0 edge
///////////////////////////////////////////////////////////////////////////////////////////
// CommitStrips()
//
// "Commits" the input strips by setting their m_experimentId to -1 and adding to the allStrips
//  vector
//
// Iterate through strips
// Tell the strip that it is now real
// add to the list of real strips
// Iterate through the faces of the strip
// Tell the faces of the strip that they belong to a real strip now
///////////////////////////////////////////////////////////////////////////////////////////
// FindTraversal()
//
// Finds the next face to start the next strip on.
//
// if the strip was v0->v1 on the edge, then v1 will be a vertex in the next edge.
// find the next edgeIter
//note! used to be m_v1
////////////////////////////////////////////////////////////////////////////////////////
// RemoveSmallStrips()
//
// allStrips is the whole strip vector...all small strips will be deleted from this list, to avoid leaking mem
// allBigStrips is an out parameter which will contain all strips above minStripLength
// faceList is an out parameter which will contain all faces which were removed from the striplist
//
//make sure these are empty
//strip is too small, add faces to faceList
//and free memory
//find best face to add next, given the current cache
///////////////////////////////////////////////////////////////////////////////////////////
// NextIsCW()
//
// Returns true if the next face should be ordered in CW fashion
//
///////////////////////////////////////////////////////////////////////////////////////////
// IsCW()
//
// Returns true if the face is ordered in CW fashion
//
// shouldn't get here
////////////////////////////////////////////////////////////////////////////////////////
// CreateStrips()
//
// Generates actual strips from the list-in-strip-order.
//
//we infer the cw/ccw ordering depending on the number of indices
//this is screwed up by the fact that we insert -1s to denote changing strips
//this is to account for that
// Handle the first face in the strip
// If there is a second face, reorder vertices such that the
// unique vertex is first
// If there is a third face, reorder vertices such that the
// shared vertex is last
// Double tap the first in the new strip
// Check CW/CCW ordering
// Update last face info
// Update last face info
//we've hit a degenerate
//tLastFace.m_v1;
//tLastFace.m_v2;
//tLastFace.m_v1;
// Double tap between strips.
//-1 index indicates next strip
// Update last face info
///////////////////////////////////////////////////////////////////////////////////////////
// Stripify()
//
//
// in_indices are the input indices of the mesh to stripify
// in_cacheSize is the target cache size 
//
//used in FindGoodResetPoint()
//the number of times to run the experiments
//the cache size, clamped to one
//this is the strip size threshold below which we dump the strip into a list
// build the stripification info
// stripify
//split up the strips into cache friendly pieces, optimize them, then dump these into outStrips
//clean up
///////////////////////////////////////////////////////////////////////////////////////////
// SplitUpStripsAndOptimize()
//
// Splits the input vector of strips (allBigStrips) into smaller, cache friendly pieces, then
//  reorders these pieces to maximize cache hits
// The final strips are output through outStrips
//
//split up strips into threshold-sized pieces
/*allStrips[i]->m_faces.size()*/ > threshold)
/*allStrips[i]->m_faces.size()*/ / threshold;
/*allStrips[i]->m_faces.size()*/ % threshold;
//last time or first time through, no need for a degenerate
//but, we do need to delete the degenerate, if it's marked fake, to avoid leaking
/*
//last time through
//way too small
//just add to last strip
//don't leak
/*
//we're not just doing a tempStrips.push_back(allBigStrips[i]) because
// this way we can delete allBigStrips later to free the memory
//add small strips to face list
//screw optimization for now
//	for(i = 0; i < tempStrips.size(); ++i)
//    outStrips.push_back(tempStrips[i]);
//Optimize for the vertex cache
//find strip with least number of neighbors per face
//this n^2 algo is what slows down stripification so much....
// needs to be improved
//find best strip to add next, given the current cache
//check previous strip to see if this one requires it to switch polarity
// If there is a second face, reorder vertices such that the
// unique vertex is first
// If there is a third face, reorder vertices such that the
// shared vertex is last
// Check CW/CCW ordering
//I like this one!
///////////////////////////////////////////////////////////////////////////////////////////
// UpdateCacheStrip()
//
// Updates the input vertex cache with this strip's vertices
//
///////////////////////////////////////////////////////////////////////////////////////////
// UpdateCacheFace()
//
// Updates the input vertex cache with this face's vertices
//
///////////////////////////////////////////////////////////////////////////////////////////
// CalcNumHitsStrip()
//
// returns the number of cache hits per face in the strip
//
///////////////////////////////////////////////////////////////////////////////////////////
// CalcNumHitsFace()
//
// returns the number of cache hits in the face
//
///////////////////////////////////////////////////////////////////////////////////////////
// NumNeighbors()
//
// Returns the number of neighbors that this face has
//
///////////////////////////////////////////////////////////////////////////////////////////
// AvgStripSize()
//
// Finds the average strip size of the input vector of strips
//
///////////////////////////////////////////////////////////////////////////////////////////
// FindAllStrips()
//
// Does the stripification, puts output strips into vector allStrips
//
// Works by setting runnning a number of experiments in different areas of the mesh, and
//  accepting the one which results in the longest strips.  It then accepts this, and moves
//  on to a different area of the mesh.  We try to jump around the mesh some, to ensure that
//  large open spans of strips get generated.
//
// the experiments
//
// PHASE 1: Set up numSamples * numEdges experiments
//
// Try to find another good reset point.
// If there are none to be found, we are done
// If we have already evaluated starting at this face in this slew
// of experiments, then skip going any further
// trying it now...
// otherwise, we shall now try experiments for starting on the 01,12, and 20 edges
// build the strip off of this face's 0-1 edge
// build the strip off of this face's 1-0 edge
// build the strip off of this face's 1-2 edge
// build the strip off of this face's 2-1 edge
// build the strip off of this face's 2-0 edge
// build the strip off of this face's 0-2 edge
//
// PHASE 2: Iterate through that we setup in the last phase
// and really build each of the strips and strips that follow to see how
// far we get
//
// get the strip set
// build the first strip of the list
// create the new strip info
// build the next strip
// add it to the list
//
// Phase 3: Find the experiment that has the most promise
//
//float value = 1.f / numStrips;
//float value = numStrips * avgStripSize;
//
// Phase 4: commit the best experiment of the bunch
//
// and destroy all of the others
//delete all bogus faces in the experiments
// delete the array that we used for all experiments
///////////////////////////////////////////////////////////////////////////////////////////
// CountRemainingTris()
//
// This will count the number of triangles left in the
// strip list starting at iter and finishing up at end
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\NvTriStrip\src\NvTriStrip\VertexCache.cpp
//push everything right one
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\tinyxml2\tinyxml2.cpp
/*
// yes, this one new style header, is in the Android SDK.
// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
/*int _snprintf_s(
// Microsoft Visual Studio 2003 and earlier or WinCE
// Microsoft Visual Studio 2003 and not WinCE.
// VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
// Microsoft Visual Studio 2003 and earlier or WinCE.
// GCC version 3 and higher
//#warning( "Using sn* functions." )
// all line endings are normalized to LF
// CR gets filtered out
// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
//	ef bb bf (Microsoft "lead bytes") - designates UTF-8
// This in effect implements the assignment operator by "moving"
// ownership (as in auto_ptr).
// Inner loop of text parsing.
// Adjusting _start would cause undefined behavior on delete[]
// Trim leading space.
// the read pointer
// the write pointer
// don't write to q; this trims the trailing space.
// the read pointer
// the write pointer
// CR-LF pair becomes LF
// CR alone becomes LF
// LF-CR becomes LF
// Entities handled by tinyXML2:
// - special entities in the entity table [in/out]
// - numeric character reference [in]
//   &#20013; or &#x4e2d;
// Found an entity - convert.
// fixme: treat as error?
// The loop below has plenty going on, and this
// is a less useful mode. Break it out.
// --------- XMLUtil ----------- //
// Check for BOM:
// This code won't convert this correctly anyway.
// Scary scary fall throughs.
// Presume an entity, and pull it out.
// Hexadecimal.
// Decimal.
// convert the UCS to UTF-8
/*
//github.com/leethomason/tinyxml2/issues/106
// horrible syntax trick to make the compiler happy about %lld
// horrible syntax trick to make the compiler happy about %lld
// These strings define the matching patterns:
// and a header for everything else; check last.
// use same memory pool
// use same memory pool
// Back it up, all the text counts.
// --------- XMLNode ----------- //
// Edge case: XMLDocuments don't have a Value. Return null.
// The last node or the only node.
// This is a recursive method, but thinking about it "at the current level"
// it is a pretty simple flat list:
//		<foo/>
//		<!-- comment -->
//
// With a special case:
//		<foo>
//		</foo>
//		<!-- comment -->
//
// Where the closing element (/foo) *must* be the next thing after the opening
// element, and the names must match. BUT the tricky bit is that the closing
// element will be read by the child.
//
// 'endTag' is the end tag for this node, it is returned by a call to a child.
// 'parentEnd' is the end tag for the parent, which is filled in and returned.
// A declaration can only be the first child of a document.
// Set error, if document already has children.
// We read the end tag. Return it to the parent.
// created and then immediately deleted.
// Handle an end tag returned to this level.
// And handle a bunch of annoying errors.
// --------- XMLText ---------- //
// fixme: this will always allocate memory. Intern?
// --------- XMLComment ---------- //
// Comment parses as text.
// fixme: this will always allocate memory. Intern?
// --------- XMLDeclaration ---------- //
//printf( "~XMLDeclaration\n" );
// Declaration parses as text.
// fixme: this will always allocate memory. Intern?
// --------- XMLUnknown ---------- //
// Unknown parses as text.
// fixme: this will always allocate memory. Intern?
// --------- XMLAttribute ---------- //
// Parse using the name rules: bug fix, was using ParseText before
// Skip white space before =
// move up to opening quote
// move past opening quote
// --------- XMLElement ---------- //
// always created and linked.
// Read the attributes.
// attribute.
// There is a minor bug here: if the attribute in the source xml
// document is duplicated, it will not be detected and the
// attribute will be doubly added. However, tracking the 'prevAttribute'
// avoids re-scanning the attribute list. Preferring performance for
// now, may reconsider in the future.
// end of the tag
// end of the tag
// done; sealed element.
//
//	<ele></ele>
//	<ele>foo<b>bar</b></ele>
//
// Read the element name.
// The closing element is the </element> form. It is
// parsed just like a regular element then deleted from
// the DOM.
// fixme: this will always allocate memory. Intern?
// fixme: this will always allocate memory. Intern?
// different count
// --------- XMLDocument ----------- //
// Warning: List must match 'enum XMLError'
// avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
// Isn't in the tree.
// Use the parent delete.
// Also, we need to mark it tracked: we 'know'
// it was never used.
// Call the static XMLNode version:
// This is likely overengineered template art to have a check that unsigned long value incremented
// by one still fits into size_t. If size_t type is larger than unsigned long type
// (x86_64-w64-mingw32 target) then the check is redundant and gcc and clang emit
// -Wtype-limits warning. This piece makes the compiler select code with a check when a check
// is useful and code with no check when a check is redundant depending on how size_t and unsigned long
// types sizes relate to each other.
// Cannot handle files which won't fit in buffer together with null terminator
// Clear any error from the last save, otherwise it will get reported
// for *this* call.
// clean up now essentially dangling memory.
// and the parse fail can put objects in the
// pools that are dead and inaccessible.
// Should check INT_MIN <= _errorID && _errorId <= INT_MAX, but that
// causes a clang "always true" -Wtautological-constant-out-of-range-compare warning
// Clear() must have been called previously
// not required, but consistency is nice
// Close out and re-start the va-args
// back up over the null terminator.
// Look for runs of bytes between entities to print.
// Remember, char is sometimes signed. (How many times has that bitten me?)
// Check for entities. If one is found, flush
// the stream up until the entity, write the
// entity, and keep looking.
// %.*s accepts type int as "precision"
// TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
// Flush the remaining string. This will be the entire
// string if an entity wasn't found.
// namespace tinyxml2
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\ToolWindowManager\ToolWindowManager.cpp
/*
// do nothing
// Convert area percentage desired to relative sizes.
// inherit the size policy from the widget we are wrapping
// store old geometries so we can restore them
// Convert area percentage desired to relative sizes.
// search up to find the first parent manager
// search up to find the first parent manager
// if the parent is a ToolWindowManagerArea, switch tabs
// QTimer::singleShot(1000, area, SLOT(deleteLater()));
// least top level splitter that should remain
// most top level splitter that should be deleted
// can't deleteLater immediately (strange MacOS bug)
// QTimer::singleShot(1000, wrapper, SLOT(deleteLater()));
// QTimer::singleShot(1000, invalidSplitter, SLOT(deleteLater()));
// QTimer::singleShot(1000, area, SLOT(deleteLater()));
// don't allow dragging a whole wrapper into a subset of itself
// don't allow dragging a whole wrapper into a subset of itself
// if we found a wrapper and it's not empty, then we fill into a gap between two areas in a
// splitter. Search down the hierarchy until we find a splitter whose handle intersects the
// cursor and pick an area to map to.
// try the first widget, if it's an area stop
// then the second widget
// neither widget is an area - let's search for a splitter to recurse to
// neither side is an area or a splitter - should be impossible, but stop recursing
// and treat this like a floating window
// if we still have a splitter, and didn't find an area, find which widget contains the
// cursor and recurse to that splitter
// if this isn't a splitter, and it's not an area (since that would have been found
// before any of this started) then bail out
// we found an area to use! stop now
// if we still haven't found anything, bail out
// calculate the rect of the area
// subtract the rect for the tab bar.
// move the tab one to the right, to indicate the tab is being added after the last one.
// clamp from the right, to ensure we don't display any tab off the end of the range
// no hotspot highlighted, draw geometry for a float window if previewing a tear-off, or draw
// nothing if we're dragging a float window as it moves itself.
// we also don't render any preview tear-off when floating windows are disallowed
// move these locally to prevent re-entrancy
// check if we're dragging a whole float window, if so we don't do anything as it's already
// moved
// add a little title bar
// for the sides, add an arrow.
// duplicate these pixmaps by default
// right clicking aborts any drag in progress
// pressing escape any drag in progress
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\ToolWindowManager\ToolWindowManagerArea.cpp
/*
// can start tab drag only if mouse is at some tab, not at empty tabbar space
// stop internal tab drag in QTabBar
// update the select order. Increment any existing index after the insertion point to keep the
// indices in the list up to date.
// if the tab inserted is the current index (most likely) then add it at the end, otherwise
// add it next-to-end (to keep the most recent tab the same).
// update the select order. Remove the index that just got deleted, and decrement any index
// greater than it to remap to their new indices
// move this tab to the end of the select order, as long as we have it - if it's a new index then
// ignore and leave it to be handled in tabInserted()
// before closing this index, switch the current index to the next tab in succession.
// should never get here but let's check this
// when closing the last tab there's nothing to do
// if the last in the select order is being closed, switch to the next most selected tab
// update the select order.
// This amounts to just a swap - any indices other than the pair in question are unaffected since
// one tab is removed (above/below) and added (below/above) so the indices themselves remain the
// same.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\ToolWindowManager\ToolWindowManagerSplitter.cpp
/*
// if we removed an item at one extreme or another, the new end should get all the space
// (unless the list is now empty)
// we removed an item in the middle, share the space between its previous neighbours, now in
// [idx-1] and [idx], and we know they're valid since if there were only two elements before
// the removal one or the other case above would have matched. So there are at least two
// elements now and idx > 0
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\ToolWindowManager\ToolWindowManagerTabBar.cpp
/*
// Workaround for extremely dodgy KDE behaviour - by default the KDE theme will install event
// filters on various widgets such as QTabBar and any descendents, and if a click is detected on
// them that isn't on a tab it will immediately start moving the window, interfering with our own
// click-to-drag behaviour.
// TODO make our own pin icon, that is pinned/unpinned
// we only set floatable true so we can hijack the float button for our own pin/auto-hide button
// we only set floatable true so we can hijack the float button for our own pin/auto-hide button
// TODO - temporarily until this is implemented, hide the pin button.
// process a pin of these tabs
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\ToolWindowManager\ToolWindowManagerWrapper.cpp
/*
// find the best candidate for a 'title' for this floating window.
// if we've found an area, use its currently selected tab's text
// otherwise we should have a splitter
// if it's empty, just bail
// if it's vertical, we pick the first child and recurse
// if it's horizontal there's ambiguity so we just pick the biggest one by size, with a
// tie-break for the leftmost one
// if not, use this object's window title
// abort dragging caused by QEvent::NonClientAreaMouseButtonPress in eventFilter function
// catch clicks on the close button
// if the mouse button is released, let the manager finish the drag and don't call any more
// updates for any further move events
// if we're ready to start a drag, check how far we've moved and start the drag if past a
// certain pixel threshold.
// if the drag is active, update it in the manager.
// on non-windows we have no native title bar, so we need to move the window ourselves
// if we're in the title bar, repaint to pick up motion over the close button
// Title must be painted after the frame, since the areas overlap, and
// the title may wish to extend out to all sides (eg. XP style)
// abort dragging caused by QEvent::NonClientAreaMouseButtonPress in eventFilter function
// check if we should offer to resize
// check corners first, then horizontal/vertical
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\iostream\test.cpp
// Construct a stream object with this filebuffer.  Anything sent
// to this stream will go to standard out.
// This text is getting compressed and sent to stdout.
// To prove this, run 'test | zcat'.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\iostream\zfstream.cpp
// Hard code the compression level
// Put the end-of-string indicator
// Hard code the compression level
// Put the end-of-string indicator
// If the file hasn't been opened for reading, error.
// if a buffer doesn't exists, allocate one.
// Attempt to fill the buffer.
// disable get area
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\iostream2\zstream_test.cpp
// read it back
// try ascii output; zcat temp.gz to see the results
