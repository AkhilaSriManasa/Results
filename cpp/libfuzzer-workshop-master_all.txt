                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
# libfuzzer-workshop
Materials of *"Modern fuzzing of C/C++ Projects"* workshop.

The first version of the workshop had been presented at [ZeroNights'16] security
conference.

## Requirements

* 2-3 hours of your time
* Linux-based OS
* C/C++ experience (nothing special, but you need to be able to read, write and
compile C/C++ code)
* a recent version of **clang** compiler. Distributions from
package managers are too old and most likely won't work (the workshop
called "modern", right?), you have two options:
   * checkout **llvm** repository and build it yourself. To make it easy,
     feel free to use [checkout_build_install_llvm.sh] script, it has been
     tested on clean Ubuntu 16.04
   * a [VirtualBox VM] with working environment is available, credentials:
     `fuzzer:zeronights`
* `sudo apt-get install -y make autoconf automake libtool pkg-config zlib1g-dev`


Fuzzing experience is not required.

## Contents
1. An introduction to fuzz testing
2. An example of traditional fuzzing
3. Coverage-guided fuzzing
4. Writing fuzzers (simple examples)
5. Finding Heartbleed (CVE-2014-0160)
6. Finding c-ares $100,000 bug (CVE-2016-5180)
7. How to improve your fuzzer
8. Fuzzing libxml2, learning how to improve the fuzzer and analyze performance
9. Fuzzing libpng, learning an importance of seed corpus and other stuff
10. Fuzzing re2
11. Fuzzing pcre2
12. Chromium integration & homework assignment


Most of the examples have been taken from [libFuzzer tutorial] and
[Fuzzer Test Suite].

## Prerequisites

### libFuzzer
Building libFuzzer is extreemly easy:
```bash
cd libFuzzer
Fuzzer/build.sh
```


## Links

* all slides in a single presentation: [Modern Fuzzing of C/C++ Projects](https://docs.google.com/presentation/d/1pbbXRL7HaNSjyCHWgGkbpNotJuiC4O7L_PDZoGqDf5Q/edit?usp=sharing)
* libFuzzer documentation: [http://libfuzzer.info](http://libfuzzer.info)
* libFuzzer tutorial: [http://tutorial.libfuzzer.info](http://tutorial.libfuzzer.info)
* Google Online Security Blog: [Guided in-process fuzzing of Chrome components](https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html)



[Fuzzer Test Suite]: https://github.com/google/fuzzer-test-suite
[VirtualBox VM]: https://drive.google.com/file/d/0B19rvTqcOBfTZHZseDk3ZkNjWHc/view?usp=sharing
[ZeroNights'16]: https://2016.zeronights.org/program/workshops/#ws1
[checkout_build_install_llvm.sh]: checkout_build_install_llvm.sh
[libFuzzer tutorial]: http://tutorial.libfuzzer.info
# Lesson 01

This is a theorethical introduction, see the slides.
# Lesson 02

## Traditional out-of-process fuzzing

**Target**: [pdfium]

**Mutation engine**: [radamsa]

**Seed corpus**: collected from previous [PDFium bugs]


## Instruction

Take a look at [generate_testcases.py](generate_testcases.py) scripts. Then use
`radamsa` to generate testcases from `seed_corpus`:
```bash
cd lessons/02
./generate_testcases.py
```

Verify number of files generated:
```bash
ls work/corpus/ | wc -l
1000
```

Take a look at [run_fuzzing.py](run_fuzzing.py) script. Then run fuzzing:
```bash
tar xzf bin/asan.tgz
./run_fuzzing.py
```

If you don't see any output, no crash has been found. Feel free to re-generate
testcases many more times. Though it should take for a while to find a crash.


[pdfium]: https://pdfium.googlesource.com/pdfium/
[radamsa]: https://github.com/aoh/radamsa
[PDFium bugs]: https://bugs.chromium.org/p/chromium/issues/list?can=1&q=Type%3DBug-Security+component%3AInternals%3EPlugins%3EPDF+label%3Aallpublic+opened%3E2015-04-09&colspec=ID+Pri+M+Stars+ReleaseBlock+Component+Status+Owner+Summary+OS+Modified&x=m&y=releaseblock&cells=ids
# Lesson 03

This is a theorethical lesson, see the slides.
# Lesson 04

Writing fuzzers. Here will be examples of different fuzzers.

## Sample fuzzer #1

Consider the following function:

```cpp
bool VulnerableFunction1(const uint8_t* data, size_t size) {
  bool result = false;
  if (size >= 3) {
    result = data[0] == 'F' &&
             data[1] == 'U' &&
             data[2] == 'Z' &&
             data[3] == 'Z';
  }

  return result;
}
```

Do you see any bug there? Let's try to fuzz it with the following fuzz target:

```cpp
#include "vulnerable_functions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  VulnerableFunction1(data, size);
  return 0;
}

```

Compile the fuzzer in the following way:
```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    first_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o first_fuzzer
```

Create an empty directory for corpus and run the fuzzer:

```bash
mkdir corpus1
./first_fuzzer corpus1
```

You should see the following input:
```bash
$ ./first_fuzzer corpus1/
INFO: Seed: 2547238898
INFO: Loaded 1 modules (32 guards): [0x744ea0, 0x744f20), 
Loading corpus dir: corpus1/
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0  READ units: 1
#1  INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 26Mb
#10 NEW    cov: 4 ft: 4 corp: 2/31b exec/s: 0 rss: 26Mb L: 30 MS: 4 ChangeBit-ChangeByte-ShuffleBytes-InsertRepeatedBytes-
#30588  NEW    cov: 5 ft: 5 corp: 3/60b exec/s: 0 rss: 29Mb L: 29 MS: 2 InsertByte-InsertRepeatedBytes-
#124562 NEW    cov: 6 ft: 6 corp: 4/90b exec/s: 0 rss: 36Mb L: 30 MS: 1 InsertByte-
#331574 NEW    cov: 7 ft: 7 corp: 5/99b exec/s: 0 rss: 52Mb L: 9 MS: 3 EraseBytes-CrossOver-InsertByte-
=================================================================
==14322==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000247d93 at pc 0x0000004f0781 bp 0x7ffd8e9af800 sp 0x7ffd8e9af7f8
READ of size 1 at 0x602000247d93 thread T0
    #0 0x4f0780  (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x4f0780)
    #1 0x4f07f9  (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x4f07f9)
    #2 0x4f9f17  (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x4f9f17)
    #3 0x4fa100  (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x4fa100)
    <...>
```

Wow! The fuzzer has just found a **heap-buffer-overflow**. Let's try to
reproduce the crash:

```bash
$ ./first_fuzzer crash-0eb8e4ed029b774d80f2b66408203801cb982a60 
```

To get a symbolized stacktrace, add `symbolize=1` option to `ASAN_OPTIONS` env
variable:
```bash
ASAN_OPTIONS=symbolize=1 ./first_fuzzer crash-0eb8e4ed029b774d80f2b66408203801cb982a60 
```

The symbolized result looks like:

```bash
INFO: Seed: 3080648570
INFO: Loaded 1 modules (32 guards): [0x744ea0, 0x744f20), 
./first_fuzzer: Running 1 inputs 1 time(s) each.
Running: crash-0eb8e4ed029b774d80f2b66408203801cb982a60
=================================================================
==15226==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000093 at pc 0x0000004f0781 bp 0x7ffe1dda1650 sp 0x7ffe1dda1648
READ of size 1 at 0x602000000093 thread T0
    #0 0x4f0780 in VulnerableFunction1(unsigned char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:16:14
    #1 0x4f07f9 in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/04/sample_fuzzer_one.cc:10:3
    #2 0x4f9f17 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerLoop.cpp:515:13
    #3 0x4fa100 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerLoop.cpp:469:3
    #4 0x4f0983 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDriver.cpp:272:6
    #5 0x4f2642 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDriver.cpp:482:9
    #6 0x4f08b0 in main /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMain.cpp:20:10
    #7 0x7f64a1cdbf44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
    #8 0x41b557 in _start (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x41b557)

0x602000000093 is located 0 bytes to the right of 3-byte region [0x602000000090,0x602000000093)
allocated by thread T0 here:
    #0 0x4ed57b in operator new[](unsigned long) (/home/mmoroz/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x4ed57b)
    #1 0x4f9e5a in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerLoop.cpp:506:23
    #2 0x4fa100 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerLoop.cpp:469:3
    #3 0x4f0983 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDriver.cpp:272:6
    #4 0x4f2642 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerDriver.cpp:482:9
    #5 0x4f08b0 in main /home/mmoroz/projects/libfuzzer-workshop/libFuzzer/Fuzzer/FuzzerMain.cpp:20:10
    #6 0x7f64a1cdbf44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)

SUMMARY: AddressSanitizer: heap-buffer-overflow /home/mmoroz/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:16:14 in VulnerableFunction1(unsigned char const*, unsigned long)
Shadow bytes around the buggy address:
  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff8000: fa fa 00 00 fa fa 00 fa fa fa 00 fa fa fa 03 fa
=>0x0c047fff8010: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==15226==ABORTING
```

To get symbolized stack-traces by default, let's export `ASAN_OPTIONS` env var:
```bash
export ASAN_OPTIONS=symbolize=1
```


## Sample fuzzer #2

Consider another function:

```cpp
constexpr auto kMagicHeader = "ZN_2016";
constexpr std::size_t kMaxPacketLen = 1024;
constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);

bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) {
  if (size < sizeof(kMagicHeader))
    return false;

  std::string header(reinterpret_cast<const char*>(data), sizeof(kMagicHeader));

  std::array<uint8_t, kMaxBodyLength> body;

  if (strcmp(kMagicHeader, header.c_str()))
    return false;

  auto target_hash = data[--size];

  if (size > kMaxPacketLen)
    return false;

  if (!verify_hash)
    return true;

  std::copy(data, data + size, body.data());
  auto real_hash = DummyHash(body);
  return real_hash == target_hash;
}
```

This example is a bit more complicated, but let's fuzz it with the simplest
fuzz target (almost the same as the first one written above):

```cpp
#include "vulnerable_functions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  VulnerableFunction2(data, size, false);
  return 0;
}
```

Compile the fuzzer:

```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    second_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o second_fuzzer
```

Run the fuzzer:

```bash
mkdir corpus2
./second_fuzzer corpus2
```

The output is pretty boring:

```bash
$ ./second_fuzzer ./corpus2/
INFO: Seed: 989537009
INFO: Loaded 1 modules (74 guards): [0x745f60, 0x746088),
Loading corpus dir: ./corpus2/
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0  READ units: 1
#1  INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 12Mb
#6  NEW    cov: 4 ft: 4 corp: 2/27b exec/s: 0 rss: 13Mb L: 26 MS: 5 ChangeBit-ChangeBit-ShuffleBytes-ChangeBit-InsertRepeatedBytes-
#6048 NEW    cov: 5 ft: 5 corp: 3/35b exec/s: 0 rss: 14Mb L: 8 MS: 2 InsertRepeatedBytes-TempAutoDict- DE: "ZN_2016"-
#1048576  pulse  cov: 5 ft: 5 corp: 3/35b exec/s: 524288 rss: 148Mb
#2097152  pulse  cov: 5 ft: 5 corp: 3/35b exec/s: 524288 rss: 284Mb
#4194304  pulse  cov: 5 ft: 5 corp: 3/35b exec/s: 524288 rss: 521Mb
#8388608  pulse  cov: 5 ft: 5 corp: 3/35b exec/s: 493447 rss: 523Mb
#16777216 pulse  cov: 5 ft: 5 corp: 3/35b exec/s: 508400 rss: 523Mb
<...>
```

Let's modify the fuzz target to use different values for `verify_hash` argument
of the target API:

```cpp
#include "vulnerable_functions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  bool verify_hash_flags[] = { false, true };

  for (auto flag : verify_hash_flags)
    VulnerableFunction2(data, size, flag);
  return 0;
}
```

Compile the fuzzer:

```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    third_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o third_fuzzer
```

Run the fuzzer on the same corpus:

```bash
$ ./third_fuzzer corpus2/
INFO: Seed: 2627375800
INFO: Loaded 1 modules (74 guards): [0x745fa0, 0x7460c8),
Loading corpus dir: corpus2/
INFO: -max_len is not provided, using 64
#0  READ units: 2
#2  INITED cov: 24 ft: 23 corp: 2/34b exec/s: 0 rss: 12Mb
#30 NEW    cov: 24 ft: 24 corp: 3/40b exec/s: 0 rss: 13Mb L: 6 MS: 3 ChangeBinInt-ShuffleBytes-EraseBytes-
#1048576  pulse  cov: 24 ft: 24 corp: 3/40b exec/s: 524288 rss: 219Mb
#2097152  pulse  cov: 24 ft: 24 corp: 3/40b exec/s: 419430 rss: 426Mb
#4194304  pulse  cov: 24 ft: 24 corp: 3/40b exec/s: 419430 rss: 524Mb
#8388608  pulse  cov: 24 ft: 24 corp: 3/40b exec/s: 399457 rss: 524Mb
<...>
```

The fuzzer has found a new path, but things are still boring. Please note:

```
INFO: -max_len is not provided, using 64
```

while our target analyzes packets of `ZN_2016` protocol that may have length up
to `constexpr std::size_t kMaxPacketLen = 1024;` bytes.

Let's add `-max_len=1024` libFuzzer argument:

```bash
./third_fuzzer corpus2/ -max_len=1024
```

**BOOM!**

```
INFO: Seed: 2391963130
INFO: Loaded 1 modules (74 guards): [0x745fa0, 0x7460c8),
Loading corpus dir: corpus2/
#0  READ units: 3
#3  INITED cov: 24 ft: 24 corp: 3/75b exec/s: 0 rss: 14Mb
=================================================================
==1530==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffd0a3ccbc8 at pc 0x0000004ab13c bp 0x7ffd0a3cc630 sp 0x7ffd0a3cbde0
WRITE of size 1023 at 0x7ffd0a3ccbc8 thread T0
    #0 0x4ab13b in __asan_memmove (/usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/04/third_fuzzer+0x4ab13b)
    #1 0x4f1697 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h:372:6
    #2 0x4f153d in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h:389:14
    #3 0x4f148b in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h:426:18
    #4 0x4f123e in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h:458:15
    #5 0x4f0d13 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x4f10e4 in LLVMFuzzerTestOneInput /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/04/third_fuzzer.cc:13:5
    <...>
```

We have `stack-buffer-overflow` vulnerability at `vulnerable_functions.h:61:3`.


## Sample fuzzer #3

Look at the following function:

```cpp
constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;

bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) {
  bool verify_hash = flags & kZn2016VerifyHashFlag;
  return VulnerableFunction2(data, size, verify_hash);
}
```

Actually it is just a wrapper for the previous vulnerable function, but the main
point here is a large space of possible `flags` values.

*Note*: imagine that there are more than two different `flags` values possible.
If your fantasy needs inspiration, please take a look at possible values of
`flags` and `mode` arguments of standard [open()] function.

Enumeration of all possible combinations in the fuzzer doesn't seem reasonable.
Also there is no guarantee that new possible values will not be added.

In this case, we can get some randomization of `flags` values using `data`
provided by libFuzzer:

```cpp
#include "vulnerable_functions.h"

#include <functional>
#include <string>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  std::string data_string(reinterpret_cast<const char*>(data), size);
  auto data_hash = std::hash<std::string>()(data_string);

  std::size_t flags = static_cast<size_t>(data_hash);
  VulnerableFunction3(data, size, flags);
  return 0;
}
```

Compile the fuzzer:

```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    fourth_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o fourth_fuzzer
```

and run on the empty corpus:

```bash
mkdir corpus3
./fourth_fuzzer corpus3/ -max_len=1024
```

As you see, it finds the same crash pretty quickly again, but, now the fuzzer is
universal in terms of possible `flags` values.

[open()]: http://man7.org/linux/man-pages/man2/open.2.html
# Lesson 05

Here we will find Heartbleed vulnerability (CVE-2014-0160).

***
This example has been taken from [google/fuzzer-stest-suite] repository.
***


### Build vulnerable openssl version

```bash
tar xzf openssl1.0.1f.tgz
cd openssl1.0.1f/

./config
make clean
make CC="clang -O2 -fno-omit-frame-pointer -g -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div" -j$(nproc)
```

### Build and run the fuzzer

Take a look into the fuzzer:

```c
// Copyright 2016 Google Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <assert.h>
#include <stdint.h>
#include <stddef.h>

#ifndef CERT_PATH
# define CERT_PATH
#endif

SSL_CTX *Init() {
  SSL_library_init();
  SSL_load_error_strings();
  ERR_load_BIO_strings();
  OpenSSL_add_all_algorithms();
  SSL_CTX *sctx;
  assert (sctx = SSL_CTX_new(TLSv1_method()));
  /* These two file were created with this command:
      openssl req -x509 -newkey rsa:512 -keyout server.key \
     -out server.pem -days 9999 -nodes -subj /CN=a/
  */
  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH "server.pem",
                                      SSL_FILETYPE_PEM));
  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH "server.key",
                                     SSL_FILETYPE_PEM));
  return sctx;
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);
  BIO_write(sinbio, Data, Size);
  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
```

Build the fuzzer:

```bash
cd ..
clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div \
    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \
    ../../libFuzzer/libFuzzer.a -o openssl_fuzzer
```

Run the fuzzer:

```bash
mkdir corpus1
./openssl_fuzzer ./corpus1/
```

After some time:

```
INFO: Seed: 3620533608
INFO: Loaded 1 modules (88608 guards): [0xcad4c0, 0xd03d40), 
Loading corpus dir: ./corpus1/
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0  READ units: 1
#1  INITED cov: 1473 ft: 385 corp: 1/1b exec/s: 0 rss: 31Mb
#2  NEW    cov: 1479 ft: 414 corp: 2/36b exec/s: 0 rss: 31Mb L: 35 MS: 1 InsertRepeatedBytes-
#111  NEW    cov: 1479 ft: 417 corp: 3/79b exec/s: 0 rss: 36Mb L: 43 MS: 5 ShuffleBytes-CrossOver-CMP-EraseBytes-EraseBytes- DE: "\x00\x00"-
#2256 NEW    cov: 1490 ft: 439 corp: 4/128b exec/s: 0 rss: 127Mb L: 49 MS: 5 PersAutoDict-ChangeBit-ChangeBinInt-ChangeBinInt-InsertRepeatedBytes- DE: "\x00\x00"-

<...>

#120643 NEW    cov: 1563 ft: 721 corp: 37/1736b exec/s: 24128 rss: 373Mb L: 46 MS: 2 CopyPart-CMP- DE: "\x00\x00\x00\x00\x00\x00\x00v"-
#121008 NEW    cov: 1565 ft: 723 corp: 38/1758b exec/s: 24201 rss: 373Mb L: 22 MS: 2 ChangeBinInt-EraseBytes-
=================================================================
==32104==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x0000004aad87 bp 0x7fff9266d020 sp 0x7fff9266c7d0
READ of size 25344 at 0x629000009748 thread T0
    #0 0x4aad86 in __asan_memcpy (/usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl_fuzzer+0x4aad86)
    #1 0x4ff232 in tls1_process_heartbeat /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl1.0.1f/ssl/t1_lib.c:2586:3
    #2 0x580be0 in ssl3_read_bytes /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl1.0.1f/ssl/s3_pkt.c:1092:4
    #3 0x585c37 in ssl3_get_message /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl1.0.1f/ssl/s3_both.c:457:7
    #4 0x548a54 in ssl3_get_client_hello /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl1.0.1f/ssl/s3_srvr.c:941:4
    #5 0x544a4e in ssl3_accept /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl1.0.1f/ssl/s3_srvr.c:357:9
    #6 0x4f0d42 in LLVMFuzzerTestOneInput /usr/local/google/home/mmoroz/Projects/libfuzzer-workshop/lessons/HB/openssl_fuzzer.cc:39:3
    <...>
```

**READ** of size **25344** due to  **heap-buffer-overflow** in 
`tls1_process_heartbeat` function. Here it is. One of the scariest
vulnerabilities can be found in a few minutes. Fuzzing is awesome.


[Heartbleed]: https://en.wikipedia.org/wiki/Heartbleed
[google/fuzzer-stest-suite]: https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#heartbleed# Lesson 06

Here we will find [c-ares] vulnerability (CVE-2016-5180) that has been exploited
to obtain [remote code execution] with root privileges on ChromeOS.

***
This example has been taken from [google/fuzzer-stest-suite] repository.
***


### Build vulnerable c-ares version

```bash
tar xzvf c-ares.tgz
cd c-ares

./buildconf
./configure CC="clang -O2 -fno-omit-frame-pointer -g -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div"
make CFLAGS=
```

### Build and run the fuzzer


Take a look into the fuzzer:

```cpp
#include <ares.h>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  unsigned char *buf;
  int buflen;
  std::string s(reinterpret_cast<const char *>(data), size);
  ares_create_query(s.c_str(), ns_c_in, ns_t_a, 0x1234, 0, &buf, &buflen, 0);
  ares_free_string(buf);
  return 0;
}
```

Build the fuzzer:

```bash
cd ..
clang++ -g c_ares_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div \
    -Ic-ares c-ares/.libs/libcares.a \
    ../../libFuzzer/libFuzzer.a -o c_ares_fuzzer
```

And run it:

```bash
mkdir corpus1
./c_ares_fuzzer corpus1
```

Let's look into its output:

```bash
INFO: Seed: 250951835
INFO: Loaded 1 modules (152 guards): [0x747340, 0x7475a0), 
Loading corpus dir: corpus1
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0  READ units: 1
#1  INITED cov: 12 ft: 11 corp: 1/1b exec/s: 0 rss: 26Mb
#2  NEW    cov: 18 ft: 17 corp: 2/2b exec/s: 0 rss: 26Mb L: 1 MS: 1 ChangeBit-
#5  NEW    cov: 19 ft: 21 corp: 3/4b exec/s: 0 rss: 27Mb L: 2 MS: 4 ChangeBit-CrossOver-ShuffleBytes-ChangeByte-
#8  NEW    cov: 19 ft: 25 corp: 4/52b exec/s: 0 rss: 27Mb L: 48 MS: 2 CopyPart-InsertRepeatedBytes-
#10 NEW    cov: 20 ft: 26 corp: 5/109b exec/s: 0 rss: 29Mb L: 57 MS: 4 CopyPart-InsertRepeatedBytes-InsertByte-CMP- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#26 NEW    cov: 20 ft: 30 corp: 6/148b exec/s: 0 rss: 29Mb L: 39 MS: 5 InsertRepeatedBytes-EraseBytes-ChangeBit-ChangeByte-CMP- DE: "\x01\x00"-
#28 NEW    cov: 22 ft: 32 corp: 7/199b exec/s: 0 rss: 29Mb L: 51 MS: 2 InsertRepeatedBytes-PersAutoDict- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#43 NEW    cov: 22 ft: 36 corp: 8/238b exec/s: 0 rss: 29Mb L: 39 MS: 2 ShuffleBytes-PersAutoDict- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#48 NEW    cov: 23 ft: 37 corp: 9/273b exec/s: 0 rss: 29Mb L: 35 MS: 2 CrossOver-PersAutoDict- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#62 NEW    cov: 23 ft: 41 corp: 10/312b exec/s: 0 rss: 29Mb L: 39 MS: 1 CMP- DE: "\x00\x00\x00\x00\x00\x00\x00\x01"-
#84 NEW    cov: 23 ft: 44 corp: 11/336b exec/s: 0 rss: 29Mb L: 24 MS: 3 ChangeByte-CrossOver-PersAutoDict- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#87 NEW    cov: 23 ft: 45 corp: 12/367b exec/s: 0 rss: 29Mb L: 31 MS: 1 EraseBytes-
#212  NEW    cov: 23 ft: 47 corp: 13/423b exec/s: 0 rss: 29Mb L: 56 MS: 1 CopyPart-
#224  NEW    cov: 23 ft: 48 corp: 14/487b exec/s: 0 rss: 29Mb L: 64 MS: 3 ChangeByte-PersAutoDict-CrossOver- DE: ".\x00\x00\x00\x00\x00\x00\x00"-
#899  NEW    cov: 23 ft: 50 corp: 15/547b exec/s: 0 rss: 29Mb L: 60 MS: 3 EraseBytes-ChangeByte-CopyPart-
#1019 NEW    cov: 26 ft: 53 corp: 16/602b exec/s: 0 rss: 29Mb L: 55 MS: 3 CopyPart-PersAutoDict-CMP- DE: ".\x00\x00\x00\x00\x00\x00\x00"-"\\\x00\x00\x00\x00\x00\x00\x00"-
#1483 NEW    cov: 26 ft: 55 corp: 17/658b exec/s: 0 rss: 29Mb L: 56 MS: 2 EraseBytes-CopyPart-
#2760 NEW    cov: 27 ft: 56 corp: 18/722b exec/s: 0 rss: 30Mb L: 64 MS: 4 InsertRepeatedBytes-ChangeByte-CopyPart-InsertByte-
=================================================================
==15515==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6030000470f5 at pc 0x0000004f1acf bp 0x7fff4e5b1310 sp 0x7fff4e5b1308
WRITE of size 1 at 0x6030000470f5 thread T0
    #0 0x4f1ace in ares_create_query /home/mmoroz/projects/libfuzzer-workshop/lessons/06/c-ares/ares_create_query.c:196:3
    #1 0x4f0684 in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/06/c_ares_fuzzer.cc:16:3
    <...>
```



[c-ares]: https://c-ares.haxx.se/
[remote code execution]: https://googlechromereleases.blogspot.com/2016/09/stable-channel-updates-for-chrome-os.html
[google/fuzzer-stest-suite]: https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#heartbleed
# Lesson 07

This is a theorethical lesson, see the slides.
# Lesson 08

Here we will be fuzzing [libxml2]. During this lesson we will:
* see an importance of dictionaries
* learn how to minimize the corpus
* generate coverage report
* catch Out-of-Memory errors and memory leaks


### Build the library

```bash
tar xzf libxml2.tgz
cd libxml2

./autogen.sh

export FUZZ_CXXFLAGS="-O2 -fno-omit-frame-pointer -g -fsanitize=address \
    -fsanitize-coverage=edge,indirect-calls,trace-cmp,trace-div,trace-gep,trace-pc-guard"

CXX="clang++ $FUZZ_CXXFLAGS" CC="clang $FUZZ_CXXFLAGS" \
    CCLD="clang++ $FUZZ_CXXFLAGS"  ./configure
make -j$(nproc)
```

### Build the first fuzzer

Take a look at the following fuzzer. Note the `xmlSetGenericErrorFunc` call. It
is there to disable logging of error messages like "Incorrect XML document".
These messages are very noisy, given the numbe rof invalid input generated by
the fuzzer:

```cpp
#include "libxml/parser.h"

void ignore (void* ctx, const char* msg, ...) {
  // Error handler to avoid spam of error messages from libxml parser.
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  xmlSetGenericErrorFunc(NULL, &ignore);

  if (auto doc = xmlReadMemory(reinterpret_cast<const char*>(data),
                               static_cast<int>(size), "noname.xml", NULL, 0)) {
    xmlFreeDoc(doc);
  }

  return 0;
}
```

Then build it:

```bash
cd ..
clang++ -std=c++11 xml_read_memory_fuzzer.cc $FUZZ_CXXFLAGS -I libxml2/include \
    libxml2/.libs/libxml2.a ../../libFuzzer/libFuzzer.a -lz \
    -o xml_read_memory_fuzzer
```

### Run the fuzzer with and without a dictionary

Run the fuzzer on empty corpus for 5 minutes (`-max_total_time=300`):

```bash
mkdir corpus1
./xml_read_memory_fuzzer -max_total_time=300 -print_final_stats=1 corpus1
```

Open a new terminal and run the fuzzing on empty corpus again, but also add a
dictionary (`-dict=`):

```bash
mkdir corpus2
./xml_read_memory_fuzzer -dict=./xml.dict -max_total_time=300 \
    -print_final_stats=1 corpus2
```

Compare output of both processes while they are running. You should see that the
second process gets the same coverage as the first one and then overrun it very
quickly. This is an impact of dictionary used.


### Corpus and coverage

The first process terminates somewhere at:

```
#1975901  DONE   cov: 1736 ft: 5795 corp: 1544/75Kb exec/s: 6564 rss: 494Mb
```

Let's minimize its corpus (using `-merge=1` flag):

```bash
mkdir corpus1_min
./xml_read_memory_fuzzer -merge=1 corpus1_min corpus1
```

The output looks like:

```bash
INFO: Seed: 1508800405
INFO: Loaded 1 modules (79184 guards): [0xd017e0, 0xd4ed20), 
INFO: -max_len is not provided, using 1048576
Loaded 1024/1539 files from corpus1
=== Merging extra 1539 units
#1539 MIN0   cov: 1723 ft: 5810 units: 1008 exec/s: 0 rss: 95Mb
#2547 MIN1   cov: 1724 ft: 5764 units: 987 exec/s: 0 rss: 125Mb
#3534 MIN2   cov: 1724 ft: 5765 units: 975 exec/s: 0 rss: 154Mb
#4509 MIN3   cov: 1724 ft: 5763 units: 971 exec/s: 0 rss: 183Mb
=== Merge: written 971 units
```

That means that libFuzzer made `971` testcase out of `1539` at the same code
coverage.

To get some understanding of inputs generated by the fuzzer from scratch, let's
brielfy go through the corpus:

```bash
strings corpus1_min/* | more
```

The second process terminates somewhere at:

```
#2317811  DONE   cov: 2873 ft: 8005 corp: 2359/121Kb exec/s: 7700 rss: 438Mb
```

The coverage is significantly higher comparing with the first process output.

Let's minimize its corpus as well:

```bash
mkdir corpus2_min
./xml_read_memory_fuzzer -merge=1 corpus2_min corpus2
```

The output:

```bash
INFO: Seed: 2449634923
INFO: Loaded 1 modules (79184 guards): [0xd017e0, 0xd4ed20), 
INFO: -max_len is not provided, using 1048576
Loaded 1024/2356 files from corpus2
Loaded 2048/2356 files from corpus2
=== Merging extra 2356 units
#2356 MIN0   cov: 2829 ft: 8012 units: 1571 exec/s: 0 rss: 126Mb
#3927 MIN1   cov: 2830 ft: 7970 units: 1516 exec/s: 0 rss: 169Mb
#5443 MIN2   cov: 2830 ft: 7969 units: 1503 exec/s: 0 rss: 210Mb
#6946 MIN3   cov: 2830 ft: 7968 units: 1496 exec/s: 6946 rss: 250Mb
#8442 MIN4   cov: 2830 ft: 7967 units: 1494 exec/s: 8442 rss: 291Mb
=== Merge: written 1494 units
```

And quickly go through the inputs generated by the fuzzer with a dictionary:

```bash
strings corpus2_min/* | more
```

### Generate coverage report

```bash
./xml_read_memory_fuzzer corpus1_min -runs=0 -dump_coverage=1
```

This command should generate `.sancov` file in your working directory:

```bash
$ ls *.sancov
xml_read_memory_fuzzer.26851.sancov
```

Then we need to convert that binary file to a symbolized `.symcov` file:

```bash
sancov -symbolize xml_read_memory_fuzzer xml_read_memory_fuzzer.26851.sancov \
    > xml_read_memory_fuzzer.symcov
```

To see the coverage report with user-friendly interface, let's launch local
[coverage report server]:

```bash
python3 coverage-report-server.py --symcov xml_read_memory_fuzzer.symcov \
    --srcpath libxml2
```

Open [localhost:8001](http://localhost:8001/) in your browser to see the report.


Let's generate coverage report for the second corpus (generated with dictionary)
and compare both reports by eyes. Open new terminal and do the same stuff:

```bash
ASAN_OPTIONS=coverage=1 ./xml_read_memory_fuzzer corpus2_min -runs=0

sancov -symbolize xml_read_memory_fuzzer <NEW_.SANCOV_FILE_PATH> \
    > xml_read_memory_fuzzer_2.symcov

python3 coverage-report-server.py --symcov xml_read_memory_fuzzer_2.symcov \
    --srcpath libxml2 --port 8002
```

Go to [localhost:8002](http://localhost:8002/).

The second report obviously has higher percentage of coverage for the same files
and even more source code files covered.


### Build the second fuzzer

The second fuzzer aims `xmlRegexpCompile` function of libxml2 library:

```cpp
#include "libxml/parser.h"
#include "libxml/tree.h"
#include "libxml/xmlversion.h"

void ignore (void * ctx, const char * msg, ...) {
  // Error handler to avoid spam of error messages from libxml parser.
}

// Entry point for LibFuzzer.
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  xmlSetGenericErrorFunc(NULL, &ignore);

  std::vector<uint8_t> buffer(size + 1, 0);
  std::copy(data, data + size, buffer.data());

  xmlRegexpPtr x = xmlRegexpCompile(buffer.data());
  if (x)
    xmlRegFreeRegexp(x);

  return 0;
}
```

Let's build it and run:

```bash
clang++ -std=c++11 xml_compile_regexp_fuzzer.cc $FUZZ_CXXFLAGS \
    -I libxml2/include libxml2/.libs/libxml2.a ../../libFuzzer/libFuzzer.a -lz \
    -o xml_compile_regexp_fuzzer

mkdir corpus3
./xml_compile_regexp_fuzzer -dict=./xml.dict corpus3
```

You will quickly get an Out-of-memory crash:

```bash
#796  NEW    cov: 289 bits: 845 indir: 49 corp: 54/1518b exec/s: 0 rss: 43Mb L: 64 MS: 4 CrossOver-PersAutoDict-CrossOver-ChangeByte- DE: " xml:id=\"1\""-
#800  NEW    cov: 289 bits: 855 indir: 49 corp: 55/1556b exec/s: 0 rss: 43Mb L: 38 MS: 3 PersAutoDict-ChangeBit-CrossOver- DE: "%a"-
==27928== ERROR: libFuzzer: out-of-memory (used: 2100Mb; limit: 2048Mb)
   To change the out-of-memory limit use -rss_limit_mb=<N>

Live Heap Allocations: 1003258238 bytes from 30527559 allocations; showing top 95%
732653304 byte(s) (73%) in 30527221 allocation(s)
    #0 0x4c2a0c in __interceptor_malloc (/home/mmoroz/projects/libfuzzer-workshop/lessons/07/xml_compile_regexp_fuzzer+0x4c2a0c)
    #1 0x5d8506 in xmlRegNewRange /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:719:28
    #2 0x5d8506 in xmlRegAtomAddRange /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:1251
    #3 0x5d717e in xmlFAParseCharRange /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5066:9
    #4 0x5d717e in xmlFAParsePosCharGroup /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5084
    #5 0x5d4c40 in xmlFAParseCharGroup /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5125:6
    #6 0x5d2f89 in xmlFAParseCharClass /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5145:2
    #7 0x5d2f89 in xmlFAParseAtom /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5299
    #8 0x5d2f89 in xmlFAParsePiece /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5316
    #9 0x5d25e4 in xmlFAParseBranch /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5351:8
    #10 0x5b03ad in xmlFAParseRegExp /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5377:5
    #11 0x5af8f4 in xmlRegexpCompile /home/mmoroz/projects/libfuzzer-workshop/lessons/07/libxml2/xmlregexp.c:5473:5
    #12 0x4f14d0 in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/07/xml_compile_regexp_fuzzer.cc:27:20
    <...>
```

In some cases it can be a memory leak. To detect leaks, enable `detect_leaks=1`
option of AddressSanitizer and run the fuzzer again:

```bash
ASAN_OPTIONS=detect_leaks=1 ./xml_compile_regexp_fuzzer -dict=./xml.dict corpus3
```

That option enabled LeakSanitizer (a part of AddressSanitizer) to report memory
leaks and crash the similar way as other crash reports.

[coverage report server]: http://llvm.org/svn/llvm-project/llvm/trunk/tools/sancov/coverage-report-server.py
[libxml2]: http://www.xmlsoft.org/
# Lesson 09

Here we will be fuzzing [libpng]. During this lesson we will:
* see an importance of seed corpus

### Build the target

Disabling of error messages is a bit tricky here and need to be done before the
compilation"

```bash
tar xzf libpng.tgz
cd libpng

# Disable logging via library build configuration control.
cat scripts/pnglibconf.dfa | sed -e "s/option STDIO/option STDIO disabled/" \
> scripts/pnglibconf.dfa.temp
mv scripts/pnglibconf.dfa.temp scripts/pnglibconf.dfa

# build the library.
autoreconf -f -i

export FUZZ_CXXFLAGS="-O2 -fno-omit-frame-pointer -g -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div"

./configure CC="clang" CFLAGS="$FUZZ_CXXFLAGS"
make -j2
```

### Build and run the fuzzer

Take a look at [the fuzzer]. Please note how we disable CRC check. Otherwise,
the fuzzer would almost always exit because of invalid checksum of PNG chunks.


Build the fuzzer:

```bash
cd ..
clang++ -std=c++11 libpng_read_fuzzer.cc $FUZZ_CXXFLAGS -I libpng \
    libpng/.libs/libpng16.a ../../libFuzzer/libFuzzer.a -lz \
    -o libpng_read_fuzzer
```

Run the fuzzer on empty corpus with `-mxa_len=2048` for 5 minutes:

```bash
mkdir corpus1
./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -print_final_stats=1 \
    corpus1
```

Open a new terminal and run the fuzzer with a dictionary:

```bash
mkdir corpus2
./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -dict=png.dict \
    -print_final_stats=1 corpus2
```

Then let's wait until both processes end :)


Let's run the fuzzer using a seed corpus. For seed corpus we will use some [test
images] from Chromium repo. 

Run two more fuzzer instances. One with the seed corpus:

```bash
mkdir corpus3
./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -print_final_stats=1 \
    -timeout=5 corpus3 seed_corpus
```

And another one with the seed corpus and the dictionary (super-combo!):

```bash
mkdir corpus4
./libpng_read_fuzzer -max_len=2048 -max_total_time=300 -dict=png.dict \
    -print_final_stats=1 -timeout=5 corpus4 seed_corpus
```

Compare and analyze the output of four fuzzers being run with different
configurations.



[libpng]: http://www.libpng.org/pub/png/libpng.html
[test images]: https://cs.chromium.org/chromium/src/cc/test/data/
[the fuzzer]: libpng_read_fuzzer.cc

# Lesson 10

Here we will be fuzzing [re2]. During this lesson we will:
* learn how `max_len` parameter may affect execution speed


### Build the target

```
tar xzf re2.tgz
cd re2

export FUZZ_CXXFLAGS="-O2 -fno-omit-frame-pointer -g -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div"

make clean
CXX=clang++ CXXFLAGS="$FUZZ_CXXFLAGS"  make -j
```

### Build and run the fuzzer

```bash
cd ..

clang++ -std=c++11 re2_fuzzer.cc $FUZZ_CXXFLAGS -I re2 \
    re2/obj/libre2.a ../../libFuzzer/libFuzzer.a -lz \
    -o re2_fuzzer

mkdir corpus1
./re2_fuzzer ./corpus1 -print_final_stats=1 -max_total_time=300
```

Play with different `-max_len` parameter values and other adjustments.

[re2]: https://github.com/google/re2
# Lesson 11

Here we will be fuzzing [pcre2]. During this lesson we will:
* compare fuzzing of different regexp libraries
* find known bugs and feel like a l33t h4x0r :)


### Build the target

```
tar xzf pcre2.tgz
cd pcre2

./autogen.sh

export FUZZ_CXXFLAGS="-O2 -fno-omit-frame-pointer -g -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div"

CXX="clang++ $FUZZ_CXXFLAGS" CC="clang $FUZZ_CXXFLAGS" \
    CCLD="clang++ $FUZZ_CXXFLAGS" ./configure --enable-never-backslash-C \
    --with-match-limit=1000 --with-match-limit-recursion=1000

make -j2
```

### Build and run the fuzzer

```bash
cd ..

clang++ -std=c++11 pcre2_fuzzer.cc -I pcre2/src \
    -Wl,--whole-archive pcre2/.libs/*.a -Wl,-no-whole-archive \
    ../../libFuzzer/libFuzzer.a $FUZZ_CXXFLAGS -o pcre2_fuzzer

mkdir corpus1
./pcre2_fuzzer ./corpus1 -print_final_stats=1 -max_total_time=300
```

Play with different parameters (see how speed changes with different `max_len`
values).


### Fuzzing pcre2-10.00

***
This section has been added to let everybody to feel like a l33t h4x0r again :)
***

```bash
tar xzf pcre2-10.00.tgz
cd pcre2-10.00

./autogen.sh

export FUZZ_CXXFLAGS="-O2 -fno-omit-frame-pointer -g -fsanitize=address \
    -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div"

CXX="clang++ $FUZZ_CXXFLAGS" CC="clang $FUZZ_CXXFLAGS" \
    CCLD="clang++ $FUZZ_CXXFLAGS" ./configure --enable-never-backslash-C \
    --with-match-limit=1000 --with-match-limit-recursion=1000

make -j2

cd ..

clang++ -std=c++11 pcre2_fuzzer.cc -I pcre2-10.00/src \
    -Wl,--whole-archive pcre2-10.00/.libs/*.a -Wl,-no-whole-archive \
    ../../libFuzzer/libFuzzer.a $FUZZ_CXXFLAGS -o pcre2_10.00_fuzzer

mkdir corpus2
./pcre2_10.00_fuzzer ./corpus2 -print_final_stats=1 -max_total_time=300
```

Feel free to re-run the last command to see several crashes, for example:

```bash
#290587 NEW    cov: 1884 ft: 7593 corp: 2868/129Kb exec/s: 5381 rss: 522Mb L: 62 MS: 1 ChangeBit-
=================================================================
==17288==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040005d164f at pc 0x000000585f99 bp 0x7fff827c53d0 sp 0x7fff827c53c8
READ of size 1 at 0x6040005d164f thread T0
    #0 0x585f98 in match /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2_match.c:5968:11
    #1 0x549d4b in pcre2_match_8 /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2_match.c:6876:8
    #2 0x59bfa5 in regexec /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2posix.c:291:6
    #3 0x4f093a in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2_fuzzer.cc:21:5
    <...>
```

and

```bash
#473083 NEW    cov: 2325 ft: 9716 corp: 3963/184Kb exec/s: 2263 rss: 697Mb L: 64 MS: 2 ChangeBinInt-ShuffleBytes-
=================================================================
==17265==ERROR: AddressSanitizer: heap-use-after-free on address 0x61000012caca at pc 0x000000585e83 bp 0x7ffcb3379bd0 sp 0x7ffcb3379bc8
READ of size 1 at 0x61000012caca thread T0
    #0 0x585e82 in match /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2_match.c:1426:16
    #1 0x549d4b in pcre2_match_8 /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2_match.c:6876:8
    #2 0x59bfa5 in regexec /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2-10.00/src/pcre2posix.c:291:6
    #3 0x4f093a in LLVMFuzzerTestOneInput /home/mmoroz/projects/libfuzzer-workshop/lessons/10/pcre2_fuzzer.cc:21:5
    <...>
```



[pcre2]: http://www.pcre.org/current/doc/html/pcre2.html
# Lesson 12

This is a theoretical lesson with a homework assignment, see the slides.

## Assignment:

1. check out [Chromium] repository
2. try to [build existing fuzzers]
3. write a new one

[Codesearch] is a pretty useful instrument to find [existing targets] and to
search for [new ones] as well.

Once you find a bug with it, submit your fuzzer to [Chrome Fuzzer Program].

**Happy fuzzing!**


[Chromium]: https://www.chromium.org/developers/how-tos/get-the-code
[Chrome Fuzzer Program]: https://www.google.com/about/appsecurity/chrome-rewards/index.html#fuzzerprogram
[Codesearch]: https://cs.chromium.org/
[build existing fuzzers]: https://chromium.googlesource.com/chromium/src/+/master/testing/libfuzzer/reproducing.md#Reproducing-LibFuzzer-ASan-bugs
[existing targets]: https://cs.chromium.org/search/?q=LLVMFuzzerTestOneInput&sq=package:chromium&type=cs
[new ones]: https://cs.chromium.org/search/?q=file:.*%5C.h+%22const+uint8_t*%22&sq=package:chromium&type=cs
set(LIBFUZZER_FLAGS_BASE "${CMAKE_CXX_FLAGS}")
# Disable the coverage and sanitizer instrumentation for the fuzzer itself.
set(CMAKE_CXX_FLAGS "${LIBFUZZER_FLAGS_BASE} -fno-sanitize-coverage=trace-pc-guard,edge,trace-cmp,indirect-calls,8bit-counters -Werror")
if( LLVM_USE_SANITIZE_COVERAGE )
  if(NOT "${LLVM_USE_SANITIZER}" STREQUAL "Address")
    message(FATAL_ERROR
      "LibFuzzer and its tests require LLVM_USE_SANITIZER=Address and "
      "LLVM_USE_SANITIZE_COVERAGE=YES to be set."
      )
  endif()
  add_library(LLVMFuzzerNoMainObjects OBJECT
    FuzzerCrossOver.cpp
    FuzzerDriver.cpp
    FuzzerExtFunctionsDlsym.cpp
    FuzzerExtFunctionsDlsymWin.cpp
    FuzzerExtFunctionsWeak.cpp
    FuzzerIO.cpp
    FuzzerIOPosix.cpp
    FuzzerIOWindows.cpp
    FuzzerLoop.cpp
    FuzzerMerge.cpp
    FuzzerMutate.cpp
    FuzzerSHA1.cpp
    FuzzerShmemPosix.cpp
    FuzzerShmemWindows.cpp
    FuzzerTracePC.cpp
    FuzzerTraceState.cpp
    FuzzerUtil.cpp
    FuzzerUtilDarwin.cpp
    FuzzerUtilLinux.cpp
    FuzzerUtilPosix.cpp
    FuzzerUtilWindows.cpp
    )
  add_library(LLVMFuzzerNoMain STATIC
    $<TARGET_OBJECTS:LLVMFuzzerNoMainObjects>
    )
  target_link_libraries(LLVMFuzzerNoMain ${LLVM_PTHREAD_LIB})
  add_library(LLVMFuzzer STATIC
    FuzzerMain.cpp
    $<TARGET_OBJECTS:LLVMFuzzerNoMainObjects>
    )
  target_link_libraries(LLVMFuzzer ${LLVM_PTHREAD_LIB})

  if( LLVM_INCLUDE_TESTS )
    add_subdirectory(test)
  endif()
endif()
Move to http://llvm.org/docs/LibFuzzer.html

# Build all these tests with -O0, otherwise optimizations may merge some
# basic blocks and we'll fail to discover the targets.
# We change the flags for every build type because we might be doing
# a multi-configuration build (e.g. Xcode) where CMAKE_BUILD_TYPE doesn't
# mean anything.
set(variables_to_filter
  CMAKE_CXX_FLAGS_RELEASE
  CMAKE_CXX_FLAGS_DEBUG
  CMAKE_CXX_FLAGS_RELWITHDEBINFO
  CMAKE_CXX_FLAGS_MINSIZEREL
  LIBFUZZER_FLAGS_BASE
  )
foreach (VARNAME ${variables_to_filter})
  string(REGEX REPLACE "([-/]O)[123s]" "\\10" ${VARNAME} "${${VARNAME}}")
endforeach()

# Enable the coverage instrumentation (it is disabled for the Fuzzer lib).
set(CMAKE_CXX_FLAGS "${LIBFUZZER_FLAGS_BASE} -fsanitize-coverage=trace-pc-guard,indirect-calls,trace-cmp,trace-div,trace-gep -gline-tables-only")

if(MSVC)
  # For tests use the CRT specified for release build
  # (asan doesn't support MDd and MTd)
  if ("${LLVM_USE_CRT_RELEASE}" STREQUAL "")
    set(CRT_FLAG " /MD ")
  else()
    set(CRT_FLAG " /${LLVM_USE_CRT_RELEASE} ")
  endif()
  # In order to use the sanitizers in Windows, we need to link against many
  # runtime libraries which will depend on the target being created
  # (executable or dll) and the c runtime library used (MT/MD).
  # By default, cmake uses link.exe for linking, which fails because we don't
  # specify the appropiate dependencies.
  # As we don't want to consider all of that possible situations which depends
  # on the implementation of the compiler-rt, the simplest option is to change
  # the rules for linking executables and shared libraries, using the compiler
  # instead of link.exe. Clang will consider the sanitizer flags, and
  # automatically provide the required libraries to the linker.
  set(CMAKE_CXX_LINK_EXECUTABLE "<CMAKE_CXX_COMPILER> <FLAGS> ${CMAKE_CXX_FLAGS} ${CRT_FLAG} <OBJECTS> -o <TARGET> <LINK_LIBRARIES> /link <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS>")
  set(CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_CXX_COMPILER> ${CMAKE_CXX_FLAGS} ${CRT_FLAG} /LD <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG> <TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES> /link <LINK_FLAGS>")
endif()

add_custom_target(TestBinaries)

# add_libfuzzer_test(<name>
#   SOURCES source0.cpp [source1.cpp ...]
#   )
#
#   Declares a LibFuzzer test executable with target name LLVMFuzzer-<name>.
#
#   One or more source files to be compiled into the binary must be declared
#   after the SOURCES keyword.
function(add_libfuzzer_test name)
  set(multi_arg_options "SOURCES")
  cmake_parse_arguments(
    "add_libfuzzer_test" "" "" "${multi_arg_options}" ${ARGN})
  if ("${add_libfuzzer_test_SOURCES}" STREQUAL "")
    message(FATAL_ERROR "Source files must be specified")
  endif()
  add_executable(LLVMFuzzer-${name}
    ${add_libfuzzer_test_SOURCES}
    )
  target_link_libraries(LLVMFuzzer-${name} LLVMFuzzer)
  # Place binary where llvm-lit expects to find it
  set_target_properties(LLVMFuzzer-${name}
    PROPERTIES RUNTIME_OUTPUT_DIRECTORY
    "${CMAKE_BINARY_DIR}/lib/Fuzzer/test"
    )
  add_dependencies(TestBinaries LLVMFuzzer-${name})
endfunction()

###############################################################################
# Basic tests
###############################################################################

set(Tests
  AbsNegAndConstantTest
  AbsNegAndConstant64Test
  AccumulateAllocationsTest
  BogusInitializeTest
  BufferOverflowOnInput
  CallerCalleeTest
  CounterTest
  CustomCrossOverAndMutateTest
  CustomCrossOverTest
  CustomMutatorTest
  CxxStringEqTest
  DivTest
  EmptyTest
  EquivalenceATest
  EquivalenceBTest
  FourIndependentBranchesTest
  FullCoverageSetTest
  InitializeTest
  Memcmp64BytesTest
  MemcmpTest
  LeakTest
  LeakTimeoutTest
  LoadTest
  NullDerefTest
  NullDerefOnEmptyTest
  NthRunCrashTest
  OneHugeAllocTest
  OutOfMemoryTest
  OutOfMemorySingleLargeMallocTest
  RepeatedMemcmp
  RepeatedBytesTest
  SimpleCmpTest
  SimpleDictionaryTest
  SimpleHashTest
  SimpleTest
  SimpleThreadedTest
  SingleByteInputTest
  SingleMemcmpTest
  SingleStrcmpTest
  SingleStrncmpTest
  SpamyTest
  ShrinkControlFlowTest
  ShrinkValueProfileTest
  StrcmpTest
  StrncmpOOBTest
  StrncmpTest
  StrstrTest
  SwapCmpTest
  SwitchTest
  Switch2Test
  ThreadedLeakTest
  ThreadedTest
  TimeoutTest
  TimeoutEmptyTest
  TraceMallocTest
  TwoDifferentBugsTest
  )

if(APPLE OR MSVC)
  # LeakSanitizer is not supported on OSX and Windows right now
  set(HAS_LSAN 0)
  message(WARNING "LeakSanitizer is not supported."
    " Building and running LibFuzzer LeakSanitizer tests is disabled."
    )
else()
  set(HAS_LSAN 1)
endif()

foreach(Test ${Tests})
  add_libfuzzer_test(${Test} SOURCES ${Test}.cpp)
endforeach()

function(test_export_symbol target symbol)
  if(MSVC)
    set_target_properties(LLVMFuzzer-${target} PROPERTIES LINK_FLAGS
        "-export:${symbol}")
  endif()
endfunction()

test_export_symbol(InitializeTest "LLVMFuzzerInitialize")
test_export_symbol(BogusInitializeTest "LLVMFuzzerInitialize")
test_export_symbol(CustomCrossOverTest "LLVMFuzzerCustomCrossOver")
test_export_symbol(CustomMutatorTest "LLVMFuzzerCustomMutator")

###############################################################################
# Unit tests
###############################################################################

add_executable(LLVMFuzzer-Unittest
  FuzzerUnittest.cpp
  )

add_executable(LLVMFuzzer-StandaloneInitializeTest
  InitializeTest.cpp
  ../standalone/StandaloneFuzzTargetMain.c
  )

target_link_libraries(LLVMFuzzer-Unittest
  gtest
  gtest_main
  LLVMFuzzerNoMain
  )

target_include_directories(LLVMFuzzer-Unittest PRIVATE
  "${LLVM_MAIN_SRC_DIR}/utils/unittest/googletest/include"
  )

add_dependencies(TestBinaries LLVMFuzzer-Unittest)
set_target_properties(LLVMFuzzer-Unittest
  PROPERTIES RUNTIME_OUTPUT_DIRECTORY
  "${CMAKE_CURRENT_BINARY_DIR}"
)

add_dependencies(TestBinaries LLVMFuzzer-StandaloneInitializeTest)
set_target_properties(LLVMFuzzer-StandaloneInitializeTest
  PROPERTIES RUNTIME_OUTPUT_DIRECTORY
  "${CMAKE_CURRENT_BINARY_DIR}"
)

###############################################################################
# Additional tests
###############################################################################

include_directories(..)

# add_subdirectory(uninstrumented)
add_subdirectory(no-coverage)
add_subdirectory(ubsan)

add_library(LLVMFuzzer-DSO1 SHARED DSO1.cpp)
add_library(LLVMFuzzer-DSO2 SHARED DSO2.cpp)

add_executable(LLVMFuzzer-DSOTest
  DSOTestMain.cpp
  DSOTestExtra.cpp)

target_link_libraries(LLVMFuzzer-DSOTest
  LLVMFuzzer-DSO1
  LLVMFuzzer-DSO2
  LLVMFuzzer
  )

set_target_properties(LLVMFuzzer-DSOTest PROPERTIES RUNTIME_OUTPUT_DIRECTORY
  "${CMAKE_BINARY_DIR}/lib/Fuzzer/test")

if(MSVC)
  set_output_directory(LLVMFuzzer-DSO1
    BINARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/test"
    LIBRARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/test")
  set_output_directory(LLVMFuzzer-DSO2
    BINARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/test"
    LIBRARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/test")
else(MSVC)
  set_output_directory(LLVMFuzzer-DSO1
    LIBRARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/lib")
  set_output_directory(LLVMFuzzer-DSO2
    LIBRARY_DIR "${CMAKE_BINARY_DIR}/lib/Fuzzer/lib")
endif()

add_dependencies(TestBinaries LLVMFuzzer-DSOTest)

###############################################################################
# Configure lit to run the tests
#
# Note this is done after declaring all tests so we can inform lit if any tests
# need to be disabled.
###############################################################################
set(LIBFUZZER_POSIX 1)
if (MSVC)
  set(LIBFUZZER_POSIX 0)
endif()

configure_lit_site_cfg(
  ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in
  ${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg
  )

configure_lit_site_cfg(
  ${CMAKE_CURRENT_SOURCE_DIR}/unit/lit.site.cfg.in
  ${CMAKE_CURRENT_BINARY_DIR}/unit/lit.site.cfg
  )

add_lit_testsuite(check-fuzzer "Running Fuzzer tests"
    ${CMAKE_CURRENT_BINARY_DIR}
    DEPENDS TestBinaries
    )

# Don't add dependencies on Windows. The linker step would fail on Windows,
# since cmake will use link.exe for linking and won't include compiler-rt libs.
if(NOT MSVC)
  add_dependencies(check-fuzzer FileCheck sancov not)
endif()
# Dictionary for SimpleDictionaryTest

a="Elvis"
b="Presley"
Hi!# These tests are not instrumented with coverage,
# but have coverage rt in the binary.

set(CMAKE_CXX_FLAGS
  "${LIBFUZZER_FLAGS_BASE} -fno-sanitize-coverage=edge,trace-cmp,indirect-calls,8bit-counters,trace-pc-guard")

set(NoCoverageTests
  NotinstrumentedTest
  )

foreach(Test ${NoCoverageTests})
  add_libfuzzer_test(${Test}-NoCoverage SOURCES ../${Test}.cpp)
endforeach()


###############################################################################
# AFL Driver test
###############################################################################
if(NOT MSVC)
  add_executable(AFLDriverTest
    ../AFLDriverTest.cpp ../../afl/afl_driver.cpp)

  set_target_properties(AFLDriverTest
      PROPERTIES RUNTIME_OUTPUT_DIRECTORY
      "${CMAKE_BINARY_DIR}/lib/Fuzzer/test"
      )

  add_dependencies(TestBinaries AFLDriverTest)
endif()
# These tests are not instrumented with coverage.

set(CMAKE_CXX_FLAGS
  "${LIBFUZZER_FLAGS_BASE} -fsanitize-coverage=edge,trace-bb")

set(TraceBBTests
  SimpleTest
  )

foreach(Test ${TraceBBTests})
  add_libfuzzer_test(${Test}-TraceBB SOURCES ../${Test}.cpp)
endforeach()

# Propagate value into parent directory
set(TestBinaries ${TestBinaries} PARENT_SCOPE)
# These tests are not instrumented with coverage.

set(CMAKE_CXX_FLAGS
  "${LIBFUZZER_FLAGS_BASE} -fno-sanitize-coverage=8bit-counters -fsanitize-coverage=trace-pc-guard")

set(TracePCTests
  SimpleTest
  CounterTest
  CallerCalleeTest
  NullDerefTest
  ShrinkControlFlowTest
  ShrinkValueProfileTest
  SwitchTest
  Switch2Test
  FullCoverageSetTest
  )

foreach(Test ${TracePCTests})
  add_libfuzzer_test(${Test}-TracePC SOURCES ../${Test}.cpp)
endforeach()

# Propagate value into parent directory
set(TestBinaries ${TestBinaries} PARENT_SCOPE)

add_library(LLVMFuzzer-DSO1 SHARED ../DSO1.cpp)
add_library(LLVMFuzzer-DSO2 SHARED ../DSO2.cpp)

add_executable(LLVMFuzzer-DSOTest
  ../DSOTestMain.cpp
  ../DSOTestExtra.cpp)

target_link_libraries(LLVMFuzzer-DSOTest
  LLVMFuzzer-DSO1
  LLVMFuzzer-DSO2
  LLVMFuzzer
  )

set_target_properties(LLVMFuzzer-DSOTest PROPERTIES RUNTIME_OUTPUT_DIRECTORY
  "${CMAKE_BINARY_DIR}/lib/Fuzzer/test")
set_target_properties(LLVMFuzzer-DSO1 PROPERTIES LIBRARY_OUTPUT_DIRECTORY
  "${CMAKE_BINARY_DIR}/lib/Fuzzer/lib")
set_target_properties(LLVMFuzzer-DSO2 PROPERTIES LIBRARY_OUTPUT_DIRECTORY
  "${CMAKE_BINARY_DIR}/lib/Fuzzer/lib")

set(TestBinaries ${TestBinaries} LLVMFuzzer-DSOTest PARENT_SCOPE)
# These tests are instrumented with ubsan in non-recovery mode.

set(CMAKE_CXX_FLAGS
  "${LIBFUZZER_FLAGS_BASE} -fsanitize=undefined -fno-sanitize-recover=all")

set(UbsanTests
  SignedIntOverflowTest
  )

foreach(Test ${UbsanTests})
  add_libfuzzer_test(${Test}-Ubsan SOURCES ../${Test}.cpp)
endforeach()
# These tests are not instrumented with coverage and don't
# have coverage rt in the binary.

set(CMAKE_CXX_FLAGS
  "${LIBFUZZER_FLAGS_BASE} -fno-sanitize=all -fno-sanitize-coverage=edge,trace-cmp,indirect-calls,8bit-counters,trace-pc-guard")

set(UninstrumentedTests
  UninstrumentedTest
  )

foreach(Test ${UninstrumentedTests})
  add_libfuzzer_test(${Test}-Uninstrumented SOURCES ../${Test}.cpp)
endforeach()
//===- FuzzerCrossOver.cpp - Cross over two test inputs -------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Cross over test inputs.
//===----------------------------------------------------------------------===//
// Cross Data1 and Data2, store the result (up to MaxOutSize bytes) in Out.
// Merge a part of Data into Out.
// Use the other input data on the next iteration.
// namespace fuzzer
//===- FuzzerDriver.cpp - FuzzerDriver function and flags -----------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// FuzzerDriver and flag parsing.
//===----------------------------------------------------------------------===//
// This function should be present in the libFuzzer so that the client
// binary can test for its existence.
// Program arguments.
// Avoid calling stol as it triggers a bug in clang/glibc build.
// Deprecated flag.
// We don't use any library to minimize dependencies.
// BaseCmd += " >  /dev/null 2>&1 ";
// Scores and usage count for each dictionary unit.
// Get coverage for the testcase without modifications.
// Skip dictionary unit, if the testcase does not contain it.
// Replace all occurrences of dictionary unit in the testcase.
// Get coverage for testcase with masked occurrences of dictionary unit.
// Dictionary units with positive score are treated as useful ones.
// Initialize Seed.
/*ExitOnError=*/false);
// Valid ASCII input.
// Don't need this memory any more.
// Don't let F destroy itself.
// Storage for global ExternalFunctions object.
// namespace fuzzer
//===- FuzzerExtFunctionsDlsym.cpp - Interface to external functions ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Implementation for operating systems that support dlsym(). We only use it on
// Apple platforms for now. We don't use this approach on Linux because it
// requires that clients of LibFuzzer pass ``--export-dynamic`` to the linker.
// That is a complication we don't wish to expose to clients right now.
//===----------------------------------------------------------------------===//
// Clear any previous errors.
// namespace fuzzer
// LIBFUZZER_APPLE
//===- FuzzerExtFunctionsDlsymWin.cpp - Interface to external functions ---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Implementation using dynamic loading for Windows.
//===----------------------------------------------------------------------===//
// namespace fuzzer
// LIBFUZZER_WINDOWS
//===- FuzzerExtFunctionsWeak.cpp - Interface to external functions -------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Implementation for Linux. This relies on the linker's support for weak
// symbols. We don't use this approach on Apple platforms because it requires
// clients of LibFuzzer to pass ``-U _<symbol_name>`` to the linker to allow
// weak symbols to be undefined. That is a complication we don't want to expose
// to clients right now.
//===----------------------------------------------------------------------===//
// Declare these symbols as weak to allow them to be optionally defined.
// namespace fuzzer
// LIBFUZZER_LINUX
//===- FuzzerExtFunctionsWeakAlias.cpp - Interface to external functions --===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Implementation using weak aliases. Works for Windows.
//===----------------------------------------------------------------------===//
// Declare these symbols as weak to allow them to be optionally defined.
// namespace fuzzer
// LIBFUZZER_WINDOWS
//===- FuzzerIO.cpp - IO utils. -------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// IO functions.
//===----------------------------------------------------------------------===//
// Can't stat, be conservative.
// Use raw C interface because this function may be called from a sig handler.
/*TopDir*/true);
// namespace fuzzer
//===- FuzzerIOPosix.cpp - IO utils for Posix. ----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// IO functions implementation using Posix API.
//===----------------------------------------------------------------------===//
// sanitizer internal.
// namespace fuzzer
// LIBFUZZER_POSIX
//===- FuzzerIOWindows.cpp - IO utils for Windows. ------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// IO functions implementation for Windows.
//===----------------------------------------------------------------------===//
// Get the first directory entry.
// Parse disk designators, like "C:\". If Relative == true, also accepts: "C:".
// Returns number of characters considered if successful.
// Accept relative path?
// Parse a file name, like: SomeFile.txt
// Returns number of characters considered if successful.
// Parse a directory ending in separator, like: SomeDir\
// Returns number of characters considered if successful.
// Include separator.
// Parse a servername and share, like: SomeServer\SomeShare\
// Returns number of characters considered if successful.
// Parse the given Ref string from the position Offset, to exactly match the given
// string Patt.
// Returns number of characters considered if successful.
// Parse a location, like:
// \\?\UNC\Server\Share\  \\?\C:\  \\Server\Share\  \  C:\  C:
// Returns number of characters considered if successful.
// Remove trailing separator.
// Path ended in separator.
// Remove file name from Dir.
// Remove trailing separator.
// Relative path.
// sanitizer internal.
// Not tested, may or may not work. Fix if needed.
// namespace fuzzer
// LIBFUZZER_WINDOWS
//===- FuzzerLoop.cpp - Fuzzer's main loop --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Fuzzer's main loop.
//===----------------------------------------------------------------------===//
// Only one Fuzzer per process.
// Leak detection is expensive, so we first check if there were more mallocs
// than frees (using the sanitizer malloc hooks) and only then try to call lsan.
// Returns true if there were more mallocs than frees.
// Crash on a single malloc that exceeds the rss limit.
// Stop right now.
// Happens when running individual inputs.
// Stop right now, don't perform any at-exit actions.
// In Windows Alarm callback is executed by a different thread.
// We have not started running units yet.
// Stop right now.
// Stop right now.
// Can only reset MaxInputLen from 0 to non-0.
/*ExitOnError*/ false);
// Test the callback with empty input and never try it again.
/*DuringInitialCorpusExecution*/ true);
// We copy the contents of Unit into a separate heap buffer
// so that we reliably find buffer overflows in it.
// Overrides ArtifactPrefix.
// Tries detecting a memory leak on the particular input that we have just
// executed before calling this function.
// mallocs==frees, a leak is unlikely.
// No lsan.
// Run the target once again, but with lsan disabled so that if there is
// a real leak we do not report it twice.
// a leak is unlikely.
// Now perform the actual lsan pass. This is expensive and we must ensure
// we don't call it too often.
// Leak is found, report it.
// not exit() to disable lsan further on.
/*MayDeleteFile=*/true);
/*DuringInitialCorpusExecution*/ false);
// Perform several mutations and runs.
/*DuringInitialCorpusExecution*/ false);
// namespace fuzzer
// Experimental
// extern "C"
//===- FuzzerMain.cpp - main() function and flags -------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// main() and flags.
//===----------------------------------------------------------------------===//
// This function should be defined by the user.
// extern "C"
//===- FuzzerMerge.cpp - merging corpora ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Merging corpora.
//===----------------------------------------------------------------------===//
// The control file example:
//
// 3 # The number of inputs
// 1 # The number of inputs in the first corpus, <= the previous number
// file0
// file1
// file2  # One file name per line.
// STARTED 0 123  # FileID, file size
// DONE 0 1 4 6 8  # FileID COV1 COV2 ...
// STARTED 1 456  # If DONE is missing, the input crashed while processing.
// STARTED 2 567
// DONE 2 8 9
// Parse NumFiles.
// Parse NumFilesInFirstCorpus.
// Parse file names.
// Parse STARTED and DONE lines.
// STARTED FILE_ID FILE_SIZE
// DONE FILE_ID COV1 COV2 COV3 ...
// use a vector from outer scope to avoid resizes.
// Decides which files need to be merged (add thost to NewFiles).
// Returns the number of new features added.
// What features are in the initial corpus?
// Remove all features that we already know from all other inputs.
// Sort. Give preference to
//   * smaller files
//   * files with more features.
// One greedy pass: add the file's features to AllFeatures.
// If new features were added, add this file to NewFiles.
// Printf("%s -> sz %zd ft %zd\n", Files[i].Name.c_str(),
//       Files[i].Size, Cur.size());
// Inner process. May crash if the target crashes.
// Write the pre-run marker.
// Flush is important since ExecuteCommand may crash.
// Run.
// Collect coverage.
// Show stats.
// Write the post-run marker and the coverage.
// Outer process. Does not call the target code and thus sohuld not fail.
/*TopDir*/true);
/*TopDir*/true);
// Write the control file.
// Execute the inner process untill it passes.
// Every inner process should execute at least one input.
// Read the control file and do the merge.
// We are done, delete the control file.
// namespace fuzzer
//===- FuzzerMutate.cpp - Mutate a test input -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Mutate a test input.
//===----------------------------------------------------------------------===//
// [1,8] and <= Size.
// Erase Data[Idx:Idx+N].
// Printf("Erase: %zd %zd => %zd; Idx %zd\n", N, Size, Size - N, Idx);
// Insert new value at Data[Idx].
// Insert new values at Data[Idx].
// Give preference to 0x00 and 0xff.
// Insert W.
// Overwrite some bytes with W.
// Somewhere in the past we have observed a comparison instructions
// with arguments Arg1 Arg2. This function tries to guess a dictionary
// entry that will satisfy that comparison.
// It first tries to find one of the arguments (possibly swapped) in the
// input and if it succeeds it creates a DE with a position hint.
// Otherwise it creates a DE with one of the arguments w/o a position hint.
// Overwrites part of To[0,ToSize) with a part of From[0,FromSize).
// Returns ToSize.
// Copy From[FromBeg, FromBeg + CopySize) into To[ToBeg, ToBeg + CopySize).
// Inserts part of From[0,ToSize) into To.
// Returns new size of To on success or 0 on failure.
// now we have digits in [B, E).
// strtol and friends don't accept non-zero-teminated data, parse it manually.
// Mutate the integer value.
// Just replace the bytes with the new ones, don't bother moving bytes.
// Add assuming different endiannes.
// Add assuming current endiannes.
// Maybe negate.
// Copy successful dictionary entries to PersistentAutoDictionary.
// PersistentAutoDictionary.AddWithSuccessCountOne(DE);
// Linear search is fine here as this happens seldom.
// Mutates Data in place, returns new size.
// Some mutations may fail (e.g. can't insert more bytes if Size == MaxSize),
// in which case they will return 0.
// Try several times before returning un-mutated data.
// Fallback, should not happen frequently.
// namespace fuzzer
//===- FuzzerSHA1.h - Private copy of the SHA1 implementation ---*- C++ -* ===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// This code is taken from public domain
// (http://oauth.googlecode.com/svn/code/c/liboauth/src/sha1.c)
// and modified by adding anonymous namespace, adding an interface
// function fuzzer::ComputeSHA1() and removing unnecessary code.
//
// lib/Fuzzer can not use SHA1 implementation from openssl because
// openssl may not be available and because we may be fuzzing openssl itself.
// For the same reason we do not want to depend on SHA1 from LLVM tree.
//===----------------------------------------------------------------------===//
/* This code is public-domain - it is based on libcrypt
// Added for LibFuzzer
/* override */
// ! defined __LITTLE_ENDIAN__
// machine/endian.h
/* header */
/* public API - prototypes - TODO: doxygen*/
/**
/**
/**
/**
/* code */
// Implement SHA-1 padding (fips180-2 §5.1.1)
// Pad with 0x80 followed by 0x00 until the end of the block
// Append length in the last 8 bytes
// We're only using 32 bit lengths
// But SHA-1 supports 64 bit lengths
// So zero pad the top bits
// Shifting to multiply by 8
// as SHA-1 supports bitstreams as well as
// byte.
// Pad to complete the last block
// Swap byte order back
// Return pointer to hash (20 characters)
// namespace; Added for LibFuzzer
// The rest is added for LibFuzzer
//===- FuzzerShmemPosix.cpp - Posix shared memory ---------------*- C++ -* ===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// SharedMemoryRegion
//===----------------------------------------------------------------------===//
// sem_wait may fail if interrupted by a signal.
// namespace fuzzer
// LIBFUZZER_POSIX
//===- FuzzerShmemWindows.cpp - Posix shared memory -------------*- C++ -* ===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// SharedMemoryRegion
//===----------------------------------------------------------------------===//
// namespace fuzzer
// LIBFUZZER_WINDOWS
//===- FuzzerTracePC.cpp - PC tracing--------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Trace PCs.
// This module implements __sanitizer_cov_trace_pc_guard[_init],
// the callback required for -fsanitize-coverage=trace-pc-guard instrumentation.
//
//===----------------------------------------------------------------------===//
// The coverage counters and PCs.
// These are declared as global variables named "__sancov_*" to simplify
// experiments with inlined instrumentation.
// What's PATH_MAX in portable C++?
// Func+File => lines
// sancov does not yet fully support DSOs.
// std::string Cmd = "sancov -print-coverage-pcs " + ModuleName;
// TODO: this implementation is x86 only.
// see sanitizer_common GetPreviousInstructionPc for full implementation.
// Value profile.
// We keep track of various values that affect control flow.
// These values are inserted into a bit-set-based hash map.
// Every new bit in the map is treated as a new coverage.
//
// For memcmp/strcmp/etc the interesting value is the length of the common
// prefix of the parameters.
// For cmp instructions the interesting value is a XOR of the parameters.
// The interesting value is mixed up with the PC and is then added to the map.
// Copy the data into locals in this non-msan-instrumented function
// to avoid msan complaining further.
// Compute some simple hash of both strings.
// [1,65]
// namespace fuzzer
// Skip the most common and the most boring case.
// extern "C"
//===- FuzzerTraceState.cpp - Trace-based fuzzer mutator ------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Data tracing.
//===----------------------------------------------------------------------===//
// Declared as static globals for faster checks inside the hooks.
// TODO: std::set is too inefficient, need to have a custom DS here.
// namespace fuzzer
// We may need to avoid defining weak hooks to stay compatible with older clang.
// No reason to mutate.
// Not interesting.
/*StopAtZero*/false);
// No reason to mutate.
// Not interesting.
/*StopAtZero*/true);
// No reason to mutate.
// Not interesting.
/*StopAtZero*/true);
// LLVM_FUZZER_DEFINES_SANITIZER_WEAK_HOOOKS
// extern "C"
//===- FuzzerUtil.cpp - Misc utils ----------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Misc utils.
//===----------------------------------------------------------------------===//
// We are parsing the range [L,R].
// Skip spaces from both sides.
// Check the closing "
// Find the opening "
// Handle '\\'
// Handle '\xAB'
// Invalid escape.
// Any other character.
// Skip spaces.
// Empty line.
// Comment line.
// Just in case.
// namespace fuzzer
//===- FuzzerUtilDarwin.cpp - Misc utils ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Misc utils for Darwin.
//===----------------------------------------------------------------------===//
// There is no header for this on macOS so declare here
// Global variables used to keep track of how signal handling should be
// restored. They should **not** be accessed without holding `SignalMutex`.
// This is a reimplementation of Libc's `system()`. On Darwin the Libc
// implementation contains a mutex which prevents it from being used
// concurrently. This implementation **can** be used concurrently. It sets the
// signal handlers when the first thread enters and restores them when the last
// thread finishes execution of the function and ensures this is not racey by
// using a mutex.
// Block and ignore signals of the current process when the first thread
// enters.
// Try our best to restore the signal handlers.
// Try our best to restore the signal handlers.
// NOTE: Do not introduce any new `return` statements past this
// point. It is important that `ActiveThreadCount` always be decremented
// when leaving this function.
// Make sure the child process uses the default handlers for the
// following signals rather than inheriting what the parent has.
// Make sure the child process doesn't block SIGCHLD
// Read from global
// FIXME: We probably shouldn't hardcode the shell path.
// Repeat until call completes uninterrupted.
/*options=*/0);
// Fail for some other reason.
// Fork failure.
// Shell execution failure.
// Restore the signal handlers of the current process when the last thread
// using this function finishes.
// namespace fuzzer
// LIBFUZZER_APPLE
//===- FuzzerUtilLinux.cpp - Misc utils for Linux. ------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Misc utils for Linux.
//===----------------------------------------------------------------------===//
// namespace fuzzer
// LIBFUZZER_LINUX
//===- FuzzerUtilPosix.cpp - Misc utils for Posix. ------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Misc utils implementation using Posix API.
//===----------------------------------------------------------------------===//
// Use C API to avoid coverage from instrumented libc++.
// ru_maxrss is in KiB
// ru_maxrss is in bytes
// namespace fuzzer
// LIBFUZZER_POSIX
//===- FuzzerUtilWindows.cpp - Misc utils for Windows. --------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Misc utils implementation for Windows.
//===----------------------------------------------------------------------===//
// TODO: handle (Options.HandleXfsz)
// TODO: make this implementation more efficient.
// namespace fuzzer
// LIBFUZZER_WINDOWS
//===- afl_driver.cpp - a glue between AFL and libFuzzer --------*- C++ -* ===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//===----------------------------------------------------------------------===//
/* This file allows to fuzz libFuzzer-style target functions
// Platform detection. Copied from FuzzerInternal.h
// Used to avoid repeating error checking boilerplate. If cond is false, a
// fatal error has occured in the program. In this event print error_message
// to stderr and abort(). Otherwise do nothing. Note that setting
// AFL_DRIVER_STDERR_DUPLICATE_FILENAME may cause error_message to be appended
// to the file as well, if the error occurs after the duplication is performed.
// libFuzzer interface is thin, so we don't include any libFuzzer headers.
// Notify AFL about persistent mode.
// Notify AFL about deferred forkserver.
// Input buffer.
// Variables we need for writing to the extra stats file.
// Copied from FuzzerUtil.cpp.
// ru_maxrss is in KiB
// ru_maxrss is in bytes
// Based on SetSigaction in FuzzerUtil.cpp
// Write extra stats to the file specified by the user. If none is specified
// this function will never be called.
// Call write_extra_stats before we exit.
// Make sure we don't try calling write_extra_stats again if we crashed while
// trying to call it.
// If the user has specified an extra_stats_file through the environment
// variable AFL_DRIVER_EXTRA_STATS_FILENAME, then perform necessary set up
// to write stats to it on exit. If no file is specified, do nothing. Otherwise
// install signal and exit handlers to write to the file when the process exits.
// Then if the file doesn't exist create it and set extra stats to 0. But if it
// does exist then read the initial values of the extra stats from the file
// and check that the file is writable.
// If AFL_DRIVER_EXTRA_STATS_FILENAME isn't set then we have nothing to do.
// Open the file and find the previous peak_rss_mb value.
// This is necessary because the fuzzing process is restarted after N
// iterations are completed. So we may need to get this value from a previous
// process to be accurate.
// If extra_stats_file already exists: read old stats from it.
// Make sure we have read a real extra stats file and that we have used it
// to set slowest_unit_time_secs and previous_peak_rss.
// Now open the file for writing.
// Looks like this is the first time in a fuzzing job this is being called.
// Make sure that crash_handler gets called on any kind of fatal error.
// Make sure it gets called on other kinds of exits.
// If the user asks us to duplicate stderr, then do it.
// Define LLVMFuzzerMutate to avoid link failures for targets that use it
// with libFuzzer's LLVMFuzzerCustomMutator.
// Do any other expensive one-time initialization here.
// Copy AflInputBuf into a separate buffer to let asan find buffer
// overflows. Don't use unique_ptr/etc to avoid extra dependencies.
// Update slowest_unit_time_secs if we see a new max.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// abs(x) < 0 and y == Const puzzle, 64-bit variant.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// abs(x) < 0 and y == Const puzzle.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test with a more mallocs than frees, but no leak.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Contains dummy functions used to avoid dependency on AFL.
// This declaration exists to prevent the Darwin linker
// from complaining about this being a missing weak symbol.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Make sure LLVMFuzzerInitialize does not change argv[0].
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "Hi!".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer.
// Try to find the target using the indirect caller-callee pairs.
// Spoof the counters.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test for a fuzzer: must find the case where a particular basic block is
// executed many times.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test that libFuzzer does not crash when LLVMFuzzerMutate called from
// LLVMFuzzerCustomCrossOver.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a cutom mutator.
// Ensure that two different elements exist in the corpus.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a cutom mutator.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. Must find a specific string
// used in std::string operator ==.
// Try to confuse the fuzzer
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer: find the interesting argument for div.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Source code for a simple DSO.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Source code for a simple DSO.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Source code for a simple DSO.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Source code for a simple DSO.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
// A fuzzer with empty target function.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test for libFuzzer's "equivalence" fuzzing, part A.
// fprintf(stderr, "A %zd\n", Size);
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test for libFuzzer's "equivalence" fuzzing, part B.
// fprintf(stderr, "B %zd\n", Size);
// Be a bit different from EquivalenceATest
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "FUZZ".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "FUZZER".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// namespace impl
// namespace fuzzer
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Avoid ODR violations (LibFuzzer is built without ASan and this test is built
// with ASan) involving C++ standard library types when using libcxx.
// For now, have LLVMFuzzerTestOneInput just to make it link.
// Later we may want to make unittests that actually call LLVMFuzzerTestOneInput.
/**/ if (NewSize == 8 && !memcmp(CH0, T, 8)) FoundMask |= 1 << 0;
// Size
// Sw(Size)
/**/ if (NewSize == 8 && !memcmp(CH0, T, 8)) FoundMask |= 1 << 0;
// A weak sanity check that every unit gets invoked.
// fprintf(stderr, "TESTING:\n%s\n", S);
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Make sure LLVMFuzzerInitialize is called.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// A fuzz target with lots of edges.
// for (int i = 0, n = Data[(__LINE__ - 1) % Size] % 16; i < n; i++)
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test with a leak.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test with a leak.
// Infinite loop.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer: find interesting value of array index.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// TODO: check other sizes.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// This test should not be instrumented.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Crash on the N-th execution.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the empty string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "Hi!".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Tests OOM handling when there is a single large allocation.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Tests OOM handling.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Tests OOM handling.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find repeated bytes.
// Looking for AAAAAAAAAAAAAAAAAAAAAA or some such.
// Make sure there are no conditionals in the loop so that
// coverage can't help the fuzzer.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test that we can find the minimal item in the corpus (3 bytes: "FUZ").
//fprintf(stderr, "IDS: %d %d %d\n", F, U, Z);
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test that we can find the minimal item in the corpus (3 bytes: "FUZ").
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test for signed-integer-overflow.
// int overflow.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find several narrow ranges.
// 8
// 16
// 20
// 22
// Must be the last line.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer.
// The fuzzer must find a string based on dictionary words:
//   "Elvis"
//   "Presley"
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer Fn adapter. The fuzzer has to find two non-empty
// vectors with the same content.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// This test computes a checksum of the data (all but the last 4 bytes),
// and then compares the last 4 bytes with the computed value.
// A fuzzer with cmp traces is expected to defeat this check.
// A modified jenkins_one_at_a_time_hash initialized by non-zero,
// so that simple_hash(0) != 0. See also
// https://en.wikipedia.org/wiki/Jenkins_hash_function
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "Hi!".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Threaded test for a fuzzer. The fuzzer should find "H"
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer, need just one byte to crash.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// The test spams to stderr and stdout.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Break through a series of strcmp.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test that libFuzzer itself does not read out of bounds.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find a particular string.
// TODO: check other sizes.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Test strstr and strcasestr hooks.
// Windows does not have strcasestr and memmem, so we are not testing them.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// The fuzzer must find several constants with swapped bytes.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the interesting switch value.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the interesting switch value.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// The fuzzer should find a leak in a non-main thread.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Threaded test for a fuzzer. The fuzzer should not crash.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the empty string.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. The fuzzer must find the string "Hi!".
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Tests -trace_malloc
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// Simple test for a fuzzer. This test may trigger two different bugs.
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// This test should not be instrumented.
#!/usr/bin/env python2
# Create work `directory` and `corpus` subdirectory.
#!/usr/bin/env python2
#!/usr/bin/env python3
#===- symcov-report-server.py - Coverage Reports HTTP Serve --*- python -*--===#
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
#===------------------------------------------------------------------------===#
//
/*===- StandaloneFuzzTargetMain.c - standalone main() for fuzz targets. ---===//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// This main() function can be linked to a fuzz target (i.e. a library
// that exports LLVMFuzzerTestOneInput() and possibly LLVMFuzzerInitialize())
// instead of libFuzzer. This main() function will not perform any fuzzing
// but will simply feed all input files one by one to the fuzz target.
//
// Use this file to provide reproducers for bugs when linking against libFuzzer
// or other fuzzing engine is undesirable.
//===----------------------------------------------------------------------===*/
