________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\cmake\stack_direction.c
/* Copyright (C) 2009 Sun Microsystems, Inc
/* Check stack direction (0-down, 1-up) */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\contrib\ScriptsConverter\ScriptConverter\Program.cs
//pos++;
// File.Copy(filePath, filePath + ".bkp");
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\contrib\ScriptsConverter\ScriptConverter\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\acelite\ace\Atomic_Op_Sparc.c
/*
/* __sparcv9 */
/* Make compilers stop complaining about an empty translation unit */
/* ACE_INCLUDE_ATOMIC_OP_SPARC */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\acelite\ace\Rtems_init.c
/*
/* #define RTEMS_USE_BOOTP */
/*
/*
/* name */
/* attach function */
/* link to next interface */
/* IP address */
/* IP net mask */
/*
/* name */
/* attach function */
/* link to next interface */
/* No more interfaces */
/* BOOTP supplies IP address */
/* BOOTP supplies IP net mask */
/* IP address */
/* IP net mask */
/* !RTEMS_USE_BOOTP */
/* Ethernet hardware address */
/* Driver supplies hardware address */
/* Use default driver parameters */
/*
/* Default network task priority */
/* Default mbuf capacity */
/* Default mbuf cluster capacity */
/* Host name */
/* Domain name */
/* Gateway */
/* Log host */
/* Name server(s) */
/* NTP server(s) */
/*
/* Host name */
/* Domain name */
/* Gateway */
/* Log host */
/* Name server(s) */
/* NTP server(s) */
/* !RTEMS_USE_BOOTP */
/*
/* _RTEMS_NETWORKCONFIG_H_ */
/* ACE_LACKS_NETWORKING */
/*
/* ACE_LACKS_NETWORKING */
/* Make compilers stop complaining about an empty translation unit */
/* ACE_HAS_RTEMS */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\blocksort.c
/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* Random partitioning.  Median of 3 sometimes fails to
/*---------------------------------------------*/
/* Pre:
/*--
/*--
/*-- set sentinel bits for block-end detection --*/
/*-- the log(N) loop --*/
/*-- find the next non-singleton bucket --*/
/*-- now [l, r] bracket current bucket --*/
/*-- scan bucket and generate header bits-- */
/*-- 
/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/*---------------------------------------------*/
/*--
/*-- copy 1 --*/
/*-- copy 2 --*/
/*-- copy 3 --*/
/*---------------------------------------------*/
/*--
/*---------------------------------------------*/
/* Pre:
/*-- set up the 2-byte frequency table --*/
/*-- (emphasises close relationship of block & quadrant) --*/
/*-- Complete the initial radix sort --*/
/*--
/*--
/*--
/*--
/*--
/* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.
/*--
/*---------------------------------------------*/
/* Pre:
/* Calculate the location for quadrant, remembering to get
/* (wfact-1) / 3 puts the default-factor-30
/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\bzlib.c
/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-- fast track the common case --*/           \
/*-- general, uncommon cases --*/              \
/*---------------------------------------------------*/
/*-- fast track the common case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- general, uncommon case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- flush/finish end? --*/
/*---------------------------------------------------*/
/*-- no output space? --*/
/*-- block done? --*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--not reached--*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* restore */
/* end restore */
/* try to finish existing run */
/* Only caused by corrupt data stream? */
/* can a new run be started? */
/* save */
/* end save */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/*---------------------------------------------------*/
/*NOTREACHED*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- File I/O stuff                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*not reached*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/* no use when bzdopen */
/* no use when bzdopen */
/* bzopen: 0, bzdopen:1 */
/* binary mode */
/* Guard against total chaos and anarchy -- JRS */
/*---------------------------------------------------*/
/*--
/*bzopen*/0);
/*---------------------------------------------------*/
/*bzdopen*/1);
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* do nothing now... */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\compress.c
/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* 
/*---------------------------------------------------*/
/*--
/*--- Decide how many coding tables to use ---*/
/*--- Generate an initial set of coding tables ---*/
/*--- 
/*---
/*--- Set group start & end marks. --*/
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*-- 
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*--
/* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See 
/*20*/ );
/*--- Compute MTF values for the selectors. ---*/
/*--- Assign actual codes for the tables. --*/
/*20*/ ), 3004 );
/*--- Transmit the mapping table. ---*/
/*--- Now the selectors. ---*/
/*--- Now the coding tables. ---*/
/* 10 */ };
/* 11 */ };
/*--- And finally, the block data proper ---*/
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*---------------------------------------------------*/
/*-- If this is the first block, create the stream header. --*/
/*-- Now the block's CRC, so it is in a known place. --*/
/*-- 
/*-- If this is the last block, add the stream trailer. --*/
/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\crctable.c
/*-------------------------------------------------------------*/
/*--- Table for doing CRCs                                  ---*/
/*---                                            crctable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*--
/*-- Ugly, innit? --*/
/*-------------------------------------------------------------*/
/*--- end                                        crctable.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\decompress.c
/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* the longest code */)         \
/*---------------------------------------------------*/
/* stuff that needs to be saved/restored */
/*initialise the save area*/
/*restore from the save area*/
/*--- Receive the mapping table ---*/
/*--- Now the selectors ---*/
/*--- Undo the MTF values for the selectors. ---*/
/*--- Now the coding tables ---*/
/*--- Create the Huffman decoding tables ---*/
/*--- Now the MTF values ---*/
/*-- MTF init --*/
/*-- end MTF init --*/
/* Check that N doesn't get too big, so that es doesn't
/*-- uc = MTF ( nextSym-1 ) --*/
/* avoid general-case expense */
/* general case */
/*-- end uc = MTF ( nextSym-1 ) --*/
/* Now we know what nblock is, we can do a better sanity
/*-- Set up cftab to facilitate generation of T^(-1) --*/
/* Check: unzftab entries in range. */
/* Actually generate cftab. */
/* Check: cftab entries in range. */
/* s->cftab[i] can legitimately be == nblock */
/* Check: cftab entries non-descending. */
/*-- Make a copy of cftab, used in generation of T --*/
/*-- compute the T vector --*/
/*-- Compute T^(-1) by pointer reversal on T --*/
/*-- compute the T^(-1) vector --*/
/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\huffman.c
/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* 17 Oct 04: keep-going condition for the following loop used
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\bzip2\randtable.c
/*-------------------------------------------------------------*/
/*--- Table for randomising repetitive blocks               ---*/
/*---                                           randtable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                       randtable.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\arena.c
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Generate red-black tree functions. */
/*
/* Generate red-black tree functions. */
/*
/*
/*
/* Generate red-black tree functions. */
/*
/*
/* Freeing an interior pointer can cause assertion failure. */
/* Freeing an unallocated pointer can cause assertion failure. */
/*
/* Keep track of trailing unused pages for later use. */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* Insert the run into the runs_avail tree. */
/*
/* Search the arena's chunks for the lowest best fit. */
/*
/*
/* Don't purge if the option is disabled. */
/* Don't purge if all dirty pages are already being purged. */
/*
/*
/*
/*
/* Append to list for later processing. */
/* Skip run. */
/*
/* Deallocate runs. */
/*
/* Get next chunk with dirty pages. */
/*
/*
/*
/*
/*
/* Mark pages as unallocated in the chunk map. */
/* Try to coalesce forward. */
/*
/* Try to coalesce backward. */
/*
/* Insert into runs_avail, now that coalescing is complete. */
/* Deallocate chunk if it is now completely unused. */
/*
/*
/*
/* Look for a usable run. */
/* No existing runs have any space available. */
/* Allocate a new run. */
/******************************/
/* Initialize run internals. */
/********************************/
/*
/* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
/*
/*
/* Insert such that low regions get used first. */
/* Large allocation. */
/* Only handles large allocations that require more than page alignment. */
/* Dissociate run from bin. */
/*
/******************************/
/*
/* Trim clean pages.  Convert to large run beforehand. */
/* npages = past - run_ind; */
/****************************/
/*
/* Switch runcur. */
/* arena_ptr_small_binind_get() does extra sanity checking. */
/*
/* Try to extend the run. */
/*
/*
/*
/* Same size class. */
/* Fill before shrinking in order avoid a race. */
/*
/* Reallocation would require a move. */
/* Try to avoid moving the allocation. */
/*
/* Try again, this time without extra. */
/* Junk/zero-filling were already done by ipalloc()/arena_malloc(). */
/*
/* Initialize chunks. */
/* Initialize bins. */
/*
/*
/*
/* Counter-act try_nregs-- in loop. */
/* Counter-act try_nregs-- in loop. */
/* Pad to a long boundary. */
/* Add space for bitmap. */
/* Pad to a quantum boundary. */
/* Add space for one (prof_ctx_t *) per region. */
/* run_size expansion loop. */
/*
/* Try more aggressive settings. */
/* Counter-act try_nregs-- in loop. */
/* Counter-act try_nregs-- in loop. */
/* Pad to a long boundary. */
/* Add space for bitmap. */
/* Pad to a quantum boundary. */
/*
/* Copy final settings. */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\atomic.c
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\base.c
/******************************************************************************/
/* Data. */
/*
/* Addr immediately past base_pages. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Round size up to nearest multiple of the cacheline size. */
/* Make sure there's enough space for the allocation. */
/* Allocate. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\bitmap.c
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\chunk.c
/******************************************************************************/
/* Data. */
/*
/* Various chunk-related settings. */
/* (chunksize - 1). */
/* Max size class for arenas. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Beware size_t wrap-around. */
/* Remove node from the tree. */
/* Insert the leading space as a smaller chunk. */
/* Insert the trailing space as a smaller chunk. */
/*
/*
/* "primary" dss. */
/* mmap. */
/* "secondary" dss. */
/* All strategies for allocation failed. */
/*
/* Try to coalesce forward. */
/*
/* Coalescing forward failed, so insert a new node. */
/*
/* Try to coalesce backward. */
/*
/* Set variables according to the value of opt_lg_chunk. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\chunk_dss.c
/******************************************************************************/
/* Data. */
/* Current dss precedence default, used when creating new arenas. */
/*
/* Base address of the DSS. */
/* Current end of the DSS, or ((void *)-1) if the DSS is exhausted. */
/* Current upper limit on DSS addresses. */
/******************************************************************************/
/*
/*
/* Get the current end of the DSS. */
/*
/*
/* Wrap-around. */
/* Success. */
/******************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\chunk_mmap.c
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/*
/* Beware size_t wrap-around. */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\ckh.c
/*
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/* Search primary bucket. */
/* Search secondary bucket. */
/*
/*
/*
/* Swap cell->{key,data} and {key,data} (evict). */
/* Find the alternate bucket for the evicted item. */
/*
/* Check for a cycle. */
/* Try to insert in primary bucket. */
/* Try to insert in secondary bucket. */
/*
/*
/*
/* Swap in new table. */
/* Rebuilding failed, so back out partially rebuilt table. */
/*
/*
/* Swap in new table. */
/* Rebuilding failed, so back out partially rebuilt table. */
/* Value doesn't really matter. */
/*
/* Do nothing. */
/* Not necessary. */
/* Try to halve the table if it is less than 1/4 full. */
/* Ignore error due to OOM. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\ctl.c
/******************************************************************************/
/* Data. */
/*
/******************************************************************************/
/* Helpers for named and indexed nodes. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* mallctl tree. */
/* Maximum tree depth. */
/*
/******************************************************************************/
/* Merge into sum stats as well. */
/* Merge into sum stats as well. */
/* Extend arena stats and arenas arrays. */
/* ctl_stats.arenas and arenas came from base_alloc(). */
/* Initialize the new astats and arenas elements. */
/* Swap merged stats to their new location. */
/*
/*
/*
/* Equivalent to strchrnul(). */
/* Children are named. */
/* Children are indexed. */
/* Terminal node. */
/*
/* Complete lookup successful. */
/* Update elm. */
/* No more elements. */
/* The name refers to a partial path through the ctl tree. */
/* Iterate down the tree. */
/* Children are named. */
/* Indexed element. */
/* Call the ctl function. */
/* Partial MIB. */
/******************************************************************************/
/* *_ctl() functions. */
/*
/*
/* New arena index is out of range. */
/* Initialize arena if necessary. */
/* Set new arena association. */
/******************************************************************************/
/******************************************************************************/
/* Mutable. */
/******************************************************************************/
/* ctl_mutex must be held during execution of this function. */
/******************************************************************************/
/******************************************************************************/
/* Protect opt_prof_active. */
/*
/******************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\extent.c
/******************************************************************************/
/* Generate red-black tree functions. */
/* Generate red-black tree functions. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\hash.c
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\huge.c
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Tree of chunks that are stand-alone huge allocations. */
/* Allocate one or more contiguous chunks for this request. */
/* size is large enough to cause size_t wrap-around. */
/* Allocate an extent node with which to track the chunk. */
/*
/* Insert node into huge. */
/*
/* Reallocation would require a move. */
/* Try to avoid moving the allocation. */
/*
/* Try again, this time without extra. */
/*
/*
/*
/*
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Extract from tree of huge allocations. */
/* Initialize chunks data. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\jemalloc.c
/******************************************************************************/
/* Data. */
/* Runtime configuration options. */
/* Set to true once the allocator has been initialized. */
/* Used to let the initializing thread recursively allocate. */
/* Used to avoid initialization races. */
/* Input pointer (as in realloc(p, s)). */
/* Request size. */
/* Result pointer. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Create a new arena and insert it into the arenas array at index ind. */
/* Only reached if there is an OOM error. */
/*
/* Slow path, called only by choose_arena(). */
/*
/*
/*
/* Initialize a new arena. */
/*
/*
/*
/******************************************************************************/
/*
/* Error. */
/*
/*
/*
/* Get runtime configuration. */
/*
/* No configuration specified. */
/*
/* No configuration specified. */
/*
/* No configuration specified. */
/* NOTREACHED */
/*
/*
/* Busy-wait until the initializing thread completes. */
/* Register fork handlers. */
/* Print statistics at exit. */
/*
/*
/* Initialize allocation counters before any allocations can occur. */
/* Get number of CPUs. */
/*
/*
/* Allocate and initialize arenas. */
/*
/* Copy the pointer to the one arena that was already initialized. */
/*
/******************************************************************************/
/*
/*
/* Make sure that alignment is a large enough power of 2. */
/*
/* size_t overflow. */
/* realloc(ptr, 0) is equivalent to free(p). */
/* realloc(NULL, size) is equivalent to malloc(size). */
/*
/******************************************************************************/
/*
/*
/*
//bugzilla.mozilla.org/show_bug.cgi?id=493541).
/*
/******************************************************************************/
/*
/*
/******************************************************************************/
/*
/*
/*
/*
/******************************************************************************/
/*
/*
/* Acquire all mutexes in a safe order. */
/* Release all mutexes, now that fork() has completed. */
/* Release all mutexes, now that fork() has completed. */
/******************************************************************************/
/*
/******************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\mb.c
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\mutex.c
/******************************************************************************/
/* Data. */
/******************************************************************************/
/*
/******************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\prof.c
/******************************************************************************/
/******************************************************************************/
/* Data. */
/*
/* Atomic counter. */
/*
/*
/* Do not dump any profiles until bootstrapping is complete. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/* Throw away (nignore+1) stack frames, if that many exist. */
/*
/* Extras to compensate for nignore. */
/*
/* bt has never been seen before.  Insert it. */
/*
/* OOM. */
/*
/* Link a prof_thd_cnt_t into ctx for this thread. */
/*
/* ret can now be re-used. */
/* Allocate and partially initialize a new cnt. */
/* Finish initializing ret. */
/* Move ret to the front of the LRU. */
/* Flush the buffer if it is full. */
/* Finish writing. */
/* Write as much of s as will fit. */
/* Make sure epoch is even. */
/* Terminate if epoch didn't change while reading. */
/* Add to cnt_all. */
/*
/* Remove ctx from bt2ctx. */
/* Destroy ctx. */
/*
/* Merge cnt stats and detach from ctx. */
/*
/*
/* Make space in prof_dump_buf before read(). */
/* Merge per thread profile stats, and sum them in cnt_all. */
/* Dump profile header. */
/* Dump  per ctx profile stats. */
/* Dump /proc/<pid>/maps if possible. */
/* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
/* "<prefix>.<pid>.<seq>.<v>.heap" */
/* No filename specified, so automatically generate one. */
/* Initialize an empty cache for this thread. */
/*
/*
/*
/*
/*
/*
/*
/******************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\quarantine.c
/*
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* objs ring buffer data are contiguous. */
/* objs ring buffer data wrap around. */
/*
/*
/* Grow the quarantine ring buffer if it's full. */
/* quarantine_grow() must free a slot if it fails to grow. */
/* Append ptr if its size doesn't exceed the quarantine size. */
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\rtree.c
/* Leak the rtree. */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\stats.c
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* Gap of more than one size class. */
/* Gap of one size class. */
/* Gap of more than one size class. */
/* Gap of one size class. */
/*
/* Print chunk stats. */
/* Print huge stats. */
/* Print merged arena stats. */
/* Print stats for each arena. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\tcache.c
/******************************************************************************/
/* Data. */
/* Total stack elms per tcache. */
/******************************************************************************/
/*
/*
/*
/* Lock the arena bin associated with the first object. */
/*
/*
/* Lock the arena associated with the first object. */
/*
/*
/* Link into list of extant tcaches. */
/* Unlink from list of extant tcaches. */
/* Naturally align the pointer stacks. */
/*
/* Do nothing. */
/*
/*
/* Merge and reset tcache stats. */
/*
/* Initialize tcache_bin_info. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\tsd.c
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Avoid choose_arena() in order to dodge bootstrapping issues. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\util.c
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/* malloc_message() setup. */
/*
/*
/*
/* Swallow leading whitespace and get sign, if any. */
/* Fall through. */
/* Fall through. */
/* Get prefix, if any. */
/*
/* Convert. */
/* Overflow. */
/* No characters were converted. */
/* Fall through. */
/* Left padding. */						\
/* Value. */							\
/* Right padding. */						\
/* Synthetic; used for %p. */				\
/* %% */
/* Flags. */
/* Width. */
/* Precision. */
/* Length. */
/* Conversion specifier. */
/*
/*
/* Print to stderr in such a way as to avoid memory allocation. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\jemalloc\src\zone.c
/*
/******************************************************************************/
/* Data. */
/******************************************************************************/
/* Function prototypes for non-inline static functions. */
/******************************************************************************/
/*
/*
/* Assignment avoids useless compiler warning. */
/* Assignment avoids useless compiler warning. */
/* This function should never be called. */
/*
/*
/* Register the custom zone.  At this point it won't be the default. */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\blocksort.c
/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* Random partitioning.  Median of 3 sometimes fails to
/*---------------------------------------------*/
/* Pre:
/*--
/*--
/*-- set sentinel bits for block-end detection --*/
/*-- the log(N) loop --*/
/*-- find the next non-singleton bucket --*/
/*-- now [l, r] bracket current bucket --*/
/*-- scan bucket and generate header bits-- */
/*-- 
/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/*---------------------------------------------*/
/*--
/*-- copy 1 --*/
/*-- copy 2 --*/
/*-- copy 3 --*/
/*---------------------------------------------*/
/*--
/*---------------------------------------------*/
/* Pre:
/*-- set up the 2-byte frequency table --*/
/*-- (emphasises close relationship of block & quadrant) --*/
/*-- Complete the initial radix sort --*/
/*--
/*--
/*--
/*--
/*--
/* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.
/*--
/*---------------------------------------------*/
/* Pre:
/* Calculate the location for quadrant, remembering to get
/* (wfact-1) / 3 puts the default-factor-30
/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\bzlib.c
/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-- fast track the common case --*/           \
/*-- general, uncommon cases --*/              \
/*---------------------------------------------------*/
/*-- fast track the common case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- general, uncommon case --*/
/*-- block full? --*/
/*-- no input? --*/
/*-- flush/finish end? --*/
/*---------------------------------------------------*/
/*-- no output space? --*/
/*-- block done? --*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--not reached--*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* restore */
/* end restore */
/* try to finish existing run */
/* Only caused by corrupt data stream? */
/* can a new run be started? */
/* save */
/* end save */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/* try to finish existing run */
/* can a new run be started? */
/* Only caused by corrupt data stream? */
/*---------------------------------------------------*/
/*NOTREACHED*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- File I/O stuff                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*not reached*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/* normal termination */
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/*---------------------------------------------------*/
/* no use when bzdopen */
/* no use when bzdopen */
/* bzopen: 0, bzdopen:1 */
/* binary mode */
/* Guard against total chaos and anarchy -- JRS */
/*---------------------------------------------------*/
/*--
/*bzopen*/0);
/*---------------------------------------------------*/
/*bzdopen*/1);
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* do nothing now... */
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/* for future */
/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\compress.c
/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/* CHANGES
/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* 
/*---------------------------------------------------*/
/*--
/*--- Decide how many coding tables to use ---*/
/*--- Generate an initial set of coding tables ---*/
/*--- 
/*---
/*--- Set group start & end marks. --*/
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*-- 
/*-- 
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*--
/* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See 
/*20*/ );
/*--- Compute MTF values for the selectors. ---*/
/*--- Assign actual codes for the tables. --*/
/*20*/ ), 3004 );
/*--- Transmit the mapping table. ---*/
/*--- Now the selectors. ---*/
/*--- Now the coding tables. ---*/
/* 10 */ };
/* 11 */ };
/*--- And finally, the block data proper ---*/
/*--- fast track the common case ---*/
/*--- slow version which correctly handles all situations ---*/
/*---------------------------------------------------*/
/*-- If this is the first block, create the stream header. --*/
/*-- Now the block's CRC, so it is in a known place. --*/
/*-- 
/*-- If this is the last block, add the stream trailer. --*/
/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\crctable.c
/*-------------------------------------------------------------*/
/*--- Table for doing CRCs                                  ---*/
/*---                                            crctable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*--
/*-- Ugly, innit? --*/
/*-------------------------------------------------------------*/
/*--- end                                        crctable.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\decompress.c
/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* the longest code */)         \
/*---------------------------------------------------*/
/* stuff that needs to be saved/restored */
/*initialise the save area*/
/*restore from the save area*/
/*--- Receive the mapping table ---*/
/*--- Now the selectors ---*/
/*--- Undo the MTF values for the selectors. ---*/
/*--- Now the coding tables ---*/
/*--- Create the Huffman decoding tables ---*/
/*--- Now the MTF values ---*/
/*-- MTF init --*/
/*-- end MTF init --*/
/*-- uc = MTF ( nextSym-1 ) --*/
/* avoid general-case expense */
/* general case */
/*-- end uc = MTF ( nextSym-1 ) --*/
/* Now we know what nblock is, we can do a better sanity
/*-- Set up cftab to facilitate generation of T^(-1) --*/
/* s->cftab[i] can legitimately be == nblock */
/*-- Make a copy of cftab, used in generation of T --*/
/*-- compute the T vector --*/
/*-- Compute T^(-1) by pointer reversal on T --*/
/*-- compute the T^(-1) vector --*/
/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\huffman.c
/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
/* 17 Oct 04: keep-going condition for the following loop used
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\bzip2\randtable.c
/*-------------------------------------------------------------*/
/*--- Table for randomising repetitive blocks               ---*/
/*---                                           randtable.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
/*---------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- end                                       randtable.c ---*/
/*-------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\jenkins\lookup3.c
/*
//#define SELF_TEST 1
/* defines printf for tests */
/* defines time_t for timings in the test */
/* attempt to define endianness */
/* attempt to define endianness */
/*
/*
//burtleburtle.net/bob/hash/avalanche.html to choose 
/*
/*
/* the key, an array of uint32_t values */
/* the length of the key, in uint32_ts */
/* the previous hash, or an arbitrary value */
/* Set up the internal state */
/*------------------------------------------------- handle most of the key */
/*------------------------------------------- handle the last 3 uint32_t's */
/* all the case statements fall through */
/* case 0: nothing left to add */
/*------------------------------------------------------ report the result */
/*
/* the key, an array of uint32_t values */
/* the length of the key, in uint32_ts */
/* IN: seed OUT: primary hash value */
/* IN: more seed OUT: secondary hash value */
/* Set up the internal state */
/*------------------------------------------------- handle most of the key */
/*------------------------------------------- handle the last 3 uint32_t's */
/* all the case statements fall through */
/* case 0: nothing left to add */
/*------------------------------------------------------ report the result */
/*
/* internal state */
/* needed for Mac Powerbook G4 */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* !valgrind */
/* read 16-bit chunks */
/*--------------- all but last block: aligned reads and different mixing */
/*----------------------------- handle the last (probably partial) block */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length requires no mixing */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/*
/* the key to hash */
/* length of the key */
/* IN: primary initval, OUT: primary hash */
/* IN: secondary initval, OUT: secondary hash */
/* internal state */
/* needed for Mac Powerbook G4 */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length strings require no mixing */
/* !valgrind */
/* read 16-bit chunks */
/*--------------- all but last block: aligned reads and different mixing */
/*----------------------------- handle the last (probably partial) block */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* zero length strings require no mixing */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/* zero length strings require no mixing */
/*
/* to cast key to (size_t) happily */
/* Set up the internal state */
/* read 32-bit chunks */
/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
/*----------------------------- handle the last (probably partial) block */
/* 
/* zero length strings require no mixing */
/* make valgrind happy */
/* all the case statements fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* fall through */
/* !VALGRIND */
/* need to read the key one byte at a time */
/*--------------- all but the last block: affect some 32 bits of (a,b,c) */
/*-------------------------------- last block: affect all 32 bits of (c) */
/* all the case statements fall through */
/* used for timings */
/* check that every input bit changes every output bit half the time */
/*----------------------- for each input byte, */
/*------------------------ for each input bit, */
/*------------ for serveral possible initvals, */
/*---- check that every output bit is affected by that input bit */
/* keys have one bit different */
/* have a and b be two keys differing in only one bit */
/* check every bit is 1, 0, set, and not set at least once */
/* Check for reading beyond the end of the buffer and alignment problems */
/* check that hashlittle2 and hashlittle produce the same results */
/* check that hashword2 and hashword produce the same results */
/* check hashlittle doesn't read before or after the ends of the string */
/* these should all be equal */
/* check for problems with nulls */
/* deadbeef deadbeef */
/* bd5b7dde deadbeef */
/* 9c093ccd bd5b7dde */
/* 17770551 ce7226e6 */
/* e3607cae bd371de4 */
/* cd628161 6cbea4b3 */
/* 17770551 */
/* cd628161 */
/* test that the key is hashed: used for timings */
/* test that whole key is hashed thoroughly */
/* test that nothing but the key is hashed */
/* test hashing multiple buffers (all buffers are null) */
/* test the hash against known vectors */
/* SELF_TEST */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\hashes\hash_memory.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/helper/hash_memory.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:23 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\hashes\md5.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* OID */
/* copy the state into 512-bits into W[0..15] */
/* copy state */
/**
/**
/**
/* increase the length of the message */
/* append the '1' bit */
/* if the length is currently above 56 bytes we append zeros
/* pad upto 56 bytes of zeroes */
/* store length */
/* copy output */
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/md5.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:25:28 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\hashes\sha1.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* OID */
/* copy the state into 512-bits into W[0..15] */
/* copy state */
/* expand it */
/* compress */
/* round one */
/* round two */
/* round three */
/* round four */
/* store */
/**
/**
/**
/* increase the length of the message */
/* append the '1' bit */
/* if the length is currently above 56 bytes we append zeros
/* pad upto 56 bytes of zeroes */
/* store length */
/* copy output */
/**
/* $Source: /cvs/libtom/libtomcrypt/src/hashes/sha1.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:25:28 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\math\ltm_desc.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* ---- trivial ---- */
/* ---- conversions ---- */
/* read ascii string */
/* write one */
/* get size as unsigned char string */
/* store */
/* read */
/* add */
/* sub */
/* mul */
/* sqr */
/* div */
/* modi */
/* gcd */
/* lcm */
/* invmod */
/* setup */
/* get normalization value */
/* reduce */
/* clean up */
/* LTC_MECC_FP */
/* LTC_ECC_SHAMIR */
/* LTC_MECC */
/* $Source: /cvs/libtom/libtomcrypt/src/math/ltm_desc.c,v $ */
/* $Revision: 1.31 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\math\multi.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* failed */
/* $Source: /cvs/libtom/libtomcrypt/src/math/multi.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:23 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\math\rand_prime.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* get type */
/* allow sizes between 2 and 512 bytes for a prime size */
/* valid PRNG? Better be! */
/* allocate buffer to work with */
/* generate value */
/* munge bits */
/* load value */
/* test */
/* $Source: /cvs/libtom/libtomcrypt/src/math/rand_prime.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:23 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\base64_decode.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* the final = symbols are read and used to trim the remaining bytes */
/* prevent g < 0 which would potentially allow an overflow later */
/* we only allow = to be at the end */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/base64/base64_decode.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_argchk.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_argchk.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_find_hash.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_find_hash.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_find_prng.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_find_prng.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_hash_descriptor.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_hash_descriptor.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_hash_is_valid.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/*
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_hash_is_valid.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_libc.c
/*****************************************************************************/
/* crypt_libc.c                           Copyright (c) Ladislav Zezula 2010 */
/*---------------------------------------------------------------------------*/
/* Description:                                                              */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 05.05.10  1.00  Lad  The first version of crypt_libc.c                    */
/*****************************************************************************/
// LibTomCrypt header
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_ltc_mp_descriptor.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_prng_descriptor.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_prng_descriptor.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_prng_is_valid.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/*
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_prng_is_valid.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_register_hash.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* is it already registered? */
/* find a blank spot */
/* no spot */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_register_hash.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\crypt_register_prng.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* is it already registered? */
/* find a blank spot */
/* no spot */
/* $Source: /cvs/libtom/libtomcrypt/src/misc/crypt/crypt_register_prng.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\misc\zeromem.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/misc/zeromem.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_bit_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* packet must be at least 4 bytes */
/* check for 0x03 */
/* offset in the data */
/* get the length of the data */
/* long format get number of length bytes */
/* invalid if 0 or > 2 */
/* read the data len */
/* short format */
/* is the data len too long or too short? */
/* get padding count */
/* too many bits? */
/* decode/store the bits */
/* we done */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/bit/der_decode_bit_string.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_boolean.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/boolean/der_decode_boolean.c,v $ */
/* $Revision: 1.2 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_choice.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get blk size */
/* set all of the "used" flags to zero */
/* now scan until we have a winner */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/choice/der_decode_choice.c,v $ */
/* $Revision: 1.9 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_ia5_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x16 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/ia5/der_decode_ia5_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_integer.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* min DER INTEGER is 0x02 01 00 == 0 */
/* ok expect 0x02 when we AND with 0001 1111 [1F] */
/* now decode the len stuff */
/* short form */
/* will it overflow? */
/* no so read it */
/* long form */
/* will number of length bytes overflow? (or > 4) */
/* now read it in */
/* now will reading y bytes overrun? */
/* no so read it */
/* see if it's negative */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/integer/der_decode_integer.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_object_identifier.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* header is at least 3 bytes */
/* must be room for at least two words */
/* decode the packet header */
/* get the length */
/* decode words */
/* store t */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/object_identifier/der_decode_object_identifier.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_octet_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x04 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/octet/der_decode_octet_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_printable_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x13 */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* is it too long? */
/* read the data */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/printable_string/der_decode_printable_string.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_sequence_ex.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get blk size */
/* sequence type? We allow 0x30 SEQUENCE and 0x31 SET since fundamentally they're the same structure */
/* would reading the len bytes overrun? */
/* read len */
/* would this blksize overflow? */
/* mark all as unused */
/* ok read data */
/* detect if we have the right type */
/* restart the decoder */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_ex.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_sequence_flexi.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/* skip type and read len */
/* read len */
/* <128 means literal */
/* the lower 7 bits are the length of the length */
/* len means len of len! */
/** 
/* scan the input and and get lengths and what not */
/* read the type byte */
/* fetch length */
/* alloc new link */
/* now switch on type */
/* BOOLEAN */
/* INTEGER */
/* init field */
/* decode field */
/* calc length of object */
/* BIT */
/* init field */
/* *8 because we store decoded bits one per char and they are encoded 8 per char.  */
/* OCTET */
/* init field */
/* NULL */
/* valid NULL is 0x05 0x00 */
/* simple to store ;-) */
/* OID */
/* init field */
/* resize it to save a bunch of mem */
/* out of heap but this is not an error */
/* UTF8 */
/* init field */
/* PRINTABLE */
/* init field */
/* IA5 */
/* init field */
/* UTC TIME */
/* init field */
/* SEQUENCE */
/* SET */
/* init field */
/* we have to decode the SEQUENCE header and get it's length */
/* move past type */
/* read length byte */
/* smallest SEQUENCE/SET header */
/* now if it's > 127 the next bytes are the length of the length */
/* update sequence header len */
/* Sequence elements go as child */
/* len update */
/* link them up y0 */
/* invalid byte ... this is a soft error */
/* remove link */
/* advance pointers */
/* rewind l please */
/* return */
/* free list */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_flexi.c,v $ */
/* $Revision: 1.26 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_sequence_multi.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get size of output that will be required */
/* allocate structure for x elements */
/* fill in the structure */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_decode_sequence_multi.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_short_integer.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* check length */
/* check header */
/* get the packet len */
/* read number */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/short_integer/der_decode_short_integer.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_utctime.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* check header */
/* decode the string */
/* possible encodings are 
/* clear timezone and seconds info */
/* now is it Z, +, - or 0-9 */
/* decode seconds */
/* now is it Z, +, - */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utctime/der_decode_utctime.c,v $ */
/* $Revision: 1.9 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_decode_utf8_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must have header at least */
/* check for 0x0C */
/* decode the length */
/* valid # of bytes in length are 1,2,3 */
/* read the length in */
/* proceed to decode */
/* get first byte */
/* count number of bytes */
/* decode, grab upper bits */
/* grab remaining bytes */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utf8/der_decode_utf8_string.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_bit_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get the number of the bytes */
/* 03 LL PP DD DD DD ... */
/* 03 81 LL PP DD DD DD ... */
/* 03 82 LL LL PP DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/bit/der_length_bit_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_boolean.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/boolean/der_length_boolean.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_ia5_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* scan string for validity */
/* 16 LL DD DD DD ... */
/* 16 81 LL DD DD DD ... */
/* 16 82 LL LL DD DD DD ... */
/* 16 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/ia5/der_length_ia5_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_integer.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* positive */
/* we only need a leading zero if the msb of the first byte is one */
/* size for bignum */
/* it's negative */
/* find power of 2 that is a multiple of eight and greater than count bits */
/* now we need a length */
/* short form */
/* long form (relies on z != 0), assumes length bytes < 128 */
/* we need a 0x02 to indicate it's INTEGER */
/* return length */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/integer/der_length_integer.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_object_identifier.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* must be >= 2 words */
/* word1 = 0,1,2,3 and word2 0..39 */
/* leading word is the first two */
/* grab next word */
/* now depending on the length our length encoding changes */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/object_identifier/der_length_object_identifier.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_octet_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* 04 LL DD DD DD ... */
/* 04 81 LL DD DD DD ... */
/* 04 82 LL LL DD DD DD ... */
/* 04 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/octet/der_length_octet_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_printable_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* scan string for validity */
/* 16 LL DD DD DD ... */
/* 16 81 LL DD DD DD ... */
/* 16 82 LL LL DD DD DD ... */
/* 16 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/printable_string/der_length_printable_string.c,v $ */
/* $Revision: 1.3 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_sequence.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* get size of output that will be required */
/* calc header size */
/* 0x30 0x81 LL */
/* 0x30 0x82 LL LL */
/* 0x30 0x83 LL LL LL */
/* store size */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_length_sequence.c,v $ */
/* $Revision: 1.14 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_short_integer.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* force to 32 bits */
/* get the number of bytes */
/* handle zero */
/* we need a 0x02 to indicate it's INTEGER */
/* length byte */
/* bytes in value */
/* see if msb is set */
/* return length */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/short_integer/der_length_short_integer.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_utctime.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* we encode as YYMMDDhhmmssZ */
/* we encode as YYMMDDhhmmss{+|-}hh'mm' */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utctime/der_length_utctime.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_length_utf8_string.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** Return the size in bytes of a UTF-8 character
/**
/* 0C LL DD DD DD ... */
/* 0C 81 LL DD DD DD ... */
/* 0C 82 LL LL DD DD DD ... */
/* 0C 83 LL LL LL DD DD DD ... */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/utf8/der_length_utf8_string.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\asn1\der_sequence_free.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* walk to the start of the chain */
/* now walk the list and free stuff */
/* is there a child? */
/* disconnect */
/* move to next and free current */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/asn1/der/sequence/der_sequence_free.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:27:24 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_map.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* first map z back to normal */
/* get 1/z */
/* get 1/z^2 and 1/z^3 */
/* multiply against x/y */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_map.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_mul2add.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/** Computes kA*A + kB*B = C using Shamir's Trick
/* argchks */
/* allocate memory */
/* get sizes */
/* sanity check */
/* extract and justify kA */
/* extract and justify kB */
/* allocate the table */
/* init montgomery reduction */
/* copy ones ... */
/* precomp [i,0](A + B) table */
/* precomp [0,i](A + B) table */
/* precomp [i,j](A + B) table (i != 0, j != 0) */
/* for every byte of the multiplicands */
/* grab a nibble */
/* extract two bits from both, shift/update */
/* if both zero, if first, continue */
/* double twice, only if this isn't the first */
/* double twice */
/* if not both zero */
/* if first, copy from table */
/* if not first, add from table */
/* reduce to affine */
/* clean up */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_mul2add.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_mulmod.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/* size of sliding window, don't change this! */
/**
/* init montgomery reduction */
/* alloc ram for window temps */
/* make a copy of G incase R==G */
/* tG = G  and convert to montgomery */
/* calc the M tab, which holds kG for k==8..15 */
/* M[0] == 8G */
/* now find (8+k)G for k=1..7 */
/* setup sliding window */
/* perform ops */
/* grab next digit as required */
/* grab the next msb from the ltiplicand */
/* skip leading zero bits */
/* if the bit is zero and mode == 1 then we double */
/* else we add it to the window */
/* if this is the first window we do a simple copy */
/* R = kG [k = first window] */
/* normal window */
/* ok window is filled so double as required and add  */
/* double first */
/* then add, bitbuf will be 8..15 [8..2^WINSIZE] guaranteed */
/* empty window and reset */
/* if bits remain then double/add */
/* double then add */
/* only double if we have had at least one add first */
/* first add, so copy */
/* then add */
/* map R back from projective space */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_mulmod.c,v $ */
/* $Revision: 1.26 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_points.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/** Free an ECC point from memory
/* prevents free'ing null arguments */
/* note: p->z may be NULL but that's ok with this function anyways */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_points.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_projective_add_point.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* should we dbl instead? */
/* if Z is one then these are no-operations */
/* T1 = Z' * Z' */
/* X = X * T1 */
/* T1 = Z' * T1 */
/* Y = Y * T1 */
/* T1 = Z*Z */
/* T2 = X' * T1 */
/* T1 = Z * T1 */
/* T1 = Y' * T1 */
/* Y = Y - T1 */
/* T1 = 2T1 */
/* T1 = Y + T1 */
/* X = X - T2 */
/* T2 = 2T2 */
/* T2 = X + T2 */
/* if Z' != 1 */
/* Z = Z * Z' */
/* Z = Z * X */
/* T1 = T1 * X  */
/* X = X * X */
/* T2 = T2 * x */
/* T1 = T1 * X  */
/* X = Y*Y */
/* X = X - T2 */
/* T2 = T2 - X */
/* T2 = T2 - X */
/* T2 = T2 * Y */
/* Y = T2 - T1 */
/* Y = Y/2 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_projective_add_point.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\ecc\ltc_ecc_projective_dbl_point.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/* Implements ECC over Z/pZ for curve y^2 = x^3 - 3x + b
//csrc.nist.gov/cryptval/dss.htm
/**
/**
/* t1 = Z * Z */
/* Z = Y * Z */
/* Z = 2Z */
/* T2 = X - T1 */
/* T1 = X + T1 */
/* T2 = T1 * T2 */
/* T1 = 2T2 */
/* T1 = T1 + T2 */
/* Y = 2Y */
/* Y = Y * Y */
/* T2 = Y * Y */
/* T2 = T2/2 */
/* Y = Y * X */
/* X  = T1 * T1 */
/* X = X - Y */
/* X = X - Y */
/* Y = Y - X */     
/* Y = Y * T1 */
/* Y = Y - T2 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/ecc/ltc_ecc_projective_dbl_point.c,v $ */
/* $Revision: 1.11 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\pkcs1\pkcs_1_mgf1.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* ensure valid hash */
/* get hash output size */
/* allocate memory */
/* start counter */
/* handle counter */
/* get hash of seed || counter */
/* store it */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_mgf1.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\pkcs1\pkcs_1_oaep_decode.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* default to invalid packet */
/* test valid hash */
/* test hash/message size */
/* allocate ram for DB/mask/salt of size modulus_len */
/* ok so it's now in the form
/* must have leading 0x00 byte */
/* now read the masked seed */
/* now read the masked DB */
/* compute MGF1 of maskedDB (hLen) */ 
/* XOR against seed */
/* compute MGF1 of seed (k - hlen - 1) */
/* xor against DB */
/* now DB == lhash || PS || 0x01 || M, PS == k - mlen - 2hlen - 2 zeroes */
/* compute lhash and store it in seed [reuse temps!] */
/* can't pass hash_memory a NULL so use DB with zero length */
/* compare the lhash'es */
/* now zeroes before a 0x01 */
/* step... */
/* error out if wasn't 0x01 */
/* rest is the message (and skip 0x01) */
/* copy message */
/* valid packet */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_oaep_decode.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\pkcs1\pkcs_1_pss_decode.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** 
/**
/* default to invalid */
/* ensure hash is valid */
/* check sizes */
/* allocate ram for DB/mask/salt/hash of size modulus_len */
/* ensure the 0xBC byte */
/* copy out the DB */
/* copy out the hash */
/* check the MSB */
/* generate mask of length modulus_len - hLen - 1 from hash */
/* xor against DB */
/* now clear the first byte [make sure smaller than modulus] */
/* DB = PS || 0x01 || salt, PS == modulus_len - saltlen - hLen - 2 zero bytes */
/* check for zeroes and 0x01 */
/* check for the 0x01 */
/* M = (eight) 0x00 || msghash || salt, mask = H(M) */
/* mask == hash means valid signature */
/* LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_pss_decode.c,v $ */
/* $Revision: 1.11 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\pkcs1\pkcs_1_v1_5_decode.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/** @file pkcs_1_v1_5_decode.c
/** @brief LTC_PKCS #1 v1.5 decode.
/* default to invalid packet */
/* test message size */
/* separate encoded message */
/* separator */
/* There was no octet with hexadecimal value 0x00 to separate ps from m,
/* separator check */
/* There was no octet with hexadecimal value 0x00 to separate ps from m. */
/* valid packet */
/* pkcs_1_v1_5_decode */
/* #ifdef LTC_PKCS_1 */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/pkcs1/pkcs_1_v1_5_decode.c,v $ */
/* $Revision: 1.7 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_exptmod.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** 
/* is the key of the right type for the operation? */
/* must be a private or public operation */
/* init and copy into tmp */
/* sanity check on the input */
/* are we using the private exponent and is the key optimized? */
/* tmpa = tmp^dP mod p */
/* tmpb = tmp^dQ mod q */
/* tmp = (tmpa - tmpb) * qInv (mod p) */
/* tmp = tmpb + q * tmp */
/* exptmod it */
/* read it back */
/* this should never happen ... */
/* convert it */
/* clean up and return */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_exptmod.c,v $ */
/* $Revision: 1.18 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_free.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_free.c,v $ */
/* $Revision: 1.10 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_import.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* init key */
/* see if the OpenSSL DER format RSA public key will work */
/* this includes the internal hash ID and optional params (NULL in this case) */
/* the actual format of the SSL DER key is odd, it stores a RSAPublicKey in a **BIT** string ... so we have to extract it
/* ok now we have to reassemble the BIT STRING to an OCTET STRING.  Thanks OpenSSL... */
/* now it should be SEQUENCE { INTEGER, INTEGER } */
/* not SSL public key, try to match against LTC_PKCS #1 standards */
/* it's a private key */
/* we don't support multi-prime RSA */
/* it's a public key and we lack e */
/* LTC_MRSA */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_import.c,v $ */
/* $Revision: 1.23 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_make_key.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/** 
/* make primes p and q (optimization provided by Wayne Scott) */
/* tmp3 = e */
/* make prime "p" */
/* tmp1 = p-1 */
/* tmp2 = gcd(p-1, e) */
/* while e divides p-1 */
/* make prime "q" */
/* tmp1 = q-1 */
/* tmp2 = gcd(q-1, e) */
/* while e divides q-1 */
/* tmp1 = lcm(p-1, q-1) */
/* tmp2 = p-1 */
/* tmp1 = q-1 (previous do/while loop) */
/* tmp1 = lcm(p-1, q-1) */
/* make key */
/* key->e =  e */
/* key->d = 1/e mod lcm(p-1,q-1) */
/* key->N = pq */
/* optimize for CRT now */
/* find d mod q-1 and d mod p-1 */
/* tmp1 = q-1 */
/* tmp2 = p-1 */
/* dP = d mod p-1 */
/* dQ = d mod q-1 */
/* qP = 1/q mod p */
/* set key type (in this case it's CRT optimized) */
/* return ok and free temps */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_make_key.c,v $ */
/* $Revision: 1.16 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_verify_hash.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* default to invalid */
/* valid padding? */
/* valid hash ? */
/* get modulus len in bits */
/* outlen must be at least the size of the modulus */
/* allocate temp buffer for decoded sig */
/* RSA decode it  */
/* make sure the output is the right size */
/* PSS decode and verify it */
/* LTC_PKCS #1 v1.5 decode it */
/* not all hashes have OIDs... so sad */
/* allocate temp buffer for decoded hash */
/* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */
/* construct the SEQUENCE 
/* test OID */
/* LTC_MRSA */
/* $Source: /cvs/libtom/libtomcrypt/src/pk/rsa/rsa_verify_hash.c,v $ */
/* $Revision: 1.13 $ */
/* $Date: 2007/05/12 14:32:35 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtomcrypt\src\pk\rsa\rsa_verify_simple.c
/* LibTomCrypt, modular cryptographic library -- Tom St Denis
//libtom.org
/**
/**
/* default to invalid */
/* get modulus len in bits */
/* outlen must be at least the size of the modulus */
/* allocate temp buffer for decoded sig */
/* RSA decode it  */
/* make sure the output is the right size */
/* compare the decrypted signature with the given hash */
/* LTC_MRSA */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bncore.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Known optimal configurations
/* Min. number of digits before Karatsuba multiplication is used. */
/* Min. number of digits before Karatsuba squaring is used. */
/* no optimal values of these are known yet so set em high */
/* $Source: /cvs/libtom/libtommath/bncore.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_fast_mp_invmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes the modular inverse via binary extended euclidean algorithm, 
/* 2. [modified] b must be odd   */
/* init all our temps */
/* x == modulus, y == value to invert */
/* we need y = |a| */
/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
/* 4.  while u is even do */
/* 4.1 u = u/2 */
/* 4.2 if B is odd then */
/* B = B/2 */
/* 5.  while v is even do */
/* 5.1 v = v/2 */
/* 5.2 if D is odd then */
/* D = (D-x)/2 */
/* D = D/2 */
/* 6.  if u >= v then */
/* u = u - v, B = B - D */
/* v - v - u, D = D - B */
/* if not zero goto step 4 */
/* now a = C, b = D, gcd == g*v */
/* if v != 1 then there is no inverse */
/* b is now the inverse */
/* $Source: /cvs/libtom/libtommath/bn_fast_mp_invmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_fast_mp_montgomery_reduce.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes xR**-1 == x (mod N) via Montgomery Reduction
/* get old used count */
/* grow a as required */
/* first we have to get the digits of the input into
/* alias for the W[] array */
/* alias for the digits of  x*/
/* copy the digits of a into W[0..a->used-1] */
/* zero the high words of W[a->used..m->used*2] */
/* now we proceed to zero successive digits
/* mu = ai * m' mod b
/* a = a + mu * m * b**i
/* alias for the digits of the modulus */
/* Alias for the columns set by an offset of ix */
/* inner loop */
/* now fix carry for next digit, W[ix+1] */
/* now we have to propagate the carries and
/* nox fix rest of carries */
/* alias for current word */
/* alias for next word, where the carry goes */
/* copy out, A = A/b**n
/* alias for destination word */
/* alias for shifted double precision result */
/* zero oldused digits, if the input a was larger than
/* set the max used and clamp */
/* if A >= m then A = A - m */
/* $Source: /cvs/libtom/libtommath/bn_fast_mp_montgomery_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_fast_s_mp_mul_digs.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Fast (comba) multiplier
/* grow the destination as required */
/* number of output digits to produce */
/* clear the carry */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially 
/* execute loop */
/* store term */
/* make next carry */
/* setup dest */
/* now extract the previous digit [below the carry] */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_mul_digs.c,v $ */
/* $Revision: 1.8 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_fast_s_mp_mul_high_digs.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this is a modified version of fast_s_mul_digs that only produces
/* grow the destination as required */
/* number of output digits to produce */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially its 
/* execute loop */
/* store term */
/* make next carry */
/* setup dest */
/* now extract the previous digit [below the carry] */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_mul_high_digs.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_fast_s_mp_sqr.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* the jist of squaring...
/* grow the destination as required */
/* number of output digits to produce */
/* clear counter */
/* get offsets into the two bignums */
/* setup temp aliases */
/* this is the number of times the loop will iterrate, essentially
/* now for squaring tx can never equal ty 
/* execute loop */
/* double the inner product and add carry */
/* even columns have the square term in them */
/* store it */
/* make next carry */
/* setup dest */
/* clear unused digits [that existed in the old copy of c] */
/* $Source: /cvs/libtom/libtommath/bn_fast_s_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_2expt.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes a = 2**b 
/* zero a as per default */
/* grow a to accomodate the single bit */
/* set the used count of where the bit will go */
/* put the single bit in its place */
/* $Source: /cvs/libtom/libtommath/bn_mp_2expt.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_abs.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = |a| 
/* copy a to b */
/* force the sign of b to positive */
/* $Source: /cvs/libtom/libtommath/bn_mp_abs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_add.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level addition (handles signs) */
/* get sign of both inputs */
/* handle two cases, not four */
/* both positive or both negative */
/* add their magnitudes, copy the sign */
/* one positive, the other negative */
/* subtract the one with the greater magnitude from */
/* the one of the lesser magnitude.  The result gets */
/* the sign of the one with the greater magnitude. */
/* $Source: /cvs/libtom/libtommath/bn_mp_add.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_addmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a + b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_addmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_add_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* single digit addition */
/* grow c as required */
/* if a is negative and |a| >= b, call c = |a| - b */
/* temporarily fix sign of a */
/* c = |a| - b */
/* fix sign  */
/* clamp */
/* old number of used digits in c */
/* sign always positive */
/* source alias */
/* destination alias */
/* if a is positive */
/* add digit, after this we're propagating
/* now handle rest of the digits */
/* set final carry */
/* setup size */
/* a was negative and |a| < b */
/* the result is a single digit */
/* setup count so the clearing of oldused
/* now zero to oldused */
/* $Source: /cvs/libtom/libtommath/bn_mp_add_d.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_and.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* AND two ints together */
/* zero digits above the last from the smallest mp_int */
/* $Source: /cvs/libtom/libtommath/bn_mp_and.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_clamp.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* trim unused digits 
/* decrease used while the most significant digit is
/* reset the sign flag if used == 0 */
/* $Source: /cvs/libtom/libtommath/bn_mp_clamp.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_clear.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* clear one (frees)  */
/* only do anything if a hasn't been freed previously */
/* first zero the digits */
/* free ram */
/* reset members to make debugging easier */
/* $Source: /cvs/libtom/libtommath/bn_mp_clear.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_clear_multi.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_clear_multi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_cmp.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare two ints (signed)*/
/* compare based on sign */
/* compare digits */
/* if negative compare opposite direction */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_cmp_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare a digit */
/* compare based on sign */
/* compare based on magnitude */
/* compare the only digit of a to b */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_cmp_mag.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* compare maginitude of two ints (unsigned) */
/* compare based on # of non-zero digits */
/* alias for a */
/* alias for b */
/* compare based on digits  */
/* $Source: /cvs/libtom/libtommath/bn_mp_cmp_mag.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_cnt_lsb.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Counts the number of lsbs which are zero before the first zero bit */
/* easy out */
/* scan lower digits until non-zero */
/* now scan this digit until a 1 is found */
/* $Source: /cvs/libtom/libtommath/bn_mp_cnt_lsb.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_copy.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* copy, b = a */
/* if dst == src do nothing */
/* grow dest */
/* zero b and copy the parameters over */
/* pointer aliases */
/* source */
/* destination */
/* copy all the digits */
/* clear high digits */
/* copy used count and sign */
/* $Source: /cvs/libtom/libtommath/bn_mp_copy.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_count_bits.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns the number of bits in an int */
/* shortcut */
/* get number of digits and add that */
/* take the last digit and count the bits in it */
/* $Source: /cvs/libtom/libtommath/bn_mp_count_bits.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_div.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* slower bit-bang division... also smaller */
/* is divisor zero ? */
/* if a < b then q=0, r = a */
/* init our temps */
/* now q == quotient and ta == remainder */
/* integer signed division. 
/* is divisor zero ? */
/* if a < b then q=0, r = a */
/* fix the sign */
/* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
/* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
/* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
/* y = y*b**{n-t} */
/* reset y by shifting it back down */
/* step 3. for i from n down to (t + 1) */
/* step 3.1 if xi == yt then set q{i-t-1} to b-1, 
/* while (q{i-t-1} * (yt * b + y{t-1})) > 
/* find left hand */
/* find right hand */
/* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
/* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
/* now q is the quotient and x is the remainder 
/* get sign before writing to c */
/* $Source: /cvs/libtom/libtommath/bn_mp_div.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_div_2.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = a/2 */
/* copy */
/* source alias */
/* dest alias */
/* carry */
/* get the carry for the next iteration */
/* shift the current digit, add in carry and store */
/* forward carry to next iteration */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_2.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_div_2d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift right by a certain bit count (store quotient in c, optional remainder in d) */
/* if the shift count is <= 0 then we do no work */
/* get the remainder */
/* copy */
/* shift by as many digits in the bit count */
/* shift any bit count < DIGIT_BIT */
/* mask */
/* shift for lsb */
/* alias */
/* carry */
/* get the lower  bits of this word in a temp */
/* shift the current word and mix in the carry bits from the previous word */
/* set the carry to the carry bits of the current word found above */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_div_3.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* divide by three (based on routine from MPI and the GMP manual) */
/* b = 2**DIGIT_BIT / 3 */
/* multiply w by [1/3] */
/* now subtract 3 * [w/3] from w, to get the remainder */
/* fixup the remainder as required since
/* [optional] store the remainder */
/* [optional] store the quotient */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_3.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_div_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* fast return if no power of two */
/* single digit division (based on routine from MPI) */
/* cannot divide by zero */
/* quick outs */
/* power of two ? */
/* three? */
/* no easy answer [c'est la vie].  Just division */
/* $Source: /cvs/libtom/libtommath/bn_mp_div_d.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2007/01/09 04:44:32 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_dr_is_modulus.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if a number is a valid DR modulus */
/* must be at least two digits */
/* must be of the form b**k - a [a <= b] so all
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_is_modulus.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_dr_reduce.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduce "x" in place modulo "n" using the Diminished Radix algorithm.
/* m = digits in modulus */
/* ensure that "x" has at least 2m digits */
/* top of loop, this is where the code resumes if
/* aliases for digits */
/* alias for lower half of x */
/* alias for upper half of x, or x/B**m */
/* set carry to zero */
/* compute (x mod B**m) + k * [x/B**m] inline and inplace */
/* set final carry */
/* zero words above m */
/* clamp, sub and return */
/* if x >= n then subtract and reduce again
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_dr_setup.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* the casts are required if DIGIT_BIT is one less than
/* $Source: /cvs/libtom/libtommath/bn_mp_dr_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_exch.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* swap the elements of two integers, for cases where you can't simply swap the 
/* $Source: /cvs/libtom/libtommath/bn_mp_exch.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_exptmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this is a shell function that calls either the normal or Montgomery
/* modulus P must be positive */
/* if exponent X is negative we have to recurse */
/* first compute 1/G mod P */
/* now get |X| */
/* and now compute (1/G)**|X| instead of G**X [X < 0] */
/* no invmod */
/* modified diminished radix reduction */
/* is it a DR modulus? */
/* default to no */
/* if not, is it a unrestricted DR modulus? */
/* if the modulus is odd or dr != 0 use the montgomery method */
/* otherwise use the generic Barrett reduction technique */
/* no exptmod for evens */
/* $Source: /cvs/libtom/libtommath/bn_mp_exptmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_exptmod_fast.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes Y == G**X mod P, HAC pp.616, Algorithm 14.85
/* use a pointer to the reduction algorithm.  This allows us to use
/* find window size */
/* init M array */
/* init first cell */
/* now init the second half of the array */
/* determine and setup reduction code */
/* now setup montgomery  */
/* automatically pick the comba one if available (saves quite a few calls/ifs) */
/* use slower baseline Montgomery method */
/* setup DR reduction for moduli of the form B**k - b */
/* setup DR reduction for moduli of the form 2**k - b */
/* setup result */
/* create M table
/* now we need R mod m */
/* now set M[1] to G * R mod m */
/* compute the value at M[1<<(winsize-1)] by squaring M[1] (winsize-1) times */
/* create upper table */
/* set initial mode and bit cnt */
/* grab next digit as required */
/* if digidx == -1 we are out of digits so break */
/* read next digit and reset bitcnt */
/* grab the next msb from the exponent */
/* if the bit is zero and mode == 0 then we ignore it
/* if the bit is zero and mode == 1 then we square */
/* else we add it to the window */
/* ok window is filled so square as required and multiply  */
/* square first */
/* then multiply */
/* empty window and reset */
/* if bits remain then square/multiply */
/* square then multiply if the bit is set */
/* get next bit of the window */
/* then multiply */
/* fixup result if Montgomery reduction is used
/* swap res with Y */
/* $Source: /cvs/libtom/libtommath/bn_mp_exptmod_fast.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_expt_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* calculate c = a**b  using a square-multiply algorithm */
/* set initial result */
/* square */
/* if the bit is set multiply */
/* shift to next bit */
/* $Source: /cvs/libtom/libtommath/bn_mp_expt_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_exteuclid.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Extended euclidean algorithm of (a, b) produces 
/* initialize, (u1,u2,u3) = (1,0,a) */
/* initialize, (v1,v2,v3) = (0,1,b) */
/* loop while v3 != 0 */
/* q = u3/v3 */
/* (t1,t2,t3) = (u1,u2,u3) - (v1,v2,v3)q */
/* (u1,u2,u3) = (v1,v2,v3) */
/* (v1,v2,v3) = (t1,t2,t3) */
/* make sure U3 >= 0 */
/* copy result out */
/* $Source: /cvs/libtom/libtommath/bn_mp_exteuclid.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_fread.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read a bigint from a file stream in ASCII */
/* clear a */
/* if first digit is - then set negative */
/* find y in the radix map */
/* shift up and add */
/* $Source: /cvs/libtom/libtommath/bn_mp_fread.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_fwrite.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_fwrite.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_gcd.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Greatest Common Divisor using the binary method */
/* either zero than gcd is the largest */
/* get copies of a and b we can modify */
/* must be positive for the remainder of the algorithm */
/* B1.  Find the common power of two for u and v */
/* divide the power of two out */
/* divide any remaining factors of two out */
/* make sure v is the largest */
/* swap u and v to make sure v is >= u */
/* subtract smallest from largest */
/* Divide out all factors of two */
/* multiply by 2**k which we divided out at the beginning */
/* $Source: /cvs/libtom/libtommath/bn_mp_gcd.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_get_int.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the lower 32-bits of an mp_int */
/* get number of digits of the lsb we have to read */
/* get most significant digit of result */
/* force result to 32-bits always so it is consistent on non 32-bit platforms */
/* $Source: /cvs/libtom/libtommath/bn_mp_get_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_grow.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* grow as required */
/* if the alloc size is smaller alloc more ram */
/* ensure there are always at least MP_PREC digits extra on top */
/* reallocate the array a->dp
/* reallocation failed but "a" is still valid [can be freed] */
/* reallocation succeeded so set a->dp */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_grow.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* init a new mp_int */
/* allocate memory required and clear it */
/* set the digits to zero */
/* set the used to zero, allocated digits to the default precision
/* $Source: /cvs/libtom/libtommath/bn_mp_init.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init_copy.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* creates "a" then copies b into it */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_copy.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init_multi.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Assume ok until proven otherwise */
/* Number of ok inits */
/* init args to next argument from caller */
/* Oops - error! Back-track and mp_clear what we already
/* end the current list */
/* now start cleaning up */            
/* Assumed ok, if error flagged above. */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_multi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init_set.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* initialize and set a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_set.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init_set_int.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* initialize and set a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_set_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_init_size.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* init an mp_init for a given size */
/* pad size so there are always extra digits */
/* alloc mem */
/* set the members */
/* zero the digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_init_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_invmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* hac 14.61, pp608 */
/* b cannot be negative */
/* if the modulus is odd we can use a faster routine instead */
/* $Source: /cvs/libtom/libtommath/bn_mp_invmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_invmod_slow.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* hac 14.61, pp608 */
/* b cannot be negative */
/* init temps */
/* x = a, y = b */
/* 2. [modified] if x,y are both even then return an error! */
/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
/* 4.  while u is even do */
/* 4.1 u = u/2 */
/* 4.2 if A or B is odd then */
/* A = (A+y)/2, B = (B-x)/2 */
/* A = A/2, B = B/2 */
/* 5.  while v is even do */
/* 5.1 v = v/2 */
/* 5.2 if C or D is odd then */
/* C = (C+y)/2, D = (D-x)/2 */
/* C = C/2, D = D/2 */
/* 6.  if u >= v then */
/* u = u - v, A = A - C, B = B - D */
/* v - v - u, C = C - A, D = D - B */
/* if not zero goto step 4 */
/* now a = C, b = D, gcd == g*v */
/* if v != 1 then there is no inverse */
/* if its too low */
/* too big */
/* C is now the inverse */
/* $Source: /cvs/libtom/libtommath/bn_mp_invmod_slow.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_is_square.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Check if remainders are possible squares - fast exclude non-squares */
/* Store non-zero to ret if arg is square, and zero if not */
/* Default to Non-square :) */
/* digits used?  (TSD) */
/* First check mod 128 (suppose that DIGIT_BIT is at least 7) */
/* Next check mod 105 (3*5*7) */
/* Check for other prime modules, note it's not an ERROR but we must
/* Final check - is sqr(sqrt(arg)) == arg ? */
/* $Source: /cvs/libtom/libtommath/bn_mp_is_square.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_jacobi.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes the jacobi c = (a | n) (or Legendre if n is prime)
/* if p <= 0 return MP_VAL */
/* step 1.  if a == 0, return 0 */
/* step 2.  if a == 1, return 1 */
/* default */
/* step 3.  write a = a1 * 2**k  */
/* divide out larger power of two */
/* step 4.  if e is even set s=1 */
/* else set s=1 if p = 1/7 (mod 8) or s=-1 if p = 3/5 (mod 8) */
/* step 5.  if p == 3 (mod 4) *and* a1 == 3 (mod 4) then s = -s */
/* if a1 == 1 we're done */
/* n1 = n mod a1 */
/* done */
/* $Source: /cvs/libtom/libtommath/bn_mp_jacobi.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_karatsuba_mul.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = |a| * |b| using Karatsuba Multiplication using 
/* default the return code to an error */
/* min # of digits */
/* now divide in two */
/* init copy all the temps */
/* init temps */
/* now shift the digits */
/* we copy the digits directly instead of using higher level functions
/* only need to clamp the lower words since by definition the 
/* now calc the products x0y0 and x1y1 */
/* after this x0 is no longer required, free temp [x0==t2]! */
/* x0y0 = x0*y0 */
/* x1y1 = x1*y1 */
/* now calc x1+x0 and y1+y0 */
/* t1 = x1 - x0 */
/* t2 = y1 - y0 */
/* t1 = (x1 + x0) * (y1 + y0) */
/* add x0y0 */
/* t2 = x0y0 + x1y1 */
/* t1 = (x1+x0)*(y1+y0) - (x1y1 + x0y0) */
/* shift by B */
/* t1 = (x0y0 + x1y1 - (x1-x0)*(y1-y0))<<B */
/* x1y1 = x1y1 << 2*B */
/* t1 = x0y0 + t1 */
/* t1 = x0y0 + t1 + x1y1 */
/* Algorithm succeeded set the return code to MP_OKAY */
/* $Source: /cvs/libtom/libtommath/bn_mp_karatsuba_mul.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_karatsuba_sqr.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Karatsuba squaring, computes b = a*a using three 
/* min # of digits */
/* now divide in two */
/* init copy all the temps */
/* init temps */
/* now shift the digits */
/* now calc the products x0*x0 and x1*x1 */
/* x0x0 = x0*x0 */
/* x1x1 = x1*x1 */
/* now calc (x1+x0)**2 */
/* t1 = x1 - x0 */
/* t1 = (x1 - x0) * (x1 - x0) */
/* add x0y0 */
/* t2 = x0x0 + x1x1 */
/* t1 = (x1+x0)**2 - (x0x0 + x1x1) */
/* shift by B */
/* t1 = (x0x0 + x1x1 - (x1-x0)*(x1-x0))<<B */
/* x1x1 = x1x1 << 2*B */
/* t1 = x0x0 + t1 */
/* t1 = x0x0 + t1 + x1x1 */
/* $Source: /cvs/libtom/libtommath/bn_mp_karatsuba_sqr.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_lcm.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes least common multiple as |a*b|/(a, b) */
/* t1 = get the GCD of the two inputs */
/* divide the smallest by the GCD */
/* store quotient in t2 such that t2 * b is the LCM */
/* store quotient in t2 such that t2 * a is the LCM */
/* fix the sign to positive */
/* $Source: /cvs/libtom/libtommath/bn_mp_lcm.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_lshd.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift left a certain amount of digits */
/* if its less than zero return */
/* grow to fit the new digits */
/* increment the used by the shift amount then copy upwards */
/* top */
/* base */
/* much like mp_rshd this is implemented using a sliding window
/* zero the lower digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_lshd.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = a mod b, 0 <= c < b */
/* $Source: /cvs/libtom/libtommath/bn_mp_mod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mod_2d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* calc a value mod 2**b */
/* if b is <= 0 then zero the int */
/* if the modulus is larger than the value than return */
/* copy */
/* zero digits above the last digit of the modulus */
/* clear the digit that is not completely outside/inside the modulus */
/* $Source: /cvs/libtom/libtommath/bn_mp_mod_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mod_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_mp_mod_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_montgomery_calc_normalization.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/*
/* how many bits of last digit does b use */
/* now compute C = A * B mod b */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_calc_normalization.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_montgomery_reduce.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes xR**-1 == x (mod N) via Montgomery Reduction */
/* can the fast reduction [comba] method be used?
/* grow the input as required */
/* mu = ai * rho mod b
/* a = a + mu * m * b**i */
/* alias for digits of the modulus */
/* alias for the digits of x [the input] */
/* set the carry to zero */
/* Multiply and add in place */
/* compute product and sum */
/* get carry */
/* fix digit */
/* At this point the ix'th digit of x should be zero */
/* propagate carries upwards as required*/
/* at this point the n.used'th least
/* x = x/b**n.used */
/* if x >= n then x = x - n */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_montgomery_setup.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* setups the montgomery reduction stuff */
/* fast inversion mod 2**k
/* here x*a==1 mod 2**4 */
/* here x*a==1 mod 2**8 */
/* here x*a==1 mod 2**16 */
/* here x*a==1 mod 2**32 */
/* here x*a==1 mod 2**64 */
/* rho = -1/m mod b */
/* $Source: /cvs/libtom/libtommath/bn_mp_montgomery_setup.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mul.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level multiplication (handles sign) */
/* use Toom-Cook? */
/* use Karatsuba? */
/* can we use the fast multiplier?
/* uses s_mp_mul_digs */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mulmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a * b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_mulmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mul_2.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = a*2 */
/* grow to accomodate result */
/* alias for source */
/* alias for dest */
/* carry */
/* get what will be the *next* carry bit from the 
/* now shift up this digit, add in the carry [from the previous] */
/* copy the carry that would be from the source 
/* new leading digit? */
/* add a MSB which is always 1 at this point */
/* now zero any excess digits on the destination 
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_2.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mul_2d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift left by a certain bit count */
/* copy */
/* shift by as many digits in the bit count */
/* shift any bit count < DIGIT_BIT */
/* bitmask for carries */
/* shift for msbs */
/* alias */
/* carry */
/* get the higher bits of the current word */
/* shift the current word and OR in the carry */
/* set the carry to the carry bits of the current word */
/* set final carry */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_2d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_mul_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiply by a digit */
/* make sure c is big enough to hold a*b */
/* get the original destinations used count */
/* set the sign */
/* alias for a->dp [source] */
/* alias for c->dp [dest] */
/* zero carry */
/* compute columns */
/* compute product and carry sum for this term */
/* mask off higher bits to get a single digit */
/* send carry into next iteration */
/* store final carry [if any] and increment ix offset  */
/* now zero digits above the top */
/* set used count */
/* $Source: /cvs/libtom/libtommath/bn_mp_mul_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_neg.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* b = -a */
/* $Source: /cvs/libtom/libtommath/bn_mp_neg.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_n_root.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* find the n'th root of an integer 
/* input must be positive if b is even */
/* if a is negative fudge the sign but keep track */
/* t2 = 2 */
/* t1 = t2 */
/* t2 = t1 - ((t1**b - a) / (b * t1**(b-1))) */
/* t3 = t1**(b-1) */
/* numerator */
/* t2 = t1**b */
/* t2 = t1**b - a */
/* denominator */
/* t3 = t1**(b-1) * b  */
/* t3 = (t1**b - a)/(b * t1**(b-1)) */
/* result can be off by a few so check */
/* reset the sign of a first */
/* set the result */
/* set the sign of the result */
/* $Source: /cvs/libtom/libtommath/bn_mp_n_root.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_or.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* OR two ints together */
/* $Source: /cvs/libtom/libtommath/bn_mp_or.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_fermat.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* performs one Fermat test.
/* default to composite  */
/* ensure b > 1 */
/* init t */
/* compute t = b**a mod a */
/* is it equal to b? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_fermat.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_is_divisible.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if an integers is divisible by one 
/* default to not */
/* what is a mod LBL_prime_tab[ix] */
/* is the residue zero? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_is_divisible.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_is_prime.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* performs a variable number of rounds of Miller-Rabin
/* default to no */
/* valid value of t? */
/* is the input equal to one of the primes in the table? */
/* first perform trial division */
/* return if it was trivially divisible */
/* now perform the miller-rabin rounds */
/* set the prime */
/* passed the test */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_is_prime.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_miller_rabin.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* Miller-Rabin test of "a" to the base of "b" as described in 
/* default */
/* ensure b > 1 */
/* get n1 = a - 1 */
/* set 2**s * r = n1 */
/* count the number of least significant bits
/* now divide n - 1 by 2**s */
/* compute y = b**r mod a */
/* if y != 1 and y != n1 do */
/* while j <= s-1 and y != n1 */
/* if y == 1 then composite */
/* if y != n1 then composite */
/* probably prime now */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_miller_rabin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_next_prime.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* finds the next prime after the number "a" using "t" trials
/* ensure t is valid */
/* force positive */
/* simple algo if a is less than the largest prime in the table */
/* find which prime it is bigger than */
/* ok we found a prime smaller or
/* scan upwards for a prime congruent to 3 mod 4 */
/* at this point a maybe 1 */
/* fall through to the sieve */
/* generate a prime congruent to 3 mod 4 or 1/3 mod 4? */
/* at this point we will use a combination of a sieve and Miller-Rabin */
/* if a mod 4 != 3 subtract the correct value to make it so */
/* force odd */
/* generate the restable */
/* init temp used for Miller-Rabin Testing */
/* skip to the next non-trivially divisible candidate */
/* y == 1 if any residue was zero [e.g. cannot be prime] */
/* increase step to next candidate */
/* compute the new residue without using division */
/* add the step to each residue */
/* subtract the modulus [instead of using division] */
/* set flag if zero */
/* add the step */
/* if didn't pass sieve and step == MAX then skip test */
/* is this prime? */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_next_prime.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_rabin_miller_trials.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns # of RM trials required for a given bit size */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_rabin_miller_trials.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_prime_random_ex.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* makes a truly random prime of a given size (bits),
/* This is possibly the mother of all prime generation functions, muahahahahaha! */
/* sanity check the input */
/* LTM_PRIME_SAFE implies LTM_PRIME_BBS */
/* calc the byte size */
/* we need a buffer of bsize bytes */
/* calc the maskAND value for the MSbyte*/
/* calc the maskOR_msb */
/* get the maskOR_lsb */
/* read the bytes */
/* work over the MSbyte */
/* mix in the maskORs */
/* read it in */
/* is it prime? */
/* see if (a-1)/2 is prime */
/* is it prime? */
/* restore a to the original value */
/* $Source: /cvs/libtom/libtommath/bn_mp_prime_random_ex.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_radix_size.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* returns size of ASCII reprensentation */
/* special case for binary */
/* make sure the radix is in range */
/* digs is the digit count */
/* if it's negative add one for the sign */
/* init a copy of the input */
/* force temp to positive */
/* fetch out all of the digits */
/* return digs + 1, the 1 is for the NULL byte that would be required. */
/* $Source: /cvs/libtom/libtommath/bn_mp_radix_size.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_radix_smap.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* chars used in radix conversions */
/* $Source: /cvs/libtom/libtommath/bn_mp_radix_smap.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_rand.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* makes a pseudo-random int of a given size */
/* first place a random non-zero digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_rand.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_read_radix.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read a string [ASCII] in a given radix */
/* zero the digit bignum */
/* make sure the radix is ok */
/* if the leading digit is a 
/* set the integer to the default of zero */
/* process each digit of the string */
/* if the radix < 36 the conversion is case insensitive
/* if the char was found in the map 
/* set the sign only if a != 0 */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_radix.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_read_signed_bin.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* read signed bin, big endian, first byte is 0==positive or 1==negative */
/* read magnitude */
/* first byte is 0 for positive, non-zero for negative */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_signed_bin.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_read_unsigned_bin.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reads a unsigned char array, assumes the msb is stored first [big endian] */
/* make sure there are at least two digits */
/* zero the int */
/* read the bytes in */
/* $Source: /cvs/libtom/libtommath/bn_mp_read_unsigned_bin.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces x mod m, assumes 0 < x < m**2, mu is 
/* q = x */
/* q1 = x / b**(k-1)  */
/* according to HAC this optimization is ok */
/* q3 = q2 / b**(k+1) */
/* x = x mod b**(k+1), quick (no division) */
/* q = q * m mod b**(k+1), quick (no division) */
/* x = x - q */
/* If x < 0, add b**(k+1) to it */
/* Back off if it's too big */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_2k.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces a modulo n where n is of the form 2**p - d */
/* q = a/2**p, a = a mod 2**p */
/* q = q * d */
/* a = a + q */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_2k_l.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reduces a modulo n where n is of the form 2**p - d 
/* q = a/2**p, a = a mod 2**p */
/* q = q * d */
/* a = a + q */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_2k_setup.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_2k_setup_l.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines the setup value */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_2k_setup_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_is_2k.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if mp_reduce_2k can be used */
/* Test every bit from the second digit up, must be 1 */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_is_2k.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_is_2k_l.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* determines if reduce_2k_l can be used */
/* if more than half of the digits are -1 we're sold */
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_is_2k_l.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_reduce_setup.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* pre-calculate the value required for Barrett reduction
/* $Source: /cvs/libtom/libtommath/bn_mp_reduce_setup.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_rshd.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shift right a certain amount of digits */
/* if b <= 0 then ignore it */
/* if b > used then simply zero it and return */
/* shift the digits down */
/* bottom */
/* top [offset into digits] */
/* this is implemented as a sliding window where 
/* zero the top digits */
/* remove excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_rshd.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_set.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set to a digit */
/* $Source: /cvs/libtom/libtommath/bn_mp_set.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_set_int.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set a 32-bit const */
/* set four bits at a time */
/* shift the number up four bits */
/* OR in the top four bits of the source */
/* shift the source up to the next four bits */
/* ensure that digits are not clamped off */
/* $Source: /cvs/libtom/libtommath/bn_mp_set_int.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_shrink.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* shrink a bignum */
/* $Source: /cvs/libtom/libtommath/bn_mp_shrink.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_signed_bin_size.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the size for an signed equivalent */
/* $Source: /cvs/libtom/libtommath/bn_mp_signed_bin_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_sqr.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* computes b = a*a */
/* use Toom-Cook? */
/* Karatsuba? */
/* can we use the fast comba multiplier? */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_sqrmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* c = a * a (mod b) */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqrmod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_sqrt.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* this function is less generic than mp_n_root, simpler and faster */
/* must be positive */
/* easy out */
/* First approx. (not very bad for large arg) */
/* t1 > 0  */ 
/* And now t1 > sqrt(arg) */
/* t1 >= sqrt(arg) >= t2 at this point */
/* $Source: /cvs/libtom/libtommath/bn_mp_sqrt.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_sub.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* high level subtraction (handles signs) */
/* subtract a negative from a positive, OR */
/* subtract a positive from a negative. */
/* In either case, ADD their magnitudes, */
/* and use the sign of the first number. */
/* subtract a positive from a positive, OR */
/* subtract a negative from a negative. */
/* First, take the difference between their */
/* magnitudes, then... */
/* Copy the sign from the first */
/* The first has a larger or equal magnitude */
/* The result has the *opposite* sign from */
/* the first number. */
/* The second has a larger magnitude */
/* $Source: /cvs/libtom/libtommath/bn_mp_sub.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_submod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* d = a - b (mod c) */
/* $Source: /cvs/libtom/libtommath/bn_mp_submod.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_sub_d.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* single digit subtraction */
/* grow c as required */
/* if a is negative just do an unsigned
/* clamp */
/* setup regs */
/* if a <= b simply fix the single digit */
/* negative/1digit */
/* positive/size */
/* subtract first digit */
/* handle rest of the digits */
/* zero excess digits */
/* $Source: /cvs/libtom/libtommath/bn_mp_sub_d.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_toom_mul.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplication using the Toom-Cook 3-way algorithm 
/* init temps */
/* B */
/* a = a2 * B**2 + a1 * B + a0 */
/* b = b2 * B**2 + b1 * B + b0 */
/* w0 = a0*b0 */
/* w4 = a2 * b2 */
/* w1 = (a2 + 2(a1 + 2a0))(b2 + 2(b1 + 2b0)) */
/* w3 = (a0 + 2(a1 + 2a2))(b0 + 2(b1 + 2b2)) */
/* w2 = (a2 + a1 + a0)(b2 + b1 + b0) */
/* now solve the matrix 
/* r1 - r4 */
/* r3 - r0 */
/* r1/2 */
/* r3/2 */
/* r2 - r0 - r4 */
/* r1 - r2 */
/* r3 - r2 */
/* r1 - 8r0 */
/* r3 - 8r4 */
/* 3r2 - r1 - r3 */
/* r1 - r2 */
/* r3 - r2 */
/* r1/3 */
/* r3/3 */
/* at this point shift W[n] by B*n */
/* $Source: /cvs/libtom/libtommath/bn_mp_toom_mul.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_toom_sqr.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* squaring using Toom-Cook 3-way algorithm */
/* init temps */
/* B */
/* a = a2 * B**2 + a1 * B + a0 */
/* w0 = a0*a0 */
/* w4 = a2 * a2 */
/* w1 = (a2 + 2(a1 + 2a0))**2 */
/* w3 = (a0 + 2(a1 + 2a2))**2 */
/* w2 = (a2 + a1 + a0)**2 */
/* now solve the matrix
/* r1 - r4 */
/* r3 - r0 */
/* r1/2 */
/* r3/2 */
/* r2 - r0 - r4 */
/* r1 - r2 */
/* r3 - r2 */
/* r1 - 8r0 */
/* r3 - 8r4 */
/* 3r2 - r1 - r3 */
/* r1 - r2 */
/* r3 - r2 */
/* r1/3 */
/* r3/3 */
/* at this point shift W[n] by B*n */
/* $Source: /cvs/libtom/libtommath/bn_mp_toom_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_toradix.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* stores a bignum as a ASCII string in a given radix (2..64) */
/* check range of the radix */
/* quick out if its zero */
/* if it is negative output a - */
/* reverse the digits of the string.  In this case _s points
/* append a NULL so the string is properly terminated */
/* $Source: /cvs/libtom/libtommath/bn_mp_toradix.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_toradix_n.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* stores a bignum as a ASCII string in a given radix (2..64) 
/* check range of the maxlen, radix */
/* quick out if its zero */
/* if it is negative output a - */
/* we have to reverse our digits later... but not the - sign!! */
/* store the flag and mark the number as positive */
/* subtract a char */
/* no more room */
/* reverse the digits of the string.  In this case _s points
/* append a NULL so the string is properly terminated */
/* $Source: /cvs/libtom/libtommath/bn_mp_toradix_n.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_to_signed_bin.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in signed [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_signed_bin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_to_signed_bin_n.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in signed [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_signed_bin_n.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_to_unsigned_bin.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in unsigned [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_unsigned_bin.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_to_unsigned_bin_n.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* store in unsigned [big endian] format */
/* $Source: /cvs/libtom/libtommath/bn_mp_to_unsigned_bin_n.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_unsigned_bin_size.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* get the size for an unsigned equivalent */
/* $Source: /cvs/libtom/libtommath/bn_mp_unsigned_bin_size.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_xor.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* XOR two ints together */
/* $Source: /cvs/libtom/libtommath/bn_mp_xor.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_mp_zero.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* set to zero */
/* $Source: /cvs/libtom/libtommath/bn_mp_zero.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_prime_tab.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* $Source: /cvs/libtom/libtommath/bn_prime_tab.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_reverse.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* reverse an array, used for radix code */
/* $Source: /cvs/libtom/libtommath/bn_reverse.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_add.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level addition, based on HAC pp.594, Algorithm 14.7 */
/* find sizes, we let |a| <= |b| which means we have to sort
/* init result */
/* get old used digit count and set new one */
/* alias for digit pointers */
/* first input */
/* second input */
/* destination */
/* zero the carry */
/* Compute the sum at one digit, T[i] = A[i] + B[i] + U */
/* U = carry bit of T[i] */
/* take away carry bit from T[i] */
/* now copy higher words if any, that is in A+B 
/* T[i] = X[i] + U */
/* U = carry bit of T[i] */
/* take away carry bit from T[i] */
/* add carry */
/* clear digits above oldused */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_add.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_exptmod.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* find window size */
/* init M array */
/* init first cell */
/* now init the second half of the array */
/* create mu, used for Barrett reduction */
/* create M table
/* compute the value at M[1<<(winsize-1)] by squaring 
/* square it */
/* reduce modulo P */
/* create upper table, that is M[x] = M[x-1] * M[1] (mod P)
/* setup result */
/* set initial mode and bit cnt */
/* grab next digit as required */
/* if digidx == -1 we are out of digits */
/* read next digit and reset the bitcnt */
/* grab the next msb from the exponent */
/* if the bit is zero and mode == 0 then we ignore it
/* if the bit is zero and mode == 1 then we square */
/* else we add it to the window */
/* ok window is filled so square as required and multiply  */
/* square first */
/* then multiply */
/* empty window and reset */
/* if bits remain then square/multiply */
/* square then multiply if the bit is set */
/* then multiply */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_exptmod.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_mul_digs.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplies |a| * |b| and only computes upto digs digits of result
/* can we use the fast multiplier? */
/* compute the digits of the product directly */
/* set the carry to zero */
/* limit ourselves to making digs digits of output */
/* setup some aliases */
/* copy of the digit from a used within the nested loop */
/* an alias for the destination shifted ix places */
/* an alias for the digits of b */
/* compute the columns of the output and propagate the carry */
/* compute the column as a mp_word */
/* the new column is the lower part of the result */
/* get the carry word from the result */
/* set carry if it is placed below digs */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_mul_digs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_mul_high_digs.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* multiplies |a| * |b| and does not compute the lower digs digits
/* can we use the fast multiplier? */
/* clear the carry */
/* left hand side of A[ix] * B[iy] */
/* alias to the address of where the digits will be stored */
/* alias for where to read the right hand side from */
/* calculate the double precision result */
/* get the lower part */
/* carry the carry */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_mul_high_digs.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_sqr.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level squaring, b = a*a, HAC pp.596-597, Algorithm 14.16 */
/* default used is maximum possible size */
/* first calculate the digit at 2*ix */
/* calculate double precision result */
/* store lower part in result */
/* get the carry */
/* left hand side of A[ix] * A[iy] */
/* alias for where to store the results */
/* first calculate the product */
/* now calculate the double precision result, note we use
/* store lower part */
/* get carry */
/* propagate upwards */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_sqr.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\libtommath\bn_s_mp_sub.c
/* LibTomMath, multiple-precision integer library -- Tom St Denis
//libtom.org
/* low level subtraction (assumes |a| > |b|), HAC pp.595 Algorithm 14.9 */
/* find sizes */
/* init result */
/* alias for digit pointers */
/* set carry to zero */
/* T[i] = A[i] - B[i] - U */
/* U = carry bit of T[i]
/* Clear carry from T[i] */
/* now copy higher words if any, e.g. if A has more digits than B  */
/* T[i] = A[i] - U */
/* U = carry bit of T[i] */
/* Clear carry from T[i] */
/* clear digits above used (since we may not have grown result above) */
/* $Source: /cvs/libtom/libtommath/bn_s_mp_sub.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\lzma\C\LzFind.c
/* LzFind.c -- Match finder for LZ algorithms
/* it must be power of 2 */
/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
/* if (p->streamEndWasReached) return 0; */
/* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
/* don't change it! It's required for Deflate */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\lzma\C\LzFindMt.c
/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
/* MtSync_StopWriting must be called if Writing was started */
/* DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5) ^ (crc[p[4]] << 3)) & hashMask) */
/* #define MFMT_GM_INLINE */
/* Call it after ReleaseStream / SetStream */
/* ReleaseStream is required to finish multithreading */
/* p->MatchFinder->ReleaseStream(); */
/*
/* Condition: there are matches in btBuf with length < p->numHashBytes */
/*
/* case 4: */
/* p->GetHeadsFunc = GetHeads4; */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\lzma\C\LzmaDec.c
/* LzmaDec.c -- LZMA Decoder
/* #define _LZMA_SIZE_OPT */
/* First LZMA-symbol is always decoded.
/* (UInt32)((Int32)code >> 31) */
/*
/* unexpected end of input stream */
/* if (bufLimit - buf >= 7) return DUMMY_LIT; */
/* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
/* if (code >= range) code -= range; */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\lzma\C\LzmaEnc.c
/* LzmaEnc.c -- LZMA Encoder
/* #define SHOW_STAT */
/* #define SHOW_STAT2 */
/* #define LZMA_LOG_BSR */
/* Define it for Intel's CPU */
/*
/*
/* Stream.Init(); */
/* speed optimization */
/* try Literal + rep0 */
/* for (; lenTest2 >= 2; lenTest2--) */
/* speed optimization */
/* if (_maxMode) */
/* for (; lenTest2 >= 2; lenTest2--) */
/* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
/*2*/ startLen; ; lenTest++)
/*_maxMode && */lenTest == matches[offs])
/* Try Match + Literal + Rep0 */
/* for (; lenTest2 >= 2; lenTest2--) */
/* for GCC */
/* ReleaseMFStream(); */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\lzma\C\Threads.c
/* Threads.c -- multithreading library
/* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
/* maybe we must use errno here, but probably GetLastError() is also OK. */
/* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
/* InitializeCriticalSectionAndSpinCount(p, 0); */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\pklib\crc32.c
/*****************************************************************************/
/* crc32.c                                Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Pkware Data Compression Library Version 1.11                              */
/* Dissassembled method crc32 - cdecl version                                */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 09.04.03  1.00  Lad  The first version of crc32.c                         */
/* 02.05.03  1.00  Lad  Stress test done                                     */
/*****************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\pklib\explode.c
/*****************************************************************************/
/* explode.c                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Implode function of PKWARE Data Compression library                       */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.03.03  1.00  Lad  Splitted from Pkware.cpp                             */
/* 08.04.03  1.01  Lad  Renamed to explode.c to be compatible with pklib     */
/* 02.05.03  1.01  Lad  Stress test done                                     */
/* 22.04.10  1.01  Lad  Documented                                           */
/*****************************************************************************/
// All data from the input stream is read
// Need more data (dictionary)
// Internal flag, not returned to user
// Internal flag, not returned to user
//-----------------------------------------------------------------------------
// Tables
//-----------------------------------------------------------------------------
// Local functions
// [out] Table of positions
// [in] Table of start indexes
// [in] Table of lengths. Each length is stored as number of bits
// [in] Number of elements in start_indexes and length_bits
// Get the length in bytes
//-----------------------------------------------------------------------------
// Removes given number of bits in the bit buffer. New bits are reloaded from
// the input buffer, if needed.
// Returns: PKDCL_OK:         Operation was successful
//          PKDCL_STREAM_END: There are no more bits in the input buffer
// If number of bits required is less than number of (bits in the buffer) ?
// Load input buffer if necessary
// Update bit buffer
//-----------------------------------------------------------------------------
// Decodes next literal from the input (compressed) data.
// Returns : 0x000: One byte 0x00
//           0x001: One byte 0x01
//           ...
//           0x0FF: One byte 0xFF
//           0x100: Repetition, length of 0x02 bytes
//           0x101: Repetition, length of 0x03 bytes
//           ...
//           0x304: Repetition, length of 0x206 bytes
//           0x305: End of stream
//           0x306: Error
// Number of bits of extra literal length
// Length code
// Test the current bit in byte buffer. If is not set, simply return the next 8 bits.
// Remove one bit from the input data
// The next 8 bits hold the index to the length code table
// Remove the apropriate number of bits
// Are there some extra bits for the obtained length code ?
// In order to distinguish uncompressed byte from repetition length,
// we have to add 0x100 to the length.
// Remove one bit from the input data
// If the binary compression type, read 8 bits and return them as one byte.
// When ASCII compression ...
//-----------------------------------------------------------------------------
// Decodes the distance of the repetition, backwards relative to the
// current output buffer position
// Distance position code
// Number of bits of distance position
// Distance position
// Next 2-8 bits in the input buffer is the distance position code
// If the repetition is only 2 bytes length,
// then take 2 bits from the stream in order to get the distance
// If the repetition is more than 2 bytes length,
// then take "dsize_bits" bits in order to get the distance
// Literal decoded from the compressed data
// Value to be returned
// Number of bytes to copy to the output buffer
// Initialize output buffer position
// Decode the next literal from the input data.
// The returned literal can either be an uncompressed byte (next_literal < 0x100)
// or an encoded length of the repeating byte sequence that
// is to be copied to the current buffer position
// If the literal is greater than 0x100, it holds length
// of repeating byte sequence
// literal of 0x100 means repeating sequence of 0x2 bytes
// literal of 0x101 means repeating sequence of 0x3 bytes
// ...
// literal of 0x305 means repeating sequence of 0x207 bytes
// Length of the repetition, in bytes
// Backward distance to the repetition, relative to the current buffer position
// Get the length of the repeating sequence.
// Note that the repeating block may overlap the current output position,
// for example if there was a sequence of equal bytes
// Get backward distance to the repetition
// Target and source pointer
// Update buffer output position
// Copy the repeating sequence
// Flush the output buffer, if number of extracted bytes has reached the end
// Copy decompressed data into user buffer
// Now copy the decompressed data to the first half of the buffer.
// This is needed because the decompression might reuse them as repetitions.
// Note that if the output buffer overflowed previously, the extra decompressed bytes
// are stored in "out_buff_overflow", and they will now be
// within decompressed part of the output buffer.
// Flush any remaining decompressed bytes
//-----------------------------------------------------------------------------
// Main exploding function.
// Initialize work struct and load compressed data
// Note: The caller must zero the "work_buff" before passing it to explode
// Get the compression type (CMP_BINARY or CMP_ASCII)
// Get the dictionary size
// Initialize 16-bit bit buffer
// Extra (over 8) bits
// Position in input buffer
// Test for the valid dictionary size
// Shifted by 'sar' instruction
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\pklib\implode.c
/*****************************************************************************/
/* implode.c                              Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Implode function of PKWARE Data Compression library                       */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 11.04.03  1.00  Lad  First version of implode.c                           */
/* 02.05.03  1.00  Lad  Stress test done                                     */
/* 22.04.10  1.01  Lad  Documented                                           */
/*****************************************************************************/
// Fucking Microsoft VS.NET 2003 compiler !!! (_MSC_VER=1310)
//-----------------------------------------------------------------------------
// Defines
// The longest allowed repetition
//-----------------------------------------------------------------------------
// Tables
//-----------------------------------------------------------------------------
// Macros
// Macro for calculating hash of the current byte pair.
// Note that most exact byte pair hash would be buffer[0] + buffer[1] << 0x08,
// but even this way gives nice indication of equal byte pairs, with significantly
// smaller size of the array that holds numbers of those hashes
//-----------------------------------------------------------------------------
// Local functions
// Builds the "hash_to_index" table and "pair_hash_offsets" table.
// Every element of "hash_to_index" will contain lowest index to the
// "pair_hash_offsets" table, effectively giving offset of the first
// occurence of the given PAIR_HASH in the input data.
// Hash value of the byte pair
// Offset of the byte pair, relative to "work_buff"
// Zero the entire "phash_to_index" table
// Step 1: Count amount of each PAIR_HASH in the input buffer
// The table will look like this:
//  offs 0x000: Number of occurences of PAIR_HASH 0
//  offs 0x001: Number of occurences of PAIR_HASH 1
//  ...
//  offs 0x8F7: Number of occurences of PAIR_HASH 0x8F7 (the highest hash value)
// Step 2: Convert the table to the array of PAIR_HASH amounts. 
// Each element contains count of PAIR_HASHes that is less or equal
// to element index
// The table will look like this:
//  offs 0x000: Number of occurences of PAIR_HASH 0 or lower
//  offs 0x001: Number of occurences of PAIR_HASH 1 or lower
//  ...
//  offs 0x8F7: Number of occurences of PAIR_HASH 0x8F7 or lower
// Step 3: Convert the table to the array of indexes.
// Now, each element contains index to the first occurence of given PAIR_HASH
// If more than 8 bits to output, do recursion
// Add bits to the last out byte in out_buff;
// If 8 or more bits, increment number of bytes
// If there is enough compressed bytes, flush them
// This function searches for a repetition
// (a previous occurence of the current byte sequence)
// Returns length of the repetition, and stores the backward distance 
// to pWork structure.
// Pointer into pWork->phash_to_index table
// Pointer to the table containing offsets of each PAIR_HASH
// An eventual repetition must be at position below this pointer
// Pointer to the previous occurence of the current PAIR_HASH
// End of the previous repetition
// Index to the table with PAIR_HASH positions
// The lowest allowed hash offset
// Offset within found repetition
// Number of bytes that are equal to the previous occurence
// Length of the found repetition
// Secondary repetition
// Last but one byte from a repetion
// Calculate the previous position of the PAIR_HASH
// If the PAIR_HASH offset is below the limit, find a next one
// Get the first location of the PAIR_HASH,
// and thus the first eventual location of byte repetition
// If the current PAIR_HASH was not encountered before,
// we haven't found a repetition.
// We have found a match of a PAIR_HASH. Now we have to make sure
// that it is also a byte match, because PAIR_HASH is not unique.
// We compare the bytes and count the length of the repetition
// If the first byte of the repetition and the so-far-last byte
// of the repetition are equal, we will compare the blocks.
// Skip the current byte
// Now count how many more bytes are equal
// Are the bytes different ?
// If we found a repetition of at least the same length, take it.
// If there are multiple repetitions in the input buffer, this will
// make sure that we find the most recent one, which in turn allows
// us to store backward length in less amount of bits
// Calculate the backward distance of the repetition.
// Note that the distance is stored as decremented by 1
// Repetitions longer than 10 bytes will be stored in more bits,
// so they need a bit different handling
// Move forward in the table of PAIR_HASH repetitions.
// There might be a more recent occurence of the same repetition.
// If the next repetition is beyond the minimum allowed repetition, we are done.
// A repetition must have at least 2 bytes, otherwise it's not worth it
// If the repetition has max length of 0x204 bytes, we can't go any fuhrter
// Check for possibility of a repetition that occurs at more recent position
//
// The following part checks if there isn't a longer repetition at
// a latter offset, that would lead to better compression.
//
// Example of data that can trigger this optimization:
//
//   "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEQQQQQQQQQQQQ"
//   "XYZ"
//   "EEEEEEEEEEEEEEEEQQQQQQQQQQQQ";
//
// Description of data in this buffer
//   [0x00] Single byte "E"
//   [0x01] Single byte "E"
//   [0x02] Repeat 0x1E bytes from [0x00]
//   [0x20] Single byte "X"
//   [0x21] Single byte "Y"
//   [0x22] Single byte "Z"
//   [0x23] 17 possible previous repetitions of length at least 0x10 bytes:
//          - Repetition of 0x10 bytes from [0x00] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x10 bytes from [0x01] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x10 bytes from [0x02] "EEEEEEEEEEEEEEEE"
//          ...
//          - Repetition of 0x10 bytes from [0x0F] "EEEEEEEEEEEEEEEE"
//          - Repetition of 0x1C bytes from [0x10] "EEEEEEEEEEEEEEEEQQQQQQQQQQQQ"
//          The last repetition is the best one.
//
// Note: I failed to figure out what does the table "offs09BC" mean.
// If anyone has an idea, let me know to zezula_at_volny_dot_cz
// 
// Now go through all the repetitions from the first found one
// to the current input data, and check if any of them migh be
// a start of a greater sequence match.
//
// Get the pointer to the previous repetition
// Skip those repetitions that don't reach the end
// of the first found repetition
// Verify if the last but one byte from the repetition matches
// the last but one byte from the input data.
// If not, find a next repetition
// If the new repetition reaches beyond the end
// of previously found repetition, reset the repetition length to zero.
// Reset the length of the repetition to 2 bytes only
// Find out how many more characters are equal to the first repetition.
// Is the newly found repetion at least as long as the previous one ?
// Calculate the distance of the new repetition
// Update the additional elements in the "offs09BC" table
// to reflect new rep length
// Pointer to the end of the input data
// If 1, then all data from the input stream have been already loaded
// Saved length of current repetition
// Saved distance of current repetition
// Length of the found repetition
// 
// Store the compression type and dictionary size
// Reset output buffer to zero
// Load the bytes from the input stream, up to 0x1000 bytes
//
// Warning: The end of the buffer passed to "SortBuffer" is actually 2 bytes beyond
// valid data. It is questionable if this is actually a bug or not,
// but it might cause the compressed data output to be dependent on random bytes
// that are in the buffer. 
// To prevent that, the calling application must always zero the compression
// buffer before passing it to "implode"
//
// Search the PAIR_HASHes of the loaded blocks. Also, include
// previously compressed data, if any.
// Perform the compression of the current block
// Find if the current byte sequence wasn't there before.
// If we found repetition of 2 bytes, that is 0x100 or fuhrter back,
// don't bother. Storing the distance of 0x100 bytes would actually
// take more space than storing the 2 bytes as-is.
// When we are at the end of the input data, we cannot allow
// the repetition to go past the end of the input data.
// Shorten the repetition length so that it only covers valid data
// If we got repetition of 2 bytes, that is 0x100 or more backward, don't bother
// Try to find better repetition 1 byte later.
// Example: "ARROCKFORT" "AROCKFORT"
// When "input_data" points to the second string, FindRep
// returns the occurence of "AR". But there is longer repetition "ROCKFORT",
// beginning 1 byte after.
// Only use the new repetition if it's length is greater than the previous one
// If the new repetition if only 1 byte better
// and the previous distance is less than 0x80 bytes, use the previous repetition
// Flush one byte, so that input_data will point to the secondary repetition
// Revert to the previous repetition
// Move the begin of the input data by the length of the repetition
// If there was no previous repetition for the current position in the input data,
// just output the 9-bit literal for the one character
// Write the termination literal
//-----------------------------------------------------------------------------
// Main imploding function
// Fill the work buffer information
// Note: The caller must zero the "work_buff" before passing it to implode
// Test dictionary size
// 0x1000 bytes
// No break here !!!
// 0x800 bytes
// No break here !!!
// 0x400
// Test the compression type
// We will compress data with binary compression type
// We will compress data with ASCII compression type
// Copy the distance codes and distance bits and perform the compression
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\adler32.c
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* use NO_DIVIDE if your processor does not do division in hardware */
/* ========================================================================= */
/* split Adler-32 into component sums */
/* in case user likes doing a byte at a time, keep it fast */
/* initial Adler-32 value (deferred check for len == 1 speed) */
/* in case short lengths are provided, keep it somewhat fast */
/* only added so many BASE's */
/* do length NMAX blocks -- requires just one modulo operation */
/* NMAX is divisible by 16 */
/* 16 sums unrolled */
/* do remaining bytes (less than NMAX, still just one modulo) */
/* avoid modulos if none remaining */
/* return recombined sums */
/* ========================================================================= */
/* the derivation of this formula is left as an exercise for the reader */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\compress2.c
/* compress.c -- compress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* ===========================================================================
/* ===========================================================================
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\crc32.c
/* crc32.c -- compute the CRC-32 of a data stream
/* @(#) $Id$ */
/*
/* !DYNAMIC_CRC_TABLE */
/* MAKECRCH */
/* for STDC and FAR definitions */
/* Find a four-byte integer type for crc32_little() and crc32_big(). */
/* need ANSI C limits.h to determine sizes */
/* can't find a four-byte integer type! */
/* STDC */
/* !NOBYFOUR */
/* Definitions for doing the crc four data bytes at a time. */
/* BYFOUR */
/* Local functions for crc concatenation */
/* MAKECRCH */
/*
/* polynomial exclusive-or pattern */
/* terms of polynomial defining this crc (except x^32): */
/* flag to limit concurrent making */
/* See if another task is already doing this (not thread-safe, but better
/* make exclusive-or pattern from polynomial (0xedb88320UL) */
/* generate a crc for every 8-bit value */
/* generate crc for each value followed by one, two, and three zeros,
/* BYFOUR */
/* not first */
/* wait for the other guy to finish (not efficient, but rare) */
/* write out CRC tables to crc32.h */
/* crc32.h -- tables for rapid CRC calculation\n");
/* BYFOUR */
/* MAKECRCH */
/* MAKECRCH */
/* !DYNAMIC_CRC_TABLE */
/* ========================================================================
/* DYNAMIC_CRC_TABLE */
/* =========================================================================
/* DYNAMIC_CRC_TABLE */
/* ========================================================================= */
/* ========================================================================= */
/* DYNAMIC_CRC_TABLE */
/* BYFOUR */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* BYFOUR */
/* dimension of GF(2) vectors (length of CRC) */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* even-power-of-two zeros operator */
/* odd-power-of-two zeros operator */
/* degenerate case */
/* put operator for one zero bit in odd */
/* CRC-32 polynomial */
/* put operator for two zero bits in even */
/* put operator for four zero bits in odd */
/* apply len2 zeros to crc1 (first square will put the operator for one
/* apply zeros operator for this bit of len2 */
/* if no more bits set, then done */
/* another iteration of the loop with odd and even swapped */
/* if no more bits set, then done */
/* return combined crc */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\deflate.c
/* deflate.c -- compress data using the deflation algorithm
/*
//www.ietf.org/rfc/rfc1951.txt
/* @(#) $Id$ */
/*
/* ===========================================================================
/* block not completed, need more input or more output */
/* block flush performed */
/* finish started, need only more output at next deflate */
/* finish done, accept no more input or output */
/* Compression function. Returns the block state after the call. */
/* asm code initialization */
/* ===========================================================================
/* Tail of hash chains */
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
/* Minimum amount of lookahead, except at the end of the input file.
/* Values for max_lazy_match, good_match and max_chain_length, depending on
/* reduce lazy search above this match length */
/* do not perform lazy search above this match length */
/* quit search above this match length */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},
/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
/* result of memcmp for equal strings */
/* for buggy compilers */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* ========================================================================= */
/* To do: ignore strm->next_in if we use it as window */
/* ========================================================================= */
/* We overlay pending_buf and d_buf+l_buf. This works since the average
/* suppress zlib wrapper */
/* write gzip wrapper instead */
/* until 256-byte window bug fixed */
/* 16K elements by default */
/* ========================================================================= */
/* use the tail of the dictionary */
/* Insert all strings in the hash table (except for the last two bytes).
/* to make compiler happy */
/* ========================================================================= */
/* use zfree if we ever allocate msg dynamically */
/* was made negative by deflate(..., Z_FINISH); */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* Flush the last buffer: */
/* ========================================================================= */
/* =========================================================================
/* conservative upper bound */
/* if can't get parameters, return conservative bound */
/* if not default parameters, return conservative bound */
/* default settings: return tight bound for that case */
/* =========================================================================
/* =========================================================================
/* ========================================================================= */
/* value of flush param for previous deflate call */
/* just in case */
/* Write the header */
/* Save the adler32 of the preset dictionary: */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* Flush as much pending output as possible */
/* Since avail_out is 0, deflate will be called again with
/* Make sure there is something to do and avoid duplicate consecutive
/* User must not provide more input after the first FINISH: */
/* Start a new block or continue the current one.
/* avoid BUF_ERROR next call, see above */
/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
/* FULL_FLUSH or SYNC_FLUSH */
/* For a full flush, this empty block will be recognized
/* forget history */
/* avoid BUF_ERROR at next call, see above */
/* Write the trailer */
/* If avail_out is zero, the application will call deflate again
/* write the trailer only once! */
/* ========================================================================= */
/* Deallocate in reverse order of allocations: */
/* =========================================================================
/* following zmemcpy do not work for 16-bit MSDOS */
/* MAXSEG_64K */
/* ===========================================================================
/* ===========================================================================
/* Set the default configuration parameters:
/* initialize the asm code */
/* ===========================================================================
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
/* current match */
/* max hash chain length */
/* current string */
/* matched string */
/* length of current match */
/* best match length so far */
/* stop if match long enough */
/* Stop when cur_match becomes <= limit. To simplify the code,
/* Compare two bytes at a time. Note: this is not always beneficial.
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Do not waste too much time if we already have a good match: */
/* Do not look for matches beyond the end of the input. This is necessary
/* Skip to next match if the match length cannot increase
/* This code assumes sizeof(unsigned short) == 2. Do not use
/* It is not necessary to compare scan[2] and match[2] since they are
/* The funny "do {}" generates better code on most compilers */
/* Here, scan <= window+strstart+257 */
/* UNALIGNED_OK */
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* UNALIGNED_OK */
/* ASMV */
/* FASTEST */
/* ---------------------------------------------------------------------------
/* current match */
/* current string */
/* matched string */
/* length of current match */
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Return failure if the match length is less than 2:
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* ===========================================================================
/* check that the match is indeed a match */
/* DEBUG */
/* ===========================================================================
/* Amount of free space at the end of the window. */
/* Deal with !@#$% 64K limit: */
/* Very unlikely, but possible on 16 bit machine if
/* If the window is almost full and there is insufficient lookahead,
/* we now have strstart >= MAX_DIST */
/* Slide the hash table (could be avoided with 32 bit values
/* %%% avoid this when Z_RLE */
/* If n is not on any hash chain, prev[n] is garbage but
/* If there was no sliding:
/* Initialize the hash value now that we have some input: */
/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
/* ===========================================================================
/* Same but force premature exit if necessary. */
/* ===========================================================================
/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
/* Copy as much as possible from input to output: */
/* Fill the window as much as possible: */
/* flush the current block */
/* Emit a stored block if pending_buf will be full: */
/* strstart == 0 is possible when wraparound on 16-bit machine */
/* Flush if we may have to slide, otherwise block_start may become
/* ===========================================================================
/* head of the hash chain */
/* set if current block must be flushed */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() or longest_match_fast() sets match_start */
/* Insert new strings in the hash table only if the match length
/* string at strstart already in table */
/* strstart never exceeds WSIZE-MAX_MATCH, so there are
/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
/* No match, output a literal byte */
/* ===========================================================================
/* head of hash chain */
/* set if current block must be flushed */
/* Process the input block. */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() or longest_match_fast() sets match_start */
/* If prev_match is also MIN_MATCH, match_start is garbage
/* If there was a match at the previous step and the current
/* Do not insert strings in hash table beyond this. */
/* Insert in hash table all strings up to the end of the match.
/* If there was no match at the previous position, output a
/* There is no previous match to compare with, wait for
/* FASTEST */
/* ===========================================================================
/* set if current block must be flushed */
/* length of run */
/* maximum length of run */
/* byte at distance one to match */
/* scan for end of run */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* See how many times the previous byte repeats */
/* if there is a previous byte, that is */
/* Emit match if have run of MIN_MATCH or longer, else emit literal */
/* No match, output a literal byte */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\inffast.c
/* inffast.c -- fast decoding
/* Allow machine dependent optimization for post-increment or pre-increment.
/*
/* inflate()'s starting value for strm->avail_out */
/* local strm->next_in */
/* while in < last, enough input available */
/* local strm->next_out */
/* inflate()'s initial strm->next_out */
/* while out < end, enough space available */
/* maximum distance from zlib header */
/* window size or zero if not using window */
/* valid bytes in the window */
/* window write index */
/* allocated sliding window, if wsize != 0 */
/* local strm->hold */
/* local strm->bits */
/* local strm->lencode */
/* local strm->distcode */
/* mask for first level of length codes */
/* mask for first level of distance codes */
/* retrieved table entry */
/* code bits, operation, extra bits, or */
/*  window position, window bytes to copy */
/* match length, unused bytes */
/* match distance */
/* where to copy match from */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* literal */
/* length base */
/* number of extra bits */
/* distance base */
/* number of extra bits */
/* max distance in output */
/* see if copy from window */
/* distance back in window */
/* very common case */
/* some from window */
/* rest from output */
/* wrap around window */
/* some from end of window */
/* some from start of window */
/* rest from output */
/* contiguous in window */
/* some from window */
/* rest from output */
/* copy direct from output */
/* minimum length is three */
/* 2nd level distance code */
/* 2nd level length code */
/* end-of-block */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
/*
/* !ASMINF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\inflate.c
/* inflate.c -- zlib decompression
/*
/* function prototypes */
/* to support ill-conceived Java test suite */
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/*
/* inffixed.h -- table for decoding fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/*
/* if it hasn't been done already, allocate space for the window */
/* if window not in use yet, initialize */
/* copy state->wsize or less output bytes into the circular window */
/* Macros for inflate(): */
/* check function to use adler32() for zlib or crc32() for gzip */
/* check macros for header crc */
/* Load registers with state in inflate() for speed */
/* Restore state from registers in inflate() */
/* Clear the input bit accumulator */
/* Get a byte of input into the bit accumulator, or return from inflate()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Reverse the bytes in a 32-bit value */
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* save starting available input and output */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* buffer for gzip header crc calculation */
/* permutation of code lengths */
/* skip check */
/* gzip header */
/* expect zlib header */
/* check if zlib header allowed */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* go to byte boundary */
/* handle error breaks in while */
/* build code tables */
/* copy from window */
/* copy from output */
/*
/* check state */
/* check for correct dictionary id */
/* copy dictionary to window */
/* check state */
/* save header structure */
/*
/* number of bytes to look at or looked at */
/* temporary to save total_in and total_out */
/* to restore bit buffer to byte string */
/* check parameters */
/* if first time, start search in bit buffer */
/* search available input */
/* return no joy or set up to restart inflate() on a new block */
/*
/* check input */
/* allocate space */
/* copy state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\inftrees.c
/* inftrees.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..29 base */
/* Distance codes 0..29 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no symbols to code at all */
/* invalid code marker */
/* make a table to force an error */
/* no symbols, but wait for decoding to report error */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* save offset to next table */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* here min is 1 << curr */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/*
/* invalid code marker */
/* when done with sub-table, drop back to root table */
/* put invalid code marker in table */
/* backwards increment the len-bit code huff */
/* set return parameters */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\trees.c
/* trees.c -- output deflated data using Huffman coding
/*
/* @(#) $Id$ */
/* #define GEN_TREES_H */
/* ===========================================================================
/* Bit length codes must not exceed MAX_BL_BITS bits */
/* end of block literal code */
/* repeat previous bit length 3-6 times (2 bits of repeat count) */
/* repeat a zero length 3-10 times  (3 bits of repeat count) */
/* repeat a zero length 11-138 times  (7 bits of repeat count) */
/* extra bits for each length code */
/* extra bits for each distance code */
/* extra bits for each bit length code */
/* The lengths of the bit length codes are sent in order of decreasing
/* Number of bits used within bi_buf. (bi_buf might be implemented on
/* ===========================================================================
/* see definition of array dist_code below */
/* non ANSI compilers may not accept trees.h */
/* The static literal tree. Since the bit lengths are imposed, there is no
/* The static distance tree. (Actually a trivial tree since all codes use
/* Distance codes. The first 256 values correspond to the distances
/* length code for each normalized match length (0 == MIN_MATCH) */
/* First normalized length for each code (0 = MIN_MATCH) */
/* First normalized distance for each code (0 = distance of 1) */
/* GEN_TREES_H */
/* static tree or NULL */
/* extra bits for each code or NULL */
/* base index for extra_bits */
/* max number of elements in the tree */
/* max bit length for the codes */
/* ===========================================================================
/* Send a code of the given tree. c and tree must not have side effects */
/* DEBUG */
/* ===========================================================================
/* ===========================================================================
/* value to send */
/* number of bits */
/* If not enough room in bi_buf, use (valid) bits from bi_buf and
/* !DEBUG */
/* DEBUG */
/* the arguments must not have side effects */
/* ===========================================================================
/* iterates over tree elements */
/* bit counter */
/* length value */
/* code value */
/* distance index */
/* number of codes at each bit length for an optimal tree */
/* For some embedded targets, global variables are not initialized: */
/* Initialize the mapping length (0..255) -> length code (0..28) */
/* Note that the length 255 (match length 258) can be represented
/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
/* from now on, all distances are divided by 128 */
/* Construct the codes of the static literal tree */
/* Codes 286 and 287 do not exist, but we must include them in the
/* The static distance tree is trivial: */
/* defined(GEN_TREES_H) || !defined(STDC) */
/* ===========================================================================
/* header created automatically with -DGEN_TREES_H */\n\n");
/* GEN_TREES_H */
/* ===========================================================================
/* enough lookahead for inflate */
/* Initialize the first block of the first file: */
/* ===========================================================================
/* iterates over tree elements */
/* Initialize the trees. */
/* Index within the heap array of least frequent node in the Huffman tree */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the tree to restore */
/* node to move down */
/* left son of k */
/* Set j to the smallest of the two sons: */
/* Exit if v is smaller than both sons */
/* Exchange v with the smallest son */
/* And continue down the tree, setting j to the left son of k */
/* ===========================================================================
/* the tree descriptor */
/* heap index */
/* iterate over the tree elements */
/* bit length */
/* extra bits */
/* frequency */
/* number of elements with bit length too large */
/* In a first pass, compute the optimal bit lengths (which may
/* root of the heap */
/* We overwrite tree[n].Dad which is no longer needed */
/* not a leaf node */
/* This happens for example on obj2 and pic of the Calgary corpus */
/* Find the first bit length which could increase: */
/* move one leaf down the tree */
/* move one overflow item as its brother */
/* The brother of the overflow item also moves one step up,
/* Now recompute all bit lengths, scanning in increasing frequency.
/* ===========================================================================
/* the tree to decorate */
/* largest code with non zero frequency */
/* number of codes at each bit length */
/* next code value for each bit length */
/* running code value */
/* bit index */
/* code index */
/* The distribution counts are first used to generate the code values
/* Check that the bit counts in bl_count are consistent. The last code
/* Now reverse the bits */
/* ===========================================================================
/* the tree descriptor */
/* iterate over heap elements */
/* largest code with non zero frequency */
/* new node being created */
/* Construct the initial heap, with least frequent element in
/* The pkzip format requires that at least one distance code exists,
/* node is 0 or 1 so it does not have extra bits */
/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
/* Construct the Huffman tree by repeatedly combining the least two
/* next internal node of the tree */
/* n = node of least frequency */
/* m = node of next least frequency */
/* keep the nodes sorted by frequency */
/* Create a new node father of n and m */
/* and insert the new node in the heap */
/* At this point, the fields freq and dad are set. We can now
/* The field len is now set, we can generate the bit codes */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* guard */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* tree[max_code+1].Len = -1; */  /* guard already set */
/* ===========================================================================
/* index of last bit length code of non zero freq */
/* Determine the bit length frequencies for literal and distance trees */
/* Build the bit length tree: */
/* opt_len now includes the length of the tree representations, except
/* Determine the number of bit length codes to send. The pkzip format
/* Update opt_len to include the bit length tree and counts */
/* ===========================================================================
/* number of codes for each tree */
/* index in bl_order */
/* not +255 as stated in appnote.txt */
/* not -3 as stated in appnote.txt */
/* literal tree */
/* distance tree */
/* ===========================================================================
/* input block */
/* length of input block */
/* true if this is the last block for a file */
/* send block type */
/* with header */
/* ===========================================================================
/* 3 for block type, 7 for EOB */
/* Of the 10 bits for the empty block, we have already sent
/* ===========================================================================
/* input block, or NULL if too old */
/* length of input block */
/* true if this is the last block for a file */
/* opt_len and static_len in bytes */
/* index of last bit length code of non zero freq */
/* Build the Huffman trees unless a stored block is forced */
/* Check if the file is binary or text */
/* Construct the literal and distance trees */
/* At this point, opt_len and static_len are the total bit lengths of
/* Build the bit length tree for the above two trees, and get the index
/* Determine the best encoding. Compute the block lengths in bytes. */
/* force a stored block */
/* force stored block */
/* 4: two words for the lengths */
/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
/* force static trees */
/* The above check is made mod 2^32, for files larger than 512 MB
/* align on byte boundary */
/* ===========================================================================
/* distance of matched string */
/* match length-MIN_MATCH or unmatched char (if dist==0) */
/* lc is the unmatched char */
/* Here, lc is the match length - MIN_MATCH */
/* dist = match distance - 1 */
/* Try to guess if it is profitable to stop the current block here */
/* Compute an upper bound for the compressed length */
/* We avoid equality with lit_bufsize because of wraparound at 64K
/* ===========================================================================
/* literal tree */
/* distance tree */
/* distance of matched string */
/* match length or unmatched char (if dist == 0) */
/* running index in l_buf */
/* the code to send */
/* number of extra bits to send */
/* send a literal byte */
/* Here, lc is the match length - MIN_MATCH */
/* send the length code */
/* send the extra length bits */
/* dist is now the match distance - 1 */
/* send the distance code */
/* send the extra distance bits */
/* literal or match pair ? */
/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
/* ===========================================================================
/* ===========================================================================
/* the value to invert */
/* its bit length */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the input data */
/* its length */
/* true if block header must be written */
/* align on byte boundary */
/* enough lookahead for inflate */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\src\zlib\zutil.c
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* for buggy compilers */
/* Z_NEED_DICT       2  */
/* Z_STREAM_END      1  */
/* Z_OK              0  */
/* Z_ERRNO         (-1) */
/* Z_STREAM_ERROR  (-2) */
/* Z_DATA_ERROR    (-3) */
/* Z_MEM_ERROR     (-4) */
/* Z_BUF_ERROR     (-5) */
/* Z_VERSION_ERROR (-6) */
/* exported to allow conversion of error code to string for compress() and
/* The Microsoft C Run-Time Library for Windows CE doesn't have
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Turbo C in 16-bit mode */
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* M_I86 */
/* SYS16BIT */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\StormLib\stormlib_dll\DllMain.c
/*****************************************************************************/
/* DllMain.c                              Copyright (c) Ladislav Zezula 2006 */
/*---------------------------------------------------------------------------*/
/* Description: DllMain for the StormLib.dll library                         */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* 23.11.06  1.00  Lad  The first version of DllMain.c                       */
/*****************************************************************************/
//-----------------------------------------------------------------------------
// DllMain
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\adler32.c
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* use NO_DIVIDE if your processor does not do division in hardware --
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
/* this assumes a is not negative */ \
/* ========================================================================= */
/* split Adler-32 into component sums */
/* in case user likes doing a byte at a time, keep it fast */
/* initial Adler-32 value (deferred check for len == 1 speed) */
/* in case short lengths are provided, keep it somewhat fast */
/* only added so many BASE's */
/* do length NMAX blocks -- requires just one modulo operation */
/* NMAX is divisible by 16 */
/* 16 sums unrolled */
/* do remaining bytes (less than NMAX, still just one modulo) */
/* avoid modulos if none remaining */
/* return recombined sums */
/* ========================================================================= */
/* for negative len, return invalid adler32 as a clue for debugging */
/* the derivation of this formula is left as an exercise for the reader */
/* assumes len2 >= 0 */
/* ========================================================================= */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\compress.c
/* compress.c -- compress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* ===========================================================================
/* ===========================================================================
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\crc32.c
/* crc32.c -- compute the CRC-32 of a data stream
/* @(#) $Id$ */
/*
/* !DYNAMIC_CRC_TABLE */
/* MAKECRCH */
/* for STDC and FAR definitions */
/* Definitions for doing the crc four data bytes at a time. */
/* BYFOUR */
/* Local functions for crc concatenation */
/* MAKECRCH */
/*
/* polynomial exclusive-or pattern */
/* terms of polynomial defining this crc (except x^32): */
/* flag to limit concurrent making */
/* See if another task is already doing this (not thread-safe, but better
/* make exclusive-or pattern from polynomial (0xedb88320UL) */
/* generate a crc for every 8-bit value */
/* generate crc for each value followed by one, two, and three zeros,
/* BYFOUR */
/* not first */
/* wait for the other guy to finish (not efficient, but rare) */
/* write out CRC tables to crc32.h */
/* crc32.h -- tables for rapid CRC calculation\n");
/* BYFOUR */
/* MAKECRCH */
/* MAKECRCH */
/* !DYNAMIC_CRC_TABLE */
/* ========================================================================
/* DYNAMIC_CRC_TABLE */
/* =========================================================================
/* DYNAMIC_CRC_TABLE */
/* ========================================================================= */
/* ========================================================================= */
/* DYNAMIC_CRC_TABLE */
/* BYFOUR */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* BYFOUR */
/* dimension of GF(2) vectors (length of CRC) */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* even-power-of-two zeros operator */
/* odd-power-of-two zeros operator */
/* degenerate case (also disallow negative lengths) */
/* put operator for one zero bit in odd */
/* CRC-32 polynomial */
/* put operator for two zero bits in even */
/* put operator for four zero bits in odd */
/* apply len2 zeros to crc1 (first square will put the operator for one
/* apply zeros operator for this bit of len2 */
/* if no more bits set, then done */
/* another iteration of the loop with odd and even swapped */
/* if no more bits set, then done */
/* return combined crc */
/* ========================================================================= */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\deflate.c
/* deflate.c -- compress data using the deflation algorithm
/*
//tools.ietf.org/html/rfc1951
/* @(#) $Id$ */
/*
/* ===========================================================================
/* block not completed, need more input or more output */
/* block flush performed */
/* finish started, need only more output at next deflate */
/* finish done, accept no more input or output */
/* Compression function. Returns the block state after the call. */
/* asm code initialization */
/* ===========================================================================
/* Tail of hash chains */
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
/* Values for max_lazy_match, good_match and max_chain_length, depending on
/* reduce lazy search above this match length */
/* do not perform lazy search above this match length */
/* quit search above this match length */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},
/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
/* result of memcmp for equal strings */
/* for buggy compilers */
/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* ========================================================================= */
/* To do: ignore strm->next_in if we use it as window */
/* ========================================================================= */
/* We overlay pending_buf and d_buf+l_buf. This works since the average
/* suppress zlib wrapper */
/* write gzip wrapper instead */
/* until 256-byte window bug fixed */
/* nothing written to s->window yet */
/* 16K elements by default */
/* ========================================================================= */
/* when using zlib wrappers, compute Adler-32 for provided dictionary */
/* avoid computing Adler-32 in read_buf */
/* if dictionary would fill window, just replace the history */
/* already empty otherwise */
/* use the tail */
/* insert dictionary into window and hash */
/* ========================================================================= */
/* use zfree if we ever allocate msg dynamically */
/* was made negative by deflate(..., Z_FINISH); */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* Flush the last buffer: */
/* ========================================================================= */
/* =========================================================================
/* conservative upper bound for compressed data */
/* if can't get parameters, return conservative bound plus zlib wrapper */
/* compute wrapper length */
/* raw deflate */
/* zlib wrapper */
/* gzip wrapper */
/* user-supplied gzip header */
/* for compiler happiness */
/* if not default parameters, return conservative bound */
/* default settings: return tight bound for that case */
/* =========================================================================
/* =========================================================================
/* ========================================================================= */
/* value of flush param for previous deflate call */
/* just in case */
/* Write the header */
/* Save the adler32 of the preset dictionary: */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* Flush as much pending output as possible */
/* Since avail_out is 0, deflate will be called again with
/* Make sure there is something to do and avoid duplicate consecutive
/* User must not provide more input after the first FINISH: */
/* Start a new block or continue the current one.
/* avoid BUF_ERROR next call, see above */
/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
/* FULL_FLUSH or SYNC_FLUSH */
/* For a full flush, this empty block will be recognized
/* forget history */
/* avoid BUF_ERROR at next call, see above */
/* Write the trailer */
/* If avail_out is zero, the application will call deflate again
/* write the trailer only once! */
/* ========================================================================= */
/* Deallocate in reverse order of allocations: */
/* =========================================================================
/* following zmemcpy do not work for 16-bit MSDOS */
/* MAXSEG_64K */
/* ===========================================================================
/* ===========================================================================
/* Set the default configuration parameters:
/* initialize the asm code */
/* ===========================================================================
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
/* current match */
/* max hash chain length */
/* current string */
/* matched string */
/* length of current match */
/* best match length so far */
/* stop if match long enough */
/* Stop when cur_match becomes <= limit. To simplify the code,
/* Compare two bytes at a time. Note: this is not always beneficial.
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Do not waste too much time if we already have a good match: */
/* Do not look for matches beyond the end of the input. This is necessary
/* Skip to next match if the match length cannot increase
/* This code assumes sizeof(unsigned short) == 2. Do not use
/* It is not necessary to compare scan[2] and match[2] since they are
/* The funny "do {}" generates better code on most compilers */
/* Here, scan <= window+strstart+257 */
/* UNALIGNED_OK */
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* UNALIGNED_OK */
/* ASMV */
/* FASTEST */
/* ---------------------------------------------------------------------------
/* current match */
/* current string */
/* matched string */
/* length of current match */
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Return failure if the match length is less than 2:
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* FASTEST */
/* ===========================================================================
/* check that the match is indeed a match */
/* DEBUG */
/* ===========================================================================
/* Amount of free space at the end of the window. */
/* Deal with !@#$% 64K limit: */
/* Very unlikely, but possible on 16 bit machine if
/* If the window is almost full and there is insufficient lookahead,
/* we now have strstart >= MAX_DIST */
/* Slide the hash table (could be avoided with 32 bit values
/* If n is not on any hash chain, prev[n] is garbage but
/* If there was no sliding:
/* Initialize the hash value now that we have some input: */
/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
/* If the WIN_INIT bytes after the end of the current data have never been
/* Previous high water mark below current data -- zero WIN_INIT
/* High water mark at or above current data, but below current data
/* ===========================================================================
/* Same but force premature exit if necessary. */
/* ===========================================================================
/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
/* Copy as much as possible from input to output: */
/* Fill the window as much as possible: */
/* flush the current block */
/* Emit a stored block if pending_buf will be full: */
/* strstart == 0 is possible when wraparound on 16-bit machine */
/* Flush if we may have to slide, otherwise block_start may become
/* ===========================================================================
/* head of the hash chain */
/* set if current block must be flushed */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* Insert new strings in the hash table only if the match length
/* string at strstart already in table */
/* strstart never exceeds WSIZE-MAX_MATCH, so there are
/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
/* No match, output a literal byte */
/* ===========================================================================
/* head of hash chain */
/* set if current block must be flushed */
/* Process the input block. */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* If prev_match is also MIN_MATCH, match_start is garbage
/* If there was a match at the previous step and the current
/* Do not insert strings in hash table beyond this. */
/* Insert in hash table all strings up to the end of the match.
/* If there was no match at the previous position, output a
/* There is no previous match to compare with, wait for
/* FASTEST */
/* ===========================================================================
/* set if current block must be flushed */
/* byte at distance one to match */
/* scan goes up to strend for length of run */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* See how many times the previous byte repeats */
/* Emit match if have run of MIN_MATCH or longer, else emit literal */
/* No match, output a literal byte */
/* ===========================================================================
/* set if current block must be flushed */
/* Make sure that we have a literal to write. */
/* flush the current block */
/* Output a literal byte */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\gzclose.c
/* gzclose.c -- zlib gzclose() function
/* gzclose() is in a separate file so that it is linked in only if it is used.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\gzlib.c
/* gzlib.c -- zlib functions common to reading and writing gzip files
/* Local functions */
/* Map the Windows error number in ERROR to a locale-dependent error message
/* Default language */
/* If there is an \r\n appended, zap it.  */
/* UNDER_CE */
/* Reset gzip file state */
/* no output data available */
/* for reading ... */
/* not at end of file */
/* have not read past end yet */
/* look for gzip header */
/* no seek request pending */
/* clear error */
/* no uncompressed data yet */
/* no input data yet */
/* Open a gzip file either by name or file descriptor. */
/* check input */
/* allocate gzFile structure to return */
/* no buffers allocated yet */
/* requested buffer size */
/* no error message yet */
/* interpret mode */
/* can't read and write at the same time */
/* ignore -- will request binary anyway */
/* could consider as an error, but just ignore */
/* must provide an "r", "w", or "a" */
/* can't force transparent read */
/* for empty file */
/* save the path name for error messages */
/* compute the flags for open() */
/* open the file with the appropriate flags (or just use fd) */
/* simplify later checks */
/* save the current position for rewinding (only if reading) */
/* initialize stream */
/* return stream */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* identifier for error messages */
/* for debugging */
/* for debugging */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* make sure we haven't already allocated memory */
/* check and set requested size */
/* need two bytes to check magic header */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no error */
/* back up and start over */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* check that there's no error */
/* can only seek from start or relative to current position */
/* normalize offset to a SEEK_CUR specification */
/* if within raw area while reading, just go there */
/* calculate skip amount, rewinding if needed for back seek when reading */
/* writing -- can't go backwards */
/* before start of file! */
/* rewind, then skip to offset */
/* if reading, skip what's in output buffer (one less gzgetc() check) */
/* request skip (if not zero) */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return position */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* compute and return effective offset in file */
/* reading */
/* don't count buffered input */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return end-of-file state */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return error information */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* clear error and end-of-file */
/* Create an error message in allocated memory and set state->err and
/* free previously allocated message and clear */
/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
/* set error code, and if no message, then done */
/* for an out of memory error, return literal string when requested */
/* construct error message with path */
/* portably return maximum value for an int (when limits.h presumed not
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\gzread.c
/* gzread.c -- zlib functions for reading gzip files
/* Local functions */
/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
/* Load up input buffer and set eof flag if last data loaded -- return -1 on
/* copy what's there to the start */
/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
/* allocate read buffers and inflate memory */
/* allocate buffers */
/* allocate inflate memory */
/* gunzip */
/* get at least the magic bytes in the input buffer */
/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
/* no gzip header -- if we were decoding gzip before, then this is trailing
/* doing raw i/o, copy any leftover input to output -- this assumes that
/* Decompress from input to the provided next_out and avail_out in the state.
/* fill output buffer up to end of deflate stream */
/* get more input for inflate() */
/* decompress and handle errors */
/* deflate stream invalid */
/* update available output */
/* if the gzip stream completed successfully, look for another */
/* good decompression */
/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
/* -> LOOK, COPY (only if never GZIP), or GZIP */
/* -> COPY */
/* -> GZIP or LOOK (if end of gzip stream) */
/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
/* skip over len bytes or reach end-of-file, whichever comes first */
/* skip over whatever is in output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* need more data to skip -- load up output buffer */
/* get more output, looking for header if required */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* process a skip request */
/* get len bytes to buf, or less than len if at the end */
/* first just try copying data from the output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* tried to read past end */
/* need output data -- for small len or new stream load up our output
/* get more output, looking for header if required */
/* no progress yet -- go back to copy above */
/* the copy above assures that we will leave with space in the
/* large len -- read directly into user buffer */
/* read directly */
/* large len -- decompress directly into user buffer */
/* state->how == GZIP */
/* update progress */
/* return number of bytes read into user buffer (will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* try output buffer (no need to check for skip request) */
/* nothing there -- try gzread() */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* can't push EOF */
/* if output buffer empty, put byte at end (allows more pushing) */
/* if no room, give up (must have already done a gzungetc()) */
/* slide output data if needed and insert byte before existing data */
/* -- see zlib.h -- */
/* check parameters and get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* copy output bytes up to new line or len - 1, whichever comes first --
/* assure that something is in the output buffer */
/* error */
/* end of file */
/* read past end */
/* return what we have */
/* look for end-of-line in current output buffer */
/* copy through end-of-line, or remainder if not found */
/* return terminated string, or if nothing, end of file */
/* -- see zlib.h -- */
/* get internal structure */
/* if the state is not known, but we can find out, then do so (this is
/* return 1 if transparent, 0 if processing a gzip stream */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading */
/* free memory and close file */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\gzwrite.c
/* gzwrite.c -- zlib functions for writing gzip files
/* Local functions */
/* Initialize state for writing a gzip file.  Mark initialization by setting
/* allocate input buffer */
/* only need output buffer and deflate state if compressing */
/* allocate output buffer */
/* allocate deflate memory, set up for gzip compression */
/* mark state as initialized */
/* initialize write buffer if compressing */
/* Compress whatever is at avail_in and next_in and write to the output file.
/* allocate memory if this is the first time through */
/* write directly if requested */
/* run deflate() on provided input until it produces no more output */
/* write out current buffer contents if full, or if flushing, but if
/* compress */
/* if that completed a deflate stream, allow another to start */
/* all done, no errors */
/* Compress len zeros to output.  Return -1 on error, 0 on success. */
/* consume whatever's left in the input buffer */
/* compress len zeros (len guaranteed > 0) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* allocate memory if this is the first time through */
/* check for seek request */
/* for small len, copy to input buffer, otherwise compress directly */
/* copy to input buffer, compress when full */
/* consume whatever's left in the input buffer */
/* directly compress user buffer to file */
/* input was all buffered or compressed (put will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check for seek request */
/* try writing to input buffer for speed (state->size == 0 if buffer not
/* no room in buffer or not initialized, use gz_write() */
/* -- see zlib.h -- */
/* write string */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* !STDC && !Z_HAVE_STDARG_H */
/* -- see zlib.h -- */
/* get internal structure */
/* check that can really pass pointer in ints */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check flush parameter */
/* check for seek request */
/* compress remaining data with requested flush */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* if no change is requested, then do nothing */
/* check for seek request */
/* change compression parameters for subsequent input */
/* flush previous input with previous parameters before changing */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing */
/* check for seek request */
/* flush, free memory, and close file */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\infback.c
/* infback.c -- inflate using a call-back interface
/*
/* function prototypes */
/*
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/* Macros for inflateBack(): */
/* Load returned state from inflate_fast() */
/* Set state from registers for inflate_fast() */
/* Clear the input bit accumulator */
/* Assure that some input is available.  If input is requested, but denied,
/* Get a byte of input into the bit accumulator, or return from inflateBack()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Assure that some output space is available, by writing out the window
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* permutation of code lengths */
/* Check that the strm exists and that the state was initialized */
/* Reset the state */
/* Inflate until end of block marked as last */
/* determine and dispatch block type */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* get and verify stored block length */
/* go to byte boundary */
/* copy stored block from input to output */
/* get dynamic table entries descriptor */
/* get code length code lengths (not a typo) */
/* get length and distance code code lengths */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* use inflate_fast() if we have enough input and output */
/* get a literal, length, or end-of-block code */
/* process literal */
/* process end of block */
/* invalid code */
/* length code -- get extra bits, if any */
/* get distance code */
/* get distance extra bits, if any */
/* copy match from window to output */
/* inflate stream terminated properly -- write leftover output */
/* can't happen, but makes compilers happy */
/* Return unused input */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\inffast.c
/* inffast.c -- fast decoding
/* Allow machine dependent optimization for post-increment or pre-increment.
/*
/* inflate()'s starting value for strm->avail_out */
/* local strm->next_in */
/* have enough input while in < last */
/* local strm->next_out */
/* inflate()'s initial strm->next_out */
/* while out < end, enough space available */
/* maximum distance from zlib header */
/* window size or zero if not using window */
/* valid bytes in the window */
/* window write index */
/* allocated sliding window, if wsize != 0 */
/* local strm->hold */
/* local strm->bits */
/* local strm->lencode */
/* local strm->distcode */
/* mask for first level of length codes */
/* mask for first level of distance codes */
/* retrieved table entry */
/* code bits, operation, extra bits, or */
/*  window position, window bytes to copy */
/* match length, unused bytes */
/* match distance */
/* where to copy match from */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* literal */
/* length base */
/* number of extra bits */
/* distance base */
/* number of extra bits */
/* max distance in output */
/* see if copy from window */
/* distance back in window */
/* very common case */
/* some from window */
/* rest from output */
/* wrap around window */
/* some from end of window */
/* some from start of window */
/* rest from output */
/* contiguous in window */
/* some from window */
/* rest from output */
/* copy direct from output */
/* minimum length is three */
/* 2nd level distance code */
/* 2nd level length code */
/* end-of-block */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
/*
/* !ASMINF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\inflate.c
/* inflate.c -- zlib decompression
/*
/* function prototypes */
/* to support ill-conceived Java test suite */
/* get the state */
/* extract wrap request from windowBits parameter */
/* set number of window bits, free window if different */
/* update state and reset the rest of it */
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/*
/* inffixed.h -- table for decoding fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/*
/* if it hasn't been done already, allocate space for the window */
/* if window not in use yet, initialize */
/* copy state->wsize or less output bytes into the circular window */
/* Macros for inflate(): */
/* check function to use adler32() for zlib or crc32() for gzip */
/* check macros for header crc */
/* Load registers with state in inflate() for speed */
/* Restore state from registers in inflate() */
/* Clear the input bit accumulator */
/* Get a byte of input into the bit accumulator, or return from inflate()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* save starting available input and output */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* buffer for gzip header crc calculation */
/* permutation of code lengths */
/* skip check */
/* gzip header */
/* expect zlib header */
/* check if zlib header allowed */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* go to byte boundary */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* copy from window */
/* copy from output */
/*
/* check state */
/* copy dictionary */
/* check state */
/* check for correct dictionary identifier */
/* copy dictionary to window using updatewindow(), which will amend the
/* check state */
/* save header structure */
/*
/* number of bytes to look at or looked at */
/* temporary to save total_in and total_out */
/* to restore bit buffer to byte string */
/* check parameters */
/* if first time, start search in bit buffer */
/* search available input */
/* return no joy or set up to restart inflate() on a new block */
/*
/* check input */
/* allocate space */
/* copy state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\inftrees.c
/* inftrees.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..29 base */
/* Distance codes 0..29 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no symbols to code at all */
/* invalid code marker */
/* make a table to force an error */
/* no symbols, but wait for decoding to report error */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* save offset to next table */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* here min is 1 << curr */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/* fill in remaining table entry if code is incomplete (guaranteed to have
/* invalid code marker */
/* set return parameters */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\trees.c
/* trees.c -- output deflated data using Huffman coding
/*
/* @(#) $Id$ */
/* #define GEN_TREES_H */
/* ===========================================================================
/* Bit length codes must not exceed MAX_BL_BITS bits */
/* end of block literal code */
/* repeat previous bit length 3-6 times (2 bits of repeat count) */
/* repeat a zero length 3-10 times  (3 bits of repeat count) */
/* repeat a zero length 11-138 times  (7 bits of repeat count) */
/* extra bits for each length code */
/* extra bits for each distance code */
/* extra bits for each bit length code */
/* The lengths of the bit length codes are sent in order of decreasing
/* ===========================================================================
/* see definition of array dist_code below */
/* non ANSI compilers may not accept trees.h */
/* The static literal tree. Since the bit lengths are imposed, there is no
/* The static distance tree. (Actually a trivial tree since all codes use
/* Distance codes. The first 256 values correspond to the distances
/* length code for each normalized match length (0 == MIN_MATCH) */
/* First normalized length for each code (0 = MIN_MATCH) */
/* First normalized distance for each code (0 = distance of 1) */
/* GEN_TREES_H */
/* static tree or NULL */
/* extra bits for each code or NULL */
/* base index for extra_bits */
/* max number of elements in the tree */
/* max bit length for the codes */
/* ===========================================================================
/* Send a code of the given tree. c and tree must not have side effects */
/* DEBUG */
/* ===========================================================================
/* ===========================================================================
/* value to send */
/* number of bits */
/* If not enough room in bi_buf, use (valid) bits from bi_buf and
/* !DEBUG */
/* DEBUG */
/* the arguments must not have side effects */
/* ===========================================================================
/* iterates over tree elements */
/* bit counter */
/* length value */
/* code value */
/* distance index */
/* number of codes at each bit length for an optimal tree */
/* For some embedded targets, global variables are not initialized: */
/* Initialize the mapping length (0..255) -> length code (0..28) */
/* Note that the length 255 (match length 258) can be represented
/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
/* from now on, all distances are divided by 128 */
/* Construct the codes of the static literal tree */
/* Codes 286 and 287 do not exist, but we must include them in the
/* The static distance tree is trivial: */
/* defined(GEN_TREES_H) || !defined(STDC) */
/* ===========================================================================
/* header created automatically with -DGEN_TREES_H */\n\n");
/* GEN_TREES_H */
/* ===========================================================================
/* Initialize the first block of the first file: */
/* ===========================================================================
/* iterates over tree elements */
/* Initialize the trees. */
/* Index within the heap array of least frequent node in the Huffman tree */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the tree to restore */
/* node to move down */
/* left son of k */
/* Set j to the smallest of the two sons: */
/* Exit if v is smaller than both sons */
/* Exchange v with the smallest son */
/* And continue down the tree, setting j to the left son of k */
/* ===========================================================================
/* the tree descriptor */
/* heap index */
/* iterate over the tree elements */
/* bit length */
/* extra bits */
/* frequency */
/* number of elements with bit length too large */
/* In a first pass, compute the optimal bit lengths (which may
/* root of the heap */
/* We overwrite tree[n].Dad which is no longer needed */
/* not a leaf node */
/* This happens for example on obj2 and pic of the Calgary corpus */
/* Find the first bit length which could increase: */
/* move one leaf down the tree */
/* move one overflow item as its brother */
/* The brother of the overflow item also moves one step up,
/* Now recompute all bit lengths, scanning in increasing frequency.
/* ===========================================================================
/* the tree to decorate */
/* largest code with non zero frequency */
/* number of codes at each bit length */
/* next code value for each bit length */
/* running code value */
/* bit index */
/* code index */
/* The distribution counts are first used to generate the code values
/* Check that the bit counts in bl_count are consistent. The last code
/* Now reverse the bits */
/* ===========================================================================
/* the tree descriptor */
/* iterate over heap elements */
/* largest code with non zero frequency */
/* new node being created */
/* Construct the initial heap, with least frequent element in
/* The pkzip format requires that at least one distance code exists,
/* node is 0 or 1 so it does not have extra bits */
/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
/* Construct the Huffman tree by repeatedly combining the least two
/* next internal node of the tree */
/* n = node of least frequency */
/* m = node of next least frequency */
/* keep the nodes sorted by frequency */
/* Create a new node father of n and m */
/* and insert the new node in the heap */
/* At this point, the fields freq and dad are set. We can now
/* The field len is now set, we can generate the bit codes */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* guard */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* tree[max_code+1].Len = -1; */  /* guard already set */
/* ===========================================================================
/* index of last bit length code of non zero freq */
/* Determine the bit length frequencies for literal and distance trees */
/* Build the bit length tree: */
/* opt_len now includes the length of the tree representations, except
/* Determine the number of bit length codes to send. The pkzip format
/* Update opt_len to include the bit length tree and counts */
/* ===========================================================================
/* number of codes for each tree */
/* index in bl_order */
/* not +255 as stated in appnote.txt */
/* not -3 as stated in appnote.txt */
/* literal tree */
/* distance tree */
/* ===========================================================================
/* input block */
/* length of input block */
/* one if this is the last block for a file */
/* send block type */
/* with header */
/* ===========================================================================
/* ===========================================================================
/* 3 for block type, 7 for EOB */
/* ===========================================================================
/* input block, or NULL if too old */
/* length of input block */
/* one if this is the last block for a file */
/* opt_len and static_len in bytes */
/* index of last bit length code of non zero freq */
/* Build the Huffman trees unless a stored block is forced */
/* Check if the file is binary or text */
/* Construct the literal and distance trees */
/* At this point, opt_len and static_len are the total bit lengths of
/* Build the bit length tree for the above two trees, and get the index
/* Determine the best encoding. Compute the block lengths in bytes. */
/* force a stored block */
/* force stored block */
/* 4: two words for the lengths */
/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
/* force static trees */
/* The above check is made mod 2^32, for files larger than 512 MB
/* align on byte boundary */
/* ===========================================================================
/* distance of matched string */
/* match length-MIN_MATCH or unmatched char (if dist==0) */
/* lc is the unmatched char */
/* Here, lc is the match length - MIN_MATCH */
/* dist = match distance - 1 */
/* Try to guess if it is profitable to stop the current block here */
/* Compute an upper bound for the compressed length */
/* We avoid equality with lit_bufsize because of wraparound at 64K
/* ===========================================================================
/* literal tree */
/* distance tree */
/* distance of matched string */
/* match length or unmatched char (if dist == 0) */
/* running index in l_buf */
/* the code to send */
/* number of extra bits to send */
/* send a literal byte */
/* Here, lc is the match length - MIN_MATCH */
/* send the length code */
/* send the extra length bits */
/* dist is now the match distance - 1 */
/* send the distance code */
/* send the extra distance bits */
/* literal or match pair ? */
/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
/* ===========================================================================
/* black_mask is the bit mask of black-listed bytes
/* Check for non-textual ("black-listed") bytes. */
/* Check for textual ("white-listed") bytes. */
/* There are no "black-listed" or "white-listed" bytes:
/* ===========================================================================
/* the value to invert */
/* its bit length */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the input data */
/* its length */
/* true if block header must be written */
/* align on byte boundary */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\uncompr.c
/* uncompr.c -- decompress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/SkyFire_548-master\SkyFire_548-master\dep\zlib\zutil.c
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* for buggy compilers */
/* Z_NEED_DICT       2  */
/* Z_STREAM_END      1  */
/* Z_OK              0  */
/* Z_ERRNO         (-1) */
/* Z_STREAM_ERROR  (-2) */
/* Z_DATA_ERROR    (-3) */
/* Z_MEM_ERROR     (-4) */
/* Z_BUF_ERROR     (-5) */
/* Z_VERSION_ERROR (-6) */
/* exported to allow conversion of error code to string for compress() and
/* The Microsoft C Run-Time Library for Windows CE doesn't have
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Turbo C in 16-bit mode */
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* M_I86 */
/* SYS16BIT */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
/* !Z_SOLO */
