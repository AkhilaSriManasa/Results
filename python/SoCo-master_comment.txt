#!/usr/bin/env python
# Code from here: https://pytest.org/latest/goodpractises.html
# we don't run integration tests which need an actual Sonos device
# import here, cause outside the eggs aren't loaded
# Extract name and e-mail ("Firstname Lastname <mail@example.org>")
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pylint: disable=E0611,R0913
# Temporarily re-directing stderr to StringIO to prevent start-up message
# from rdpcap import
# Text bits that starts and ends the Sonos UPnP content
# Use the file name as prefix if none is given
# Check if the file is present, since rdpcap will not do that
# Due probably to a bug in rdpcap, this kind of error raises a
# NameError, because the exception that is tried to raise, is not
# defined
# See if there is a field called load
# Will cause AttributeError if there is no load
# Get the full load
# If the load is ??
# If there is a start in load
# and there is also an end
# If there is an end in load
# If there is an open WSPart
# Ignore ends before start
# If there is an open WSPart
# else ignore
# " + line for line in message.strip().split("\r\n")]
#" * 78, message))
# If open message and no_prefix is False
# Defaulting to 80 on windows, better ideas are welcome, but the
# solutions I found online are rather bulky
# Coerce in range
# Coerce in range
# Clear the screen
# Ugly hack until someone figures out a better way for Windows
# probably something with a cls command, but I cannot test it
# Clear screen
# Content
# Paging functionality
# Coerce in range
# Menu
# Assume less than 100 pages
# 2-3 for menu, 1 for cursor
# Blank line
# Too large line
# The line(s) can be added to the current page
# End the page and start a new
# Add the remainder
# Analyze initial xml part
# Get encoding
# Extract and replace inner DIDL xml in tags
# Extract and replace inner DIDL xml in properties in inner xml
# print tree
# print repr(self.body_formatted)
# sys.exit(1)
# Start the chosen mode
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# get a zone player - any one will do
# loop over each of the available services
# pylint: disable=no-member
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# soco documentation build configuration file, created by
# sphinx-quickstart on Mon Sep 14 08:03:37 2015.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.
# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(0, os.path.abspath('.'))
# -- General configuration ------------------------------------------------
# If your documentation needs a minimal Sphinx version, state it here.
# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
# Add any paths that contain templates here, relative to this directory.
# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
# source_suffix = ['.rst', '.md']
# The encoding of source files.
# source_encoding = 'utf-8-sig'
# The master toctree document.
# General information about the project.
# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
# The full version, including alpha/beta/rc tags.
# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'
# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# The reST default role (used for this markup: `text`) to use for all
# documents.
# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True
# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True
# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False
# The name of the Pygments (syntax highlighting) style to use.
# A list of ignored prefixes for module index sorting.
# If true, keep warnings as "system message" paragraphs in the built documents.
# If true, `todo` and `todoList` produce output, else they produce nothing.
# Allow auto links into the Python and Requests docs
# Shortcuts to Github Issues etc. Use them like this:
# :issue:`123` (which will generate a link to issue 123)
#'),
#')
# Document members by default, and in source order. This allows the stub files
# in the api directory to be much shorter.
# Concatenate the class and __init__ docstrings
# Nicer inheritance graphs for RTD theme.  NB the image map does not rescale
# properly, so we have had to add some javascript to handle it.  See
# _templates and _static
# -- Options for HTML output ----------------------------------------------
# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}
# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []
# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None
# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None
# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = None
# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None
# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
# html_extra_path = []
# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'
# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True
# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}
# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}
# If false, no module index is generated.
# html_domain_indices = True
# If false, no index is generated.
# html_use_index = True
# If true, the index is split into individual pages for each letter.
# html_split_index = False
# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True
# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True
# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True
# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''
# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None
# Language to be used for generating the HTML full-text search index.
# Sphinx supports the following languages:
#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
# html_search_language = 'en'
# A dictionary with options for the search language support, empty by default.
# Now only 'ja' uses this config value
# html_search_options = {'type': 'default'}
# The name of a javascript file (relative to the configuration directory) that
# implements a search results scorer. If empty, the default will be used.
# html_search_scorer = 'scorer.js'
# Output file base name for HTML help builder.
# -- Options for LaTeX output ---------------------------------------------
# The paper size ('letterpaper' or 'a4paper').
# 'papersize': 'letterpaper',
# The font size ('10pt', '11pt' or '12pt').
# 'pointsize': '10pt',
# Additional stuff for the LaTeX preamble.
# 'preamble': '',
# Latex figure (float) alignment
# 'figure_align': 'htbp',
# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None
# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False
# If true, show page references after internal links.
# latex_show_pagerefs = False
# If true, show URL addresses after external links.
# latex_show_urls = False
# Documents to append as an appendix to all manuals.
# latex_appendices = []
# If false, no module index is generated.
# latex_domain_indices = True
# -- Options for manual page output ---------------------------------------
# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
# If true, show URL addresses after external links.
# man_show_urls = False
# -- Options for Texinfo output -------------------------------------------
# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
# Documents to append as an appendix to all manuals.
# texinfo_appendices = []
# If false, no module index is generated.
# texinfo_domain_indices = True
# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'
# If true, do not generate a @detailmenu in the "Top" node's menu.
# texinfo_no_detailmenu = False
# -- Options for Epub output ----------------------------------------------
# Bibliographic Dublin Core info.
# The basename for the epub file. It defaults to the project name.
# epub_basename = project
# The HTML theme for the epub output. Since the default themes are not
# optimized for small screen space, using the same theme for HTML and epub
# output is usually not wise. This defaults to 'epub', a theme designed to
# save visual space.
# epub_theme = 'epub'
# The language of the text. It defaults to the language option
# or 'en' if the language is not set.
# epub_language = ''
# The scheme of the identifier. Typical schemes are ISBN or URL.
# epub_scheme = ''
# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
# epub_identifier = ''
# A unique identification for the text.
# epub_uid = ''
# A tuple containing the cover image and cover page html template filenames.
# epub_cover = ()
# A sequence of (type, uri, title) tuples for the guide element of content.opf.
# epub_guide = ()
# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_pre_files = []
# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_post_files = []
# A list of files that should not be packed into the epub file.
# The depth of the table of contents in toc.ncx.
# epub_tocdepth = 3
# Allow duplicate toc entries.
# epub_tocdup = True
# Choose between 'default' and 'includehidden'.
# epub_tocscope = 'default'
# Fix unsupported image types using the Pillow.
# epub_fix_images = False
# Scale large images.
# epub_max_image_width = 0
# How to display URL addresses: 'footnote', 'no', or 'inline'.
# epub_show_urls = 'inline'
# If false, no index is generated.
# epub_use_index = True
#!/usr/bin/env python
# TODO seems at least & needs to be escaped - should move this to
# play_uri and maybe escape other chars.
# Python 3
# Python 2
# Make a list of music files, right now it is done by collection all files
# below the current folder whose extension does not start with .py
# This will probably need to be modded for other pusposes.
# urlencode all the path parts (but not the /'s)
# play_from_queue indexes are 0-based
# Rather hackish way to get the local ip-address, recipy from
# https://stackoverflow.com/a/166589
# Settings
# Get the zone
# Check if a zone by the given name was found
# Check whether the zone is a coordinator (stand alone zone or
# master of a group)
# Setup and start the http server
# When the http server is setup you can really add your files in
# any way that is desired. The source code for
# add_random_file_from_present_folder is just an example, but it may be
# helpful in figuring out how to format the urls
# Remember the http server runs in its own daemonized thread, so it is
# necessary to keep the main thread alive. So sleep for 3 years.
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This illustrates how to use SoCo plugins
# an example plugin is provided in soco.plugins.example.ExamplePlugin
# get a plugin by name (eg from a config file)
# do something with your plugin
# create a plugin by normal instantiation
# create a new plugin, pass the soco instance to it
# do something with your plugin
# something to play on a Sonos player to start (a radio station)
# alert sound to interrupt the above (a poem) - use amy file Sonos can play
# choose device
# <--change IP to one of your Sonos devices
# start playing something on this device(a radio station)
# pause to ensure radio station playing
# take snapshot of current state
# 1) create a Snapshot class for this device
# 2) take a snapshot of this device's status
# Do something that changes what's playing on this device
# increase volume
# play an alert sound
# wait for a bit !
# Restore previous state of Sonos (with slow fade up)
# Use soco.snapshot to capture current state of each zone to allow restore
# prepare all zones for playing the alert
# Each Sonos group has one coordinator only these can play, pause, etc.
# can't pause TV - so don't try!
# pause music for each coordinators if playing
# For every Sonos player set volume and mute for every zone
# play the sound (uri) on each sonos coordinator
# wait for alert_duration
# restore each zone to previous state
# alert uri to send to sonos - this uri must be available to Sonos
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# pylint: disable=C0103
# Mon, Tue, Wed
# Sat
# Mon, Tue, Wed, Thur
# Too many digits
# create an alarm with default properties
# save the alarm to the Sonos system
# update the alarm
# Save it again for the change to take effect
# Remove it
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments
#: `datetime.time`: The alarm's start time.
#: `datetime.time`: The alarm's duration.
#: `bool`: `True` if the alarm is enabled, else `False`.
#:
#: `str`: The uri to play.
#: `bool`: `True` if the alarm should be played on the other speakers
#: in the same group, `False` otherwise.
# max 100
# Coerce in range
# pylint: disable=bad-continuation
# The alarm has been saved before. Update it instead.
# Get a soco instance to query. It doesn't matter which.
# An alarm list looks like this:
# <Alarms>
#     <Alarm ID="14" StartTime="07:00:00"
#         Duration="02:00:00" Recurrence="DAILY" Enabled="1"
#         RoomUUID="RINCON_000ZZZZZZ1400"
#         ProgramURI="x-rincon-buzzer:0" ProgramMetaData=""
#         PlayMode="SHUFFLE_NOREPEAT" Volume="25"
#         IncludeLinkedZones="0"/>
#     <Alarm ID="15" StartTime="07:00:00"
#         Duration="02:00:00" Recurrence="DAILY" Enabled="1"
#         RoomUUID="RINCON_000ZZZZZZ01400"
#         ProgramURI="x-rincon-buzzer:0" ProgramMetaData=""
#         PlayMode="SHUFFLE_NOREPEAT" Volume="25"
#          IncludeLinkedZones="0"/>
# </Alarms>
# pylint: disable=protected-access
# If an instance already exists for this ID, update and return it.
# Otherwise, create a new one and populate its values
# NB StartTime, not
# StartLocalTime, which is used by CreateAlarm
# some alarms are not associated to zones -> filter these out
# -*- coding: utf-8 -*-
# pylint: disable=not-context-manager,useless-object-inheritance
# NOTE: The pylint not-content-manager warning is disabled pending the fix of
# a bug in pylint: https://github.com/PyCQA/pylint/issues/782
# NOTE: useless-object-inheritance needed for Python 2.x compatability
# pylint: disable=no-self-use, unused-argument
#: `bool`: whether the cache is enabled
# Fetch the item again, by providing the same args and kwargs.
# Providing different args or kwargs will not return the item.
# Waiting for less than the provided timeout does not cause the
# item to expire.
# But waiting for longer does.
#: `int`: The default caching expiry interval in seconds.
# A thread lock for the cache
# Look in the cache to see if there is an unexpired item. If there is
# we can just return the cached result.
# Lock and load
# An expired item is present - delete it
# Nothing found
# Check for a timeout keyword, store and remove it.
# Store the item, along with the time at which it will expire
# This is not entirely straightforward, since args and kwargs may
# contain mutable items and unicode. Possibilities include using
# __repr__, frozensets, and code from Py3's LRU cache. But pickle
# works, and although it is not as fast as some methods, it is good
# enough at the moment
# -*- coding: utf-8 -*-
# pylint: disable=unused-import,import-error,no-name-in-module,
# pylint: disable=ungrouped-imports
# python 3
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# python 2.7
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# noqa
# python 2.7 - this has to be done the other way round
# noqa
# python 3
# noqa
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
# pylint: disable=fixme, protected-access
# pylint: disable=too-few-public-methods,no-init
# pylint: disable=R0904,too-many-instance-attributes
# pylint: disable=super-on-old-class
# Note: Creation of a SoCo instance should be as cheap and quick as
# possible. Do not make any network calls here
# Check if ip_address is a valid IPv4 representation.
# Sonos does not (yet) support IPv6
#: The speaker's ip address
# Stores information about the current speaker
# The services which we use
# pylint: disable=invalid-name
# Some private attributes
# We could get the name like this:
# result = self.deviceProperties.GetZoneAttributes()
# return result["CurrentZoneName"]
# but it is probably quicker to get it from the group topology
# and take advantage of any caching
# Since this does not change over time (?) check whether we already
# know the answer. If so, there is no need to go further
# if not, we have to get it from the zone topology, which
# is probably quicker than any alternative, since the zgt is probably
# cached. This will set self._uid for us for next time, so we won't
# have to do this again
# An alternative way of getting the uid is as follows:
# self.device_description_url = \
#    'http://{0}:1400/xml/device_description.xml'.format(
#     self.ip_address)
# response = requests.get(self.device_description_url).text
# tree = XML.fromstring(response.encode('utf-8'))
# udn = tree.findtext('.//{urn:schemas-upnp-org:device-1-0}UDN')
# # the udn has a "uuid:" prefix before the uid, so we need to strip it
# self._uid = uid = udn[5:]
# return uid
# Since this does not change over time (?) check whether we already
# know the answer. If so, return the cached version
# We could do this:
# invisible = self.deviceProperties.GetInvisible()['CurrentInvisible']
# but it is better to do it in the following way, which uses the
# zone group topology, to capitalise on any caching.
# Since this does not change over time (?) check whether we already
# know the answer. If so, there is no need to go further
# if not, we have to get it from the zone topology. This will set
# self._is_bridge for us for next time, so we won't have to do this
# again
# We could do this:
# invisible = self.deviceProperties.GetInvisible()['CurrentInvisible']
# but it is better to do it in the following way, which uses the
# zone group topology, to capitalise on any caching.
# Only for symmetry with the setter
# Sonos will automatically handle out-of-range adjustments
# Grab the speaker's information if we haven't already since we'll need
# it in the next step.
# first, set the queue itself as the source URI
#0'.format(self.uid)
# second, set the track number with a seek command
# finally, just play what's set if needed
# pylint: disable=too-many-arguments
# Radio stations need to have at least a title to play
# change uri prefix to force radio style display and commands
# The track is enqueued, now play it if needed
# Coerce in range
# Coerce in range
# Coerce in range
# Coerce in range
# Coerce in range
# zoneGroupTopology.GetZoneGroupState()['ZoneGroupState'] returns XML like
# this:
#
# <ZoneGroups>
#   <ZoneGroup Coordinator="RINCON_000XXX1400" ID="RINCON_000XXXX1400:0">
#     <ZoneGroupMember
#         BootSeq="33"
#         Configuration="1"
#         Icon="x-rincon-roomicon:zoneextender"
#         Invisible="1"
#         IsZoneBridge="1"
#         Location="http://192.168.1.100:1400/xml/device_description.xml"
#         MinCompatibleVersion="22.0-00000"
#         SoftwareVersion="24.1-74200"
#         UUID="RINCON_000ZZZ1400"
#         ZoneName="BRIDGE"/>
#   </ZoneGroup>
#   <ZoneGroup Coordinator="RINCON_000XXX1400" ID="RINCON_000XXX1400:46">
#     <ZoneGroupMember
#         BootSeq="44"
#         Configuration="1"
#         Icon="x-rincon-roomicon:living"
#         Location="http://192.168.1.101:1400/xml/device_description.xml"
#         MinCompatibleVersion="22.0-00000"
#         SoftwareVersion="24.1-74200"
#         UUID="RINCON_000XXX1400"
#         ZoneName="Living Room"/>
#     <ZoneGroupMember
#         BootSeq="52"
#         Configuration="1"
#         Icon="x-rincon-roomicon:kitchen"
#         Location="http://192.168.1.102:1400/xml/device_description.xml"
#         MinCompatibleVersion="22.0-00000"
#         SoftwareVersion="24.1-74200"
#         UUID="RINCON_000YYY1400"
#         ZoneName="Kitchen"/>
#   </ZoneGroup>
# </ZoneGroups>
#
# Create a SoCo instance for each member. Because SoCo
# instances are singletons, this is cheap if they have already
# been created, and useful if they haven't. We can then
# update various properties for that instance.
# uid doesn't change, but it's not harmful to (re)set it, in case
# the zone is as yet unseen.
# add the zone to the set of all members, and to the set
# of visible members if appropriate
# This is called quite frequently, so it is worth optimising it.
# Maintain a private cache. If the zgt has not changed, there is no
# need to repeat all the XML parsing. In addition, switch on network
# caching for a short interval (5 secs).
# Empty the set of all zone_groups
# and the set of all members
# Loop over each ZoneGroup Element
# Perform extra processing relevant to direct zone group
# members
#
# If this element has the same UUID as the coordinator, it is
# the coordinator
# is_bridge doesn't change, but it does no real harm to
# set/reset it here, just in case the zone has not been seen
# before
# add the zone to the members for this group
# Loop over Satellite elements if present, and process as for
# ZoneGroup elements
# Assume a satellite can't be a bridge or coordinator, so
# no need to check.
#
# Add the zone to the members for this group.
# Now create a ZoneGroup with this info and add it to the list
# of groups
# To get the group directly from the network, try the code below
# though it is probably slower than that above
# current_group_id = self.zoneGroupTopology.GetZoneGroupAttributes()[
#     'CurrentZoneGroupID']
# if current_group_id:
#     for group in self.all_groups:
#         if group.uid == current_group_id:
#             return group
# else:
#     return None
# Tell every other visible zone to join this one
# pylint: disable = expression-not-assigned
# pylint: disable=invalid-name
# Store the entire Metadata entry in the track, this can then be
# used if needed by the client to restart a given URI
# Duration seems to be '0:00:00' when listening to radio
# Try parse trackinfo
# Might find some kind of title anyway in metadata
# If the speaker is playing from the line-in source, querying for track
# metadata will return "NOT_IMPLEMENTED".
# Track metadata is returned in DIDL-Lite format
# no zone icon in device_description.xml -> player icon
# no mac address - extract from serial number
# I'm not sure this necessary (any more). Even with an empty queue,
# there is still a result object. This shoud be investigated.
# pylint: disable=star-args
# Check if the album art URI should be fully qualified
# pylint: disable=star-args
# FIXME: The res.protocol_info should probably represent the mime type
# etc of the uri. But this seems OK.
# Sonos seems to accept this as well
# pylint: disable=redefined-variable-type
# With each request, we can only add 16 items
# List for slicing
# TODO: what do these parameters actually do?
# Favorites are returned in DIDL-Lite format
#{0}".format(obj_id)
# pylint: disable=invalid-name
# Note: probably same as Queue service method SaveAsSonosPlaylist
# but this has not been tested.  This method is what the
# controller uses.
#{0}".format(obj_id)
# Get the update_id for the playlist
# Form the metadata for queueable_item
# Make the request
# 2 ** 32 - 1 = 4294967295, this field has always this value. Most
# likely, playlist positions are represented as a 32 bit uint and
# this is therefore the largest index possible. Asking to add at
# this index therefore probably amounts to adding it "at the end"
# Note: A value of None for sleep_time_seconds is valid, and needs to
# be preserved distinctly separate from 0. 0 means go to sleep now,
# which will immediately start the sound tappering, and could be a
# useful feature, while None means cancel the current timer
# sonos_playlist specified by the DidlPlaylistContainer object
# OR specified by the item_id
# tracks/new_pos are a list of int
# OR tracks/new_pos are a list of int-like
# OR tracks/new_pos are strings - no transform is done
# allow either a string 'SQ:10' or an object with item_id attribute.
# track_list = ','.join(track_list)
# position_list = ','.join(position_list)
# retrieve the update id for the object
# there is no move, a no-op
# definition section
# Valid play modes
# soundbar product names
# -*- coding: utf-8 -*-
# pylint: disable=star-args, too-many-arguments, fixme, import-outside-toplevel
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance,bad-mcs-classmethod-argument
# It tries to follow the class hierarchy provided by the DIDL-Lite schema
# described in the UPnP Spec, especially that for the ContentDirectory Service
# Although Sonos uses ContentDirectory v1, the document for v2 is more helpful:
# http://upnp.org/specs/av/UPnP-av-ContentDirectory-v2-Service.pdf
# Due to cyclic import problems, we only import from_didl_string at runtime.
# from data_structures_entry import from_didl_string
###############################################################################
# MISC HELPER FUNCTIONS                                                       #
###############################################################################
###############################################################################
# DIDL RESOURCE                                                               #
###############################################################################
# Adapted from a class taken from the Python Brisa project - MIT licence.
# pylint: disable=too-many-instance-attributes
# Of these attributes, only uri, protocol_info and duration have been
# spotted 'in the wild'
#: (str): a percent encoded URI
# Protocol info is in the form a:b:c:d - see
# sec 2.5.2 at
# http://upnp.org/specs/av/UPnP-av-ConnectionManager-v1-Service.pdf
#: (str): protocol information.
#: str: playback duration
# Check for and fix non-spec compliant behavior in the incoming data
# required
# Optional
# Required
# Optional
# delete any elements that have a value of None to optimize size
# of the returned structure
###############################################################################
# BASE OBJECTS                                                                #
###############################################################################
# a mapping which will be used to look up the relevant class from the
# DIDL item class
# Register all subclasses with the global _DIDL_CLASS_TO_CLASS mapping
# Py2/3 compatible way of declaring the metaclass
# the DIDL Lite class for this object.
# key: attribute_name: (ns, tag)
# All didl objects *must* have a title, a parent_id and an item_id
# so we specify these as required args in the constructor signature
# to ensure that we get them. Other didl object properties are
# optional, so can be passed as kwargs.
# The content of _translation is adapted from the list in table C at
# http://upnp.org/specs/av/UPnP-av-ContentDirectory-v2-Service.pdf
# Not all properties referred to there are catered for, since Sonos
# does not use some of them.
# pylint: disable=super-on-old-class
# Restricted is a compulsory attribute, but is almost always True for
# Sonos. (Only seen it 'false' when browsing favorites)
# Resources is multi-valued, and dealt with separately
# According to the spec, there may be one or more desc values. Sonos
# only seems to use one, so we won't bother with a list
# For each attribute, check to see if this class allows it
# It is an allowed attribute. Set it as an attribute on self, so
# that it can be accessed as Classname.attribute in the normal
# way.
# pylint: disable=too-many-locals, too-many-branches
# pylint: disable=R0914
# We used to check here that we have the right sort of element,
# ie a container or an item. But Sonos seems to use both
# indiscriminately, eg a playlistContainer can be an item or a
# container. So we now just check that it is one or the other.
# and that the upnp matches what we are expecting
# In case this class has an # specified unofficial
# subclass, ignore it by stripping it from item_class
#' in item_class:
#')]
# parent_id, item_id  and restricted are stored as attributes on the
# element
# CAUTION: This implementation deviates from the spec.
# Elements are normally required to have a `restricted` tag, but
# Spotify Direct violates this. To make it work, a missing restricted
# tag is interpreted as `restricted = True`.
# Similarily, all elements should have a title tag, but Spotify Direct
# does not comply
# Deal with any resource elements
# Not all Favorits have resources, so in case the "res"
# tage has no attributes, just skip it
# and the desc element (There is only one in Sonos)
# Get values of the elements listed in _translation and add them to
# the content dict
# We store info as unicode internally.
# Convert type for original track number
# Now pass the content dict we have just built to the main
# constructor, as kwargs, to create the object
# Do we really need this constructor? Could use DidlObject(**content)
# instead.  -- We do now
# 40 originates from terminal width (78) - (15) for address part and
# (19) for the longest class name and a little left for buffer
# Get the value of each attribute listed in _translation, and add it
# to the content dict
# also add parent_id, item_id, restricted, title and resources because
# they are not listed in _translation
# Add the title, which should always come first, according to the spec
# Add in any resources
# Add the rest of the metadata attributes (i.e all those listed in
# _translation) as sub-elements of the item element.
# Some attributes have a namespace of '', which means they
# are in the default namespace. We need to handle those
# carefully
# Now add in the item class
# And the desc element
# create default protcol info
###############################################################################
# OBJECT.ITEM HIERARCHY                                                       #
###############################################################################
# The spec allows for an option 'refID' attribute, but we do not handle it
# the DIDL Lite class for this object.
# _translation = DidlObject._translation.update({ ...})
# does not work, but doing it in two steps does
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# name: (ns, tag)
# the DIDL Lite class for this object.
# name: (ns, tag)
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# Note: The sonos-favorite part of the class spec obviously isn't part of
# the DIDL spec, so just assume that it has the same definition as the
# regular object.item.audioItem.audioBroadcast
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# The resMD tag contains the metadata of the Didl object referenced by this
# favorite. For user convenience, we will parse this metadata and make the
# object available via the 'reference' property.
# Import from_didl_string if it isn't present already. The import
# happens here because it would cause cyclic import errors if the
# import happened at load time.
# pylint: disable=global-statement
# The resMD metadata lacks a <res> tag, so we use the resources from
# the favorite to make 'reference' playable.
###############################################################################
# OBJECT.CONTAINER HIERARCHY                                                  #
###############################################################################
# the DIDL Lite class for this object.
# We do not implement createClass or searchClass. Not used by Sonos??
# TODO: handle the 'childCount' element.
# the DIDL Lite class for this object.
# name: (ns, tag)
# the DIDL Lite class for this object.
# According to the spec, all musicAlbums should be represented in
# XML by a <container> tag. Sonos sometimes uses <container> and
# sometimes uses <item>. <container> seems to work here for the moment.
# name: (ns, tag)
# pylint: disable=protected-access
#:
# the DIDL Lite class for this object.
# Despite the fact that the item derives from object.container, it's
# XML does not include a <container> tag, but an <item> tag. This seems
# to be an error by Sonos.
# These classes appear when browsing the library and Sonos has been set
# to group albums using compilations.
# See https://github.com/SoCo/SoCo/issues/280
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
#: dfdf
# Not in the DIDL-Lite spec. Sonos specific??
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# name: (ns, tag)
# This does not appear (that I can find) in the DIDL-Lite specs.
# Presumably Sonos specific
# the DIDL Lite class for this object.
#:
# Yes, really. Sonos uses the item tag, not the container tag. But
# sometimes it uses the container tag, eg:
# >>> s=soco.SoCo('192.168.1.102')
# >>> s.get_playlists()
# See https://github.com/SoCo/SoCo/issues/353
# name: (ns, tag)
# Not in the DIDL-Lite spec. Sonos specific?
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# name: (ns, tag)
#:
# the DIDL Lite class for this object.
# the DIDL Lite class for this object.
# A radio show doesn't seem to have any special attributes
###############################################################################
# SPECIAL LISTS                                                               #
###############################################################################
# In case this class has an # specified unofficial
# subclass, ignore it by stripping it from item_class
#' in item_class:
#')]
# <desc> elements are allowed as an immediate child of <DIDL-Lite>
# according to the spec, but I have not seen one there in Sonos, so
# we treat them as illegal. May need to fix this if this
# causes problems.
# Obviously imcomplete, but missing entries will not result in error, but just
# a logged warning and no upgrade of the data structure
# Get data
# Now we need to create a DIDL item id. It seems to be based on the uri
# Strip any extensions, eg .mp3, from the end of the path
# The ID has an 8 (hex) digit prefix. But it doesn't seem to
# matter what it is!
# Pass over all the available metadata in the metadata dict, in the
# future ask ms data structure to upgrade metadata from the service
# Get class
# The data structure should be upgraded, but there is an entry
# missing from DIDL_NAME_TO_QUALIFIED_MS_NAME. Log this as a
# warning.
# -*- coding: utf-8 -*-
# At least two music service (Spotify Direct and Amazon in conjunction
# with Alexa) has been known not to supply the mandatory protocolInfo, so
# if it is missing supply a dummy one
# For Spotify direct we have a better idea what it should be, since it
# is included in the main element text
# -*- coding: utf-8 -*-
# pylint: disable=too-many-locals, too-many-branches
# UPnP v1.0 requires a TTL of 4
# pylint: disable=invalid-name
# Use the specified interface, if any
# Find the local network address using a couple of different methods.
# Create a socket for each unique address found, and one for the
# default multicast address
# Add a socket using the system default address
# Used to be logged as:
# list(s.getsockname()[0] for s in _sockets)
# but getsockname fails on Windows with unconnected unbound sockets
# https://bugs.python.org/issue1049
# Send a few times to each socket. UDP is unreliable
# Check if the timeout is exceeded. We could do this check just
# before the currently only continue statement of this loop,
# but I feel it is safer to do it here, so that we do not forget
# to do it if/when another continue statement is added later.
# Note: this is sensitive to clock adjustments. AFAIK there
# is no monotonic timer available before Python 3.3.
# The timeout of the select call is set to be no greater than
# 100ms, so as not to exceed (too much) the required timeout
# in case the loop is executed more than once.
# Only Zone Players should respond, given the value of ST in the
# PLAYER_SEARCH message. However, to prevent misbehaved devices
# on the network disrupting the discovery process, we check that
# the response contains the "Sonos" string; otherwise we keep
# waiting for a correct response.
#
# Here is a sample response from a real Sonos device (actual numbers
# have been redacted):
# HTTP/1.1 200 OK
# CACHE-CONTROL: max-age = 1800
# EXT:
# LOCATION: http://***.***.***.***:1400/xml/device_description.xml
# SERVER: Linux UPnP/1.0 Sonos/26.1-76230 (ZPS3)
# ST: urn:schemas-upnp-org:device:ZonePlayer:1
# USN: uuid:RINCON_B8*************00::urn:schemas-upnp-org:device:
#                                                     ZonePlayer:1
# X-RINCON-BOOTSEQ: 3
# X-RINCON-HOUSEHOLD: Sonos_7O********************R7eU
# Now we have an IP, we can build a SoCo instance and query
# that player for the topology to find the other players.
# It is much more efficient to rely upon the Zone
# Player's ability to find the others, than to wait for
# query responses from them ourselves.
# pylint: disable=no-member, protected-access
# Try to get the first pre-existing soco instance we know about,
# as long as it is visible (i.e. not a bridge etc). Otherwise,
# perform discovery (again, excluding invisibles) and return one of
# those
# -*- coding: utf-8 -*-
# pylint: disable=not-context-manager
# NOTE: The pylint not-content-manager warning is disabled pending the fix of
# a bug in pylint. See https://github.com/PyCQA/pylint/issues/782
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# Py2.7
# pick a device at random and use it to get
# the group coordinator
# Event is imported so that 'from events import Events' still works
# pylint: disable=unused-import
# noqa: F401
# pylint: disable=C0103
# The SubscriptionsMap instance created when this module is imported.
# This is referenced by soco.events_base.EventNotifyHandlerBase.
# super appears at the end of __init__, because
# BaseHTTPRequestHandler.__init__ does not return.
# pylint: disable=invalid-name
# pylint: disable=no-self-use, missing-docstring
# pylint: disable=arguments-differ
# Divert standard webserver logging to the debug log
#: `threading.Event`: Used to signal that the server should stop.
#: `tuple`: The (ip, port) address on which the server is
#: configured to listen.
# Listen for events until told to stop
#: `EventServerThread`: thread on which to run.
# Signal the thread to stop before handling the next request
# Send a dummy request in case the http server is currently listening
# If the server is already shut down, we receive a socket error,
# which we ignore.
# wait for the thread to finish, with a timeout of one second
# to ensure the main thread does not hang
# check if join timed out and issue a warning if it did
# Used to keep track of the auto_renew thread
# The SubscriptionsMap instance created when this module is imported.
# This is referenced by soco.events_base.SubscriptionBase.
# The EventListener instance created when this module is imported.
# This is referenced by soco.events_base.SubscriptionBase.
# Used to stop race conditions, as autorenewal may occur from a thread
# pylint: disable=arguments-differ
# pylint: disable=no-self-use, too-many-arguments
# A lock is used, because autorenewal occurs in
# a thread
# pylint: disable=broad-except
# If an Exception occurred during execution of subscribe,
# renew or unsubscribe, set the cancel flag to True unless
# the Exception was a SoCoException upon subscribe
# If the cancel flag was set to true, cancel the
# subscription with an explanation.
# If we're not being strict, log the Exception
# If we're not being strict upon a renewal
# (e.g. an autorenewal) call the optional
# self.auto_renew_fail method, if it has been set
# pylint: disable=not-callable
# If we're being strict, reraise the Exception
# pylint: disable=raising-bad-type
# Return the Subscription to the function that
# called subscribe, renew or unsubscribe (unless an
# Exception occurred and it was reraised above)
# pylint: disable=lost-exception
# pylint: disable=C0103
# pylint: disable=C0103
# -*- coding: utf-8 -*-
# pylint: disable=not-context-manager
# NOTE: The pylint not-content-manager warning is disabled pending the fix of
# a bug in pylint. See https://github.com/PyCQA/pylint/issues/782
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# pylint: disable=C0103
# pylint: disable=too-many-branches
# property values are just under the propertyset, which
# uses this namespace
# pylint: disable=too-many-nested-blocks
# Special handling for a LastChange event specially. For details on
# LastChange events, see
# http://upnp.org/specs/av/UPnP-av-RenderingControl-v1-Service.pdf
# and http://upnp.org/specs/av/UPnP-av-AVTransport-v1-Service.pdf
# We assume there is only one InstanceID tag. This is true for
# Sonos, as far as we know.
# InstanceID can be in one of two namespaces, depending on
# whether we are looking at an avTransport event, a
# renderingControl event, or a Queue event
# (there, it is named QueueID)
# Look at each variable within the LastChange event
# Remove any namespaces from the tags
# Un-camel case it
# Now extract the relevant value for the variable.
# The UPnP specs suggest that the value of any variable
# evented via a LastChange Event will be in the 'val'
# attribute, but audio related variables may also have a
# 'channel' attribute. In addition, it seems that Sonos
# sometimes uses a text value instead: see
# http://forums.sonos.com/showthread.php?t=34663
# If DIDL metadata is returned, convert it to a music
# library data structure
# Wrap any parsing exception in a SoCoFault, so the
# user can handle it
# pylint: disable=too-few-public-methods, too-many-arguments
# Initialisation has to be done like this, because __setattr__ is
# overridden, and will not allow direct setting of attributes
# pylint: disable=too-many-public-methods
# Event sequence number
# Event Subscription Identifier
# find the relevant service from the sid
# pylint: disable=no-member
# It might have been removed by another thread
# Build the Event object
# pass the event details on to the service so it can update
# its cache.
# pylint: disable=protected-access
# Pass the event on for handling
# pylint: disable=missing-docstring
#: `bool`: Indicates whether the server is currently running
#: `tuple`: The address (ip, port) on which the server is
#: configured to listen.
# Empty for the moment. (It is set in `start`)
#: `int`: Port on which to listen.
# Find our local network IP address which is accessible to the
# Sonos net, see http://stackoverflow.com/q/166506
# Use configured IP address if there is one, else detect
# automatically.
# doesn't have to be reachable
# Otherwise, no point trying to start server
# Check what port we actually got (twisted only)
# pylint: disable=missing-docstring
# pylint: disable=missing-docstring
# pylint: disable=too-many-instance-attributes
#: `str`: A unique ID for this subscription
#: `int`: The amount of time in seconds until the subscription expires.
#: `bool`: An indication of whether the subscription is subscribed.
#: :class:`~queue.Queue`: The queue on which events are placed.
#: `int`: The period (seconds) for which the subscription is requested
#: :py:obj:`function`: an optional function to be called if an
#: exception occurs upon autorenewal. This will be called with the
#: exception (or failure, when using :py:mod:`soco.events_twisted`)
#: as its only parameter. This function must be threadsafe (unless
#: :py:mod:`soco.events_twisted` is being used).
# A flag to make sure that an unsubscribed instance is not
# resubscribed
# The time when the subscription was made
# TIMEOUT is provided for in the UPnP spec, but it is not clear if
# Sonos pays any attention to it. A timeout of 86400 secs always seems
# to be allocated
# The Event Listener must be running, so start it if not
# pylint: disable=no-member
# an event subscription looks like this:
# SUBSCRIBE publisher path HTTP/1.1
# HOST: publisher host:publisher port
# CALLBACK: <delivery URL>
# NT: upnp:event
# TIMEOUT: Second-requested subscription duration (optional)
# pylint: disable=unbalanced-tuple-unpacking
# pylint: disable=missing-docstring
# According to the spec, timeout can be "infinite" or "second-123"
# where 123 is a number of seconds.  Sonos uses "Second-123"
# (with a capital letter)
# Register the subscription so it can be looked up by sid
# and unsubscribed at exit
# Set up auto_renew
# Autorenew just before expiry, say at 85% of self.timeout seconds
# Lock out EventNotifyHandler during registration.
# If events_twisted is used, this lock should always be
# available, since threading is not being used. This is to prevent
# the EventNotifyHandler from sending a notification before the
# subscription has been registered.
# NB This code may be called from a separate thread when
# subscriptions are auto-renewed. Be careful to ensure thread-safety
# SUBSCRIBE publisher path HTTP/1.1
# HOST: publisher host:publisher port
# SID: uuid:subscription UUID
# TIMEOUT: Second-requested subscription duration (optional)
# pylint: disable=missing-docstring
# According to the spec, timeout can be "infinite" or "second-123"
# where 123 is a number of seconds.  Sonos uses "Second-123"
# (with a capital letter)
# Trying to unsubscribe if already unsubscribed, or not yet
# subscribed, fails silently
# If the subscription has timed out, an attempt to
# unsubscribe from it will fail silently.
# Send an unsubscribe request like this:
# UNSUBSCRIBE publisher path HTTP/1.1
# HOST: publisher host:publisher port
# SID: uuid:subscription UUID
# pylint: disable=missing-docstring, unused-argument
# pylint: disable=no-member
# pylint: disable=missing-docstring
# pylint: disable=missing-docstring
# pylint: disable=missing-docstring, too-many-arguments
# pylint: disable=missing-docstring
# unregister subscription
# pylint: disable=no-member
# Stop the event listener, if there are no other subscriptions
# No need to do any more if this flag has been set to True
# Set the self._has_been_unsubscribed flag now
# to prevent reuse of the subscription, even if
# an attempt to unsubscribe fails
# Cancel any auto renew
#: `weakref.WeakValueDictionary`: Thread safe mapping.
#: Used to store a mapping of sid to subscription
# The lock to go with it
# You must only ever access the mapping in the context of this lock,
# eg:
#   with self.subscriptions_lock:
#       queue = self.subscriptions[sid].events
#: `threading.Lock`: for use with `subscriptions`
# Add the queue to the master dict of subscriptions so it can be
# looked up by sid. The subscriptions_lock is not used here as
# it is used in Subscription.subscribe() in the events_base
# module, from which the register function is called.
# Register subscription to be unsubscribed at exit if still alive
# This will not happen if exit is abnormal (eg in response to a
# signal or fatal interpreter error - see the docs for `atexit`).
# -*- coding: utf-8 -*-
# pylint: disable=not-context-manager,import-error,wrong-import-position
# NOTE: The pylint not-content-manager warning is disabled pending the fix of
# a bug in pylint. See https://github.com/PyCQA/pylint/issues/782
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# pick a device at random and use it to get
# the group coordinator
# Hack to make docs build without twisted installed
# pylint: disable=no-init
# Event is imported for compatibility with events.py
# pylint: disable=unused-import
# noqa: F401
# noqa: E402
# noqa: E402
# pylint: disable=C0103
# The SubscriptionsMapTwisted instance created when this module is
# imported. This is referenced by
# soco.events_base.EventNotifyHandlerBase.
# pylint: disable=invalid-name
# pylint: disable=no-self-use, missing-docstring
#:  :py:class:`twisted.internet.tcp.Port`: set at `listen`
# pylint: disable=no-member
# pylint: disable=invalid-name
# pylint: disable=unused-argument
#: :py:obj:`function`: callback function to be called whenever an
#: `Event` is received. If it is set and is callable, the callback
#: function will be called with the `Event` as the only parameter and
#: the Subscription's event queue won't be used.
# The SubscriptionsMapTwisted instance created when this module is
# imported. This is referenced by soco.events_base.SubscriptionBase.
# The EventListener instance created when this module is imported.
# This is referenced by soco.events_base.SubscriptionBase.
# Used to keep track of the auto_renew loop
# Used to serialise calls to subscribe, renew and unsubscribe
# pylint: disable=arguments-differ
# False means wait for the interval to elapse, rather than fire at once
# pylint: disable=no-self-use, too-many-branches, too-many-arguments
# pylint: disable=invalid-name
# pylint: disable=missing-docstring
# pylint: disable=unused-argument
# Increment the counter of pending calls to Subscription.subscribe
# if method is subscribe
# Execute method
# If there is another deferred in the queue,
# call it
# pylint: disable=invalid-name
# We start by assuming no Failure occurred
# If a Failure or Exception occurred during execution of
# subscribe, renew or unsubscribe, cancel it unless the
# Failure or Exception was a SoCoException upon subscribe
# If we're not being strict, log the Failure
# If we're not being strict upon a renewal
# (e.g. an autorenewal) call the optional
# self.auto_renew_fail method, if it has been set
# pylint: disable=not-callable
# Decrement the counter of pending calls to Subscription.subscribe
# if completed action was subscribe
# Remove the previous deferred from the queue
# And call the next deferred in the queue
# If a Failure occurred and we're in strict mode, reraise it
# Create a deferred
# pylint: disable=invalid-name
# Set its subscription property to refer to this Subscription
# Set the deferred to execute method, when the
# deferred is called
# Add handle_outcome as both a callback and errback
# Add the deferred to the queue
# If this is the only deferred in the queue,
# call it
# Return the deferred
# A counter of calls to Subscription.subscribe
# that have started but not completed. This is
# to prevent the event listener from being stopped prematurely
# Add the subscription to the local dict of subscriptions so it
# can be looked up by sid
# Register subscription to be unsubscribed at exit if still alive
# pylint: disable=no-member
# Increment the counter
# Decrement the counter
# pylint: disable=C0103
# pylint: disable=C0103
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
#: The unique Sonos ID for this group
#: The `SoCo` instance which coordinates this group
#: A set of `SoCo` instances which are members of the group
# Coerce in range
# Sonos automatically handles out-of-range values.
# -*- coding: utf-8 -*-
# pylint: disable = star-args, too-many-arguments, unsupported-membership-test
# pylint: disable = not-an-iterable
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# This needs to be integrated with Music Library data structures
# pylint: disable=len-as-condition
# These fields must be overwritten in the sub classes
# Add a few extra pieces of information
# Extract values from the XML
# Strip namespace
# Convert to nice names
# Convert values for known types
# Rename a single item
# And get the extended id
# Add URI if there is one for the relevant class
# Check for all required values
# 40 originates from terminal width (78) - (15) for address part and
# (19) for the longest class name and a little left for buffer
# Check if this item is meant to be played
# Check if we have the attributes to create the didl metadata:
# Main element, ugly? yes! but I have given up on using namespaces
# with xml.etree.ElementTree
# Item sub element
# Only add the parent_id if we have it
# Add title and class
# Add the desc element
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# x-sonos-http:trackid_19356232.mp4?sid=20&amp;flags=32
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# x-rincon-cpcontainer:0004002calbumid_22757081
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# x-rincon-cpcontainer:000d006cplaylistid_26b18dbb-fd35-40bd-8d4f-
# 8669bfc9f712
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# x-rincon-cpcontainer:000d006cplaylistid_c86ddf26-8ec5-483e-b292-
# abe18848e89e
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# x-rincon-cpcontainer:100f006cartistpopsongsid_1566
# Since MSArtist cannot produce didl_metadata, they are not strictly
# required, but it makes sense to require them anyway, since they are the
# fields that that describe the item
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# Since MSFavorites cannot produce didl_metadata, they are not strictly
# required, but it makes sense to require them anyway, since they are the
# fields that that describe the item
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# Since MSCollection cannot produce didl_metadata, they are not strictly
# required, but it makes sense to require them anyway, since they are the
# fields that that describe the item
# IMPORTANT. Keep this list, __init__ args and content in __init__ in sync
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# Key words used when performing searches
# pylint: disable=invalid-name, protected-access
# Add on the full album art link, as the URI version
# does not include the ipaddress
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
#soco.music_library.MusicLibrary.get_music_library_information>`_.
# pylint: disable=too-many-locals, too-many-arguments,
# too-many-branches
# Add sub categories
# Add fuzzy search
# Change start and max for complete searches
# Try and get this batch of results
# 'No such object' UPnP errors
# Parse the results
# Check if the album art URI should be fully qualified
# Append the item to the list
# If we are not after the complete results, the stop after 1
# iteration
# pylint: disable=star-args
# Add sub categories
# Add fuzzy search
# 'No such object' UPnP errors
# Parse the results
# Check if the album art URI should be fully qualified
# pylint: disable=star-args
# Check if the string ID already has the type, if so we do not want to
# add one also Imported playlist have a full path to them, so they do
# not require the A:PLAYLISTS part first
#" + search_item_id
# Not sure about the res protocol. But this seems to work
# Call the base version
# Get result information
# Perform the search
# It is necessary to update the list of items in two places, due to
# a bug in SearchResult
# Zero matches
# One match
# Otherwise it's multiple matches
# share_name must be prefixed with 'S:'
# -*- coding: utf-8 -*-
# pylint: disable=fixme, invalid-name
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# UPnP Spec at http://upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0.pdf
# UNICODE NOTE
# UPnP requires all XML to be transmitted/received with utf-8 encoding. All
# strings used in this module are unicode. The Requests library should take
# care of all of the necessary encoding (on sending) and decoding (on
# receiving) for us, provided that we specify the correct encoding headers
# (which, hopefully, we do).
# But since ElementTree seems to prefer being fed bytes to unicode, at least
# for Python 2.x, we have to encode strings specifically before using it. see
# http://bugs.python.org/issue11033 TODO: Keep an eye on this when it comes to
# Python 3 compatibility
# pylint: disable=C0103
# logging.basicConfig()
# log.setLevel(logging.INFO)
# A shared cache for ZoneGroupState. Each zone has the same info, so when a
# SoCo instance is asked for group info, we can cache it and return it when
# another instance is asked. To do this we need a cache to be shared between
# instances
# pylint: disable=too-many-instance-attributes
# pylint: disable=bad-continuation
# noqa PEP8
#: `SoCo`: The `SoCo` instance to which UPnP Actions are sent
# Some defaults. Some or all these will need to be overridden
# specifically in a sub-class. There is other information we could
# record, but this will do for the moment. Info about a Sonos device is
# available at <IP_address>/xml/device_description.xml in the
# <service> tags
#: str: The UPnP service type.
#: str: The UPnP service version.
#: str: The base URL for sending UPnP Actions.
#: str: The UPnP Control URL.
#: str: The service control protocol description URL.
#: str: The service eventing subscription URL.
#: A cache for storing the result of network calls. By default, this is
#: a `TimedCache` with a default timeout=0.
# Caching variables for actions and event_vars, will be filled when
# they are requested for the first time
# From table 3.3 in
# http://upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf
# This list may not be complete, but should be good enough to be going
# on with.  Error codes between 700-799 are defined for particular
# services, and may be overriden in subclasses. Error codes >800
# are generally SONOS specific. NB It may well be that SONOS does not
# use some of these error codes.
# pylint: disable=invalid-name
# Define a function to be invoked as the method, which calls
# send_command.
# rename the function so it appears to be the called method. We
# probably don't need this, but it doesn't harm
# _dispatcher is now an unbound menthod, but we need a bound method.
# This turns an unbound method into a bound method (i.e. one that
# takes self - an instance of the class - as the first parameter)
# pylint: disable=no-member
# Now we have a bound method, we cache it on this instance, so that
# next time we don't have to go through this again
# return our new bound method, which will be called by Python
# % converts to unicode because we are using unicode literals.
# Avoids use of 'unicode' function which does not exist in python 3
# A UPnP SOAP response (including headers) looks like this:
# HTTP/1.1 200 OK
# CONTENT-LENGTH: bytes in body
# CONTENT-TYPE: text/xml; charset="utf-8" DATE: when response was
# generated
# EXT:
# SERVER: OS/version UPnP/1.0 product/version
#
# <?xml version="1.0"?>
# <s:Envelope
#   xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
#   s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
#   <s:Body>
#       <u:actionNameResponse
#           xmlns:u="urn:schemas-upnp-org:service:serviceType:v">
#           <argumentName>out arg value</argumentName>
#               ... other out args and their values go here, if any
#       </u:actionNameResponse>
#   </s:Body>
# </s:Envelope>
# Get all tags in order. Elementree (in python 2.x) seems to prefer to
# be fed bytes, rather than unicode
# Try to filter illegal xml chars (as unicode), in case that is
# the reason for the parse error
# Get the first child of the <Body> tag which will be
# <{actionNameResponse}> (depends on what actionName is). Turn the
# children of this into a {tagname, content} dict. XML unescaping
# is carried out for us by elementree.
# The found 'action' will be visible from outside the loop
# Check for given argument names which do not occur in the expected
# argument list
# pylint: disable=undefined-loop-variable
# List the (name, value) tuples for each argument in the argument list
# A complete request should look something like this:
# POST path of control URL HTTP/1.1
# HOST: host of control URL:port of control URL
# CONTENT-LENGTH: bytes in body
# CONTENT-TYPE: text/xml; charset="utf-8"
# SOAPACTION: "urn:schemas-upnp-org:service:serviceType:v#actionName"
#
# <?xml version="1.0"?>
# <s:Envelope
#   xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
#   s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
#   <s:Body>
#       <u:actionName
#           xmlns:u="urn:schemas-upnp-org:service:serviceType:v">
#           <argumentName>in arg value</argumentName>
#           ... other in args and their values go here, if any
#       </u:actionName>
#   </s:Body>
# </s:Envelope>
#{action}"
# Note that although we set the charset to utf-8 here, in fact the
# body is still unicode. It will only be converted to bytes when it
# is set over the network
# Cache miss, so go ahead and make a network call
# Convert the body to bytes, and send it.
# The response is good. Get the output params, and return them.
# NB an empty dict is a valid result. It just means that no
# params are returned. By using response.text, we rely upon
# the requests library to convert to unicode for us.
# Store in the cache. There is no need to do this if there was an
# error, since we would want to try a network call again.
# Internal server error. UPnP requires this to be returned if the
# device does not like the action for some reason. The returned
# content will be a SOAP Fault. Parse it and raise an error.
# Something else has gone wrong. Probably a network error. Let
# Requests handle it
# An error code looks something like this:
# HTTP/1.1 500 Internal Server Error
# CONTENT-LENGTH: bytes in body
# CONTENT-TYPE: text/xml; charset="utf-8"
# DATE: when response was generated
# EXT:
# SERVER: OS/version UPnP/1.0 product/version
# <?xml version="1.0"?>
# <s:Envelope
#   xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
#   s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
#   <s:Body>
#       <s:Fault>
#           <faultcode>s:Client</faultcode>
#           <faultstring>UPnPError</faultstring>
#           <detail>
#               <UPnPError xmlns="urn:schemas-upnp-org:control-1-0">
#                   <errorCode>error code</errorCode>
#                   <errorDescription>error string</errorDescription>
#               </UPnPError>
#           </detail>
#       </s:Fault>
#   </s:Body>
# </s:Envelope>
#
# All that matters for our purposes is the errorCode.
# errorDescription is not required, and Sonos does not seem to use it.
# NB need to encode unicode strings before passing to ElementTree
# Unknown error, so just return the entire response
# pylint: disable=too-many-locals
# pylint: disable=invalid-name
# get the scpd body as bytes, and feed directly to elementtree
# which likes to receive bytes
# parse the state variables to get the relevant variable types
# find all the actions
# pylint: disable=invalid-name
# parse the state variables to get the relevant variable types
# We are only interested if 'sendEvents' is 'yes', i.e this
# is an eventable variable
# For error codes, see table 2.7.16 in
# http://upnp.org/specs/av/UPnP-av-ContentDirectory-v1-Service.pdf
# pylint: disable=invalid-name
# pylint: disable=invalid-name
# For error codes, see
# http://upnp.org/specs/av/UPnP-av-AVTransport-v1-Service.pdf
# -*- coding: utf-8 -*-
# pylint: disable=too-many-instance-attributes
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# The device that will be snapshotted
# The values that will be stored
# For all zones:
# For coordinator zone playing from Queue:
# For coordinator zone playing a Stream:
# For all coordinator zones
# Only set the queue as a list if we are going to save it
# get if device coordinator (or slave) True (or False)
# Get information about the currently playing media
# Extract source from media uri - below some media URI value examples:
#  'x-rincon-queue:RINCON_000E5859E49601400#0'
#       - playing a local queue always #0 for local queue)
#
#  'x-rincon-queue:RINCON_000E5859E49601400#6'
#       - playing a cloud queue where #x changes with each queue)
#
#  -'x-rincon:RINCON_000E5859E49601400'
#       - a slave player pointing to coordinator player
# The pylint error below is a false positive, see about removing it
# in the future
# pylint: disable=simplifiable-if-statement
#')[1] == '0':
# playing local queue
# playing cloud queue - started from Alexa
# Save the volume, mute and other sound settings
# get details required for what's playing:
# playing from queue - save repeat, random, cross fade, track, etc.
# Get information about the currently playing track
# save as integer
# playing from a stream - save media metadata
# Work out what the playing state is - if a coordinator
# Save of the current queue if we need to
# return if device is a coordinator (helps usage)
# pylint: disable=too-many-branches
# Start by ensuring that the speaker is paused as we don't want
# things all rolling back when we are changing them, as this could
# include things like audio
# Check if the queue should be restored
# Reinstate what was playing
# was playing from playlist
# The position in the playlist returned by
# get_current_track_info starts at 1, but when
# playing from playlist, the index starts at 0
# if position > 0:
# reinstate track, position, play mode, cross fade
# Need to make sure there is a proper track selected first
# was playing a cloud queue started by Alexa
# No way yet to re-start this so prevent it throwing an error!
# was playing a stream (radio station, file, or nothing)
# reinstate uri and meta data
# For all devices:
# Reinstate all the properties that are pretty easy to do
# Reinstate volume
# Can only change volume on device with fixed volume set to False
# otherwise get uPnP error, so check first. Before issuing a network
# command to check, fixed volume always has volume set to 100.
# So only checked fixed volume if volume is 100.
# now set volume if not fixed
# if fade requested in restore
# set volume to 0 then fade up to saved volume (non blocking)
# set volume
# Now everything is set, see if we need to be playing, stopped
# or paused ( only for coordinators)
# Maximum batch is 486, anything larger will still only
# return 486
# Need to get all the tracks in batches, but Only get the next
# batch if all the items requested were in the last batch
# Check how many entries were returned
# Make sure the queue is not empty
# Update the total that have been processed
# Clear the queue so that it can be reset
# Now loop around all the queue entries adding them
# -*- coding: utf-8 -*-
# pylint: disable=fixme
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# The state of Python's SOAP libraries is poor. In any event, the two main
# libraries, PySimpleSOAP and SUDS (or the more up-to-date SUDS-Jurko),
# are too complex for our needs. SUDS requires a WSDL file to be parsed,
# and although SONOS provides one in relation to music services (at
# http://musicpartners.sonos.com/sites/default/files/Sonos.wsdl) the various
# music services themselves provide buggy, incomplete or old
# implementations which cause SUDS to break. PySimpleSOAP can work without a
# WSDL file, but contains various bugs which mean that we would have to use
# a patched version (upstream releases are infrequent).  Since SONOS only
# appears to use basic SOAP features, and after experimenting with other
# libraries, it seems best to write our own.
# Some is the same as that in services.py.
# TODO: refactor services.py to depend on this code
# Sonos uses SOAP to send commands in the RPC form. A complete RPC SOAP
# message should look something like this. See generally
# http://www.w3.org/TR/2000/NOTE-SOAP-20000508/
# POST Endpoint URL HTTP/1.1
# HOST: Host of Endpoint URL:port
# CONTENT-LENGTH: bytes in body
# CONTENT-TYPE: text/xml; charset="utf-8"
# SOAPACTION: URI
#
# <?xml version="1.0"?>
# <s:Envelope
#   xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
#   s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
#   <s:Header>
#       </Header elements go here>
#   </s:Header>
#   <s:Body>
#       <ns:MethodName xmlns:ns="MethodNamespace>"
#           <param1>value</param1>
#           ...
#           <param_n>value</param_n>
#       </ns:MethodName>
#   </s:Body>
# </s:Envelope>
# pylint: disable=too-many-instance-attributes, too-many-arguments
# pylint:disable=no-self-use
# % converts to unicode because we are using unicode literals.
# Avoids use of 'unicode' function which does not exist in python 3
# Prepare the SOAP Body
# pylint: disable=bad-continuation
# noqa PEP8
# Check log level before logging XML, since prettifying it is
# expensive
# The response is good. Extract the Body
# Get the first child of the <Body> tag. NB There should only be
# one if the RPC standard is followed.
# We probably have a SOAP Fault
# Not a SOAP fault. Must be something else.
# Something else has gone wrong. Probably a network error. Let
# Requests handle it
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance,import-outside-toplevel
# pylint: disable=star-args
# pylint really doesn't like decorators!
# pylint: disable=invalid-name, too-few-public-methods
# pylint: disable=missing-docstring
# Using 'safe' arg does not seem to work for python 2.6
# -*- coding: utf-8 -*-
# pylint: disable=invalid-name,wrong-import-position,redefined-builtin
# Create regular expression for filtering invalid characters, from:
# http://stackoverflow.com/questions/1707890/
# fast-way-to-filter-illegal-xml-unicode-chars-in-python
#: Commonly used namespaces, and abbreviations, used by `ns_tag`.
# Register common namespaces to assist in serialisation (avoids the ns:0
# prefixes in XML output )
# -*- coding: utf-8 -*-
# There is no need for all strings here to be unicode, and Py2 cannot import
# modules with unicode names so do not use from __future__ import
# unicode_literals
# https://github.com/SoCo/SoCo/issues/98
#
# Will be parsed by setup.py to determine package metadata
# Please add the suffix "+" to the version after release, to make it
# possible infer whether in development code from the version string
# You really should not `import *` - it is poor practice
# but if you do, here is what you get:
# http://docs.python.org/2/howto/logging.html#library-config
# Avoids spurious error messages if no logger is configured by the user
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance,no-else-continue
# pylint: disable=C0103
# pylint: disable=too-many-instance-attributes
#: str: A unique identifier for the music service to which this
#: account relates, eg ``'2311'`` for Spotify.
#: str: A unique identifier for this account
#: str: The account's nickname
#: bool: `True` if this account has been deleted
#: str: The username used for logging into the music service
#: str: Metadata for the account
#: str: Used for OpenAuth id for some services
#: str: Used for OpenAuthid for some services
# It is likely that the same information is available over UPnP as well
# via a call to
# systemProperties.GetStringX([('VariableName','R_SvcAccounts')]))
# This returns an encrypted string, and, so far, we cannot decrypt it
# _get_account_xml returns an ElementTree element like this:
# <ZPSupportInfo type="User">
#   <Accounts
#   LastUpdateDevice="RINCON_000XXXXXXXX400"
#   Version="8" NextSerialNum="5">
#     <Account Type="2311" SerialNum="1">
#         <UN>12345678</UN>
#         <MD>1</MD>
#         <NN></NN>
#         <OADevID></OADevID>
#         <Key></Key>
#     </Account>
#     <Account Type="41735" SerialNum="3" Deleted="1">
#         <UN></UN>
#         <MD>1</MD>
#         <NN>Nickname</NN>
#         <OADevID></OADevID>
#         <Key></Key>
#     </Account>
# ...
#   <Accounts />
# cls._all_accounts is a weakvaluedict keyed by serial number.
# We use it as a database to store details of the accounts we
# know about. We need to update it with info obtained from the
# XML just obtained, so (1) check to see if we already have an
# entry in cls._all_accounts for the account we have found in
# XML; (2) if so, delete it if the XML says it has been deleted;
# and (3) if not, create an entry for it
# We have an existing entry in our database. Do we need to
# delete it?
# Yes, so delete it and move to the next XML account
# No, so load up its details, ready to update them
# We have no existing entry for this account
# but it is marked as deleted, so we don't need one
# If it is not marked as deleted, we need to create an entry
# Now, update the entry in our database with the details from XML
# Not sure what 'MD' stands for.  Metadata? May Delete?
# There is always a TuneIn account, but it is handled separately
#  by Sonos, and does not appear in the xml account data. We
# need to add it ourselves.
# Is this always the case?
# -*- coding: utf-8 -*-
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# For now we generate classes dynamically. This is shorter, but
# provides no custom documentation for all the different types.
# So MediaMetadataTrack turns into MSTrack
# The result to be parsed is in either searchResult or getMetadataResult
# Form the search metadata
# Upper case the first letter (used for the class_key)
# If there is only 1 result, it is not put in an array
# Form the class_key, which is a unique string for this type,
# formed by concatenating the result type with the item type. Turns
# into e.g: MediaMetadataTrack
# Type Helper
# Music Service item base classes
# The following two fields should be overwritten in subclasses
# _valid_fields is a set of valid fields
# _types is a dict of fields with non-string types and their convertion
# callables
# Check for invalid fields
# Really wanted to raise exceptions here, but as it
# turns out I have already encountered invalid fields
# from music services.
# Convert names and create metadata dict
# See comment in MetadataDictBase for explanation of these two attributes
# pylint: disable=too-many-arguments
# Form the item_id
# The hex prefix remains a mistery for now
# Form the uri
# Form resources and get desc
# We piggy back on the implementation in DidlItem
# This is ignored. Sonos gets the title from the item_id
# Ditto
# _valid_fields is a set of valid fields
# _types is a dict of fields with non-string types and their
# convertion callables
# _valid_fields is a set of valid fields
# _types is a dict of fields with non-string types and their
# convertion callables
# _valid_fields is a set of valid fields
# _types is a dict of fields with non-string types and their
# convertion callables
# We ignore types on the dynamic field
# 'dynamic': ???,
# _valid_fields is a set of valid fields
# _types is a dict of fields with non-string types and their
# convertion callables
# -*- coding: utf-8 -*-
# pylint: disable=fixme
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# pylint: disable=C0103
# pylint: disable=too-many-instance-attributes, protected-access
# Spotify uses gzip. Others may do so as well. Unzipping is handled
# for us by the requests library. Google Play seems to be very fussy
#  about the user-agent string. The firmware release number (after
# 'Sonos/') has to be '26' for some reason to get Google Play to
# work. Although we have access to a real SONOS user agent
# string (one is returned, eg, in the SERVER header of discovery
# packets and looks like this: Linux UPnP/1.0 Sonos/29.5-91030 (
# ZPS3)) it is a bit too much trouble here to access it, and Google
# Play does not like it anyway.
# According to the SONOS SMAPI, this header must be sent with all
# SOAP requests. Building this is an expensive operation (though
# occasionally necessary), so f we have a cached value, return it
# OAuth account credentials are present. We must use them to
# authenticate.
# otherwise, perhaps use DeviceLink or UserId auth
# We need a session ID from Sonos
# Anonymous auth. No need for anything further.
#{0}".format(method),
# Remove any cached value for the SOAP header
# <detail>
#   <refreshAuthTokenResult>
#       <authToken>xxxxxxx</authToken>
#       <privateKey>zzzzzz</privateKey>
#   </refreshAuthTokenResult>
# </detail>
# We have new details - update the account
#{0}".format(method),
# The top key in the OrderedDict will be the methodResult. Its
# value may be None if no results were returned.
# pylint: disable=too-many-instance-attributes
# Used for pretty printing ordereddicts
# Look up the data for this service
# Auth_type can be 'Anonymous', 'UserId, 'DeviceLink'
# try to find an account for this service
# The default is 60
# Return from cache if we have it.
# <Services SchemaVersion="1">
#     <Service Id="163" Name="Spreaker" Version="1.1"
#         Uri="http://sonos.spreaker.com/sonos/service/v1"
#         SecureUri="https://sonos.spreaker.com/sonos/service/v1"
#         ContainerType="MService"
#         Capabilities="513"
#         MaxMessagingChars="0">
#         <Policy Auth="Anonymous" PollInterval="30" />
#         <Presentation>
#             <Strings
#                 Version="1"
#                 Uri="https:...string_table.xml" />
#             <PresentationMap Version="2"
#                 Uri="https://...presentation_map.xml" />
#         </Presentation>
#     </Service>
# ...
# </ Services>
# Ideally, the search path should be './/Service' to find Service
# elements at any level, but Python 2.6 breaks with this if Service
# is a child of the current element. Since 'Service' works here, we use
# that instead
# ServiceType is used elsewhere in Sonos, eg to form tokens,
# and get_subscribed_music_services() below. It is also the
# 'Type' used in account_xml (see above). Its value always
# seems to be (ID*256) + 7. Some serviceTypes are also
# listed in available_services['AvailableServiceTypeList']
# but this does not seem to be comprehensive
# Cache this so we don't need to do it again.
# This is very inefficient - loops within loops within loops, and
# many network requests
# Optimise it?
# TuneIn does not have a pmap. Its search keys are is search:station,
# search:show, search:host
# Presentation maps can also define custom categories. See eg
# http://sonos-pmap.ws.sonos.com/hypemachine_pmap.6.xml
# <SearchCategories>
# ...
#     <CustomCategory mappedId="SBLG" stringId="Blogs"/>
# </SearchCategories>
# Is it already cached? If so, return it
# Not cached. Fetch and parse presentation map
# Tunein is a special case. It has no pmap, but supports searching
# Assume not searchable?
# Search translations can appear in Category or CustomCategory elements
# Real Sonos URIs look like this:
# x-sonos-http:tr%3a92352286.mp3?sid=2&flags=8224&sn=4 The
# extension (.mp3) presumably comes from the mime-type returned in a
# MusicService.get_metadata() result (though for Spotify the mime-type
# is audio/x-spotify, and there is no extension. See
# http://musicpartners.sonos.com/node/464 for supported mime-types and
# related extensions). The scheme (x-sonos-http) presumably
# indicates how the player is to obtain the stream for playing. It
# is not clear what the flags param is used for (perhaps bitrate,
# or certain metadata such as canSkip?). Fortunately, none of these
# seems to be necessary. We can leave them out, (or in the case of
# the scheme, use 'soco' as dummy text, and the players still seem
# to do the right thing.
# quote_url will break if given unicode on Py2.6, and early 2.7. So
# we need to encode.
# Add the account info to the end as query params
########################################################################
#                                                                      #
#                           SOAP METHODS.                              #
#                                                                      #
########################################################################
#  Looking at various services, we see that the following SOAP methods
#  are implemented, but not all in each service. Probably, the
#  Capabilities property indicates which features are implemented, but
#  it is not clear precisely how. Some of the more common/useful
#  features have been wrapped into instance methods, below.
#  See generally: http://musicpartners.sonos.com/node/81
#    createItem(xs:string favorite)
#    createTrialAccount(xs:string deviceId)
#    deleteItem(xs:string favorite)
#    getAccount()
#    getExtendedMetadata(xs:string id)
#    getExtendedMetadataText(xs:string id, xs:string Type)
#    getLastUpdate()
#    getMediaMetadata(xs:string id)
#    getMediaURI(xs:string id)
#    getMetadata(xs:string id, xs:int index, xs:int count,xs:boolean
#                recursive)
#    getScrollIndices(xs:string id)
#    getSessionId(xs:string username, xs:string password)
#    mergeTrialccount(xs:string deviceId)
#    rateItem(id id, xs:integer rating)
#    search(xs:string id, xs:string term, xs:string index, xs:int count)
#    setPlayedSeconds(id id, xs:int seconds)
# pylint: disable=no-member
# TODO: Maybe create a favorites/catalog cache which is invalidated
# TODO: when these values change?
#
# If there is an sn parameter (which is the serial number of an account),
# we can obtain all the information we need from that, because we can find
# the relevant service_id in the account database (it is the same as the
# service_type). Consequently, the sid parameter is unneeded. But if sn is
# missing, we need the sid (service_type) parameter to find a relevant
# account
# urlparse does not work consistently with custom URI schemes such as
# those used by Sonos. This is especially broken in Python 2.6 and
# early versions of 2.7: http://bugs.python.org/issue9374
# As a workaround, we split off the scheme manually, and then parse
# the uri as if it were http
# Is there an account serial number?
# There is no account matching this serial number. Fall back to
# using the service id to find an account
# Use the first account we find
# Nothing found. Default to the standard desc value. Is this the right
# thing to do?
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
# Only raise this import error if we are not building the docs
# -*- coding: utf-8 -*-
# pylint: disable=star-args,too-many-locals
# Due to a bug in requests, the post command will sometimes fail to
# properly wrap a socket.timeout exception in requests own exception.
# See https://github.com/kennethreitz/requests/issues/2045
# Until this is fixed, we need to catch both types of exceptions
# pylint: disable=maybe-no-member
# This way of setting accepted language is obviously flawed, in that it
# depends on the locale settings of the system. However, I'm unsure if
# they are actually used. The character coding is set elsewhere and I think
# the available music in each country is bound to the account.
# Instantiate variables
# Get a session id for the searches
# Check input
# Transform search: tracks -> tracksearch
# Perform search
# Parse results
# Check for correct service
# Form HTTP body and set parent_id
# Get HTTP header and post
# Check for errors and get XML
# Find the getMetadataResult item ...
# ... and make sure there is exactly 1
# Browse the children of metadata result
# Add the Body part
# Add the Body part
# Investigate this index, count stuff more
# Add the Header part
#getMetadata"',
#search"'
# Note UPnP exception 802 while trying to add a Wimp track indicates that these
# are tracks that not available in Wimp. Do something with that.
# This one is unknown
# This one is unknown
# -*- coding: utf-8 -*-
# pylint: disable=R0201,E0711
# Disable while we have Python 2.x compatability
# pylint: disable=useless-object-inheritance
# print()
# print(element1.tag, "TAG", element2.tag)
# print(element1.attrib, element2.attrib)
# print(element1.attrib, element2.attrib)
# print(len(element1), len(element2))
# -*- coding: utf-8 -*-
# pylint: disable-msg=R0904
# pylint: disable-msg=W0603
# Test return strings that are used a lot
# functions for running via pytest
# pylint: disable-msg=C0103
# NOTE We don't test coerce from too large values, since that would
# put the unit at full volume
# pylint: disable-msg=C0103
# Values on the boundaries of the valid equivalence partition
# Values on the boundaries of the two invalid equivalence partitions
# pylint: disable-msg=C0103
# Values on the boundaries of the valid equivalence partition
# Values on the boundaries of the two invalid equivalence partitions
# pylint: disable-msg=C0103
# The value in this list must be kept up to date with the values in
# the test_get doc string
# Add new element and check
# Clean up
# pylint: disable-msg=C0103
# The values in this list must be kept up to date with the values in
# the test_get doc string
# pylint: disable-msg=C0103
# The values in this list must be kept up to date with the values in
# the test doc string
# pylint: disable-msg=C0103
# The values in this list must be kept up to date with the values in
# the test doc string
# class GetSpeakersIp(unittest.TestCase):
#""" Unit tests for the get_speakers_ip method """
# TODO: Awaits https://github.com/rahims/SoCo/issues/26
# def test(self):
# print SOCO.get_speakers_ip()
# Reset unit the way it was before the test
# Clean up
# Format 1
# Reset and format 2
# Clean up
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
# Check it's there
# delete it
# put it back
# Check it's there
# -*- coding: utf-8 -*-
# save old state
# restore original value
# save old state
# restore original value
# got 'should' returned
# no network request performed
# save old state
# restore original value
# get_speaker_info only updates internal speaker_info and does not
# replace it
# Test that uris are forced to Radio style display and controls when
# force_radio is True prefix is replaced with "x-rincon-mp3radion://"
# first set of test with no forcing, second set with force_radio=True
# No forcing
# with force_radio=True
# '12:34', # Should this be valid?
# Should this really be valid?
#0</res></container></DIDL-Lite>',
#{}".format(
#{}".format(
# GetVolume is called twice, once for each of the left
# and right channels
# SetVolume is called twice, once for each of the left
# and right channels
# Check 3 unique groups
# Have to mock out group members zone group state here since
# g.members is parsed from the XML.
# Have to mock out group members zone group state here since
# g.members is parsed from the XML.
# -*- coding: utf-8 -*-
# Create a fake socket, whose data is always a certain string
# (data, # address)
# Each time gethostbyname is called, it gets a different value
# Stop getfqdn from working, to avoud network access
# prevent creation of soco instances
# Fake return value for select
# set timeout
# 9 packets in total should be sent (3 to default, 3 to
# 192.168.1.15 and 3 to 192.168.1.15)
# select called with the relevant timeout
# SoCo should be created with the IP address received
# Now test include_visible parameter. include_invisible=True should
# result in calling SoCo.all_zones etc
# Reset gethostbyname, to always return the same value
# if select does not return within timeout SoCo should not be called
# at all
# simulate no data being returned within timeout
# Check no SoCo instance created
# The mock we want to find is the last one
# Patch out discover and test
# Test not found
# Test found
# -*- coding: utf-8 -*-
# Basic initialisation
# attribute access
# Should not access non-existent attributes
# Should be read only
# -*- coding: utf-8 -*-
# pylint: disable-msg=too-few-public-methods, redefined-outer-name, no-self-use
# Mark all tests in this module with the pytest custom "integration" marker so
# they can be selected or deselected as a whole, eg:
# py.test -m "integration"
# or
# py.test -m "no integration"
# Get the ip address from the command line, and create the soco object
# Only one is used per test session, hence the decorator
# Check the device is playing and has items in the queue
# Save the device's state
# Yield the device to the test function
# Tear down. Restore state
# NOTE We don't test coerce from too large values, since that would
# put the unit at full volume
# Values on the boundaries of the valid equivalence partition
# Values on the boundaries of the two invalid equivalence partitions
# Values on the boundaries of the valid equivalence partition
# Values on the boundaries of the two invalid equivalence partitions
# The values in this list must be kept up to date with the values in
# the test doc string
# Format 1
# Reset and format 2
# Clean up
# The values in this list must be kept up to date with the values in
# the test doc string
# TODO: test GetSpeakersIp
# The values in this list must be kept up to date with the values in
# the test doc string
# Add new element and check
# queue index is 0 based
# compare uri because item_id is different, SQ:xx/n for playlist
# a place holder, remove_sonos_playlist is exercised in the
# 'restore_sonos_playlists'
# junky bad
# realistic non-existing
# FIXME remove the list on spl and que before slicing, when
# the deprecated __getitem__ on ListOfMusicInfoItems is
# removed
# FIXME remove the list on queue() call, when the deprecated
# __getitem__ on ListOfMusicInfoItems is removed
# [0, 0, 1, ..., n-1]
# [None, 0, ..., n-1]
# FIXME remove the list on queue() call, when the deprecated
# __getitem__ on ListOfMusicInfoItems is removed
# FIXME remove the list on queue() call, when the deprecated
# __getitem__ on ListOfMusicInfoItems is removed
# pylint: disable=R0914
# get rid of the even numbered tracks
# get rid of the even numbered tracks
# we know what we are doing
# trackA, trackB, trackC, ...
# trackC, trackB, ...
# FIXME remove the list on spl and que before slicing, when
# the deprecated __getitem__ on ListOfMusicInfoItems is
# removed
# FIXME remove the list on spl and que before slicing, when
# the deprecated __getitem__ on ListOfMusicInfoItems is
# removed
# FIXME remove the list on spl and que before slicing, when
# the deprecated __getitem__ on ListOfMusicInfoItems is
# removed
# FIXME remove the list on queue() call, when the deprecated
# __getitem__ on ListOfMusicInfoItems is removed
# -*- coding: utf-8 -*-
# pylint: disable=star-args,no-member
##############################################################################
# Example XML and the content dict to compare with for MS items              #
##############################################################################
# This one is unknown
# This one is unknown
# pylint: disable=star-args
# MusicServiceItem.from_xml and MusicServiceItem.to_dict
# MusicServiceItem.from_dict and MusicServiceItem.to_dict
# MusicServiceItem.didl_metadata
# NOTE! These tests is reliant on the attributes being put in the same
# order by ElementTree and so it might fail if that changes
# pylint: disable=pointless-statement
# Text attributes with mandatory content
# Text attributes with voluntary content
# Boolean attribute
# -*- coding: utf-8 -*-
# Typical account data from http://{Sonos-ip}:1400/status/accounts
# Typical service descriptor list
# available_services = device.musicServices.ListAvailableServices()
# descriptor_list_xml = available_services['AvailableServiceDescriptorList']
# The list has been edited to include services represented in ACCOUNT_DATA
# TuneIn account is added automatically
# TuneIn
# Including TuneIn
# Set up dummy search categories
# Check for escaping with a few difficult characters
# and a different service
# -*- coding: utf-8 -*-
# Browse returns an exception if the artist can't be found
# <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"><s:Body><s:Fault><faultcode>s:Client</faultcode><faultstring>UPnPError</faultstring><detail><UPnPError xmlns="urn:schemas-upnp-org:control-1-0"><errorCode>701</errorCode></UPnPError></detail></s:Fault></s:Body></s:Envelope>
# Browse returns an empty result set if artist and album and
# track cannot be found
#A:ALBUMARTIST/The%20Artist/First%20Album</res><dc:creator>The Artist</dc:creator><ns2:albumArtURI>/getaa?u=x-file-cifs%3a%2f%2fserver%2fThe%2520Artist%2fFirst%2520Album%2ftrack2.mp3&amp;v=432</ns2:albumArtURI></container><container id="A:ALBUMARTIST/The%20Artist/Second%20Album" parentID="A:ALBUMARTIST/The%20Artist" restricted="true"><dc:title>Second Album</dc:title><ns2:class>object.container.album.musicAlbum</ns2:class><res protocolInfo="x-rincon-playlist:*:*:*">x-rincon-playlist:RINCON_000123456789001400#A:ALBUMARTIST/The%20Artist/Second%20Album</res><dc:creator>The Artist</dc:creator><ns2:albumArtURI>/getaa?u=x-file-cifs%3a%2f%2fserver%2fThe%2520Artist%2fSecond%2520Album%2ftrack2.mp3&amp;v=432</ns2:albumArtURI></container></DIDL-Lite>',
# Tests with 2, 1 and 0 library shares
#S://share_host/music_01/Music/Lossless</res></container>'
#S://share_host_2/music_01</res></container></DIDL-Lite>')
#'
# -*- coding: utf-8 -*-
# DATA
# Test core functionality for base class MediaMetadata
# Test core functionality for base class Mediacolection
# Test the caching function
# Asking for bad class should raise KeyError
# Check the search result metadata
# Check the result
# Test non track uri
# Test track uri
# Assert only metadata element, name conversion and value
# MetadataDictBase is meant to ve overwritten, to supply
# valid_fields and conversion functions
# Check that the duration has been properly type converted
# And that title has been left unchanged
# Test normal lookup
# Test raise attribute error when the key is not in metadata
# Test call to super class init
# Test that all but the metadata_dict arg have been set as
# attributes with the same names as the arguments
# Setup mock music service with mocked desc property
# Setup content dict
# Setup return values of mocks
# Call the class method and assert init called
# -*- coding: utf-8 -*-
# Using the wrong element
# specified sub class, that the sub class is
#SubClass')
# mismatched upnp class
# adding in an attibute not in _translation should make no difference
# round trip
# should be not the same, but equal!
# adding in an attibute not in _translation should make no difference
# but changing on the other should
# we seem to have to go through this to get ElementTree to deal
# with namespaces properly!
# -*- coding: utf-8 -*-
# These tests require pytest, and mock. Mock comes with Python 3.3, but has
# also been backported for Python 2.7. It is available on pypi.
# TODO: add mock to requirements
# Dummy known-good errors/responses etc.  These are not necessarily valid as
# actual commands, but are valid XML/UPnP. They also contain unicode characters
# to test unicode handling.
# noqa PEP8
# noqa PEP8
# noqa PEP8
# There should be no testing method
# but we should be able to inspect it
# and then, having examined it, the method should be cached on the instance
# check that send_command is actually called when we invoke a method
# http://bugs.python.org/issue7688
# __name__ must be a string in python 2
# no args
# one arg + cache_timeout
# Unicode
# XML escaping - do we also need &apos; ?
# Note, the invalid ^D (code point 0x04) should be filtered out
# Detect unknown action
# Detect missing / unknown arguments
# Check correct output
# Set Argument1 = 1 as default
# Check that arguments are completed with default values
# Check that given arguments override the default values
#SetAVTransportURI'}
# Now the cache should be primed, so try it again
# The cache should be hit, so there should be no http request
# but this should not affefct a call with different params
# calling again after the time interval will avoid the cache
# TODO: Try this with a None Error Code
# TODO: test iter_actions
# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
# New in Python 3.3
# Python 2.7
# noqa PEP8
# No params
# One param
# Two params
# And with a namespace
# -*- coding: utf-8 -*-
# Deprecation decorator
# -*- coding: utf-8 -*-
